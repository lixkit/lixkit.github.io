<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="李峰峰博客">
  <meta name="keyword" content="李峰峰, iOS, 底层原理">
  <meta name="baidu-site-verification" content="codeva-SYZlEXwvUN" />
  <meta name="sogou_site_verification" content="YdqRkfPyHk" />


  <meta name="description" content="一、概述dispatch_async 是用于将任务异步提交到指定调度队列的函数。它允许调用者线程继续执行，而不必等待任务的完成。 dispatch_async 特点：  会开启新线程 dispatch_async 提交的任务不会阻塞调用者线程。调用者线程可以继续执行后续代码，而任务会被异步地添加到队列中。 无论将任务提交到并发队列还是串行队列，都会开启新线程。 主队列除外，提交到主队列的任务，会在">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD 底层原理 4 - dispatch_async">
<meta property="og:url" content="https://www.lixkit.com/posts/50907/index.html">
<meta property="og:site_name" content="李峰峰博客">
<meta property="og:description" content="一、概述dispatch_async 是用于将任务异步提交到指定调度队列的函数。它允许调用者线程继续执行，而不必等待任务的完成。 dispatch_async 特点：  会开启新线程 dispatch_async 提交的任务不会阻塞调用者线程。调用者线程可以继续执行后续代码，而任务会被异步地添加到队列中。 无论将任务提交到并发队列还是串行队列，都会开启新线程。 主队列除外，提交到主队列的任务，会在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_226.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_227.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_228.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_229.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_230.png">
<meta property="article:published_time" content="2022-11-17T23:54:00.000Z">
<meta property="article:modified_time" content="2025-03-14T00:26:48.901Z">
<meta property="article:author" content="李峰峰">
<meta property="article:tag" content="底层">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.lixkit.com/images/lix_blog_226.png">


  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      GCD 底层原理 4 - dispatch_async | 李峰峰博客
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  

  
  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="李峰峰博客" type="application/atom+xml">
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>李峰峰博客</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">主页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">分类</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">主页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">分类</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>GCD 底层原理 4 - dispatch_async</h2>
  <p class="post-date">2022-11-17</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><code>dispatch_async</code> 是用于将任务异步提交到指定调度队列的函数。它允许调用者线程继续执行，而不必等待任务的完成。</p>
<p><code>dispatch_async</code> 特点：</p>
<ul>
<li><strong>会开启新线程</strong><ul>
<li><code>dispatch_async</code> 提交的任务不会阻塞调用者线程。调用者线程可以继续执行后续代码，而任务会被异步地添加到队列中。</li>
<li>无论将任务提交到并发队列还是串行队列，都会开启新线程。<ul>
<li>主队列除外，提交到主队列的任务，会在主线程执行。</li>
<li>串行队列在有任务需要执行时，只会开启一个线程去执行任务。</li>
</ul>
</li>
</ul>
</li>
<li><strong>任务顺序</strong><ul>
<li><strong>串行队列</strong><ul>
<li>在串行队列上，<code>dispatch_async</code> 提交的任务会按照提交的顺序依次执行，确保任务之间的顺序性。</li>
</ul>
</li>
<li><strong>并发队列</strong><ul>
<li>在并发队列上，<code>dispatch_async</code> 提交的任务可以并行执行，具体执行顺序取决于系统的线程调度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.lixkit.concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 任务 1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 任务 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="二、dispatch-async"><a href="#二、dispatch-async" class="headerlink" title="二、dispatch_async"></a>二、dispatch_async</h2><p><code>dispatch_async</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dispatch_async</span><span class="params">(<span class="type">dispatch_queue_t</span> dq, <span class="type">dispatch_block_t</span> work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1、新建或者从缓存中获取 dispatch continuation 对象</span></span><br><span class="line">    <span class="type">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 设置 continuation 的标志，表示这个 continuation 在执行完后应该被销毁</span></span><br><span class="line">    <span class="type">uintptr_t</span> dc_flags = DC_FLAG_CONSUME;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 用于存储服务质量(QoS)信息</span></span><br><span class="line">    <span class="type">dispatch_qos_t</span> qos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、初始化 continuation 对象（为 continuation 中各成员赋值）</span></span><br><span class="line">    <span class="comment">// 设置要执行的 block、优先级等</span></span><br><span class="line">    <span class="comment">// 返回与这个任务相关的服务质量(QoS)级别</span></span><br><span class="line">    qos = _dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, dc_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将初始化好的 continuation 异步提交到指定的队列</span></span><br><span class="line">    <span class="comment">// 传入目标队列、continuation 对象、QoS 信息和标志</span></span><br><span class="line">    _dispatch_continuation_async(dq, dc, qos, dc-&gt;dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述主要逻辑如下：</p>
<ul>
<li><strong>获取 <code>continuation</code> 对象</strong><ul>
<li><code>_dispatch_continuation_alloc</code></li>
</ul>
</li>
<li><strong>初始化 <code>continuation</code> 对象</strong>（为 <code>continuation</code> 中各成员赋值）<ul>
<li><code>_dispatch_continuation_init</code></li>
</ul>
</li>
<li><strong>提交 <code>continuation</code> 到指定的队列</strong><ul>
<li><code>_dispatch_continuation_async</code></li>
</ul>
</li>
</ul>
<p>接下来，基于源码分别看下这几部分逻辑。</p>
<h2 id="三、-dispatch-continuation-alloc"><a href="#三、-dispatch-continuation-alloc" class="headerlink" title="三、 _dispatch_continuation_alloc"></a>三、 _dispatch_continuation_alloc</h2><p><code>_dispatch_continuation_alloc</code> 函数用于获取 <code>continuation</code> 对象，<code>continuation</code> 对象是对任务的包装，其中存储了任务、优先级、上下文等信息。</p>
<p><code>continuation</code> 是 <code>dispatch_continuation_t</code> 类型，<code>dispatch_continuation_t</code> 是一个指向 <code>dispatch_continuation_s</code> 结构体的指针，<code>dispatch_continuation_s</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> &#123;</span></span><br><span class="line">    DISPATCH_CONTINUATION_HEADER(continuation);</span><br><span class="line">&#125; *<span class="type">dispatch_continuation_t</span>;</span><br></pre></td></tr></table></figure>
<p>将其涉及的宏完全展开后，结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> &#123;</span></span><br><span class="line"> <span class="comment">// 虚函数表指针 &amp; 标志位</span></span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">     <span class="type">const</span> <span class="type">void</span> *__ptrauth_objc_isa_pointer do_vtable; <span class="comment">// 指向虚函数表的指针</span></span><br><span class="line">     <span class="type">uintptr_t</span> dc_flags;                               <span class="comment">// 用于存储各种标志位</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 优先级、缓存计数或填充</span></span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">     <span class="type">pthread_priority_t</span> dc_priority; <span class="comment">// 任务的优先级</span></span><br><span class="line">     <span class="type">int</span> dc_cache_cnt;               <span class="comment">// 缓存计数器</span></span><br><span class="line">     <span class="type">uintptr_t</span> dc_pad;               <span class="comment">// 用于对齐的填充</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指向下一个 continuation 的指针</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 初始化当前 dispatch_continuation_s 的线程的上下文凭证（包含活动 ID 等元数据）</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">voucher_s</span> *<span class="title">dc_voucher</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 要执行的函数</span></span><br><span class="line"> <span class="type">dispatch_function_t</span> dc_func;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 函数的上下文或参数</span></span><br><span class="line"> <span class="type">void</span> *dc_ctxt;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 额外的数据，如组对象等</span></span><br><span class="line"> <span class="type">void</span> *dc_data;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 其他用途的指针</span></span><br><span class="line"> <span class="type">void</span> *dc_other;</span><br><span class="line">&#125; *<span class="type">dispatch_continuation_t</span>;</span><br></pre></td></tr></table></figure>
<p>从 <code>dispatch_continuation_s</code> 结构可以看出，<code>dispatch_continuation_s</code> 是一个链表结构，其中的 <code>do_next</code> 则是指向下一个 <code>continuation</code>。</p>
<p><code>_dispatch_continuation_alloc</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_continuation_t</span></span><br><span class="line">_dispatch_continuation_alloc(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 尝试从缓存中读取一个 continuation 对象</span></span><br><span class="line">    <span class="type">dispatch_continuation_t</span> dc =</span><br><span class="line">            _dispatch_continuation_alloc_cacheonly();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果缓存分配失败(返回 NULL)</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!dc)) &#123;</span><br><span class="line">        <span class="comment">// 从堆上分配一个新的 continuation 对象</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_alloc_from_heap();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数主要逻辑为先从缓存中读取 <code>continuation</code> 对象，如果缓存不存在，再去新建一个 <code>continuation</code> 对象。</p>
<p>这里重点看下 <code>continuation</code> 缓存读取的逻辑，根据上述源码可知，缓存的读取是调用 <code>_dispatch_continuation_alloc_cacheonly</code> 函数获取的，该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_continuation_t</span></span><br><span class="line">_dispatch_continuation_alloc_cacheonly(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从当前线程存储空间中获取一个缓存的 continuation 对象</span></span><br><span class="line">    <span class="type">dispatch_continuation_t</span> dc = (<span class="type">dispatch_continuation_t</span>)</span><br><span class="line">            _dispatch_thread_getspecific(dispatch_cache_key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果成功获取到缓存的 continuation 对象</span></span><br><span class="line">    <span class="keyword">if</span> (likely(dc)) &#123;</span><br><span class="line">        <span class="comment">// 将线程存储空间中的 continuation 缓存更新为下一个对象</span></span><br><span class="line">        <span class="comment">// 这样可以维护一个 continuation 对象的链表作为缓存</span></span><br><span class="line">        _dispatch_thread_setspecific(dispatch_cache_key, dc-&gt;do_next);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回获取到的 continuation 对象(可能为 NULL 如果缓存为空)</span></span><br><span class="line">    <span class="keyword">return</span> dc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面提到 <code>continuation</code> 是一个链表结构，而其中 <code>do_next</code> 则是指向当前节点的下一个节点。</p>
<p>可以看到，上述主要逻辑是先从线程从当前线程存储空间中获取一个缓存的 <code>continuation</code>。如果取到，则将缓存更新为 <code>continuation</code> 的下个节点对象 <code>do_next</code>。</p>
<p>对于缓存不存在时新建的那个 <code>continuation</code>，也会在使用完释放时存入缓存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_free(<span class="type">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    dc = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_continuation_t</span></span><br><span class="line">_dispatch_continuation_free_cacheonly(<span class="type">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 将 continuation 放入线程缓存池</span></span><br><span class="line">    _dispatch_thread_setspecific(dispatch_cache_key, dc);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_continuation_alloc</code> 函数主要逻辑如下：</p>
<ul>
<li>从当前线程存储空间中获取一个缓存的 <code>continuation</code> 对象 <code>dc</code>。</li>
<li>如果读取成功，则将当前线程缓存的 <code>continuation</code> 对象设置为 <code>dc</code> 的下一个对象（<code>dc-&gt;do_next</code>）。</li>
<li>如果缓存没有读取到，则创建新的 <code>continuation</code>。<ul>
<li>这个新建的 <code>continuation</code> 在使用完成后，设置成线程缓存的 <code>continuation</code>。</li>
</ul>
</li>
</ul>
<p>结合上述源码可以知道，每个线程都利用 <code>continuation</code> 链表实现了一个 <code>continuation</code> 缓存池，<code>continuation</code> 不再使用后将会放入缓存池待下次使用，这么设计有下面两个好处：</p>
<ul>
<li>通过重用这些对象，可以减少频繁创建和销毁对象的开销，提高性能。</li>
<li>每个线程维护自己的缓存，可以减少多线程同时分配内存时的锁竞争。</li>
</ul>
<h2 id="四、-dispatch-continuation-init"><a href="#四、-dispatch-continuation-init" class="headerlink" title="四、_dispatch_continuation_init"></a>四、_dispatch_continuation_init</h2><p><code>_dispatch_continuation_init</code> 函数用于初始化 <code>continuation</code> 对象，该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_qos_t</span></span><br><span class="line">_dispatch_continuation_init(<span class="type">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="type">dispatch_queue_class_t</span> dqu, <span class="type">dispatch_block_t</span> work,</span><br><span class="line">        <span class="type">dispatch_block_flags_t</span> flags, <span class="type">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 复制传入的 block 对象，确保其在异步执行时仍然有效</span></span><br><span class="line">    <span class="type">void</span> *ctxt = _dispatch_Block_copy(work);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 continuation 的标志，表明它包含一个 block 且已被分配内存</span></span><br><span class="line">    dc_flags |= DC_FLAG_BLOCK | DC_FLAG_ALLOCATED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 block 是否包含私有数据</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">        <span class="comment">// 如果包含私有数据，设置 continuation 的标志和上下文</span></span><br><span class="line">        dc-&gt;dc_flags = dc_flags;</span><br><span class="line">        dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">        <span class="comment">// 调用慢速初始化路径，它会处理所有私有数据相关的设置</span></span><br><span class="line">        <span class="comment">// 注意：这个函数会初始化所有字段，但要求 dc_flags 和 dc_ctxt 已被设置</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_init_slow(dc, dqu, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 block 的执行函数</span></span><br><span class="line">    <span class="type">dispatch_function_t</span> func = _dispatch_Block_invoke(work);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了 CONSUME 标志，使用特殊的函数来在执行后释放 block</span></span><br><span class="line">    <span class="keyword">if</span> (dc_flags &amp; DC_FLAG_CONSUME) &#123;</span><br><span class="line">        func = _dispatch_call_block_and_release;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数指针方式初始化 continuation</span></span><br><span class="line">    <span class="comment">// 这个函数会设置 continuation 的函数、上下文、优先级等信息</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_continuation_init_f(dc, dqu, ctxt, func, flags, dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述逻辑，会先调用 <code>_dispatch_block_has_private_data</code> 函数检查 <code>block</code> 是否包含私有数据，关于 <code>_dispatch_block_has_private_data</code> 函数，<a href="https://www.lixkit.com/posts/42034/">《GCD 底层原理 3 - dispatch_sync》</a> 中有解释，我们常规使用传入的 <code>block</code> 是不包含私有数据的。所以最终会执行 <code>_dispatch_continuation_init_f</code> 函数。</p>
<p><code>_dispatch_continuation_init_f</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_qos_t</span></span><br><span class="line">_dispatch_continuation_init_f(<span class="type">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="type">dispatch_queue_class_t</span> dqu, <span class="type">void</span> *ctxt, <span class="type">dispatch_function_t</span> f,</span><br><span class="line">        <span class="type">dispatch_block_flags_t</span> flags, <span class="type">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化优先级为 0</span></span><br><span class="line">    <span class="type">pthread_priority_t</span> pp = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 continuation 的标志，包括已分配标志和传入的额外标志</span></span><br><span class="line">    dc-&gt;dc_flags = dc_flags | DC_FLAG_ALLOCATED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 continuation 的函数和上下文</span></span><br><span class="line">    dc-&gt;dc_func = f;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     在这个上下文中，DISPATCH_BLOCK_HAS_PRIORITY 表示优先级不应该被传播，只有当处理程序有优先级时才从处理程序中获取。</span></span><br><span class="line"><span class="comment">     如果没有设置 DISPATCH_BLOCK_HAS_PRIORITY 标志，则传播当前优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; DISPATCH_BLOCK_HAS_PRIORITY)) &#123;</span><br><span class="line">        pp = _dispatch_priority_propagate();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     为 continuation 的 dc_voucher 赋值，该函数内部会读取当前线程的 voucher，并赋值给 dc_voucher</span></span><br><span class="line"><span class="comment">     voucher 中携带了各种上下文信息，包括但不限于活动 ID、重要性等元数据。</span></span><br><span class="line"><span class="comment">     这些信息可以在不同的执行上下文（如线程、进程）之间传递，支持复杂的分布式系统中的上下文传递、活动追踪和资源管理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    _dispatch_continuation_voucher_set(dc, flags);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为 continuation 的 dc_priority 赋值，并返回对应 QoS</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_continuation_priority_set(dc, dqu, pp, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，该函数主要是为 <code>continuation</code> 各成员进行赋值，例如 <code>dc_flags</code>、<code>dc_func</code>、<code>dc_voucher</code>、<code>dc_priority</code> 等。</p>
<p>该函数中涉及到对 <code>_dispatch_priority_propagate</code>、<code>_dispatch_continuation_voucher_set</code>、<code>_dispatch_continuation_priority_set</code> 的函数调用，接下来分别分析下三个函数的实现逻辑。</p>
<h3 id="1、-dispatch-priority-propagate"><a href="#1、-dispatch-priority-propagate" class="headerlink" title="1、_dispatch_priority_propagate"></a>1、_dispatch_priority_propagate</h3><p>先看下 <code>_dispatch_continuation_init_f</code> 函数源码中优先级 <code>pp</code> 的赋值，从源码可知调用该函数时，传入的 <code>flags</code> 参数值是 <code>0</code>，所以最终会调用 <code>_dispatch_priority_propagate</code> 函数，该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">static</span> <span class="keyword">inline</span> <span class="type">pthread_priority_t</span></span><br><span class="line"> _dispatch_priority_propagate(<span class="type">void</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="keyword">return</span> _dispatch_priority_compute_propagated(<span class="number">0</span>,</span><br><span class="line"> 			DISPATCH_PRIORITY_PROPAGATE_CURRENT);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pthread_priority_t</span></span><br><span class="line">_dispatch_priority_compute_propagated(<span class="type">pthread_priority_t</span> pp,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果设置了 DISPATCH_PRIORITY_PROPAGATE_CURRENT 标志，则使用当前线程的优先级</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DISPATCH_PRIORITY_PROPAGATE_CURRENT) &#123;</span><br><span class="line">		<span class="comment">// 使用当前线程存储的优先级值</span></span><br><span class="line">        pp = _dispatch_get_priority();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除优先级中的所有标志位，只保留纯粹的优先级值</span></span><br><span class="line">    pp = _pthread_priority_strip_all_flags(pp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不是同步 IPC 调用，且优先级高于 USER_INITIATED 级别，则进行限制</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; DISPATCH_PRIORITY_PROPAGATE_FOR_SYNC_IPC) &amp;&amp;</span><br><span class="line">            pp &gt; _dispatch_qos_to_pp(DISPATCH_QOS_USER_INITIATED)) &#123;</span><br><span class="line">        <span class="comment">// 将 QOS 限制在用户发起级别 (USER_INITIATED)</span></span><br><span class="line">        <span class="comment">// 这是为了解决 rdar://16681262 和 rdar://16998036 中提到的问题</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_qos_to_pp(DISPATCH_QOS_USER_INITIATED);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回计算得到的优先级</span></span><br><span class="line">    <span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pthread_priority_t</span></span><br><span class="line">_dispatch_get_priority(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从线程存储空间中获取当前线程优先级</span></span><br><span class="line">    <span class="comment">// dispatch_priority_key 是一个线程特定数据的键，用于存储当前线程的优先级</span></span><br><span class="line">    <span class="comment">// _dispatch_thread_getspecific 函数用于获取与该键关联的值</span></span><br><span class="line">    <span class="type">pthread_priority_t</span> pp = (<span class="type">uintptr_t</span>)</span><br><span class="line">            _dispatch_thread_getspecific(dispatch_priority_key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合函数调用时的参数值，总结上述主要逻辑如下：</p>
<ul>
<li>从当前线程存储空间中获取当前线程优先级，并赋值给 <code>pp</code>。</li>
<li>移除优先级中的所有标志位，只保留纯粹的优先级值。</li>
<li>如果优先级高于 <code>USER_INITIATED</code> 级别，则限制为 <code>USER_INITIATED</code>。</li>
</ul>
<p><strong>这里的优先级 <code>pp</code> 是 <code>pthread_priority_t</code> 类型，它和 <code>Qos</code> 什么关系呢？</strong><br><code>pthread_priority_t</code> 和 <code>QoS</code> (Quality of Service) 有密切的关系。在 GCD 中，它们用于表示任务的优先级和服务质量。它们之间的关系如下：</p>
<ul>
<li><code>pthread_priority_t</code> 是一个更底层的表示，它包含了 <code>QoS</code> 信息以及其他一些标志位。</li>
<li><code>QoS</code> 是一个更高级的抽象，它定义了几个离散的优先级级别，如 <code>USER_INTERACTIVE</code>、<code>USER_INITIATED</code>、<code>UTILITY</code> 等。</li>
<li><code>pthread_priority_t</code> 可以通过位操作来包含 <code>QoS</code> 信息。通常，<code>QoS</code> 值被编码在 <code>pthread_priority_t</code> 的高位字节中。</li>
<li>可以使用一些宏或函数在 <code>pthread_priority_t</code> 和 <code>QoS</code> 之间进行转换，例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 pthread_priority_t 提取 QoS</span></span><br><span class="line"><span class="type">dispatch_qos_t</span> qos = _dispatch_qos_from_pp(pthread_priority);</span><br><span class="line"><span class="comment">// 从 QoS 创建 pthread_priority_t</span></span><br><span class="line"><span class="type">pthread_priority_t</span> pp = _dispatch_qos_to_pp(qos);</span><br></pre></td></tr></table></figure></li>
<li><code>pthread_priority_t</code> 除了包含 <code>QoS</code> 信息外，还可以包含其他标志，如相对优先级、覆盖标志等。</li>
<li>在实际使用中，通常会使用 <code>QoS</code> 级别来设置任务优先级，而系统内部会将其转换为 <code>pthread_priority_t</code> 来进行更细粒度的调度控制。</li>
</ul>
<p>可以通过一个简单示例，打印下默认 <code>Qos</code>：<br><img src="/images/lix_blog_226.png"><br>可以看到，默认 <code>Qos</code> 是 <code>USER_INITIATED</code>。</p>
<h3 id="2、-dispatch-continuation-voucher-set"><a href="#2、-dispatch-continuation-voucher-set" class="headerlink" title="2、_dispatch_continuation_voucher_set"></a>2、_dispatch_continuation_voucher_set</h3><p><code>_dispatch_continuation_init_f</code> 函数中，会调用 <code>_dispatch_continuation_voucher_set</code> 函数为 <code>continuation</code> 的 <code>dc_voucher</code> 赋值，根据前述 <code>dispatch_continuation_s</code> 结构可知，<code>dc_voucher</code> 是 <code>voucher_s</code> 类型。</p>
<p>完全展开后的 <code>voucher_s</code> 结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">voucher_s</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * isa 指针，指向对象的类信息。</span></span><br><span class="line"><span class="comment">     * 使用了 `__ptrauth_objc_isa_pointer` 进行指针认证（Pointer Authentication）。</span></span><br><span class="line"><span class="comment">     * 这是一个防止指针篡改的安全机制。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">voucher_vtable_s</span> *__<span class="title">ptrauth_objc_isa_pointer</span> <span class="title">os_obj_isa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用计数（Reference Count）。</span></span><br><span class="line"><span class="comment">     * 用于管理对象的生命周期，表示当前有多少地方引用了该对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> os_obj_ref_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交叉引用计数（Cross Reference Count）。</span></span><br><span class="line"><span class="comment">     * 用于管理对象的交叉引用，通常在对象之间存在复杂依赖关系时使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> os_obj_xref_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * voucher 的哈希表节点，用于将 voucher 对象加入到哈希表中。</span></span><br><span class="line"><span class="comment">     * 包含双向链表的前后指针。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">voucher_hash_entry_s</span> &#123;</span></span><br><span class="line">        <span class="type">uintptr_t</span> vhe_next;      <span class="comment">// 指向下一个节点</span></span><br><span class="line">        <span class="type">uintptr_t</span> vhe_prev_ptr;  <span class="comment">// 指向前一个节点的指针</span></span><br><span class="line">    &#125; v_list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Mach voucher 端口。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">mach_voucher_t</span> v_kvoucher;</span><br><span class="line">    <span class="type">mach_voucher_t</span> v_ipc_kvoucher;</span><br><span class="line"></span><br><span class="line">    <span class="type">voucher_t</span> v_kvbase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Firehose 日志系统的活动 ID。</span></span><br><span class="line"><span class="comment">     * 用于跟踪与该 voucher 相关的活动。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">firehose_activity_id_t</span> v_activity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建该活动的进程 ID。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint64_t</span> v_activity_creator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父活动的 ID。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">firehose_activity_id_t</span> v_parent_activity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 布尔值，表示该 voucher 是否具有重要性标志。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v_kv_has_importance:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VOUCHER_ENABLE_RECIPE_OBJECTS</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配方数据的偏移量和大小（仅在启用 `VOUCHER_ENABLE_RECIPE_OBJECTS` 时存在）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">size_t</span> v_recipe_extra_offset;</span><br><span class="line">    <span class="type">mach_voucher_attr_recipe_size_t</span> v_recipe_extra_size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; voucher_s;</span><br></pre></td></tr></table></figure>
<p><code>voucher_s</code> 不是本次源码分析的重点，且涉及内容较多，不再逐个字段分析。</p>
<p><code>_dispatch_continuation_voucher_set</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_voucher_set(<span class="type">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="type">dispatch_block_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用于存储 voucher 的指针，voucher_t 是一个指向 voucher_s 结构体的指针</span></span><br><span class="line">    <span class="type">voucher_t</span> v = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     _dispatch_continuation_voucher_set 从不会被调用于带有私有数据或设置了 DISPATCH_BLOCK_HAS_VOUCHER 标志的块。</span></span><br><span class="line"><span class="comment">     只有 _dispatch_continuation_init_slow 处理这个标志位。</span></span><br><span class="line"><span class="comment">     这个断言确保传入的 flags 不包含 DISPATCH_BLOCK_HAS_VOUCHER 标志，因为带有该标志的块应该由 _dispatch_continuation_init_slow 函数处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dispatch_assert(!(flags &amp; DISPATCH_BLOCK_HAS_VOUCHER));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有设置 DISPATCH_BLOCK_NO_VOUCHER 标志</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; DISPATCH_BLOCK_NO_VOUCHER)) &#123;</span><br><span class="line">        <span class="comment">// 复制当前线程的 voucher</span></span><br><span class="line">        <span class="comment">// _voucher_copy() 函数会增加 voucher 的引用计数</span></span><br><span class="line">        v = _voucher_copy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将复制的 voucher 赋值给 continuation 的 dc_voucher 字段</span></span><br><span class="line">    dc-&gt;dc_voucher = v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调试输出</span></span><br><span class="line">    _dispatch_voucher_debug(<span class="string">&quot;continuation[%p] set&quot;</span>, dc-&gt;dc_voucher, dc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录 ktrace 日志</span></span><br><span class="line">    _dispatch_voucher_ktrace_dc_push(dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>_voucher_copy</code> 函数用于复制当前线程的 <code>voucher</code>，其相关实现逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制当前线程关联的 voucher</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">voucher_t</span></span><br><span class="line">_voucher_copy(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程关联的 voucher</span></span><br><span class="line">    <span class="type">voucher_t</span> voucher = _voucher_get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 voucher 存在，增加其引用计数</span></span><br><span class="line">    <span class="comment">// _voucher_retain 函数会增加 voucher 的引用计数，确保 voucher 在使用期间不会被释放</span></span><br><span class="line">    <span class="keyword">if</span> (voucher) _voucher_retain(voucher);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回 voucher（可能是 NULL，如果当前线程没有关联的 voucher）</span></span><br><span class="line">    <span class="keyword">return</span> voucher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前线程关联的 voucher</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">voucher_t</span></span><br><span class="line">_voucher_get(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     从线程存储空间中，使用 dispatch_voucher_key 这个 Key 获取关联的 voucher。</span></span><br><span class="line"><span class="comment">     这个函数实际上是在线程本地存储中查找与 dispatch_voucher_key 关联的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_thread_getspecific(dispatch_voucher_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据源码可知，上述核心逻辑为读取当前线程的 <code>voucher</code>，并赋值给 <code>dc_voucher</code>。</p>
<h3 id="3、-dispatch-continuation-priority-set"><a href="#3、-dispatch-continuation-priority-set" class="headerlink" title="3、_dispatch_continuation_priority_set"></a>3、_dispatch_continuation_priority_set</h3><p>该函数主要是为 <code>continuation</code> 的 <code>dc_priority</code> 赋值，并返回对应 <code>QoS</code>，函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_qos_t</span></span><br><span class="line">_dispatch_continuation_priority_set(<span class="type">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="type">dispatch_queue_class_t</span> dqu,</span><br><span class="line">        <span class="type">pthread_priority_t</span> pp, <span class="type">dispatch_block_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化 QoS 为未指定状态</span></span><br><span class="line">    <span class="type">dispatch_qos_t</span> qos = DISPATCH_QOS_UNSPECIFIED;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">    <span class="comment">// 获取实际的调度队列对象</span></span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(pp)) &#123;</span><br><span class="line">        <span class="comment">// 检查是否强制执行 QoS 类别</span></span><br><span class="line">        <span class="type">bool</span> enforce = (flags &amp; DISPATCH_BLOCK_ENFORCE_QOS_CLASS);</span><br><span class="line">        <span class="comment">// 检查队列是否设置了优先级下限标志</span></span><br><span class="line">        <span class="type">bool</span> is_floor = (dq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_FLOOR);</span><br><span class="line">        <span class="comment">// 检查队列是否有请求的优先级</span></span><br><span class="line">        <span class="type">bool</span> dq_has_qos = (dq-&gt;dq_priority &amp; DISPATCH_PRIORITY_REQUESTED_MASK);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enforce) &#123;</span><br><span class="line">            <span class="comment">// 如果强制执行 QoS 类别，则在优先级中添加强制标志</span></span><br><span class="line">            pp |= _PTHREAD_PRIORITY_ENFORCE_FLAG;</span><br><span class="line">            <span class="comment">// 从优先级中提取 QoS 值</span></span><br><span class="line">            qos = _dispatch_qos_from_pp_unsafe(pp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_floor &amp;&amp; dq_has_qos) &#123;</span><br><span class="line">            pp = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，从优先级中提取 QoS 值</span></span><br><span class="line">            qos = _dispatch_qos_from_pp_unsafe(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将计算后的优先级设置到 continuation 的 dc_priority 字段</span></span><br><span class="line">    dc-&gt;dc_priority = pp;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    (<span class="type">void</span>)dc; (<span class="type">void</span>)dqu; (<span class="type">void</span>)pp; (<span class="type">void</span>)flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、-dispatch-continuation-async"><a href="#五、-dispatch-continuation-async" class="headerlink" title="五、_dispatch_continuation_async"></a>五、_dispatch_continuation_async</h2><p>在前面完成 <code>continuation</code> 的初始化之后，将会调用 <code>_dispatch_continuation_async</code> 函数将初始化好的 <code>continuation</code> 异步提交到指定的队列。</p>
<p><code>_dispatch_continuation_async</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_async(<span class="type">dispatch_queue_class_t</span> dqu,</span><br><span class="line">        <span class="type">dispatch_continuation_t</span> dc, <span class="type">dispatch_qos_t</span> qos, <span class="type">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果启用了调试内省功能（DISPATCH_INTROSPECTION 宏定义）</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_INTROSPECTION</span></span><br><span class="line">    <span class="comment">// 检查是否设置了 DC_FLAG_NO_INTROSPECTION 标志</span></span><br><span class="line">    <span class="comment">// 如果未设置该标志，则将当前 continuation 对象推送到调试追踪系统中</span></span><br><span class="line">    <span class="keyword">if</span> (!(dc_flags &amp; DC_FLAG_NO_INTROSPECTION)) &#123;</span><br><span class="line">        <span class="comment">// 调用 _dispatch_trace_item_push 函数，将 continuation 对象记录到调试追踪中</span></span><br><span class="line">        _dispatch_trace_item_push(dqu, dc);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 如果未启用调试内省功能，避免未使用的参数警告</span></span><br><span class="line">    (<span class="type">void</span>)dc_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 continuation 对象推送到目标队列中</span></span><br><span class="line">    <span class="comment">// dx_push 是一个虚函数调用，具体实现取决于队列的类型</span></span><br><span class="line">    <span class="comment">// 参数说明：</span></span><br><span class="line">    <span class="comment">// - dqu._dq: 目标队列</span></span><br><span class="line">    <span class="comment">// - dc: continuation 对象</span></span><br><span class="line">    <span class="comment">// - qos: 服务质量（QoS）级别</span></span><br><span class="line">    <span class="keyword">return</span> dx_push(dqu._dq, dc, qos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述实现中，重点是对 <code>dx_push</code> 这个宏的调用，其他的都是日志、调试相关。</p>
<p><code>dx_push</code> 宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> dx_push(x, y, z) dx_vtable(x)-&gt;dq_push(x, y, z)</span></span><br></pre></td></tr></table></figure>
<p>可以知道，这里是访问队列虚表的 <code>dq_push</code> 函数进行调用。结合在另篇文章<a href="https://www.lixkit.com/posts/12465/">《GCD 底层原理 2 - dispatch_queue》</a> 中的内容可知，串行队列、并发队列的虚表如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列的虚表</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> _<span class="title">dispatch_queue_serial_vtable</span> =</span> &#123;</span><br><span class="line">    ._os_obj_xref_dispose = _dispatch_xref_dispose,</span><br><span class="line">    ._os_obj_dispose = _dispatch_dispose,</span><br><span class="line">    ._os_obj_vtable = &#123;</span><br><span class="line">        .do_kind = <span class="string">&quot;queue_serial&quot;</span>,</span><br><span class="line">        .do_type        = DISPATCH_QUEUE_SERIAL_TYPE,</span><br><span class="line">        .do_dispose     = _dispatch_lane_dispose,</span><br><span class="line">        .do_debug       = _dispatch_queue_debug,</span><br><span class="line">        .do_invoke      = _dispatch_lane_invoke,</span><br><span class="line"></span><br><span class="line">        .dq_activate    = _dispatch_lane_activate,</span><br><span class="line">        .dq_wakeup      = _dispatch_lane_wakeup,</span><br><span class="line">        .dq_push        = _dispatch_lane_push,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发队列的虚表</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> _<span class="title">dispatch_queue_concurrent_vtable</span> =</span> &#123;</span><br><span class="line">    ._os_obj_xref_dispose = _dispatch_xref_dispose,</span><br><span class="line">    ._os_obj_dispose = _dispatch_dispose,</span><br><span class="line">    ._os_obj_vtable = &#123;</span><br><span class="line">        .do_kind = <span class="string">&quot;queue_concurrent&quot;</span>,</span><br><span class="line">        .do_type = DISPATCH_QUEUE_CONCURRENT_TYPE,</span><br><span class="line">        .do_dispose = _dispatch_lane_dispose,</span><br><span class="line">        .do_debug = _dispatch_queue_debug,</span><br><span class="line">        .do_invoke = _dispatch_lane_invoke,</span><br><span class="line">        .dq_activate = _dispatch_lane_activate,</span><br><span class="line">        .dq_wakeup = _dispatch_lane_wakeup,</span><br><span class="line">        .dq_push = _dispatch_lane_concurrent_push,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，前面对 <code>dx_push</code> 的调用：</p>
<ul>
<li>串行队列调用的是 <code>_dispatch_lane_push</code> 函数。</li>
<li>并发队列调用的是 <code>_dispatch_lane_concurrent_push</code> 函数。</li>
</ul>
<p>接下来，分别看下将任务提交到串行队列、并发队列的逻辑。</p>
<h3 id="1、提交到串行队列"><a href="#1、提交到串行队列" class="headerlink" title="1、提交到串行队列"></a>1、提交到串行队列</h3><h4 id="（1）-dispatch-lane-push"><a href="#（1）-dispatch-lane-push" class="headerlink" title="（1）_dispatch_lane_push"></a>（1）_dispatch_lane_push</h4><p><code>dispatch_async</code> 将任务提交到串行队列时，调用 <code>dx_push</code> 实际调用的是 <code>_dispatch_lane_push</code> 函数，该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_lane_push(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="type">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化唤醒标志</span></span><br><span class="line">    <span class="type">dispatch_wakeup_flags_t</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用于存储队列中的前一个对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为等待对象（例如 dispatch_sync 同步调用的上下文）</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_object_is_waiter(dou))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_lane_push_waiter(dq, dou._dsc, qos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保队列不是全局对象</span></span><br><span class="line">    dispatch_assert(!_dispatch_object_is_global(dq));</span><br><span class="line">    <span class="comment">// 计算并更新服务质量（QoS）</span></span><br><span class="line">    qos = _dispatch_queue_push_qos(dq, qos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     注意：如果我们要调用 dx_wakeup()，必须在推送的项目可能被出队之前保留队列，这意味着：</span></span><br><span class="line"><span class="comment">        - 如果我们需要覆盖，则在交换尾部之前</span></span><br><span class="line"><span class="comment">        - 如果我们使队列变为非空，则在设置头部之前</span></span><br><span class="line"><span class="comment">     否则，如果在这些操作和调用 dx_wakeup() 之间被抢占，当 _dispatch_lane_drain 调用队列中的块时，这些块可能会释放队列的最后一个引用。</span></span><br><span class="line"><span class="comment">     参见 &lt;rdar://problem/6932776&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     将新元素 dou._do 添加到队列的尾部。</span></span><br><span class="line"><span class="comment">     原子地更新队列的尾指针，使其指向新添加的元素。</span></span><br><span class="line"><span class="comment">     返回之前的尾部元素 prev。</span></span><br><span class="line"><span class="comment">        - 如果 prev 为 NULL，说明队列之前是空的，这个新元素就是第一个元素。</span></span><br><span class="line"><span class="comment">        - 如果 prev 不为 NULL，说明队列中已经有元素，新元素被添加到最后。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    prev = os_mpsc_push_update_tail(os_mpsc(dq, dq_items), dou._do, do_next);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(os_mpsc_push_was_empty(prev))) &#123;</span><br><span class="line">        <span class="comment">// 如果之前队列为空，增加队列的引用计数</span></span><br><span class="line">        _dispatch_retain_2_unsafe(dq);</span><br><span class="line">        <span class="comment">// 设置唤醒标志，表示需要消耗引用计数并标记队列为脏</span></span><br><span class="line">        flags = DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(_dispatch_queue_need_override(dq, qos))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里存在一个竞争条件，_dispatch_queue_need_override 可能会读取到过时的 dq_state 值。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 如果读取到的是同一轮 drain 操作中的过时值，由于最大 QoS 是单调递增的，</span></span><br><span class="line"><span class="comment">         * 过时的读取只会导致不必要的覆盖尝试，这是无害的。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 假设读取到上一轮 drain 操作中的过时值在实际中不会发生。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加队列的引用计数，防止队列被过早销毁</span></span><br><span class="line">        _dispatch_retain_2_unsafe(dq);</span><br><span class="line">        <span class="comment">// 设置唤醒标志，表示需要消耗引用计数</span></span><br><span class="line">        flags = DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     更新队列中新添加节点的前驱节点指针</span></span><br><span class="line"><span class="comment">     如果 prev 不为 NULL（队列不为空）：</span></span><br><span class="line"><span class="comment">        - 将 prev 节点的 do_next 字段设置为新节点 dou._do。</span></span><br><span class="line"><span class="comment">        - 这样就把新节点链接到了队列的末尾。</span></span><br><span class="line"><span class="comment">     如果 prev 为 NULL（队列之前为空）：</span></span><br><span class="line"><span class="comment">        - 直接将队列的头指针设置为新节点 dou._do。</span></span><br><span class="line"><span class="comment">        - 这处理了队列从空变为非空的情况。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    os_mpsc_push_update_prev(os_mpsc(dq, dq_items), prev, dou._do, do_next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了唤醒标志，调用 dx_wakeup 函数唤醒队列</span></span><br><span class="line">        <span class="keyword">return</span> dx_wakeup(dq, qos, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的参数 <code>dq</code> 是 <code>dispatch_lane_t</code> 类型，在另篇文章<a href="https://www.lixkit.com/posts/12465/">《GCD 底层原理 2 - dispatch_queue》</a> 中分析了 <code>dispatch_lane_t</code> 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_s</span> &#123;</span></span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dq_items_head</span>;</span> <span class="comment">// 队列头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dq_items_tail</span>;</span> <span class="comment">// 队列尾</span></span><br><span class="line">    dispatch_unfair_lock_s dq_sidelock; <span class="comment">// 辅助锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch_queue_s 包含的其他字段 ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，将源码中的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prev = os_mpsc_push_update_tail(os_mpsc(dq, dq_items), dou._do, do_next);</span><br></pre></td></tr></table></figure>
<p>宏完全展开后，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prev = (&#123;</span><br><span class="line">    <span class="comment">// 声明一个临时变量 _tl 并将 dou._do 赋值给它</span></span><br><span class="line">    __typeof__(__c11_atomic_load((__typeof__(*(&amp;(dq)-&gt;dq_items_head)) <span class="keyword">_Atomic</span> *)(&amp;(dq)-&gt;dq_items_head), memory_order_relaxed)) _tl = (dou._do);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 _tl 的 do_next 指针设置为 NULL</span></span><br><span class="line">    __c11_atomic_store((__typeof__((*(_tl)).do_next) <span class="keyword">_Atomic</span> *)(&amp;(_tl)-&gt;do_next), <span class="literal">NULL</span>, memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将队列的尾指针地址存储到线程特定数据中</span></span><br><span class="line">    _dispatch_thread_setspecific(dispatch_enqueue_key, (<span class="type">void</span> *) (&amp;(dq)-&gt;dq_items_tail));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子地交换队列的尾指针,将新节点 _tl 设置为新的尾节点</span></span><br><span class="line">    <span class="comment">// 返回交换前的旧尾节点作为 prev</span></span><br><span class="line">    atomic_exchange_explicit((__typeof__(*(&amp;(dq)-&gt;dq_items_tail)) <span class="keyword">_Atomic</span> *)(&amp;(dq)-&gt;dq_items_tail), _tl, memory_order_release);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以看出，这部分逻辑将任务作为节点添加到队列的尾部，并将 <code>dq_items_tail</code> 指向这个新节点（<code>continuation</code>），<code>prev</code> 为之前的尾部指针，可以理解为上一个节点。</p>
<p>将源码中的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os_mpsc_push_update_prev(os_mpsc(dq, dq_items), prev, dou._do, do_next);</span><br></pre></td></tr></table></figure>
<p>宏完全展开后，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    <span class="comment">// 原子地加载队列的头部指针，使用 relaxed 内存序</span></span><br><span class="line">    __typeof__(atomic_load_explicit(_os_atomic_c11_atomic(&amp;(dq)-&gt;dq_items_head), memory_order_relaxed)) _prev = (prev);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (likely(_prev)) &#123;</span><br><span class="line">        <span class="comment">// 如果 _prev 不为 NULL，说明队列不为空</span></span><br><span class="line">        <span class="comment">// 将新元素 dou._do 设置为 _prev 的下一个元素</span></span><br><span class="line">        <span class="comment">// 使用 relaxed 内存序，因为这个操作不需要同步</span></span><br><span class="line">        (<span class="type">void</span>)atomic_store_explicit(_os_atomic_c11_atomic(&amp;(_prev)-&gt;do_next), dou._do, memory_order_relaxed);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 _prev 为 NULL，说明队列为空</span></span><br><span class="line">        <span class="comment">// 将新元素 dou._do 设置为队列的头部</span></span><br><span class="line">        <span class="comment">// 使用 relaxed 内存序，因为入队操作的同步已经在之前的 os_mpsc_push_update_tail 中完成</span></span><br><span class="line">        (<span class="type">void</span>)atomic_store_explicit(_os_atomic_c11_atomic(&amp;(dq)-&gt;dq_items_head), dou._do, memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除入队者的标识，可能是用于调试或跟踪目的</span></span><br><span class="line">    _dispatch_clear_enqueuer();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这部分逻辑是将上一步返回的 <code>prev</code> 的 <code>do_next</code> 指向当前任务节点。</p>
<p><strong>这里入队的操作，为什么分成两部分去做呢？</strong><br>从入队宏命名上，也可以看出这是 <code>MPSC</code> 队列，<code>MPSC</code> 是 “Multiple Producer, Single Consumer” 的缩写，表示多生产者单消费者队列。这是一种并发数据结构，允许多个生产者线程向队列中添加数据，而只有一个消费者线程从队列中提取数据。</p>
<p><code>MPSC</code> 队列的特性：</p>
<ul>
<li><strong>多生产者</strong><ul>
<li>多个生产者线程可以同时向队列中添加数据。这需要在并发环境下确保数据的一致性和正确性。</li>
</ul>
</li>
<li><strong>单消费者</strong><ul>
<li>只有一个消费者线程从队列中提取数据。这简化了消费者端的同步问题，因为不需要处理多个消费者之间的竞争。</li>
</ul>
</li>
</ul>
<p><code>os_mpsc_push_update_tail</code> 和 <code>os_mpsc_push_update_prev</code> 是配合使用的，它们共同完成了将新节点添加到多生产者单消费者（<code>MPSC</code>）队列的操作。这两个宏的作用：</p>
<ul>
<li><code>os_mpsc_push_update_tail</code><ul>
<li>这个函数主要负责更新队列的尾指针。</li>
<li>它将新节点添加到队列的末尾，并返回之前的尾节点。</li>
<li>但是，它并不会更新之前尾节点的 <code>do_next</code> 指针。</li>
</ul>
</li>
<li><code>os_mpsc_push_update_prev</code><ul>
<li>这个函数负责更新前一个节点（之前的尾节点）的 <code>do_next</code> 指针，使其指向新节点。<br><img src="/images/lix_blog_227.png"></li>
</ul>
</li>
</ul>
<p>将一个复杂的原子操作（同时更新尾指针和前一个节点的 do_next 指针）分解为两个简单的原子操作。简单的原子操作通常比复杂的原子操作更高效，尤其是在高并发情况下。</p>
<p>从这里也可以看出，管理任务的队列 <code>dispatch_lane_t</code>，是使用单向链表实现的。</p>
<p>总结 <code>_dispatch_lane_push</code> 函数核心逻辑：</p>
<ul>
<li>将任务作为节点添加到队列的尾部，并将 <code>dq_items_tail</code> 指向这个新节点（<code>continuation</code>），并返回 <code>prev</code>（之前的尾部节点）。</li>
<li>其他关键参数配置。</li>
<li><code>prev</code> 的 <code>do_next</code> 指向当前任务节点。</li>
<li>调用 <code>dx_wakeup</code> 唤醒队列。</li>
</ul>
<p>其中，<code>dx_wakeup</code> 宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> dx_wakeup(x, y, z) dx_vtable(x)-&gt;dq_wakeup(x, y, z)</span></span><br></pre></td></tr></table></figure>
<p>所以对于串行队列，这里实际调用的是 <code>_dispatch_lane_wakeup</code> 函数</p>
<h4 id="（2）-dispatch-lane-wakeup"><a href="#（2）-dispatch-lane-wakeup" class="headerlink" title="（2）_dispatch_lane_wakeup"></a>（2）_dispatch_lane_wakeup</h4><p><code>_dispatch_lane_wakeup</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_queue_wakeup(<span class="type">dispatch_queue_class_t</span> dqu, <span class="type">dispatch_qos_t</span> qos,</span><br><span class="line">        <span class="type">dispatch_wakeup_flags_t</span> flags, <span class="type">dispatch_queue_wakeup_target_t</span> target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line">    <span class="type">uint64_t</span> old_state, new_state, enqueue = DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">    <span class="comment">// 确保目标不是等待事件状态</span></span><br><span class="line">    dispatch_assert(target != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有目标且不消耗引用计数,增加引用计数并设置消耗标志</span></span><br><span class="line">    <span class="keyword">if</span> (target &amp;&amp; !(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">        _dispatch_retain_2(dq);</span><br><span class="line">        flags |= DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理屏障完成的情况</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; DISPATCH_WAKEUP_BARRIER_COMPLETE)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         _dispatch_lane_class_barrier_complete() 处理常规队列和源需要评估的内容，但前者可能有同步切换需要执行，这是 _dispatch_lane_class_barrier_complete()，不处理的，只有 _dispatch_lane_barrier_complete() 处理。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         _dispatch_lane_wakeup() 是为普通队列调用 _dispatch_lane_barrier_complete() 的函数，这里只针对非队列类型。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断言确保当前对象是源类型</span></span><br><span class="line">        dispatch_assert(dx_metatype(dq) == _DISPATCH_SOURCE_TYPE);</span><br><span class="line">        <span class="comment">// 获取唤醒的 QoS</span></span><br><span class="line">        qos = _dispatch_queue_wakeup_qos(dq, qos);</span><br><span class="line">        <span class="comment">// 调用 _dispatch_lane_class_barrier_complete 处理屏障完成</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_lane_class_barrier_complete(upcast(dq)._dl, qos,</span><br><span class="line">                flags, target, DISPATCH_QUEUE_SERIAL_DRAIN_OWNED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理有目标的情况</span></span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        <span class="comment">// 如果目标是管理队列，设置相应的入队标志</span></span><br><span class="line">        <span class="keyword">if</span> (target == DISPATCH_QUEUE_WAKEUP_MGR) &#123;</span><br><span class="line">            enqueue = DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取唤醒的 QoS</span></span><br><span class="line">        qos = _dispatch_queue_wakeup_qos(dq, qos);</span><br><span class="line">        <span class="comment">// 原子地更新队列状态</span></span><br><span class="line">        os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, &#123;</span><br><span class="line">            <span class="comment">// 合并新的 QoS 到状态中</span></span><br><span class="line">            new_state = _dq_state_merge_qos(old_state, qos);</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; DISPATCH_WAKEUP_CLEAR_ACTIVATING) &#123;</span><br><span class="line">                <span class="comment">// 当事件正在被传递到源，因为其 unote 在 ACTIVATING 状态有机会被清除之前就被注册了，我们不希望唤醒失败，这可能导致优先级反转。相反，允许这些唤醒完成挂起的激活。</span></span><br><span class="line">                <span class="keyword">if</span> (_dq_state_is_activating(old_state)) &#123;</span><br><span class="line">                    new_state &amp;= ~DISPATCH_QUEUE_ACTIVATING;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             检查是否需要设置入队标志</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             _dq_state_is_suspended:</span></span><br><span class="line"><span class="comment">             用于判断队列是否处于挂起状态。</span></span><br><span class="line"><span class="comment">             通过检查 DISPATCH_QUEUE_SUSPEND_BITS_MASK 位是否被设置来确定。</span></span><br><span class="line"><span class="comment">             挂起状态通常表示队列暂时不能处理任务。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             _dq_state_is_enqueued:</span></span><br><span class="line"><span class="comment">             用于判断队列是否已被入队。</span></span><br><span class="line"><span class="comment">             检查 DISPATCH_QUEUE_ENQUEUED 或 DISPATCH_QUEUE_ENQUEUED_ON_MGR 位是否被设置。</span></span><br><span class="line"><span class="comment">             入队状态表示队列已被调度，等待执行。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             _dq_state_drain_locked:</span></span><br><span class="line"><span class="comment">             用于判断队列是否被锁定（正在被某个线程处理）。</span></span><br><span class="line"><span class="comment">             检查 DISPATCH_QUEUE_DRAIN_OWNER_MASK 位是否被设置。</span></span><br><span class="line"><span class="comment">             锁定状态表示队列当前正在被某个线程独占处理，其他线程需等待。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (likely(!_dq_state_is_suspended(new_state) &amp;&amp;</span><br><span class="line">                    !_dq_state_is_enqueued(old_state) &amp;&amp;</span><br><span class="line">                    (!_dq_state_drain_locked(old_state) ||</span><br><span class="line">                    enqueue != DISPATCH_QUEUE_ENQUEUED_ON_MGR))) &#123;</span><br><span class="line">                <span class="comment">// 更新 new_state</span></span><br><span class="line">                new_state |= enqueue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; DISPATCH_WAKEUP_MAKE_DIRTY) &#123;</span><br><span class="line">                <span class="comment">// 更新 new_state</span></span><br><span class="line">                new_state |= DISPATCH_QUEUE_DIRTY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (new_state == old_state) &#123;</span><br><span class="line">                <span class="comment">// 状态没有变化，放弃循环</span></span><br><span class="line">                os_atomic_rmw_loop_give_up(<span class="keyword">goto</span> done);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qos) &#123;</span><br><span class="line">        <span class="comment">// 有人试图覆盖队列的最后一个工作项</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原子地更新队列状态</span></span><br><span class="line">        os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, &#123;</span><br><span class="line">            <span class="comment">// 避免在我们能应用覆盖之前项目被排空导致的虚假覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (!_dq_state_drain_locked(old_state) &amp;&amp;</span><br><span class="line">                !_dq_state_is_enqueued(old_state)) &#123;</span><br><span class="line">                os_atomic_rmw_loop_give_up(<span class="keyword">goto</span> done);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 合并新的 QoS 到状态中</span></span><br><span class="line">            new_state = _dq_state_merge_qos(old_state, qos);</span><br><span class="line">            <span class="keyword">if</span> (_dq_state_is_base_wlh(old_state) &amp;&amp;</span><br><span class="line">                    !_dq_state_is_suspended(old_state) &amp;&amp;</span><br><span class="line">                    <span class="comment">/* &lt;rdar://problem/63179930&gt; */</span></span><br><span class="line">                    !_dq_state_is_enqueued_on_manager(old_state)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 始终为层级结构中的所有队列上的异步入队操作设置已入队位 (rdar://62447289)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                 场景：</span></span><br><span class="line"><span class="comment">                 - Mach 通道 DM</span></span><br><span class="line"><span class="comment">                 - 目标是 TQ</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                 线程 1：</span></span><br><span class="line"><span class="comment">                 - 持有 (TQ) 的锁，无争用同步</span></span><br><span class="line"><span class="comment">                 - 在 DM 上以低 QoS 触发唤醒，导致其具有：</span></span><br><span class="line"><span class="comment">                   max_qos = UT，已入队 = 1</span></span><br><span class="line"><span class="comment">                 - DM 到 TQ 的入队操作尚未发生。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                 线程 2：</span></span><br><span class="line"><span class="comment">                 - 一个传入的 IN IPC 正在服务线程上合并</span></span><br><span class="line"><span class="comment">                 - DM 的 QoS 为 UT，已入队 = 1，没有进一步的入队操作，</span></span><br><span class="line"><span class="comment">                   但我们需要一个额外的覆盖，并通过这段代码来处理 TQ。</span></span><br><span class="line"><span class="comment">                 - 这导致 TQ 被“暂存”，这需要设置已入队位，否则 try_lock_wlh()</span></span><br><span class="line"><span class="comment">                   会报错，并且唤醒引用计数会不正确。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                new_state |= enqueue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (new_state == old_state) &#123;</span><br><span class="line">                <span class="comment">// 如果状态没有变化，放弃循环</span></span><br><span class="line">                os_atomic_rmw_loop_give_up(<span class="keyword">goto</span> done);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        target = DISPATCH_QUEUE_WAKEUP_TARGET;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HAVE_PTHREAD_WORKQUEUE_QOS</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有 QoS 和 target，直接完成</span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     old_state ^ new_state 对旧状态和新状态进行异或操作，得到两者之间发生变化的位。</span></span><br><span class="line"><span class="comment">     &amp; enqueue 将异或结果与入队标志进行按位与操作，检查入队标志位是否发生了变化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (likely((old_state ^ new_state) &amp; enqueue)) &#123;</span><br><span class="line">        <span class="type">dispatch_queue_t</span> tq;</span><br><span class="line">        <span class="keyword">if</span> (target == DISPATCH_QUEUE_WAKEUP_TARGET) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             上面的 rmw_loop 没有获取屏障，因为队列的最后一个块异步到该队列并不是一个不常见的模式，在这种情况下，获取屏障将完全无用。</span></span><br><span class="line"><span class="comment">             因此，使用依赖顺序来读取 targetq 指针。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            os_atomic_thread_fence(dependency);</span><br><span class="line">            tq = os_atomic_load_with_dependency_on2o(dq, do_targetq,</span><br><span class="line">                    (<span class="type">long</span>)new_state);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tq = target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 断言确保新状态已入队</span></span><br><span class="line">        dispatch_assert(_dq_state_is_enqueued(new_state));</span><br><span class="line">        <span class="comment">// 将队列推送到目标队列</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_push_queue(tq, dq, new_state);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">    <span class="comment">// 检查是否需要处理 QoS 覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely((old_state ^ new_state) &amp; DISPATCH_QUEUE_MAX_QOS_MASK)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_dq_state_should_override(new_state)) &#123;</span><br><span class="line">            <span class="comment">// 如果需要覆盖，调用相应的函数处理</span></span><br><span class="line">            <span class="keyword">return</span> _dispatch_queue_wakeup_with_override(dq, new_state,</span><br><span class="line">                    flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HAVE_PTHREAD_WORKQUEUE_QOS</span></span></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// 如果设置了消耗标志，释放引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (likely(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_release_2_tailcall(dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述代码进行精简，最终会走该函数走进  <code>_dispatch_queue_push_queue</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_queue_wakeup(<span class="type">dispatch_queue_class_t</span> dqu, <span class="type">dispatch_qos_t</span> qos,</span><br><span class="line">        <span class="type">dispatch_wakeup_flags_t</span> flags, <span class="type">dispatch_queue_wakeup_target_t</span> target)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> old_state, new_state, enqueue = DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理有目标的情况</span></span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，这里会增加 DISPATCH_QUEUE_ENQUEUED 标志</span></span><br><span class="line">        new_state |= enqueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely((old_state ^ new_state) &amp; enqueue)) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将队列推送到目标队列</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_push_queue(tq, dq, new_state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dispatch_queue_push_queue</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_queue_push_queue(<span class="type">dispatch_queue_t</span> tq, <span class="type">dispatch_queue_class_t</span> dq,</span><br><span class="line">		<span class="type">uint64_t</span> dq_state, <span class="type">dispatch_wakeup_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_assert(flags &amp; DISPATCH_EVENT_LOOP_CONSUME_2);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_USE_KEVENT_WORKLOOP</span></span><br><span class="line">    <span class="keyword">if</span> (likely(_dq_state_is_base_wlh(dq_state))) &#123;</span><br><span class="line">        _dispatch_trace_runtime_event(worker_request, dq._dq, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_event_loop_poke((<span class="type">dispatch_wlh_t</span>)dq._dq, dq_state,DISPATCH_EVENT_LOOP_CONSUME_2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DISPATCH_USE_KEVENT_WORKLOOP</span></span></span><br><span class="line">    _dispatch_trace_item_push(tq, dq);</span><br><span class="line">    <span class="keyword">return</span> dx_push(tq, dq,_dq_state_max_qos(dq_state));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据在另篇文章<a href="https://www.lixkit.com/posts/12465/">《GCD 底层原理 2 - dispatch_queue》</a> 提到的串行队列 <code>dq_state</code> 为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq_state = (DISPATCH_QUEUE_STATE_INIT_VALUE(dq_width) | DISPATCH_QUEUE_ROLE_BASE_WLH)</span><br></pre></td></tr></table></figure>
<p>所以这里会调用 <code>_dispatch_event_loop_poke</code> 函数，该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_event_loop_poke(<span class="type">dispatch_wlh_t</span> wlh, <span class="type">uint64_t</span> dq_state, <span class="type">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (wlh == DISPATCH_WLH_MANAGER) &#123;</span><br><span class="line">        dispatch_kevent_s ke = (dispatch_kevent_s)&#123;</span><br><span class="line">            .ident  = <span class="number">1</span>,</span><br><span class="line">            .filter = EVFILT_USER,</span><br><span class="line">            .fflags = NOTE_TRIGGER,</span><br><span class="line">            .udata = (<span class="type">dispatch_kevent_udata_t</span>)DISPATCH_WLH_MANAGER,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_kq_deferred_update(DISPATCH_WLH_ANON, &amp;ke);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wlh &amp;&amp; wlh != DISPATCH_WLH_ANON) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_USE_KEVENT_WORKLOOP</span></span><br><span class="line">        <span class="type">dispatch_queue_t</span> dq = (<span class="type">dispatch_queue_t</span>)wlh;</span><br><span class="line">        dispatch_assert(_dq_state_is_base_wlh(dq_state));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(unlikely(_dq_state_is_enqueued_on_manager(dq_state))) &#123;</span><br><span class="line">            dispatch_assert(!(flags &amp; DISPATCH_EVENT_LOOP_OVERRIDE));</span><br><span class="line">            dispatch_assert(flags &amp; DISPATCH_EVENT_LOOP_CONSUME_2);</span><br><span class="line">            _dispatch_trace_item_push(&amp;_dispatch_mgr_q, dq);</span><br><span class="line">            <span class="keyword">return</span> dx_push(_dispatch_mgr_q._as_dq, dq, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">dispatch_deferred_items_t</span> ddi = _dispatch_deferred_items_get();</span><br><span class="line">        <span class="keyword">if</span> (ddi &amp;&amp; ddi-&gt;ddi_wlh == wlh) &#123;</span><br><span class="line">            <span class="keyword">return</span> _dispatch_kevent_workloop_poke_self(ddi, dq_state, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_kevent_workloop_poke(wlh, dq_state, flags);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        (<span class="type">void</span>)dq_state; (<span class="type">void</span>)flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DISPATCH_USE_KEVENT_WORKLOOP</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    DISPATCH_INTERNAL_CRASH(wlh, <span class="string">&quot;Unsupported wlh configuration&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据函数中判断条件可知，这里会执行 <code>_dispatch_kevent_workloop_poke</code> 函数。</p>
<p><code>_dispatch_kevent_workloop_poke</code> 这个函数名中，有一个 <code>workloop</code>，这个 <code>workloop</code> 是什么呢？</p>
<p>接下来先看下什么是 <code>Workqueue</code> 与 <code>Workloop</code>。</p>
<h4 id="（3）Workqueue-与-Workloop"><a href="#（3）Workqueue-与-Workloop" class="headerlink" title="（3）Workqueue 与 Workloop"></a>（3）Workqueue 与 Workloop</h4><p>GCD 通过 <code>Workqueue</code> 和 <code>Workloop</code> 两种机制实现了灵活的任务管理。</p>
<h5 id="Workqueue"><a href="#Workqueue" class="headerlink" title="Workqueue"></a>Workqueue</h5><p><code>Workqueue</code> 是 XNU 内核提供的基于线程池的任务调度机制，旨在高效地管理并发任务。它是 GCD 的底层实现之一，能够动态调整线程池的大小以适应当前的任务负载。</p>
<p><strong>Workqueue 特点：</strong></p>
<ul>
<li><strong>线程池管理</strong><ul>
<li><code>Workqueue</code> 使用线程池来执行任务，线程可以被多个任务复用，从而减少线程创建和销毁的开销。</li>
</ul>
</li>
<li><strong>并发任务调度</strong><ul>
<li>适合处理大量并发任务，任务之间没有严格的顺序要求。</li>
</ul>
</li>
<li><strong>动态扩展</strong><ul>
<li>根据任务的数量和优先级，<code>Workqueue</code> 可以动态增加或减少线程池中的线程。</li>
</ul>
</li>
</ul>
<p>其中，线程池的管理是通过 <code>pthread_workqueue</code> 相关接口与内核进行交互的，<code>pthread_workqueue</code> 是 <code>pthread</code> 的扩展，专门用于高效的任务调度和线程管理。GCD 通过调用 <code>pthread_workqueue</code> 接口，将任务分发到内核的 <code>Workqueue</code>，内核的 <code>Workqueue</code> 接收到任务后，会从线程池中分配线程来执行任务。<br><img src="/images/lix_blog_228.png"><br><code>Workqueue</code> 在 GCD 中一个很重要的应用场景就是并发队列的异步派发，关于这一点后续内容会分析。</p>
<h5 id="Workloop"><a href="#Workloop" class="headerlink" title="Workloop"></a>Workloop</h5><p><code>Workloop</code> 是基于 <code>Workqueue</code> 构建的更高级抽象。<code>Workqueue</code> 提供了线程池和并发任务调度的基础设施，而 <code>Workloop</code> 在此基础上增加了任务顺序性和事件驱动支持，专注于管理任务的顺序性和事件驱动，能够更好地支持串行任务和基于事件的任务调度。</p>
<p>任务被提交到串行队列后，GCD 会将任务分配到 <code>Workloop</code>，<code>Workloop</code> 会按照任务的提交顺序依次执行任务。</p>
<p>简单总结一下：</p>
<ul>
<li><p><code>Workqueue</code></p>
<ul>
<li>基于线程池的任务调度机制，适合处理并发任务。</li>
<li>通过动态调整线程池的大小和优先级，最大化利用系统资源。</li>
<li>主要用于 GCD 的并发队列。</li>
</ul>
</li>
<li><p><code>Workloop</code></p>
<ul>
<li>基于事件驱动的任务调度机制，专注于任务的顺序性和上下文切换。</li>
<li>支持事件监听和优先级调度，适合处理串行任务和事件驱动任务。</li>
<li>主要用于 GCD 的串行队列。</li>
</ul>
</li>
</ul>
<h4 id="（4）-dispatch-kevent-workloop-poke"><a href="#（4）-dispatch-kevent-workloop-poke" class="headerlink" title="（4）_dispatch_kevent_workloop_poke"></a>（4）_dispatch_kevent_workloop_poke</h4><p>该函数源码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_kevent_workloop_poke(<span class="type">dispatch_wlh_t</span> wlh, <span class="type">uint64_t</span> dq_state,</span><br><span class="line">        <span class="type">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个 kevent 结构体，用于描述工作循环事件</span></span><br><span class="line">    dispatch_kevent_s ke;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> action;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言</span></span><br><span class="line">    dispatch_assert(_dq_state_is_enqueued_on_target(dq_state));</span><br><span class="line">    dispatch_assert(!_dq_state_is_enqueued_on_manager(dq_state));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据队列状态获取对应的操作类型</span></span><br><span class="line">    <span class="comment">// 该函数会根据 `dq_state` 的值，返回一个与工作循环相关的操作标志</span></span><br><span class="line">    action = _dispatch_event_loop_get_action_for_state(dq_state);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充 kevent 结构体</span></span><br><span class="line">    _dispatch_kq_fill_workloop_event(&amp;ke, action, wlh, dq_state);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 `_dispatch_kq_poll` 函数，向内核提交 kevent 并等待处理结果</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_kq_poll(wlh, &amp;ke, <span class="number">1</span>, &amp;ke, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, kev_flags)) &#123;</span><br><span class="line">        <span class="comment">// 如果 `_dispatch_kq_poll` 返回非零，表示发生错误</span></span><br><span class="line">        _dispatch_kevent_workloop_drain_error(&amp;ke, <span class="number">0</span>);</span><br><span class="line">        __builtin_unreachable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; DISPATCH_EVENT_LOOP_OVERRIDE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_release_tailcall((<span class="type">dispatch_queue_t</span>)wlh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DISPATCH_EVENT_LOOP_CONSUME_2) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_release_2_tailcall((<span class="type">dispatch_queue_t</span>)wlh);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又看到了熟悉的 <code>_dispatch_kq_poll</code> 函数，在<a href="https://www.lixkit.com/posts/42034/">《GCD 底层原理 3 - dispatch_sync》</a> 中也针对这个函数做过分析，有需要可以参考这篇文章里 <code>_dispatch_kq_poll</code> 相关内容。</p>
<p>该函数内部调用了 <code>_dispatch_kq_fill_workloop_event</code>，从这一点也可以看出串行队列是基于 <code>Workloop</code> 的。</p>
<p><code>_dispatch_kq_fill_workloop_event</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_kq_fill_workloop_event(<span class="type">dispatch_kevent_t</span> ke, <span class="type">int</span> which,</span><br><span class="line">        <span class="type">dispatch_wlh_t</span> wlh, <span class="type">uint64_t</span> dq_state)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = (<span class="type">dispatch_queue_t</span>)wlh;</span><br><span class="line">    <span class="type">dispatch_qos_t</span> qos = _dq_state_max_qos(dq_state);</span><br><span class="line">    <span class="type">pthread_priority_t</span> pp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> fflags = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint16_t</span> action = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (which) &#123;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_ASYNC:</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_ASYNC_FROM_SYNC:</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_ASYNC_QOS_UPDATE:</span><br><span class="line">        dispatch_assert(_dq_state_is_base_wlh(dq_state));</span><br><span class="line">        dispatch_assert(_dq_state_is_enqueued_on_target(dq_state));</span><br><span class="line">        action = EV_ADD | EV_ENABLE;</span><br><span class="line">        mask |= DISPATCH_QUEUE_ROLE_MASK;</span><br><span class="line">        mask |= DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">        mask |= DISPATCH_QUEUE_MAX_QOS_MASK;</span><br><span class="line">        fflags |= NOTE_WL_IGNORE_ESTALE;</span><br><span class="line">        fflags |= NOTE_WL_UPDATE_QOS;</span><br><span class="line">        <span class="keyword">if</span> (_dq_state_in_uncontended_sync(dq_state)) &#123;</span><br><span class="line">            fflags |= NOTE_WL_DISCOVER_OWNER;</span><br><span class="line">            mask |= DISPATCH_QUEUE_UNCONTENDED_SYNC;</span><br><span class="line">        &#125;</span><br><span class="line">        pp = _dispatch_kevent_workloop_priority(dq, which, qos);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_SYNC:</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_TRANSFER:</span><br><span class="line">        fflags |= NOTE_WL_IGNORE_ESTALE;</span><br><span class="line">        <span class="comment">/* FALLTHROUGH */</span></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_ASYNC_LEAVE:</span><br><span class="line">        dispatch_assert(!_dq_state_is_enqueued_on_target(dq_state));</span><br><span class="line">        action = EV_ADD | EV_DELETE | EV_ENABLE;</span><br><span class="line">        mask |= DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_RETARGET:</span><br><span class="line">        action = EV_ADD | EV_DELETE | EV_ENABLE;</span><br><span class="line">        fflags |= NOTE_WL_END_OWNERSHIP;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        DISPATCH_INTERNAL_CRASH(which, <span class="string">&quot;Invalid transition&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ke = (dispatch_kevent_s)&#123;</span><br><span class="line">        .ident  = (<span class="type">uintptr_t</span>)wlh,</span><br><span class="line">        .filter = EVFILT_WORKLOOP,</span><br><span class="line">        .flags  = action,</span><br><span class="line">        .fflags = fflags | NOTE_WL_THREAD_REQUEST,</span><br><span class="line">        .qos    = (__typeof__(ke-&gt;qos))pp,</span><br><span class="line">        .udata  = (<span class="type">uintptr_t</span>)wlh,</span><br><span class="line"></span><br><span class="line">        .ext[EV_EXTIDX_WL_ADDR]  = (<span class="type">uintptr_t</span>)&amp;dq-&gt;dq_state,</span><br><span class="line">        .ext[EV_EXTIDX_WL_MASK]  = mask,</span><br><span class="line">        .ext[EV_EXTIDX_WL_VALUE] = dq_state,</span><br><span class="line">    &#125;;</span><br><span class="line">    _dispatch_kevent_wlh_debug(_dispatch_workloop_actions[which], ke);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数最终创建的 <code>ke</code> 中有个 <code>NOTE_WL_THREAD_REQUEST</code> 配置，该配置的作用是请求内核分配一个线程去处理当前任务。</p>
<p>再次进入 <code>_dispatch_kq_poll</code> 这个函数，其精简后的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_dispatch_kq_poll(<span class="type">dispatch_wlh_t</span> wlh, <span class="type">dispatch_kevent_t</span> ke, <span class="type">int</span> n,</span><br><span class="line">        <span class="type">dispatch_kevent_t</span> ke_out, <span class="type">int</span> n_out, <span class="type">void</span> *buf, <span class="type">size_t</span> *avail,</span><br><span class="line">        <span class="type">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 dispatch_once_f 确保 _dispatch_kq_init 仅被执行一次</span></span><br><span class="line">    dispatch_once_f(&amp;_dispatch_kq_poll_pred, &amp;kq_initialized, _dispatch_kq_init);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(wlh == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wlh == DISPATCH_WLH_ANON) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        r = kevent_id((<span class="type">uintptr_t</span>)wlh, ke, n, ke_out, n_out, buf, avail, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分主要逻辑如下：</p>
<ul>
<li><strong>初始化，会调用一次 <code>_dispatch_kq_init</code>。</strong></li>
<li><strong>进行 <code>kevent_id</code> 系统调用。</strong></li>
</ul>
<p>其中，<code>_dispatch_kq_init</code> 的执行逻辑中，会调用到 <code>_dispatch_root_queues_init_once</code> 函数，执行路径如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_kq_init</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_kevent_workqueue_init</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_root_queues_init</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_root_queues_init_once</span><br></pre></td></tr></table></figure>
<p>精简后的 <code>_dispatch_root_queues_init_once</code> 实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queues_init_once(<span class="type">void</span> *context DISPATCH_UNUSED)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作队列配置。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pthread_workqueue_config</span> <span class="title">cfg</span> =</span> &#123;</span><br><span class="line">        .version = PTHREAD_WORKQUEUE_CONFIG_VERSION, </span><br><span class="line">        .flags = <span class="number">0</span>, </span><br><span class="line">        .workq_cb = <span class="number">0</span>, <span class="comment">// workqueue 回调函数</span></span><br><span class="line">        .kevent_cb = <span class="number">0</span>, <span class="comment">// kevent/kevent_id 事件回调函数</span></span><br><span class="line">        .workloop_cb = <span class="number">0</span>, <span class="comment">// workloop 回调函数</span></span><br><span class="line">        .queue_serialno_offs = dispatch_queue_offsets.dqo_serialnum, </span><br><span class="line">        .queue_label_offs = dispatch_queue_offsets.dqo_label, </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!_dispatch_kevent_workqueue_enabled)) &#123;</span><br><span class="line">    	<span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wq_supported &amp; WORKQ_FEATURE_WORKLOOP) &#123;</span><br><span class="line">        <span class="comment">// 设置各回调函数。</span></span><br><span class="line">        cfg.workq_cb = _dispatch_worker_thread2;</span><br><span class="line">        cfg.kevent_cb = (<span class="type">pthread_workqueue_function_kevent_t</span>) _dispatch_kevent_worker_thread;</span><br><span class="line">        cfg.workloop_cb = (<span class="type">pthread_workqueue_function_workloop_t</span>) _dispatch_workloop_worker_thread;</span><br><span class="line">        <span class="comment">// 调用 pthread_workqueue_setup 函数，设置工作循环。</span></span><br><span class="line">        r = pthread_workqueue_setup(&amp;cfg, <span class="keyword">sizeof</span>(cfg));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wq_supported &amp; WORKQ_FEATURE_KEVENT) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果系统不支持任何工作队列特性，触发崩溃。</span></span><br><span class="line">        DISPATCH_INTERNAL_CRASH(wq_supported, <span class="string">&quot;Missing Kevent WORKQ support&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述关键逻辑如下：</p>
<ul>
<li>配置 <code>workqueue</code> 回调函数<ul>
<li><code>workq_cb = _dispatch_worker_thread2</code></li>
</ul>
</li>
<li>配置 <code>workloop</code> 回调函数<ul>
<li><code>workloop_cb = _dispatch_workloop_worker_thread</code></li>
</ul>
</li>
<li>调用 <code>pthread_workqueue_setup</code> 进行上述配置</li>
</ul>
<p>前面已经分析过，串行队列是基于 <code>Workloop</code>，最终会执行 <code>workloop</code> 回调函数 <code>workloop_cb</code>。</p>
<p>当前面 <code>kevent_id</code> 系统调用执行完成后，内核会进行线程的的创建和分配。之后将会从内核态切换到用户态的 <code>start_wqthread</code> 函数，<code>start_wqthread</code> 函数中，会继续调用 <code>_pthread_wqthread</code> 函数，<code>_pthread_wqthread</code> 负责管理线程生命周期，并从工作队列中提取任务交由上面配置回调函数执行。</p>
<p>由于串行队列是基于 <code>Workloop</code> 的，所以 <code>_pthread_wqthread</code> 会将任务交给 <code>workloop</code> 回调函数 <code>workloop_cb</code> 执行，即 <code>_dispatch_workloop_worker_thread</code> 函数。</p>
<p><code>_dispatch_workloop_worker_thread</code> 函数中，会先调用 <code>_dispatch_root_queue_drain_deferred_wlh</code> 函数，再调用 <code>_dispatch_lane_invoke</code> 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start_wqthread</span><br><span class="line">⬇️</span><br><span class="line">_pthread_wqthread</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_workloop_worker_thread</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_root_queue_drain_deferred_wlh</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_lane_invoke</span><br></pre></td></tr></table></figure>
<p>相关调用堆栈如下：<br><img src="/images/lix_blog_229.png"></p>
<h4 id="（5）-dispatch-root-queue-drain-deferred-wlh"><a href="#（5）-dispatch-root-queue-drain-deferred-wlh" class="headerlink" title="（5）_dispatch_root_queue_drain_deferred_wlh"></a>（5）_dispatch_root_queue_drain_deferred_wlh</h4><p>该函数精简后的逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queue_drain_deferred_wlh(<span class="type">dispatch_deferred_items_t</span> ddi</span><br><span class="line">		DISPATCH_PERF_MON_ARGS_PROTO)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = ...;</span><br><span class="line">    dispatch_invoke_context_s dic = ...;</span><br><span class="line">    <span class="comment">// 注意这里的标志位，后续关键逻辑还会用到</span></span><br><span class="line">    <span class="type">dispatch_invoke_flags_t</span> flags = DISPATCH_INVOKE_WORKER_DRAIN |</span><br><span class="line">			DISPATCH_INVOKE_REDIRECTING_DRAIN | DISPATCH_INVOKE_WLH;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取 drain 锁</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_queue_drain_try_lock_wlh(dq, &amp;dq_state)) &#123;</span><br><span class="line">        <span class="comment">// 获取 drain 锁成功，调用 _dispatch_lane_invoke</span></span><br><span class="line">        dx_invoke(dq, &amp;dic, flags);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中获取 <code>drain</code> 锁的的函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dispatch_queue_drain_try_lock_wlh(<span class="type">dispatch_queue_t</span> dq, <span class="type">uint64_t</span> *dq_state)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> old_state, new_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义锁定位，包含当前线程的锁值、队列宽度已满标志以及屏障操作标志</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     定义锁标志位</span></span><br><span class="line"><span class="comment">     其中，_dispatch_lock_value_for_self 会获取当前线程 tid 并：</span></span><br><span class="line"><span class="comment">     tid &amp; DLOCK_OWNER_MASK</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">uint64_t</span> lock_bits = _dispatch_lock_value_for_self() | DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子读-修改-写循环尝试更新队列状态</span></span><br><span class="line">    os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, acquire, &#123;</span><br><span class="line">        <span class="comment">// 初始化新状态为旧状态</span></span><br><span class="line">        new_state = old_state;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列处于挂起状态</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dq_state_is_suspended(old_state))) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             清除队列的入队标志</span></span><br><span class="line"><span class="comment">             清除 DISPATCH_QUEUE_ENQUEUED 标志后，调度系统会认为该队列不需要被处理，因此不会将其分配给线程或工作循环。</span></span><br><span class="line"><span class="comment">             这通常用于暂停队列的执行，直到队列被显式恢复（resume）。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            new_state &amp;= ~DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列已经被锁定</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(_dq_state_drain_locked(old_state))) &#123;</span><br><span class="line">            <span class="comment">// 如果队列处于非争用的同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (_dq_state_in_uncontended_sync(old_state)) &#123;</span><br><span class="line">                <span class="comment">// 设置接收到同步等待的标志</span></span><br><span class="line">                new_state |= DISPATCH_QUEUE_RECEIVED_SYNC_WAIT;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则放弃更新并退出循环</span></span><br><span class="line">                os_atomic_rmw_loop_give_up(<span class="keyword">break</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列未被锁定且未挂起</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 增加标志位</span></span><br><span class="line">            new_state &amp;= DISPATCH_QUEUE_DRAIN_PRESERVED_BITS_MASK;</span><br><span class="line">            new_state |= lock_bits;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查旧状态是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!_dq_state_is_base_wlh(old_state) || !_dq_state_is_enqueued_on_target(old_state) || _dq_state_is_enqueued_on_manager(old_state))) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_SIZEOF_PTR == 4</span></span><br><span class="line">        <span class="comment">// 如果是 32 位架构，右移 32 位以获取高位状态</span></span><br><span class="line">        old_state &gt;&gt;= <span class="number">32</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 如果状态无效，触发内部崩溃并记录状态</span></span><br><span class="line">        DISPATCH_INTERNAL_CRASH(old_state, <span class="string">&quot;Invalid wlh state&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入了 dq_state 指针，则更新其值为新状态</span></span><br><span class="line">    <span class="keyword">if</span> (dq_state) *dq_state = new_state;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     _dispatch_queue_drain_try_unlock 会清除的标志位：</span></span><br><span class="line"><span class="comment">     - DLOCK_OWNER_MASK：会使下面 _dq_state_drain_locked(old_state) 返回 false</span></span><br><span class="line"><span class="comment">     - DISPATCH_QUEUE_RECEIVED_OVERRIDE</span></span><br><span class="line"><span class="comment">     - DISPATCH_QUEUE_RECEIVED_SYNC_WAIT</span></span><br><span class="line"><span class="comment">     - DLOCK_FAILED_TRYLOCK_BIT</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回队列是否未挂起且未被锁定</span></span><br><span class="line">    <span class="keyword">return</span> !_dq_state_is_suspended(old_state) &amp;&amp; !_dq_state_drain_locked(old_state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述获取 <code>drain</code> 锁的主要逻辑如下：</p>
<ul>
<li>如果队列未被挂起，并且未被锁定，可以获取锁，返回值为 <code>true</code>。<ul>
<li>此时会同时设置一系列标志位 <code>lock_bits</code>：<ul>
<li><code>tid &amp; DLOCK_OWNER_MASK</code><ul>
<li>设置了该标志位后，<code>_dq_state_drain_locked</code> 会返回 true</li>
</ul>
</li>
<li><code>DISPATCH_QUEUE_WIDTH_FULL_BIT</code></li>
<li><code>DISPATCH_QUEUE_IN_BARRIER</code></li>
</ul>
</li>
</ul>
</li>
<li>如果队列被挂起，或者已被锁定，无法获取锁，返回值为 <code>false</code>。</li>
</ul>
<p>其中，函数的返回值是队列是否未挂起且未被锁定，上面已经提到，是否被锁定，取决于是否设置了 <code>tid &amp; DLOCK_OWNER_MASK</code> 标志位。在后续调用的 <code>_dispatch_queue_drain_try_unlock</code> 函数(后面分析会提到)中，会清除锁定标志位，使队列重新变成未锁定状态。</p>
<p>而当我们显示调用了 GCD 的 <code>dispatch_suspend</code> 时候，会使队列变成挂起状态。<code>dispatch_suspend</code> 不是本次分析的重点，所以在获取 <code>drain</code> 锁的逻辑里，我们只需要关注队列是否被锁定即可。</p>
<p>所以，<code>_dispatch_root_queue_drain_deferred_wlh</code> 函数核心逻辑是先尝试获取锁，如果获取成功，则调用 <code>dx_invoke</code> 开始执行任务。如果获取锁失败，代表当前串行队列中的任务正在其他线程被执行。<br>根据 <code>dx_invoke</code> 宏的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> dx_invoke(x, y, z) dx_vtable(x)-&gt;do_invoke(x, y, z)</span></span><br></pre></td></tr></table></figure>
<p>结合前面提到的串行队列虚表可知，这里实际是调用 <code>_dispatch_lane_invoke</code> 函数。</p>
<h4 id="（6）-dispatch-lane-invoke"><a href="#（6）-dispatch-lane-invoke" class="headerlink" title="（6）_dispatch_lane_invoke"></a>（6）_dispatch_lane_invoke</h4><p><code>_dispatch_lane_invoke</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_lane_invoke(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_invoke_context_t</span> dic,</span><br><span class="line">		<span class="type">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注意这里的第 4 个参数 invoke 传的是 _dispatch_lane_invoke2</span></span><br><span class="line">    _dispatch_queue_class_invoke(dq, dic, flags, <span class="number">0</span>, _dispatch_lane_invoke2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_queue_class_invoke(<span class="type">dispatch_queue_class_t</span> dqu,</span><br><span class="line">		<span class="type">dispatch_invoke_context_t</span> dic, <span class="type">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">		<span class="type">dispatch_invoke_flags_t</span> const_restrict_flags,</span><br><span class="line">		<span class="type">_dispatch_queue_class_invoke_handler_t</span> invoke)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     对于串行队列，从 _dispatch_root_queue_drain_deferred_wlh 走进来的时候传了 DISPATCH_INVOKE_WLH</span></span><br><span class="line"><span class="comment">     所以，不会走到 _dispatch_queue_drain_try_lock</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (likely(flags &amp; DISPATCH_INVOKE_WLH)) &#123;</span><br><span class="line">        <span class="comment">// 标记队列为已拥有并已入队</span></span><br><span class="line">        owned = DISPATCH_QUEUE_SERIAL_DRAIN_OWNED | DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试获取队列的 drain 锁，串行队列因为传了 DISPATCH_INVOKE_WLH 参数，所以不会走到这里</span></span><br><span class="line">        owned = _dispatch_queue_drain_try_lock(dq, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果成功获取了队列的 drain 锁</span></span><br><span class="line">    <span class="keyword">if</span> (likely(owned)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        <span class="comment">// invoke 传的是 _dispatch_lane_invoke2，所以这里执行的实际是 _dispatch_lane_invoke2 函数</span></span><br><span class="line">        tq = invoke(dq, dic, flags, &amp;owned);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果目标队列需要重新入队</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(tq != DISPATCH_QUEUE_WAKEUP_NONE &amp;&amp; tq != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT)) &#123;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 解锁，这里调用了 _dispatch_queue_drain_try_unlock 函数，使其他线程可以重新获取 drain 锁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_dispatch_queue_drain_try_unlock(dq, owned, tq == DISPATCH_QUEUE_WAKEUP_NONE)) &#123;</span><br><span class="line">            <span class="comment">// 解锁失败 ......</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果目标队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> (tq) &#123;</span><br><span class="line">        <span class="comment">// 完成队列的调用并返回</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_invoke_finish(dq, dic, tq, owned);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 否则，释放队列并返回</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_release_2_tailcall(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述主要逻辑如下：</p>
<ul>
<li>调用 <code>_dispatch_lane_invoke2</code> 函数执行任务。</li>
<li>调用 <code>_dispatch_queue_drain_try_unlock</code> 解锁。<ul>
<li>这里解锁后，会使下次调用 <code>_dispatch_root_queue_drain_deferred_wlh</code> 时可以成功获取到 <code>drain</code> 解锁。</li>
</ul>
</li>
</ul>
<p>接下来看下 <code>_dispatch_lane_invoke2</code> 函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_queue_wakeup_target_t</span></span><br><span class="line">_dispatch_lane_invoke2(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_invoke_context_t</span> dic,</span><br><span class="line">		<span class="type">dispatch_invoke_flags_t</span> flags, <span class="type">uint64_t</span> *owned)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_queue_t</span> otq = dq-&gt;do_targetq;</span><br><span class="line">    <span class="type">dispatch_queue_t</span> cq = _dispatch_queue_get_current();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(cq != otq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> otq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_width == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_lane_serial_drain(dq, dic, flags, owned);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_lane_concurrent_drain(dq, dic, flags, owned);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前的文章里已经提到，串行队列的 <code>dq_width</code> 为 <code>1</code>，所以这里会继续调用 <code>_dispatch_lane_serial_drain</code> 函数。</p>
<h4 id="（7）-dispatch-lane-serial-drain"><a href="#（7）-dispatch-lane-serial-drain" class="headerlink" title="（7）_dispatch_lane_serial_drain"></a>（7）_dispatch_lane_serial_drain</h4><p><code>_dispatch_lane_serial_drain</code> 函数 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_wakeup_target_t</span></span><br><span class="line">_dispatch_lane_serial_drain(<span class="type">dispatch_lane_class_t</span> dqu,</span><br><span class="line">		<span class="type">dispatch_invoke_context_t</span> dic, <span class="type">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">		<span class="type">uint64_t</span> *owned)</span><br><span class="line">&#123;</span><br><span class="line">    flags &amp;= ~(<span class="type">dispatch_invoke_flags_t</span>)DISPATCH_INVOKE_REDIRECTING_DRAIN;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_lane_drain(dqu._dl, dic, flags, owned, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里最继续执行 <code>_dispatch_lane_drain</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列的处理分为两种类型（串行/并发）和两种模式（重定向或非重定向）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 串行</span></span><br><span class="line"><span class="comment"> * ~~~~~~</span></span><br><span class="line"><span class="comment"> * 串行处理适用于串行队列（宽度 == 1）。它不支持重定向模式（因为没有意义），并将所有的任务视为屏障任务。</span></span><br><span class="line"><span class="comment"> * 在串行模式下，记录操作非常少，大部分循环都被优化掉了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当队列的宽度增长到大于 1 时，串行处理会停止。</span></span><br><span class="line"><span class="comment"> * 通过串行处理可以防止任何递归的处理被重定向。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 并发</span></span><br><span class="line"><span class="comment"> * ~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> * 在非重定向模式下（即目标队列之一是串行队列），非屏障任务和屏障任务都会在处理线程的上下文中运行。</span></span><br><span class="line"><span class="comment"> * 即使是较慢的非屏障任务也会被全部标记，以便它们可以向 `dispatch_sync()` 迈进，从而将它们全部串行化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在重定向模式下，非屏障任务会被向下重定向。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当队列的宽度变为 1 时，并发处理会停止，从而队列处理切换到更高效的串行模式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="type">static</span> <span class="type">dispatch_queue_wakeup_target_t</span></span><br><span class="line">_dispatch_lane_drain(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_invoke_context_t</span> dic,</span><br><span class="line">        <span class="type">dispatch_invoke_flags_t</span> flags, <span class="type">uint64_t</span> *owned_ptr, <span class="type">bool</span> serial_drain)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取队列的目标队列（通常是父队列）</span></span><br><span class="line">    <span class="type">dispatch_queue_t</span> orig_tq = dq-&gt;do_targetq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程帧，用于保存当前线程的上下文信息</span></span><br><span class="line">    dispatch_thread_frame_s dtf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义当前任务和下一个任务的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dc</span> =</span> <span class="literal">NULL</span>, *next_dc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义队列状态和拥有的宽度</span></span><br><span class="line">    <span class="type">uint64_t</span> dq_state, owned = *owned_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空（没有任务），直接返回 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!dq-&gt;dq_items_tail)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推入线程帧，保存当前队列的上下文</span></span><br><span class="line">    _dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是串行模式或当前任务是屏障任务</span></span><br><span class="line">    <span class="keyword">if</span> (serial_drain || _dq_state_is_in_barrier(owned)) &#123;</span><br><span class="line">        <span class="comment">// 设置拥有的状态为屏障模式</span></span><br><span class="line">        owned = DISPATCH_QUEUE_IN_BARRIER;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，仅保留队列宽度相关的状态</span></span><br><span class="line">        owned &amp;= DISPATCH_QUEUE_WIDTH_MASK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的头部任务</span></span><br><span class="line">    dc = _dispatch_queue_get_head(dq);</span><br><span class="line">    <span class="keyword">goto</span> first_iteration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环，用于处理队列中的任务</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        dispatch_assert(dic-&gt;dic_barrier_waiter == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前任务设置为下一个任务</span></span><br><span class="line">        dc = next_dc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前任务为空</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!dc)) &#123;</span><br><span class="line">            <span class="comment">// 如果队列为空，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (!dq-&gt;dq_items_tail) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，获取队列的头部任务</span></span><br><span class="line">            dc = _dispatch_queue_get_head(dq);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要返回内核，执行相关操作</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_needs_to_return_to_kernel())) &#123;</span><br><span class="line">            _dispatch_return_to_kernel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果串行模式与队列宽度不匹配，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(serial_drain != (dq-&gt;dq_width == <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要缩小队列宽度，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!(flags &amp; DISPATCH_INVOKE_DISABLED_NARROWING) &amp;&amp;</span><br><span class="line">                _dispatch_queue_drain_should_narrow(dic))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是工作循环模式，检查队列的最大 QoS</span></span><br><span class="line">        <span class="keyword">if</span> (likely(flags &amp; DISPATCH_INVOKE_WORKLOOP_DRAIN)) &#123;</span><br><span class="line">            <span class="type">dispatch_workloop_t</span> dwl = (<span class="type">dispatch_workloop_t</span>)_dispatch_get_wlh();</span><br><span class="line">            <span class="keyword">if</span> (unlikely(_dispatch_queue_max_qos(dwl) &gt; dwl-&gt;dwl_drained_qos)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">first_iteration:</span><br><span class="line">        <span class="comment">// 加载队列的当前状态</span></span><br><span class="line">        dq_state = os_atomic_load(&amp;dq-&gt;dq_state, relaxed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列被挂起，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dq_state_is_suspended(dq_state))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果目标队列发生变化，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(orig_tq != dq-&gt;do_targetq)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是串行模式或当前任务是屏障任务</span></span><br><span class="line">        <span class="keyword">if</span> (serial_drain || _dispatch_object_is_barrier(dc)) &#123;</span><br><span class="line">            <span class="comment">// 如果不是串行模式且未拥有屏障状态，尝试升级为屏障模式</span></span><br><span class="line">            <span class="keyword">if</span> (!serial_drain &amp;&amp; owned != DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!_dispatch_queue_try_upgrade_full_width(dq, owned)) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> out_with_no_width;</span><br><span class="line">                &#125;</span><br><span class="line">                owned = DISPATCH_QUEUE_IN_BARRIER;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前任务是同步等待者且未绑定线程，设置屏障等待者</span></span><br><span class="line">            <span class="keyword">if</span> (_dispatch_object_is_sync_waiter(dc) &amp;&amp;</span><br><span class="line">                    !(flags &amp; DISPATCH_INVOKE_THREAD_BOUND)) &#123;</span><br><span class="line">                dic-&gt;dic_barrier_waiter = dc;</span><br><span class="line">                <span class="keyword">goto</span> out_with_barrier_waiter;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 弹出队列头部任务</span></span><br><span class="line">            next_dc = _dispatch_queue_pop_head(dq, dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前状态是屏障模式，释放屏障状态并更新宽度</span></span><br><span class="line">            <span class="keyword">if</span> (owned == DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">                os_atomic_xor2o(dq, dq_state, owned, release);</span><br><span class="line">                owned = dq-&gt;dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(owned == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果未拥有宽度，尝试获取宽度</span></span><br><span class="line">                <span class="keyword">if</span> (_dispatch_object_is_waiter(dc)) &#123;</span><br><span class="line">                    _dispatch_queue_reserve_sync_width(dq);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_dispatch_queue_try_acquire_async(dq)) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> out_with_no_width;</span><br><span class="line">                &#125;</span><br><span class="line">                owned = DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 弹出队列头部任务</span></span><br><span class="line">            next_dc = _dispatch_queue_pop_head(dq, dc);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前任务是等待者，处理等待者逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (_dispatch_object_is_waiter(dc)) &#123;</span><br><span class="line">                owned -= DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">                _dispatch_non_barrier_waiter_redirect_or_wake(dq, dc);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是重定向模式，处理重定向逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; DISPATCH_INVOKE_REDIRECTING_DRAIN) &#123;</span><br><span class="line">                owned -= DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">                _dispatch_continuation_redirect_push(dq, dc,</span><br><span class="line">                        _dispatch_queue_max_qos(dq));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行当前任务</span></span><br><span class="line">        _dispatch_continuation_pop_inline(dc, dic, flags, dq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前状态是屏障模式，更新宽度</span></span><br><span class="line">    <span class="keyword">if</span> (owned == DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">        owned += dq-&gt;dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有未完成的任务，调整拥有的宽度</span></span><br><span class="line">    <span class="keyword">if</span> (dc) &#123;</span><br><span class="line">        owned = _dispatch_queue_adjust_owned(dq, owned, dc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新拥有的状态</span></span><br><span class="line">    *owned_ptr &amp;= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">    *owned_ptr |= owned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出线程帧，恢复上下文</span></span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有任务，返回目标队列；否则返回 NULL</span></span><br><span class="line">    <span class="keyword">return</span> dc ? dq-&gt;do_targetq : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">out_with_no_width:</span><br><span class="line">    <span class="comment">// 如果没有宽度，更新状态并弹出线程帧</span></span><br><span class="line">    *owned_ptr &amp;= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">    <span class="keyword">return</span> DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT;</span><br><span class="line"></span><br><span class="line">out_with_barrier_waiter:</span><br><span class="line">    <span class="comment">// 如果不允许同步等待者，触发崩溃</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; DISPATCH_INVOKE_DISALLOW_SYNC_WAITERS)) &#123;</span><br><span class="line">        DISPATCH_INTERNAL_CRASH(<span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;Deferred continuation on source, mach channel or mgr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出线程帧，恢复上下文</span></span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标队列</span></span><br><span class="line">    <span class="keyword">return</span> dq-&gt;do_targetq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dispatch_lane_drain</code> 函数主要逻辑就是按照先进先出的顺序，逐个执行串行队列中的各个任务。</p>
<h3 id="2、提交到并发队列"><a href="#2、提交到并发队列" class="headerlink" title="2、提交到并发队列"></a>2、提交到并发队列</h3><p>再回头看下 <code>_dispatch_continuation_async</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_async(<span class="type">dispatch_queue_class_t</span> dqu,</span><br><span class="line">        <span class="type">dispatch_continuation_t</span> dc, <span class="type">dispatch_qos_t</span> qos, <span class="type">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dx_push(dqu._dq, dc, qos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面已经提到，对于并发队列，<code>dx_push</code> 实际调用的是 <code>_dispatch_lane_concurrent_push</code> 函数。</p>
<h4 id="（1）-dispatch-lane-concurrent-push"><a href="#（1）-dispatch-lane-concurrent-push" class="headerlink" title="（1）_dispatch_lane_concurrent_push"></a>（1）_dispatch_lane_concurrent_push</h4><p>该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_lane_concurrent_push(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="type">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     模拟器的回退路径，用于协作队列</span></span><br><span class="line"><span class="comment">     检查队列是否为协作队列，且任务对象是否支持协作队列</span></span><br><span class="line"><span class="comment">     如果不支持，则触发崩溃，提示不支持将任务目标设置为协作根队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_queue_is_cooperative(dq) &amp;&amp;</span><br><span class="line">            !_dispatch_object_supported_on_cooperative_queue(dou))) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(dou._do,</span><br><span class="line">            <span class="string">&quot;Cannot target the cooperative root queue - not implemented&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;rdar://problem/24738102&amp;24743140&gt; 保留非屏障宽度</span></span><br><span class="line">    <span class="comment">// 如果仅设置了 ENQUEUED 位（而不是屏障宽度等效位），则不会失败</span></span><br><span class="line">    <span class="comment">// 因此需要检查当前线程是否在此调用之前已将任务入队，否则可能会破坏任务的顺序</span></span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_items_tail == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            !_dispatch_object_is_waiter(dou) &amp;&amp; <span class="comment">// 检查任务是否为等待者</span></span><br><span class="line">            !_dispatch_object_is_barrier(dou) &amp;&amp; <span class="comment">// 检查任务是否为屏障任务</span></span><br><span class="line">            _dispatch_queue_try_acquire_async(dq)) &#123; <span class="comment">// 尝试异步获取队列</span></span><br><span class="line">        <span class="comment">// 将任务重定向推送到队列中</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_redirect_push(dq, dou, qos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 _dispatch_lane_push</span></span><br><span class="line">    _dispatch_lane_push(dq, dou, qos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该函数的 <code>if</code> 判断条件里，<code>dq-&gt;dq_items_tail</code> 一定是 <code>NULL</code>（具体原因后续会分析）。并且根据其他几个判断条件可知，这里会调用 <code>_dispatch_continuation_redirect_push</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_redirect_push(<span class="type">dispatch_lane_t</span> dl,</span><br><span class="line">        <span class="type">dispatch_object_t</span> dou, <span class="type">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = dl-&gt;do_targetq;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意，这里传入的 dq 是 do_targetq，不是当前 dp，do_targetq 是从根队列数组 _dispatch_root_queues 中取出的对应的根队列（root queue）</span></span><br><span class="line">    dx_push(dq, dou, qos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，这里又调用了熟悉的 <code>dx_push</code> 宏，但是传入的并不是我们创建的并发队列，而是并发队列的 <code>do_targetq</code>。</p>
<p>在之前的文章<a href="https://www.lixkit.com/posts/12465/">《GCD 底层原理 2 - dispatch_queue》</a> 中已经分析了，结论是并发队列和串行队列都是从根队列数组 <code>_dispatch_root_queues</code> 中取出的对应的根队列（<code>root queue</code>）。创建并发队列时，返回的是 <code>_dispatch_root_queues</code> 数组 <code>index = 9</code> 的元素（<code>DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS</code>），即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS] = &#123;</span><br><span class="line">    DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">    .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">    .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS),</span><br><span class="line">    .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">    .dq_priority = _dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT),</span><br><span class="line">    .dq_label = <span class="string">&quot;com.apple.root.default-qos&quot;</span>,</span><br><span class="line">    .dq_serialnum = <span class="number">13</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>所以这里调用 <code>dx_push</code> 时传入的实际上是对应的 <code>root queue</code>。而对于 <code>root queue</code>，其 <code>dx_push</code> 对应的函数是 <code>_dispatch_root_queue_push</code>，所以对于后续往队列 <code>push</code> 任务，都是在对应的 <code>root queue</code> 上的，而不是在当然任务 <code>dq</code> 上的。<strong>这也是 <code>_dispatch_lane_concurrent_push</code> 里的判断条件 <code>dq-&gt;dq_items_tail</code> 为 <code>NULL</code> 的原因。</strong></p>
<h4 id="（2）-dispatch-root-queue-push"><a href="#（2）-dispatch-root-queue-push" class="headerlink" title="（2）_dispatch_root_queue_push"></a>（2）_dispatch_root_queue_push</h4><p>该函数精简后的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_root_queue_push(<span class="type">dispatch_queue_global_t</span> rq, <span class="type">dispatch_object_t</span> dou,</span><br><span class="line">		<span class="type">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_root_queue_push_needs_override(rq, qos)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_root_queue_push_override(rq, dou, qos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_root_queue_push_inline(rq, dou, dou, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>_dispatch_root_queue_push_needs_override</code>、<code>_dispatch_root_queue_push_override</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要覆盖当前队列的优先级</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dispatch_root_queue_push_needs_override(<span class="type">dispatch_queue_global_t</span> rq,</span><br><span class="line">        <span class="type">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 外部传进来的 qos 是 dq 的，而不是 dq-&gt;do_targetq 的。</span></span><br><span class="line">    <span class="comment">// 而 rq 是  dq-&gt;do_targetq，即 root queue</span></span><br><span class="line">    <span class="type">dispatch_qos_t</span> fallback = _dispatch_priority_fallback_qos(rq-&gt;dq_priority);</span><br><span class="line">    <span class="keyword">if</span> (fallback) &#123;</span><br><span class="line">        <span class="comment">// 如果存在 QoS，且当 QoS 不等于回退  fallback，则需要覆盖</span></span><br><span class="line">        <span class="keyword">return</span> qos &amp;&amp; qos != fallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的当前 QoS</span></span><br><span class="line">    <span class="type">dispatch_qos_t</span> rqos = _dispatch_priority_qos(rq-&gt;dq_priority);</span><br><span class="line">    <span class="comment">// 如果当前 QoS 存在且小于传入的 QoS，则需要覆盖</span></span><br><span class="line">    <span class="keyword">return</span> rqos &amp;&amp; qos &gt; rqos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行优先级覆盖操作</span></span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queue_push_override(<span class="type">dispatch_queue_global_t</span> orig_rq,</span><br><span class="line">        <span class="type">dispatch_object_t</span> dou, <span class="type">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uintptr_t</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列是否设置了超额提交标志</span></span><br><span class="line">    <span class="keyword">if</span> (orig_rq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了超额提交标志，添加 DISPATCH_QUEUE_OVERCOMMIT 标志</span></span><br><span class="line">        flags |= DISPATCH_QUEUE_OVERCOMMIT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_dispatch_queue_is_cooperative(orig_rq)) &#123;</span><br><span class="line">        <span class="comment">// 如果是协作队列，添加 DISPATCH_QUEUE_COOPERATIVE 标志</span></span><br><span class="line">        flags |= DISPATCH_QUEUE_COOPERATIVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 QoS 和标志获取目标根队列</span></span><br><span class="line">    <span class="type">dispatch_queue_global_t</span> rq = _dispatch_get_root_queue(qos, flags);</span><br><span class="line">    <span class="comment">// 获取调度对象的 continuation</span></span><br><span class="line">    <span class="type">dispatch_continuation_t</span> dc = dou._dc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果调度对象是重定向类型</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_is_redirection(dc)) &#123;</span><br><span class="line">        <span class="comment">// 不需要双重包装，直接设置原始队列为函数上下文</span></span><br><span class="line">        dc-&gt;dc_func = (<span class="type">void</span> *)orig_rq;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 分配一个新的 continuation</span></span><br><span class="line">        dc = _dispatch_continuation_alloc();</span><br><span class="line">        <span class="comment">// 设置 continuation 的虚表为 OVERRIDE_OWNING 类型</span></span><br><span class="line">        dc-&gt;do_vtable = DC_VTABLE(OVERRIDE_OWNING);</span><br><span class="line">、        dc-&gt;dc_ctxt = dc;</span><br><span class="line">        dc-&gt;dc_other = orig_rq;</span><br><span class="line">        dc-&gt;dc_data = dou._do;</span><br><span class="line">        dc-&gt;dc_priority = DISPATCH_NO_PRIORITY;</span><br><span class="line">        dc-&gt;dc_voucher = DISPATCH_NO_VOUCHER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 continuation 推送到目标根队列</span></span><br><span class="line">    _dispatch_root_queue_push_inline(rq, dc, dc, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最终会调用到 <code>_dispatch_root_queue_push_inline</code> 函数。</p>
<h4 id="（3）-dispatch-root-queue-push-inline"><a href="#（3）-dispatch-root-queue-push-inline" class="headerlink" title="（3）_dispatch_root_queue_push_inline"></a>（3）_dispatch_root_queue_push_inline</h4><p>该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queue_push_inline(<span class="type">dispatch_queue_global_t</span> dq,</span><br><span class="line">		<span class="type">dispatch_object_t</span> _head, <span class="type">dispatch_object_t</span> _tail, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">hd</span> =</span> _head._do, *tl = _tail._do;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(os_mpsc_push_list(os_mpsc(dq, dq_items), hd, tl, do_next))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_root_queue_poke_and_wakeup(dq, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将其中涉及到的宏展开后实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queue_push_inline(<span class="type">dispatch_queue_global_t</span> dq,</span><br><span class="line">        <span class="type">dispatch_object_t</span> _head, <span class="type">dispatch_object_t</span> _tail, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 提取任务链表的起始和结束节点，这两个节点表示需要处理的一组任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">hd</span> =</span> _head._do, *tl = _tail._do;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个本地变量 _token 来表示队列中新的尾部元素</span></span><br><span class="line">    __typeof__(atomic_load_explicit((__typeof__(*(&amp;_os_mpsc_head(dq, dq_items))) <span class="keyword">_Atomic</span> *)(&amp;_os_mpsc_head(dq, dq_items)), memory_order_relaxed)) _token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 _tail 更新为队列的新尾部，并获取之前的尾部元素（即 _token）</span></span><br><span class="line">    _token = os_mpsc_push_update_tail((dq, dq_items), tl, do_next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将链表的头部（hd）与新尾部（tl）链接在一起</span></span><br><span class="line">    os_mpsc_push_update_prev((dq, dq_items), _token, hd, do_next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     检查如果队列在插入这个任务链前是空的，则需要分配线程去处理队列中的任务。</span></span><br><span class="line"><span class="comment">     如果 _token == NULL，说明这是个新队列首次插入任务，或者队列中的任务已被处理完。</span></span><br><span class="line"><span class="comment">     如果插入任务后，发现还没有分配线程处理这个队列中的任务，就需要分配线程去处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((_token) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_root_queue_poke_and_wakeup(dq, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又看到了前面总结过的 <code>MPSC</code> 队列操作。</p>
<p>总结该函数逻辑如下：</p>
<ul>
<li>通过 <code>MPSC</code> 队列操作将任务插入队列尾部。</li>
<li>分配线程去处理队列中的任务。<ul>
<li>调用 <code>_dispatch_root_queue_poke_and_wakeup</code> 函数<ul>
<li>传参 <code>n = 1</code></li>
<li>传参 <code>floor = 0</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>其中，<code>_dispatch_root_queue_poke_and_wakeup</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_root_queue_poke_and_wakeup(<span class="type">dispatch_queue_global_t</span> dq, <span class="type">int</span> n, <span class="type">int</span> <span class="built_in">floor</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !DISPATCH_USE_INTERNAL_WORKQUEUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">    <span class="keyword">if</span> (likely(dx_type(dq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE ||</span><br><span class="line">            dx_type(dq) == DISPATCH_QUEUE_COOPERATIVE_ROOT_TYPE))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> old_pending, new_pending;</span><br><span class="line">        os_atomic_rmw_loop2o(dq, dgq_pending, old_pending, new_pending, release, &#123;</span><br><span class="line">            new_pending = old_pending ?: n;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (old_pending &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _dispatch_root_queue_debug(<span class="string">&quot;worker thread request still pending &quot;</span></span><br><span class="line">                    <span class="string">&quot;for global queue: %p&quot;</span>, dq);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !DISPATCH_USE_INTERNAL_WORKQUEUE</span></span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_root_queue_poke_slow(dq, n, <span class="built_in">floor</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数主要逻辑是调用 <code>_dispatch_root_queue_poke_slow</code> 函数，且第二个参数 <code>n = 1</code>。</p>
<h4 id="（4）-dispatch-root-queue-poke-slow"><a href="#（4）-dispatch-root-queue-poke-slow" class="headerlink" title="（4） _dispatch_root_queue_poke_slow"></a>（4） _dispatch_root_queue_poke_slow</h4><p>精简后的 <code>_dispatch_root_queue_poke_slow</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queue_poke_slow(<span class="type">dispatch_queue_global_t</span> dq, <span class="type">int</span> n, <span class="type">int</span> <span class="built_in">floor</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数 n = 1，所以 remaining = 1</span></span><br><span class="line">    <span class="type">int</span> remaining = n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    _dispatch_root_queues_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dx_type(dq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        r = _pthread_workqueue_addthreads(remaining,</span><br><span class="line">                _dispatch_priority_to_pp_prefer_fallback(dq-&gt;dq_priority));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>_dispatch_root_queues_init</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queues_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_once_f(&amp;_dispatch_root_queues_pred, <span class="literal">NULL</span>,</span><br><span class="line">			_dispatch_root_queues_init_once);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又调用了 <code>_dispatch_root_queues_init_once</code> 函数，关于该函数在前面串行队列部分已经分析过，函数中关键逻辑如下：</p>
<ul>
<li>配置 <code>workqueue</code> 回调函数<ul>
<li><code>workq_cb = _dispatch_worker_thread2</code></li>
</ul>
</li>
<li>配置 <code>workloop</code> 回调函数<ul>
<li><code>workloop_cb = _dispatch_workloop_worker_thread</code></li>
</ul>
</li>
</ul>
<p>而且前面也已经分析过，并发队列是基于 <code>workqueue</code> 的，从 <code>_dispatch_root_queue_poke_slow</code> 函数实现也可以看到，函数逻辑中没有涉及到像串行队列那样的 <code>workloop</code> 的配置。所以在 <code>_dispatch_root_queue_poke_slow</code> 函数中，调用 <code>_pthread_workqueue_addthreads</code> 完成线程的分配之后，会执行 <code>workqueue</code> 回调函数<code> _dispatch_worker_thread2</code>。</p>
<p><code>_pthread_workqueue_addthreads</code> 函数有两个参数：</p>
<ul>
<li><strong>numthreads</strong><ul>
<li>要请求的线程数量</li>
</ul>
</li>
<li><strong>priority</strong><ul>
<li>线程优先级</li>
</ul>
</li>
</ul>
<p><font color=#ff0000>而上面调用 <code>_pthread_workqueue_addthreads</code> 函数时，传入的 <code>numthreads</code> 参数为 <code>1</code>，表示请求分配一个线程去处理任务。</font></p>
<p>按照经验来看，<code>dispatch_async</code> + 并发队列，是会分配多个线程去处理各个任务的。为什么这一步却只请求一个线程去处理任务呢？后面会分析原因。</p>
<h4 id="（5）-dispatch-worker-thread2"><a href="#（5）-dispatch-worker-thread2" class="headerlink" title="（5）_dispatch_worker_thread2"></a>（5）_dispatch_worker_thread2</h4><p>该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_worker_thread2(<span class="type">pthread_priority_t</span> pp)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dispatch_queue_global_t</span> dq; <span class="comment">// 全局队列。</span></span><br><span class="line">    <span class="type">dispatch_invoke_flags_t</span> invoke_flags = <span class="number">0</span>; <span class="comment">// 调用标志初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uintptr_t</span> rq_flags = <span class="number">0</span>; <span class="comment">// 队列标志初始化。</span></span><br><span class="line">    <span class="keyword">if</span> (cooperative) &#123;</span><br><span class="line">        <span class="comment">// 如果是合作线程，设置合作队列标志和调用标志。</span></span><br><span class="line">        rq_flags |= DISPATCH_QUEUE_COOPERATIVE;</span><br><span class="line">        invoke_flags |= DISPATCH_INVOKE_COOPERATIVE_DRAIN;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是超额提交线程，设置超额提交标志。</span></span><br><span class="line">        rq_flags |= (overcommit ? DISPATCH_QUEUE_OVERCOMMIT : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据优先级和标志获取对应的全局队列。</span></span><br><span class="line">    dq = _dispatch_get_root_queue(_dispatch_qos_from_pp(pp), rq_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置调用标志</span></span><br><span class="line">    invoke_flags |= DISPATCH_INVOKE_WORKER_DRAIN | DISPATCH_INVOKE_REDIRECTING_DRAIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 root queue 中提取任务并执行。</span></span><br><span class="line">    _dispatch_root_queue_drain(dq, dq-&gt;dq_priority, invoke_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该函数中，主要是调用了 <code>_dispatch_root_queue_drain</code> 函数去执行具体任务。</p>
<h4 id="（6）-dispatch-root-queue-drain"><a href="#（6）-dispatch-root-queue-drain" class="headerlink" title="（6）_dispatch_root_queue_drain"></a>（6）_dispatch_root_queue_drain</h4><p><code>_dispatch_root_queue_drain</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queue_drain(<span class="type">dispatch_queue_global_t</span> dq,</span><br><span class="line">        <span class="type">dispatch_priority_t</span> pri, <span class="type">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前线程与队列关联</span></span><br><span class="line">    _dispatch_queue_set_current(dq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个指向调度对象的指针 item，用于存储从队列中弹出的任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">item</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化调度上下文 dic，用于存储调度过程中的相关信息</span></span><br><span class="line">    dispatch_invoke_context_s dic = &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环处理队列中的任务，直到队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (likely(item = _dispatch_root_queue_drain_one(dq))) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹出并执行队列中的任务</span></span><br><span class="line">        _dispatch_continuation_pop_inline(item, &amp;dic, flags, dq);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前线程与队列取消关联</span></span><br><span class="line">    _dispatch_queue_set_current(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数核心逻辑如下：</p>
<ul>
<li>将当前线程与队列关联。<ul>
<li>确保任务执行期间，GCD 能正确识别当前线程所属队列，防止线程池中的线程后续任务调度混乱。</li>
</ul>
</li>
<li>使用 <code>while</code> 循环，按照 <code>FIFO</code> 顺序取出一个任务 <code>item</code>。<ul>
<li>取任务调用的 <code>_dispatch_root_queue_drain_one</code> 函数。</li>
</ul>
</li>
<li><code>while</code> 循环中，弹出并执行的上一步取出的任务 <code>item</code>。<ul>
<li>调用 <code>_dispatch_continuation_pop_inline</code> 函数。</li>
</ul>
</li>
<li>所有任务处理完成后，将当前线程与队列取消关联。</li>
</ul>
<p>这里需要重点看下 <code>_dispatch_root_queue_drain_one</code> 函数，这是实现多线程并发执行的关键。</p>
<h4 id="（7）-dispatch-root-queue-drain-one"><a href="#（7）-dispatch-root-queue-drain-one" class="headerlink" title="（7）_dispatch_root_queue_drain_one"></a>（7）_dispatch_root_queue_drain_one</h4><p>该函数内部实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *</span></span><br><span class="line"><span class="class">_<span class="title">dispatch_root_queue_drain_one</span>(<span class="title">dispatch_queue_global_t</span> <span class="title">dq</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">head</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    <span class="comment">// MEDIATOR 值同时充当“锁”和信号的作用。</span></span><br><span class="line">    <span class="comment">// 将队列的头部指针交换为 DISPATCH_ROOT_QUEUE_MEDIATOR，表示当前线程正在处理队列。</span></span><br><span class="line">    head = os_atomic_xchg2o(dq, dq_items_head,</span><br><span class="line">            DISPATCH_ROOT_QUEUE_MEDIATOR, relaxed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列头部为空，检查是否与并发入队操作发生竞争。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(head == <span class="literal">NULL</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次交换 tail 指针会告诉入队线程可以安全地写入 head 指针。</span></span><br><span class="line">        <span class="comment">// 如果 CAS 操作失败，说明有并发入队操作使队列变为非空。</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!os_atomic_cmpxchg2o(dq, dq_items_head,</span><br><span class="line">                DISPATCH_ROOT_QUEUE_MEDIATOR, <span class="literal">NULL</span>, relaxed))) &#123;</span><br><span class="line">            <span class="comment">// 与并发入队线程竞争，重新尝   提取任务。</span></span><br><span class="line">            <span class="keyword">goto</span> start;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 tail 指针不为空，说明有并发入队操作尚未完成。</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(dq-&gt;dq_items_tail)) &#123; <span class="comment">// &lt;rdar://problem/14416349&gt;</span></span><br><span class="line">            <span class="comment">// head 被设置为 MEDIATOR，表示之前 head 为空，但 tail 有值。</span></span><br><span class="line">            <span class="comment">// 等待入队操作完成。</span></span><br><span class="line">            <span class="keyword">if</span> (__DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(dq,</span><br><span class="line">                    _dispatch_root_queue_head_tail_quiesced)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列仍然为空，记录调试信息并返回 NULL。</span></span><br><span class="line">        _dispatch_root_queue_debug(<span class="string">&quot;no work on global queue: %p&quot;</span>, dq);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 head 是 MEDIATOR，说明与另一个线程竞争失败。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(head == DISPATCH_ROOT_QUEUE_MEDIATOR)) &#123;</span><br><span class="line">        <span class="comment">// 等待 MEDIATOR 被清除。</span></span><br><span class="line">        <span class="keyword">if</span> (likely(__DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(dq,</span><br><span class="line">                _dispatch_root_queue_mediator_is_gone))) &#123;</span><br><span class="line">            <span class="keyword">goto</span> start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复 head 指针为正常值。</span></span><br><span class="line">    <span class="comment">// 如果 next 为空，说明当前任务可能是最后一个任务。</span></span><br><span class="line">    next = head-&gt;do_next;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!next)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将队列头部指针设置为 NULL。</span></span><br><span class="line">        os_atomic_store2o(dq, dq_items_head, <span class="literal">NULL</span>, relaxed);</span><br><span class="line">        <span class="comment">// 将 tail 指针也设置为 NULL，确保队列为空的状态一致性。</span></span><br><span class="line">        <span class="keyword">if</span> (os_atomic_cmpxchg2o(dq, dq_items_tail, head, <span class="literal">NULL</span>, release)) &#123;</span><br><span class="line">            <span class="comment">// head 和 tail 都为 NULL，队列为空。</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 CAS 失败，说明有新的任务被入队。</span></span><br><span class="line">        next = os_mpsc_get_next(head, do_next, &amp;dq-&gt;dq_items_tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新队列头部指针为下一个任务。</span></span><br><span class="line">    os_atomic_store2o(dq, dq_items_head, next, relaxed);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️ 注意，这里调用了 _dispatch_root_queue_poke 函数，内部会再次调用 _dispatch_root_queue_poke_slow</span></span><br><span class="line">    _dispatch_root_queue_poke(dq, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数核心逻辑有两部分：</p>
<ul>
<li>按照 <code>FIFO</code> 顺序取一个任务并返回，交由外面 <code>_dispatch_continuation_pop_inline</code> 函数取执行任务。</li>
<li>调用 <code>_dispatch_root_queue_poke</code> 函数。<ul>
<li>该函数内部会再次调用 <code>_dispatch_root_queue_poke_slow</code> 函数。</li>
</ul>
</li>
</ul>
<p><code>_dispatch_root_queue_poke</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_root_queue_poke(<span class="type">dispatch_queue_global_t</span> dq, <span class="type">int</span> n, <span class="type">int</span> <span class="built_in">floor</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_dispatch_queue_class_probe(dq)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !DISPATCH_USE_INTERNAL_WORKQUEUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">    <span class="keyword">if</span> (likely(dx_type(dq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE ||</span><br><span class="line">            dx_type(dq) == DISPATCH_QUEUE_COOPERATIVE_ROOT_TYPE))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!os_atomic_cmpxchg2o(dq, dgq_pending, <span class="number">0</span>, n, release))) &#123;</span><br><span class="line">            _dispatch_root_queue_debug(<span class="string">&quot;worker thread request still pending &quot;</span></span><br><span class="line">                    <span class="string">&quot;for global queue: %p&quot;</span>, dq);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !DISPATCH_USE_INTERNAL_WORKQUEUE</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用了 _dispatch_root_queue_poke_slow 函数</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_root_queue_poke_slow(dq, n, <span class="built_in">floor</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里再次调用了 <code>_dispatch_root_queue_poke_slow</code> 函数，上面已经提到 _<code>dispatch_root_queue_poke_slow</code> 会请求分配 1 个线程去执行任务。</p>
<p>这个“循环”的执行链路如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_root_queue_poke_slow</span><br><span class="line">⬇️</span><br><span class="line">_pthread_workqueue_addthreads // 申请分配 1 个线程去执行任务</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_worker_thread2</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_root_queue_drain // 调用 _dispatch_root_queue_drain_one 取出 1 个任务并执行</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_root_queue_drain_one</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_root_queue_poke_slow // 新一轮循环，申请 1 个线程执行 1 个任务</span><br><span class="line">⬇️</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>这里就是 <code>dispatch_async</code> + 并发队列的多线程并发执行的关键逻辑了：<font color=#ff0000><strong>每次申请 <code>1</code> 个线程去执行 <code>1</code> 个任务，在从队列取任务的同时，同时去申请新的线程执行下个任务，这样就达到了多个线程并发执行任务的目的。而具体哪个任务先执行，则取决于的线程调度先后。</strong></font></p>
<p>这里用到了“任务窃取优化”：<br>新创建的线程立即进入 <code>_dispatch_root_queue_drain</code> 循环，尝试从队列中窃取任务执行。提高多核 CPU 利用率，减少任务排队时间。</p>
<h4 id="（8）-dispatch-continuation-pop-inline"><a href="#（8）-dispatch-continuation-pop-inline" class="headerlink" title="（8）_dispatch_continuation_pop_inline"></a>（8）_dispatch_continuation_pop_inline</h4><p>这里再回头简单看下上一步取出的任务，是如何执行的。执行时调用的是 <code>_dispatch_continuation_pop_inline</code> 函数，该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_pop_inline(<span class="type">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="type">dispatch_invoke_context_t</span> dic, <span class="type">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="type">dispatch_queue_class_t</span> dqu)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_pthread_root_queue_observer_hooks_t</span> observer_hooks =</span><br><span class="line">            _dispatch_get_pthread_root_queue_observer_hooks();</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_will_execute(dqu._dq);</span><br><span class="line">    flags &amp;= _DISPATCH_INVOKE_PROPAGATE_MASK;</span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dx_type(dou._do) == DISPATCH_SWIFT_JOB_TYPE) &#123;</span><br><span class="line">            dx_invoke(dou._dsjc, <span class="literal">NULL</span>,</span><br><span class="line">                    _dispatch_invoke_flags_to_swift_invoke_flags(flags));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dx_invoke(dou._dq, dic, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_continuation_invoke_inline(dou, flags, dqu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dqu._dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面主要逻辑是判断传入的任务是否有虚函数表，如果有的话调用 <code>dx_invoke</code> 宏执行任务，否则调用 <code>_dispatch_continuation_invoke_inline</code> 宏执行任务。</p>
<p>由于传进来的任务，是前面包装好的 <code>continuation</code>，是没有虚函数表的，所以这里会继续调用 <code>_dispatch_continuation_invoke_inline</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_invoke_inline(<span class="type">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="type">dispatch_invoke_flags_t</span> flags, <span class="type">dispatch_queue_class_t</span> dqu)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    <span class="comment">// 使用自动释放池包装调度项的执行，确保在执行过程中管理内存</span></span><br><span class="line">    dispatch_invoke_with_autoreleasepool(flags, &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> dc_flags = dc-&gt;dc_flags;</span><br><span class="line">        <span class="comment">// 将调度项重新放回缓存中，以便快速回收和复用，这样可以减少内存分配的开销，提高性能</span></span><br><span class="line">        _dispatch_continuation_voucher_adopt(dc, dc_flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(dc_flags &amp; DC_FLAG_NO_INTROSPECTION)) &#123;</span><br><span class="line">            _dispatch_trace_item_pop(dqu, dou);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果设置了 DC_FLAG_CONSUME 标志，则释放调度项的缓存</span></span><br><span class="line">        <span class="keyword">if</span> (dc_flags &amp; DC_FLAG_CONSUME) &#123;</span><br><span class="line">            dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dc1 = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果设置了 DC_FLAG_GROUP_ASYNC 标志，表示这是一个异步任务组，调用专门的函数处理任务组的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc_flags &amp; DC_FLAG_GROUP_ASYNC)) &#123;</span><br><span class="line">            _dispatch_continuation_with_group_invoke(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，调用调度项的回调函数</span></span><br><span class="line">            _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">            <span class="comment">// 记录调度项的完成事件</span></span><br><span class="line">            _dispatch_trace_item_complete(dc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓存释放失败，则将调度项释放到缓存限制中</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc1)) &#123;</span><br><span class="line">            _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 增加性能监控的工作项计数</span></span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述核心逻辑如下：</p>
<ul>
<li>使用 <code>autoreleasepool</code> 包裹调度项的执行，确保在执行过程中管理内存。</li>
<li>判断是否是 <code>dispatch_group</code> 任务组。<ul>
<li>如果是 <code>dispatch_group</code> 任务组，调用 <code>_dispatch_continuation_with_group_invoke</code> 执行。</li>
<li>如果是普通任务，调用 <code>_dispatch_client_callout</code> 执行任务。</li>
</ul>
</li>
<li>释放 <code>continuation</code>，存到线程的 <code>continuation</code> 缓存池。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>可以用下图表示 <code>dispatch_async</code> + 串行队列&#x2F;并发队列的逻辑：<br><img src="/images/lix_blog_230.png"></p>
</section>

    <!-- Copyright START -->
    
      <div>
  <ul class="post-copyright">
    <li>
      <a rel=license href=http://creativecommons.org/licenses/by/4.0/>
        <img alt="知识共享许可协议" style="border-width:0;height:30px;width:auto;" src="/css/images/copyright.png">
      </a>
    </li>
    <li>
      本文章采用 <a rel=license href=http://creativecommons.org/licenses/by/4.0/>知识共享署名 4.0 国际许可协议</a> 进行许可，完整转载、部分转载、图片转载时均请注明原文链接。
    </li>
  </ul>
<div>
    
    <!-- Copyright START -->


    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#底层" >
    <span class="tag-code">底层</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/posts/42034/">
        <span class="nav-arrow">← </span>
        
          GCD 底层原理 3 - dispatch_sync
        
      </a>
    
    
      <a class="nav-right" href="/posts/34692/">
        
          GCD 底层原理 5 - 线程池
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Gitalk START -->
      <div id="gitalk-container"></div>
      <!-- Gitalk END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://www.lixkit.com/posts/50907/';
    var banner = 'undefined'
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>








<link rel='stylesheet' type='text/css' href='//cdnjs.cloudflare.com/ajax/libs/gitalk/1.2.2/gitalk.min.css'>
<div id="gitalk-container"></div>
<script>
    // Promise 异步加载脚本
    function loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    // 异步加载 Gitalk
    async function initGitalk() {
        try {
            await loadScript('//cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.10.0/js/md5.min.js');
            await loadScript('//cdnjs.cloudflare.com/ajax/libs/gitalk/1.2.2/gitalk.min.js');
            const gitalk = new Gitalk({
                clientID: '124a73ebef61e7821d74',
                clientSecret: 'a1ef084cca4d78256620f08f439ba70522f84581',
                repo: 'lixkit.github.io',
                owner: 'lixkit',
                admin: ['lixkit'],
                id: md5(location.pathname),
                distractionFreeMode: false
            });
            gitalk.render('gitalk-container');
        } catch (error) {
            console.error('Error loading Gitalk:', error);
        }
    }

    // 在页面加载完成后异步加载 Gitalk
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initGitalk);
    } else {
        initGitalk();
    }
</script>


    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    
<footer class="app-footer">
  <p class="copyright">
    李峰峰 © 2016 - 2025
    
        |
        
            <a style="color: #7f8c8d;" href="http://beian.miit.gov.cn/" target="_blank" rel="noopener nofollow">京ICP备2023030486号-6</a>
        
    
  </p>
</footer>


<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script>
    var _baId = 'cef02744ce74fd7afbb6bab85e4a6c24';
    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>


<script src="/js/script.js"></script>


  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>