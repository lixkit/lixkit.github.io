<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入解析 iOS 系统架构</title>
      <link href="/posts/28259/"/>
      <url>/posts/28259/</url>
      
        <content type="html"><![CDATA[<h2 id="一、iOS-的诞生"><a href="#一、iOS-的诞生" class="headerlink" title="一、iOS 的诞生"></a>一、iOS 的诞生</h2><h3 id="1、macOS-的历史"><a href="#1、macOS-的历史" class="headerlink" title="1、macOS 的历史"></a>1、macOS 的历史</h3><p>1984 年，Apple 发布了第一款计算机 Macintosh 128K，Macintosh 以其标志性的图形用户界面（GUI）和用户友好的设计，彻底改变了计算机行业，取代了当时普遍使用的命令行界面。<br><img src="/images/lix_blog_205.png"><br>这个阶段，Macintosh 中的操作系统名称为 System Software，这是 macOS 系统最早期的名称。</p><p>1985 年，史蒂夫·乔布斯被“驱逐”离开了 Apple，离开 Apple 后，乔布斯创立了 NeXT 公司，致力于生产高性能的工作站和开发新的操作系统 NeXTSTEP。</p><p>NeXTSTEP 基于卡内基梅隆大学开发的 Mach 微内核，这使得系统具有模块化、高效和灵活的特点。Mach 微内核提供了基本的操作系统功能，如进程管理、内存管理和进程间通信（IPC）。NeXTSTEP  所使用的 Objective-C 开发语言，作为 macOS、iOS 的开发语言沿用至今。</p><p>NeXTSTEP 拥有优雅的图形用户界面，提供了直观的用户体验。其 GUI 中使用了 PostScript 技术来呈现高质量的文本和图形，与当时的其他操作系统相比显得非常先进。NeXTSTEP 还集成了多种服务功能，包括文件服务器、邮件服务器等，增强了系统的多功能性。</p><p>这里不得不提到这个阶段另一家著名的公司 Sun Microsystems（简称 Sun），该公司在 2010 年已被 Oracle Corporation 收购，Sun 在当时以其高性能工作站和服务器而闻名，目前仍然流行的 Java 就是其杰作之一。</p><p>Sun 的工作站最初通过直接调用底层 Unix 操作系统和 SunView 窗口系统工具包进行编程，并使用基于这些接口构建的库，这导致即使是简单项目的编程也变得复杂。为了应对这一问题，Sun 在 20 世纪 80 年 代中期推出了 NeWS 窗口系统，尝试使用面向对象的编程模型，但由于复杂的应用程序编程接口（API）和普遍较差的性能，NeWS 并未得到广泛应用，最终被放弃。</p><p>为了解决这一问题，1993 年 Sun 决定与 NeXT 进行合作构建其面向对象的应用框架，并对 NeXT 进行 1000 万美元的投资。Sun 与 NeXT 合作，从 NeXTSTEP 操作系统中提取出的核心面向对象编程接口和框架，这些接口和框架经过精简和适配，以便能够在 Sun 的 Solaris 操作系统上运行。最终，Sun 和 NeXT 合作开发出了 OpenStep，OpenStep 就是从 NeXTSTEP 提取出的面向对象编程接口和框架，开发者基于 OpenStep 框架开发出的应用，就可以运行在任何符合 OpenStep 规范的操作系统上。</p><p>NeXT 与 Sun 分别基于 OpenStep 改造其现有操作系统，使其操作系统支持基于 OpenStep 开发的应用。1994 年，NeXT 最终发布了一个兼容 OpenStep 的 NeXTSTEP 版本，命名为 OPENSTEP（注意大小写），OPENSTEP 操作系统实际上是 NeXTSTEP 操作系统的 4.0 版本。</p><p>1994 发布的官方 OpenStep API 首次将 API 分为 Foundation 和 Application Kit，并首次使用 “NS” 前缀（早期版本的 NeXTSTEP 使用 “NX” 前缀，仅包含 Application Kit）。这个 “NS” 前缀，则是 NeXT&#x2F;Sun 的简写，这就是 “NS” 前缀的来历。</p><p>1996 年，Apple 宣布以 4.29 亿美元收购 NeXT。这一交易旨在获取 OPENSTEP 操作系统的技术，用于开发新一代的 Macintosh 操作系统。史蒂夫·乔布斯也随着这次收购重新回到了 Apple。</p><p>收购 NeXT 后，Apple 融合了早期的 System Software 和 OPENSTEP （更准确的说，是 OPENSTEP 慢慢吸收了 System Software），开发出了新一代操作系统：Mac OS X。“Mac” 是 Macintosh 的缩写。</p><p>1999 年，Apple 将操作系统 Mac OS X 的底层（Mach 内核及其上的 BSD 层）重新打包，并以开源形式发布了 Darwin 操作系统。并在后续，Apple 以 Darwin 为核心诞生了 iOS、tvOS、watchOS、BridgeOS（用于 Macbook Touch Bar 的 OS） 等一系列变体操作系统：<br><img src="/images/lix_blog_206.png"><br>使用如下命令可以查看系统所使用的 Darwin 版本信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -v</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_207.png"><br><strong>直到现在，macOS、iOS 中仍然可以看到 OPENSTEP 的痕迹。OPENSTEP 对应的 OpenStep 框架演变成了现在 macOS 上的 Cocoa 框架，OpenStep 的 Foundation 和 Application Kit 演变成了 Cocoa 框架中的 Foundation 和 AppKit。</strong></p><p>2012 年时候，Apple 简化“Mac OS X” 命名，去掉“Mac”前缀，更名为“ OS X”。</p><p>2016 年，苹果公司宣布 OS X 更名为 macOS，以便与苹果其他操作系统 iOS、watchOS 和 tvOS 保持统一的命名风格。<br><img src="/images/lix_blog_208.png"></p><h3 id="2、macOS-的衍生品-—-iOS"><a href="#2、macOS-的衍生品-—-iOS" class="headerlink" title="2、macOS 的衍生品 — iOS"></a>2、macOS 的衍生品 — iOS</h3><p>2005 年，苹果公司启动了一个名为“Project Purple”的秘密项目，目标是开发一款革命性的移动设备，即后来的 iPhone。在技术上，乔布斯面临两个选择：</p><ul><li><strong>把 Mac 缩小</strong>：即基于 macOS 技术开发 iPhone 操作系统。</li><li><strong>把 iPod 扩大</strong>：即基于 iPod 的操作系统开发 iPhone 操作系统。<ul><li>iPod 使用的操作系统是一个专为嵌入式设备设计的系统，是基于 Pixo OS 定制化开发出来的。</li></ul></li></ul><p>史蒂夫·乔布斯采用了内部竞争的策略，让 Mac 团队和 iPod 团队分别提出各自的方案，并通过竞争来激发创新和找到最佳的技术解决方案。最终，Mac 团队胜出，决定基于 macOS 开发 iPhone 使用的操作系统，即后来的 iOS 系统。为了适应移动设备的资源限制，苹果对 macOS 的许多组件进行了优化。例如，内存管理和电源管理系统进行了调整，以适应 iPhone 的硬件配置。</p><p>2007 年 1 月，苹果公司于 Macworld 开发者大会上为 iOS 揭幕，并宣布于同年 6 月推出。在揭幕时，乔布斯称：“iPhone 运行 OS X，并且可使用‘桌面应用程序’”，最初随 iPhone 发布的操作系统并没有独立的名称，直至 2008 年才正式取名为 iPhone OS。</p><p>2010 年 6 月，苹果公司于全球开发者大会中，宣布把 iPhone OS 重命名为 iOS，然而，思科系统已经使用 “iOS” 商标多年，用于其网络设备的操作系统，iOS 在思科的定义是 “Internetwork Operating System”。为避免商标侵权纠纷，苹果公司与思科系统达成了协议，从思科获得了“iOS”商标的使用权。</p><p>iOS 作为 iPhone 中的操作系统名称，沿用至今。</p><p>所以，从本质上看，iOS 实际上就是 macOS，但是两者还是有一些显著的区别的：</p><ul><li><p><strong>目标架构</strong></p><ul><li>iOS：iOS 的内核和二进制文件编译的目标架构是基于 ARM 架构。<ul><li>ARM 处理器设计在电源管理方面具有显著优势，这对于移动设备来说非常重要。</li></ul></li><li>macOS：早期 macOS 的内核和二进制文件编译的目标架构主要是 Intel 的 x86_64 架构。<ul><li>Intel 处理器在性能方面表现出色，适用于桌面和笔记本电脑等需要高性能计算的设备。</li><li>2020 年，新款 MacBook 从 Intel x86_64 架构的处理器转向自家设计的基于 ARM 架构的 Apple Silicon 处理器。<ul><li>x86 是 32 位架构，而 x86_64 是其 64 位扩展版本</li></ul></li></ul></li></ul></li><li><p><strong>内核源码开放性</strong></p><ul><li>iOS：iOS 的内核源码是闭源的，尽管苹果公司承诺 macOS 的内核 XNU 要一直开源，但这一承诺并不适用于 iOS。</li><li>macOS：macOS 的内核 XNU 是开源的，苹果公司定期发布其源代码。</li></ul></li><li><p><strong>系统 GUI</strong></p><ul><li>iOS：iOS 的系统 GUI 是 SpringBoard，这是一个触屏应用加载器。<ul><li>SpringBoard 的设计专注于触摸交互，适用于移动设备。</li></ul></li><li>macOS：macOS 的 GUI 是 Aqua，这是一个鼠标驱动的界面，特别为窗口系统设计。<ul><li>Aqua 界面专注于窗口管理和多任务处理，提供了丰富的桌面操作体验。</li></ul></li></ul></li><li><p><strong>内存限制</strong></p><ul><li>iOS：iOS 的内存管理更加紧凑，因为移动设备上没有几乎无穷的交换空间。开发者需要适应更严苛的内存限制和编程模型。</li><li>macOS：macOS 可以利用更大的物理内存和交换空间，内存管理相对宽松。</li></ul></li><li><p><strong>系统限制和安全性</strong></p><ul><li>iOS：iOS 系统的限制更加严格，应用程序不允许访问底层 UNIX API（即 Darwin），也没有 root 访问权限，只能访问自己的目录数据。只有苹果的应用可以访问整个系统。App Store 的应用被严格限制，必须通过苹果的审查。</li><li>macOS：macOS 系统的限制相对宽松，用户和应用程序可以访问底层 UNIX API，具有更高的系统权限。用户可以安装和运行未经过苹果审查的应用程序。</li></ul></li></ul><h3 id="3、CUP-架构的统一"><a href="#3、CUP-架构的统一" class="headerlink" title="3、CUP 架构的统一"></a>3、CUP 架构的统一</h3><p>iPhone 4 之前，iPhone 使用的是三星研发的基于 ARM11 架构的处理器，从 iPhone 4 开始，苹果转向使用自家设计的 A 系列处理器，首款为 A4。A 系列处理器基于 ARM 架构，由苹果自主设计并由合作伙伴制造。而 Mac，则主要使用的是 Intel x86_64 处理器。</p><p>Mac 基于 Intel x86_64，遇到了如下问题：</p><ul><li><p><strong>性能和能效瓶颈</strong></p><ul><li>性能提升有限：近年来，Intel 处理器的性能提升速度放缓，未能满足苹果对高性能计算的需求。</li><li>能效比不足：Intel 处理器在能效比方面表现不佳，特别是在笔记本电脑和移动设备中，电池续航时间成为一个重要问题。</li></ul></li><li><p><strong>散热和功耗</strong></p><ul><li>功耗较高：Intel 处理器的功耗较高，导致设备发热严重，影响用户体验和设备寿命。</li><li>散热问题：高功耗带来的散热问题，使得设备设计需要更复杂的散热系统，增加了设计难度和成本。</li></ul></li><li><p><strong>生态系统整合</strong></p><ul><li>架构不统一：苹果的移动设备（如 iPhone 和 iPad）使用的是 ARM 架构，而 Mac 设备使用的是 Intel x86_64 架构。这种架构不统一导致开发者需要为不同架构编写和优化应用程序，增加了开发和维护的复杂性。</li></ul></li></ul><p>近年来，媒体报道中多次记载了苹果对英特尔研发速度和质量的疑惑和不满。一份 2018 年的报告指出英特尔芯片的问题导致了苹果对 MacBook 的重新设计(<a href="https://venturebeat.com/2018/08/17/apple-reportedly-redesigned-basic-macbook-after-intel-chip-issues/">链接</a>)。2019 年，苹果指责英特尔芯片库存的短缺导致了 Mac 销量的下降(<a href="https://www.techradar.com/news/apple-blames-intels-processor-shortage-for-slump-in-mac-sales">链接</a>)。</p><p>到 2020 年，有报道指出在 2018 款 iPad Pro 中使用的基于 ARM 架构的 Apple A12X Bionic 处理器已经能够在性能上和在 MacBook Pro 中使用的英特尔 Core i7 处理器打平。</p><p>最早在 2018 年，就有媒体报道苹果计划用自家设计的处理器取代 Mac 设备中的 Intel 处理器，这一计划被称为“Project Kalamata”。</p><p>最终，2020 年的全球开发者大会（WWDC 2020）上，Apple 公布自己研发的基于 ARM64 架构的新一代处理器：Apple Silicon。Apple Silicon 是苹果公司为其自家设计的基于 ARM 架构的处理器所使用的总称，而 M 系列处理器是 Apple Silicon 家族中的具体产品系列之一。Apple 同时发布了新版操作系统 macOS Big Sur，是首个支持 Apple Silicon 的 macOS 版本。以及发布了搭载首款 M 系列处理器 M1 以及 macOS Big Sur 系统的一系列 MacBook 设备。</p><p>macOS Big Sur 系统的发布标志着苹果开始从 x86-64 架构（Intel 处理器）过渡到 ARM 架构（Apple Silicon 处理器）。为了确保这一过渡的顺利进行，并确保用户在新旧架构上的无缝体验，苹果采取了一系列技术措施，使得自带应用和第三方应用能够同时支持 x86-64 与 ARM 架构：</p><ul><li><p><strong>通用二进制（Universal Binary）</strong></p><ul><li>通用二进制是一种包含多个架构版本的应用程序包。在 macOS Big Sur 系统中，苹果引入了新的通用二进制格式，使得应用程序可以同时包含 x86-64 和 ARM 架构的代码。</li><li>实现方式：<ul><li>编译工具：通过 Xcode 开发工具，开发者可以将他们的应用程序编译为通用二进制，包含适用于 Intel 和 Apple Silicon 的代码。</li><li>自动选择：当用户在不同架构的 Mac 上运行应用程序时，系统会自动选择并执行适用于当前硬件架构的代码。</li></ul></li></ul></li><li><p><strong>Rosetta 2</strong></p><ul><li>Rosetta 2 是一个动态二进制翻译层，允许基于 x86-64 架构的应用程序在 Apple Silicon 设备上运行。</li><li>工作原理：<ul><li>动态翻译：当用户在 Apple Silicon 设备上运行仅支持 x86-64 架构的应用程序时，Rosetta 2 会在运行时将 x86-64 指令动态翻译为 ARM 指令。</li><li>性能优化：Rosetta 2 不仅支持动态翻译，还能在应用程序安装或首次运行时进行静态翻译，以提高性能。</li></ul></li></ul></li></ul><p>至此，iPhone、iPad、Mac 实现了 CPU 架构的统一。CPU 架构的统一就意味着软件生态的统一，开发者开发一个 APP，就可以同时运行在 iPhone、iPad、Mac 设备上。</p><h2 id="二、iOS-架构"><a href="#二、iOS-架构" class="headerlink" title="二、iOS 架构"></a>二、iOS 架构</h2><p>前面已经提到，iOS 起源于 macOS，本质上 iOS 就是精简版的 macOS，下图是 Apple 官方文档对 macOS &amp; iOS 架构层次划分：<br><img src="/images/lix_blog_209.png"><br>可以看到，Apple 对 macOS &amp; iOS 在架构上分层，本质上是一样的。</p><p>这里主要关注 iOS，在 Apple 官方架构分层上，iOS 系统架构层次如下：<br><img src="/images/lix_blog_210.png" style="width:50%;"></p><ul><li><p><strong>触摸层（Cocoa Touch）</strong></p><ul><li>提供了开发者常用的框架。</li><li>包括 <strong>UIKit</strong>、MapKit、iAd 等。</li></ul></li><li><p><strong>媒体层（Media）</strong></p><ul><li>为 Cocoa Touch 层提供 UI 渲染和多媒体服务。</li><li>包括 Metal、CoreText、QuartzCore、CoreGraphics 等。<ul><li>我们常用的 CoreAnimation 位于 QuartzCore 中。</li></ul></li></ul></li><li><p><strong>核心服务层（Core Services）</strong></p><ul><li>提供了如字符串操作、集合管理、网络、URL工具、联系人管理和偏好设置等服务的框架。</li><li>还提供了基于设备硬件特性的服务，例如 GPS、指南针、加速度计和陀螺仪。</li><li>包括 <strong>Foundation</strong>、CoreFoundation、CFNetwork、CoreLocation、CoreData 等。</li></ul></li><li><p><strong>核心系统层（Core OS）</strong></p><ul><li>提供了系统级的底层功能，一般来说开发者不需要接触这些技术。</li><li>这一层主要由三部分组成：<ul><li><strong>Darwin</strong> <ul><li>Darwin 是 macOS 和 iOS 操作系统开发的核心，是基于 XNU 内核的操作系统。Darwin 包含了核心的操作系统组件，包括内核、驱动程序、文件系统和网络堆栈等。</li><li>Darwin 提供了开发者常用的 libSystem 库。libSystem 是一个综合性的基础库，包含了多个子库，例如 libdispatch(GCD)、libsystem_blocks(Block)、libpthread(pthread) 等。</li></ul></li><li>64-Bit Support<ul><li>iOS 最初设计支持在使用 32 位架构的设备上运行二进制文件。从 iOS 7 开始，引入了对 64 位架构的编译、链接和调试二进制文件的支持。</li><li>iOS 使用与 OS X 和其他 64 位 UNIX 系统相同的 LP64 模型，LP64 模型通过定义特定数据类型的大小，提供了一种在 64 位系统中管理内存和数据的标准方式。</li></ul></li><li>Frameworks<ul><li>核心系统层提供了一系列安全性或与外部硬件配件通信相关的框架，通过使用这些框架，开发者可以很容易地实现安全和硬件交互功能。</li><li>包括 Accelerate、CoreBluetooth、Security 等框架。</li></ul></li></ul></li></ul></li></ul><p>在上述架构层次中，Darwin 是整个系统的基础。不同的是，macOS 上的 Darwin 是开源的，而 iOS 中的 Darwin  是在 ARM 上的移植，这个 Darwin 则是不开源的。架构层次的其他部分在 macOS &amp; iOS 上也都是不开源的，属于 Apple 的私有知识产权。</p><p><strong>“Cocoa Touch 层(触摸层)” 与 “Cocoa Touch”</strong><br>在上述 iOS 架构中，”Cocoa Touch 层(触摸层)”并不完全等价于 “Cocoa Touch”，”Cocoa Touch 层”是 iOS 架构中的一个特定层次，专注于用户界面和交互，并非传统意义上的 “Cocoa Touch”。</p><p><strong>那么，Cocoa Touch 是什么呢？</strong><br>关于这个问题，<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Cocoa.html">Apple 官方文档</a>中给出了明确的答案：</p><blockquote><p>Cocoa and Cocoa Touch are the application development environments for OS X and iOS, respectively. Both Cocoa and Cocoa Touch include the Objective-C runtime and two core frameworks:<br>Cocoa, which includes the Foundation and AppKit frameworks, is used for developing applications that run on OS X.<br>Cocoa Touch, which includes Foundation and UIKit frameworks, is used for developing applications that run on iOS.</p></blockquote><p>即：<strong>Cocoa Touch 是 iOS 应用的开发环境，包含了 iOS 开发所用到的一系列框架和技术。Cocoa Touch 中两个最核心的框架分别是 UIKit、Foundation，UIKit、Foundation 分别位于 iOS 系统架构的不同层次中，UIKit 位于触摸层(Cocoa Touch 层)，Foundation 位于核心服务层(Core Services 层)。</strong></p><p>iOS 中的 “Cocoa Touch” 等价于 macOS 中的 “Cocoa”，macOS 的 Cocoa 两个最核心的框架是 AppKit、Foundation，其中 AppKit 就等价于 iOS 中的 UIKit。在基于 macOS 开发出 iOS 系统之后，macOS 中的 Cocoa 就演变成了 iOS 中的 Cocoa Touch。</p><p>在开发时，”Cocoa Touch” 通常泛指所有继承自根类 NSObject 的类或对象。</p><h2 id="三、Darwin"><a href="#三、Darwin" class="headerlink" title="三、Darwin"></a>三、Darwin</h2><p>Darwin 是 Apple 1999 年开源出的操作系统，Darwin 是一个完整的操作系统，也是 macOS、iOS、tvOS、watchOS、BridgeOS 系统的基础。</p><p>Darwin 操作系统的主要作用，是在应用程序和硬件之间，提供一层抽象。Darwin 提供了应用程序与硬件交互的抽象接口，使开发者在开发应用程序时，避免了和硬件的直接交互，也就避免了对不同硬件的适配。由于操作系统可以运行在不同的硬件上，因此开发者编写的代码就具有了可移植性。</p><p>iOS 在 Darwin 基础上，向开发者提供了图形渲染能力及面向对象开发环境，如 Metal、QuartzCore、CoreGraphics 和 Cocoa Touch，开发者可以在此基础上，进行 APP 的开发。Darwin 的内核是 XNU，Darwin 所承担的具体工作，都是由 XNU 来完成的。当 APP 需要内核 XNU 提供服务时，就需要通过 Darwin 提供的系统调用相关的 API，从用户态切换到内核态，内核 XNU 在内核态完成具体工作后，再切换回用户态，由 APP 完成后续工作。</p><p>Darwin 架构如下：<br><img src="/images/lix_blog_211.png" style="width:50%;"></p><h3 id="1、libSystem-B-dylib"><a href="#1、libSystem-B-dylib" class="headerlink" title="1、libSystem.B.dylib"></a>1、libSystem.B.dylib</h3><p>libSystem.B.dylib 是 Darwin 系统上的非常重要的一个核心动态链接库，几乎所有的系统服务和应用程序都依赖它，libSystem.B.dylib 通过整合多个系统库的符号和链接信息，提供了统一的接口，使得开发者只需链接一个库即可访问多种基础功能，简化了开发过程，同时保持系统库的模块化和可扩展性。</p><p>libSystem.B.dylib 主要包含符号表和链接信息，而不包含实际的实现代码。它充当一个伪装库（stub library），在编译时提供符号解析，在 APP 启动时由动态链接器（dyld）解析并加载实际的实现库。</p><p>以 iOS 15.6.1 为例，其 libSystem.B.dylib 位于如下目录中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/lifengfeng/Library/Developer/Xcode/iOS DeviceSupport/iPhone13,2 15.6.1 (19G82)/Symbols/usr/lib/libSystem.B.dylib</span><br></pre></td></tr></table></figure><p>每个版本模拟器，libSystem.B.dylib 所处位置可能不同，可以使用如下命令查找 libSystem.B.dylib 的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -name libSystem.B.dylib 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>找到 libSystem.B.dylib 后，可以使用 otool 工具查看 libSystem.B.dylib 里依赖的具体系统库：</p><ul><li>otool -L：用于显示 Mach-O 文件的动态库依赖列表，简洁地列出所有依赖的动态库及其版本信息。</li><li>otool -l：用于显示 Mach-O 文件的所有加载命令，提供详细的元数据信息，包括段信息、依赖库、符号表等。</li></ul><p>可以使用 otool -L 命令打印 libSystem.B.dylib 依赖的系统库信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -L /Users/lifengfeng/Library/Developer/Xcode/iOS\ DeviceSupport/iPhone13,2\ 15.6.1\ \(19G82\)/Symbols/usr/lib/libSystem.B.dylib</span><br></pre></td></tr></table></figure><p>打印内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/Users/lifengfeng/Library/Developer/Xcode/iOS DeviceSupport/iPhone13,2 15.6.1 (19G82)/Symbols/usr/lib/libSystem.B.dylib:</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1311.120.1)</span><br><span class="line">/usr/lib/system/libcache.dylib (compatibility version 1.0.0, current version 85.0.0, reexport)</span><br><span class="line">/usr/lib/system/libcommonCrypto.dylib (compatibility version 1.0.0, current version 60191.100.1, reexport)</span><br><span class="line">/usr/lib/system/libcompiler_rt.dylib (compatibility version 1.0.0, current version 103.1.0, reexport)</span><br><span class="line">/usr/lib/system/libcopyfile.dylib (compatibility version 1.0.0, current version 1.0.0, reexport)</span><br><span class="line">/usr/lib/system/libcorecrypto.dylib (compatibility version 1.0.0, current version 1218.120.10, reexport)</span><br><span class="line">/usr/lib/system/libdispatch.dylib (compatibility version 1.0.0, current version 1325.120.2, reexport)</span><br><span class="line">/usr/lib/system/libdyld.dylib (compatibility version 1.0.0, current version 1.0.0, reexport)</span><br><span class="line">/usr/lib/system/libmacho.dylib (compatibility version 1.0.0, current version 994.2.0, reexport)</span><br><span class="line">/usr/lib/system/libremovefile.dylib (compatibility version 1.0.0, current version 60.0.0, reexport)</span><br><span class="line">/usr/lib/system/libsystem_asl.dylib (compatibility version 1.0.0, current version 392.100.2, reexport)</span><br><span class="line">/usr/lib/system/libsystem_blocks.dylib (compatibility version 1.0.0, current version 79.1.0, reexport)</span><br><span class="line">/usr/lib/system/libsystem_c.dylib (compatibility version 1.0.0, current version 1507.100.9, reexport)</span><br><span class="line">/usr/lib/system/libsystem_collections.dylib (compatibility version 1.0.0, current version 1507.100.9, reexport)</span><br><span class="line">/usr/lib/system/libsystem_configuration.dylib (compatibility version 1.0.0, current version 1163.140.3, reexport)</span><br><span class="line">/usr/lib/system/libsystem_containermanager.dylib (compatibility version 1.0.0, current version 1.0.0, reexport)</span><br><span class="line">/usr/lib/system/libsystem_coreservices.dylib (compatibility version 1.0.0, current version 133.0.0, reexport)</span><br><span class="line">/usr/lib/system/libsystem_darwin.dylib (compatibility version 1.0.0, current version 1.0.0, reexport)</span><br><span class="line">/usr/lib/system/libsystem_dnssd.dylib (compatibility version 1.0.0, current version 1557.140.4, reexport)</span><br><span class="line">/usr/lib/system/libsystem_featureflags.dylib (compatibility version 1.0.0, current version 56.0.0, reexport)</span><br><span class="line">/usr/lib/system/libsystem_info.dylib (compatibility version 1.0.0, current version 1.0.0, reexport)</span><br><span class="line">/usr/lib/system/libsystem_m.dylib (compatibility version 1.0.0, current version 3204.80.2, reexport)</span><br><span class="line">/usr/lib/system/libsystem_malloc.dylib (compatibility version 1.0.0, current version 374.120.1, reexport)</span><br><span class="line">/usr/lib/system/libsystem_networkextension.dylib (compatibility version 1.0.0, current version 1.0.0, reexport)</span><br><span class="line">/usr/lib/system/libsystem_notify.dylib (compatibility version 1.0.0, current version 301.0.0, reexport)</span><br><span class="line">/usr/lib/system/libsystem_product_info_filter.dylib (compatibility version 1.0.0, current version 10.0.0, reexport)</span><br><span class="line">/usr/lib/system/libsystem_sandbox.dylib (compatibility version 1.0.0, current version 1657.140.3, reexport)</span><br><span class="line">/usr/lib/system/libsystem_kernel.dylib (compatibility version 1.0.0, current version 8020.142.2, reexport)</span><br><span class="line">/usr/lib/system/libsystem_platform.dylib (compatibility version 1.0.0, current version 273.100.5, reexport)</span><br><span class="line">/usr/lib/system/libsystem_pthread.dylib (compatibility version 1.0.0, current version 486.100.11, reexport)</span><br><span class="line">/usr/lib/system/libsystem_symptoms.dylib (compatibility version 1.0.0, current version 1.0.0, reexport)</span><br><span class="line">/usr/lib/system/libsystem_trace.dylib (compatibility version 1.0.0, current version 1375.140.2, reexport)</span><br><span class="line">/usr/lib/system/libunwind.dylib (compatibility version 1.0.0, current version 202.2.0, reexport)</span><br><span class="line">/usr/lib/system/libxpc.dylib (compatibility version 1.0.0, current version 2236.140.2, reexport)</span><br></pre></td></tr></table></figure><p>在上述的打印信息中，列出了 libSystem.B.dylib 依赖的其他系统动态链接库的信息，其中，每一行中的 “reexport” 表示该动态库使用了 LC_REEXPORT_DYLIB 命令重新导出这些依赖库中的符号。这样，任何链接到 libSystem.B.dylib 的 APP 或其他动态库都可以直接使用这些被重新导出的符号，而无需直接链接到这些底层库。</p><p>当一个应用程序或动态库加载包含 LC_REEXPORT_DYLIB 命令的动态库时，动态链接器（dyld）会立即解析并加载所有 LC_REEXPORT_DYLIB 指定的库。这意味着这些库会在 APP 冷启动时，随着 libSystem.B.dylib 一起加载到内存中。</p><p>同时，可以在上述的打印信息中，可以看到我们开发中常用的一些系统库，例如：</p><ul><li>libdispatch.dylib：提供了 GCD</li><li>libsystem_blocks.dylib：提供了 Block</li><li>libsystem_pthread.dylib：提供了 pthread</li><li>libsystem_c.dylib：提供了标准 C 库，如字符串操作、输入输出、数学运算等。</li></ul><h3 id="2、用户态-内核态"><a href="#2、用户态-内核态" class="headerlink" title="2、用户态 &amp; 内核态"></a>2、用户态 &amp; 内核态</h3><h4 id="（1）什么是用户态、内核态"><a href="#（1）什么是用户态、内核态" class="headerlink" title="（1）什么是用户态、内核态"></a>（1）什么是用户态、内核态</h4><p>一个 iOS APP 从开发到运行，大致流程如下：</p><ul><li>在开发时，我们使用高级语言（如 Objective-C 或 Swift）编写源代码文件。</li><li>源代码文件经过编译器的处理，首先被转换为汇编语言，这个过程是将高级语言的语法和结构转换为更接近硬件的汇编语言。</li><li>之后编译器会将汇编语言进一步编译为机器语言，机器语言是由二进制代码组成的语言，这些二进制代码就是 CPU 指令集中的指令。机器语言是可以直接被 CPU 执行的代码。<ul><li>这些机器语言的代码以及其他信息最终会被打包成一个 Mach-O 文件。</li></ul></li><li>当用户启动 APP 时，iOS 操作系统会将 APP 的这些机器语言指令从磁盘加载到内存中并执行。</li></ul><p>如下图：<br><img src="/images/lix_blog_212.png"><br>CPU 指令集可以直接操作硬件的，如果指令操作的不规范，会对整个计算机系统产生很大的影响，甚至会导致操作系统或其他程序的崩溃。因此，为了防止应用程序崩溃而导致的内核崩溃，内核与应用程序之间需要进行严格的分离。基于软件的分离会产生巨大的开销，所以现代的操作系统都是依靠硬件来分离，分离的结果就是用户态与内核态。</p><p>为了保护系统的安全和稳定，硬件设备商直接在硬件层面对 CPU 指令设置了权限，在 iPhone 设备上，CPU 采用的是 ARM 架构，其指令集操作的权限等级主要分为用户模式（User mode）和特权模式（Privileged mode），这两种模式对应于操作系统的用户态和内核态。</p><ul><li><p><strong>用户模式（User mode）</strong></p><ul><li>对应于操作系统的用户态。</li><li>用户模式是应用程序的运行模式。在这种模式下，应用程序只能访问自己的内存空间，不能直接访问硬件或其他程序的内存，也不能执行特权指令。如果应用程序需要执行这些特权操作，如读写文件、创建进程等，必须通过系统调用的方式，请求操作系统代为完成。</li></ul></li><li><p><strong>特权模式（Privileged mode）</strong></p><ul><li>对应于操作系统的内核态。</li><li>特权模式是操作系统内核的运行模式。在这种模式下，操作系统可以访问所有的硬件和内存，可以执行所有的 CPU 指令。特权模式通常用于处理系统调用、中断等系统级的任务。</li></ul></li></ul><p>在特权模式下，又可以细分为以下几种子模式，以处理不同的系统级任务：</p><ul><li><p><strong>系统模式（System mode）</strong></p><ul><li>这是操作系统内核的正常运行模式。</li><li>在这种模式下，操作系统可以访问所有的硬件和内存，可以执行所有的 CPU 指令。当用户态应用程序需要执行高权限的操作（如文件读写、网络通信、进程管理等），会触发系统调用，并在系统模式下完成对应工作。</li></ul></li><li><p><strong>中断模式（IRQ mode）和快速中断模式（FIQ mode）</strong></p><ul><li>这些模式用于处理硬件中断。</li><li>中断模式（IRQ mode）<ul><li>用于处理标准硬件中断请求（Interrupt Requests, IRQs）。</li><li>当系统外设（如键盘、鼠标、网络设备等）需要 CPU 处理某个事件时，它们会发出中断信号，请求系统的注意。</li></ul></li><li>快速中断模式（FIQ mode）<ul><li>用于处理快速、紧急的硬件中断请求（Fast Interrupt Requests, FIQs）。</li><li>设计用于需要最低延迟和最高优先级的中断处理场景，该模式对时间敏感的任务（如音频和视频处理、实时通信等）提供最佳支持。</li></ul></li></ul></li><li><p><strong>异常模式（Abort mode）</strong></p><ul><li>这种模式用于处理内存访问异常。</li><li>当程序试图访问一个无效的内存地址时，CPU 会切换到异常模式，执行预设的异常处理程序。</li></ul></li><li><p><strong>未定义模式（Undefined mode）</strong></p><ul><li>这种模式用于处理未定义的指令。</li><li>当程序试图执行一个未定义的指令时，CPU 会切换到未定义模式，执行预设的错误处理程序。</li></ul></li></ul><h4 id="（2）用户态、内核态的转换"><a href="#（2）用户态、内核态的转换" class="headerlink" title="（2）用户态、内核态的转换"></a>（2）用户态、内核态的转换</h4><p>前面已经提到，用户态、内核态的区分是由硬件（CPU）提供的，当我们开发的 APP 需要内核 XNU 提供服务时，就需要从用户态切换到内核态，由 XNU 在内核态完成对应工作后，再切回回用户态，由 APP 继续完成后续的工作。<br><img src="/images/lix_blog_213.png"><br>用户态、内核态转换，主要有两种方式：</p><ul><li><strong>自愿转换</strong><ul><li>当应用程序需要内核服务的时候，应用程序通过<strong>系统调用</strong>进入内核态。这种转换方式就是自愿切换。</li></ul></li><li><strong>非自愿转换</strong><ul><li>当发生执行异常、中断或处理器陷阱的时候，代码的执行会被挂起，并且保留发生错误时候的完整状态。控制权被转交给预定义的内核态错误处理程序或中断服务程序(interrupt serviceroutine, ISR)。</li></ul></li></ul><p>在 XNU 中，系统调用有四种类别：</p><ul><li><p><strong>BSD 系统调用</strong></p><ul><li>“经典” 的系统调用，是 XNU 的 BSD 提供的接口，又称“BSD 调用”。</li><li>BSD 提供的这些接口遵循 POSIX 标准，提供与 Unix 类操作系统兼容的功能，如文件操作、进程管理、网络通信等。</li><li>如常用的 <code>open</code>、<code>read</code>、<code>write</code>、<code>mmap</code> 等 C 函数内部都是使用 <code>syscall</code> 指令将控制权转移到内核态。</li></ul></li><li><p><strong>Mach 陷阱</strong></p><ul><li>XNU 的 Mach 提供的接口。</li><li>用于进程间通信（IPC）、任务管理、内存管理和其他底层操作系统功能。</li><li>用户态程序通过调用 Mach API 函数（如 <code>mach_msg</code>、<code>task_create</code>、<code>vm_allocate</code> 等）发起 Mach 陷阱，这些函数内部使用 <code>trap</code> 指令将控制权转移到内核态。</li></ul></li><li><p><strong>机器相关的调用</strong></p><ul><li>用于访问 CPU 特定的功能。</li><li>例如 CPU 缓存管理、性能监控、特殊寄存器访问等。</li></ul></li><li><p><strong>诊断调用</strong></p><ul><li>专门用于内核调试和诊断，提供内核状态监控、调试信息输出等功能。</li><li>这些调用通常不用于普通应用程序，而是用于开发和调试内核模块或驱动程序。</li></ul></li></ul><h2 id="3、XNU"><a href="#3、XNU" class="headerlink" title="3、XNU"></a>3、XNU</h2><h3 id="（1）XNU-概述"><a href="#（1）XNU-概述" class="headerlink" title="（1）XNU 概述"></a>（1）XNU 概述</h3><p>内核 XNU 是 Darwin 的核心，也是整个 iOS 的核心。XNU 是 “X is Not Unix” 的缩写，这是一个带有调侃意味的命名。Unix 社区有一种幽默文化，喜欢用反讽或自嘲的方式命名项目。例如：</p><ul><li>GNU：GNU’s Not Unix，是一个递归缩写，表明 GNU 项目虽然与 Unix 兼容，但不是 Unix。</li><li>PINE：”Pine Is Not Elm”，PINE 是一个邮件客户端，名字表明它不是另一个著名的 Unix 邮件客户端 Elm。</li></ul><p>XNU 虽然是 “X is Not Unix” 的缩写，但它仍然深受 UNIX 的设计影响，特别是在 BSD 方面，XNU 通过 BSD 提供了与 UNIX 兼容的功能，使得许多 UNIX 应用程序可以在 macOS 和 iOS 上运行。</p><p>1969 年，Ken Thompson 和 Dennis Ritchie 等人在贝尔实验室开发了操作系统 UNIX，UNIX 的设计强调简单性、可移植性、模块化和多用户支持，这些设计原则影响了许多后来的操作系统。UNIX 并不是一个开源的操作系统，但在 1970 年代和 1980 年代，AT&amp;T（贝尔实验室的母公司）通过许可协议将 UNIX 源代码提供给学术机构和商业公司，加州大学伯克利分校就是这些学术机构之一。</p><p>加州大学伯克利分校的计算机系统研究小组（CSRG）在 UNIX 的基础上进行了大量的改进和扩展，开发出了 BSD 系列操作系统。在 1990 年代，BSD 社区进行了大量工作，以移除 BSD 版本中所有 AT&amp;T 的专有代码。最终在 1994 年发布了 BSD 的新版本 4.4BSD-Lite，这个版本 BSD 已经不含 AT&amp;T 的专有代码。4.4BSD-Lite 及其后续版本是完全开源的，任何人都可以自由使用、修改和分发这些代码，这使得 BSD 系统成为真正的开源 UNIX 实现。</p><p>BSD 系统引入了许多关键技术和概念，如虚拟内存、TCP&#x2F;IP 网络协议栈、文件系统（如 FFS）等，BSD 的开源发布为后来的开源操作系统奠定了基础，许多开源项目直接或间接地受益于 BSD 的代码和设计。FreeBSD、OpenBSD、NetBSD 是三个比较著名的 BSD 血统的操作系统：</p><ul><li>FreeBSD<ul><li>一个基于 4.4BSD-Lite 的开源操作系统，以其高性能和先进的网络功能著称。</li></ul></li><li>OpenBSD<ul><li>专注于安全性和代码审计的开源操作系统。</li></ul></li><li>NetBSD<ul><li>以其可移植性著称，支持多种硬件平台的开源操作系统。</li></ul></li></ul><p>其中，FreeBSD 以其高性能、稳定性和丰富的网络功能著称，广泛用于服务器和嵌入式系统。Darwin 中的 BSD 就是基于 FreeBSD 进行开发的，XNU 中的 BSD 为 Darwin 提供了 POSIX 兼容的 API 和工具集，让 Darwin 具备了与 Unix 类操作系统兼容的功能，使得许多 UNIX 应用程序可以在 macOS 和 iOS 上运行。</p><h3 id="（2）XNU-的架构"><a href="#（2）XNU-的架构" class="headerlink" title="（2）XNU 的架构"></a>（2）XNU 的架构</h3><p>所有操作系统的架构上，都包含内核，但内核的设计上却有所不同。目前主流的，主要有三种风格的内核：宏内核、微内核和混合内核。</p><h4 id="宏内核"><a href="#宏内核" class="headerlink" title="宏内核"></a>宏内核</h4><p>宏内核又称 “巨内核”、”单内核”，这是一个比较经典的内核架构，也是  UNIX 和 Linux 世界采用的主要内核架构。宏内核的特点是将所有内核功能全部放在一个地址空间中。</p><p>宏内核大致架构如下图：<br><img src="/images/lix_blog_214.png"><br>宏内核将所有内核功能全部放在一个地址空间中，并且将这个地址空间映射到每一个进程的内存中。这种设计使得除了硬件强制的内核态和用户态之间的隔离外，用户态和内核态其实没有任何分别，所以从用户态到内核态的切换非常高效，基本上就相当于一次线程切换的开销。</p><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><p>微内核并不像宏内核那么常见，微内核的特点是内核只包含最核心的内核功能，通常包括进程间通信（IPC）、线程管理、虚拟内存管理、时钟和定时器等。</p><p>内核功能之外的部分全部交给各个独立的用户态服务程序完成，这些用户态服务程序包括文件系统服务、网络协议栈服务、进程管理服务等。服务程序之间的所有通信都由消息传递完成。消息传递机制允许将消息(通常都是透明的)以及后续消息投递至服务程序的队列中排队，服务程序可以从队列中取出消息并且依次处理。</p><p>微内核大致架构如下图：<br><img src="/images/lix_blog_215.png"></p><p>微内核由于功能简单、代码量少，所以相较于宏内核，微内核更加稳定，并且更容易移植到其他平台。</p><p>但微内核也有其显著的缺点，微内核的消息传递在底层需要通过内存复制操作以及数次上下文切换操作来实现，而这些操作对计算速度的影响都不小。这一个缺点太严重了，所以“纯粹” 的微内核操作系统基本上只具有学术意义，而没有商业应用，在现代操作系统中则更少见。</p><h4 id="混合内核"><a href="#混合内核" class="headerlink" title="混合内核"></a>混合内核</h4><p>混合内核就是同时包含宏内核和微内核的架构，同时吸收了两种内核架构的优点，兼顾了健壮性、可移植性和运行效率。内核中最核心的部分，如进程间通信（IPC）、线程管理、虚拟内存管理、时钟和定时器等，仍然由微内核负责，其余部分则交由宏内核负责，并且都在内核态之中，而且都在同一个内存空间之中。</p><p>XNU 是一个由宏内核 BSD 与微内核 Mach 组成的混合内核：<br><img src="/images/lix_blog_216.png"><br>XNU 主要由三部分组成：</p><ul><li><p><strong>Mach</strong></p><ul><li>Mach 最初是一个在卡内基梅隆大学(CMU)开发的研究型操作系统，致力于研制一个用于操作系统的轻量级且高效的平台。</li><li>Mach 提供内核最基础的 API 和功能，主要包括：<ul><li>进程间通信（IPC）</li><li>线程管理和调度</li><li>虚拟内存管理</li><li>时钟和定时器</li></ul></li></ul></li><li><p><strong>BSD</strong></p><ul><li>BSD 建立在 Mach 之上，提供了 POSIX 标准的 API，使得许多 UNIX 应用程序可以在 macOS 和 iOS 上运行。</li><li>BSD 提供了更高层次的抽象功能，主要包括：<ul><li>文件系统访问</li><li>进程管理</li><li>资源控制</li><li>网络协议栈</li></ul></li></ul></li><li><p><strong>I&#x2F;O Kit</strong></p><ul><li>一个面向对象的框架，用于开发设备驱动程序，提供了与硬件交互的标准接口，提高驱动程序的安全性和可维护性。</li></ul></li></ul><p>XNU 也是完全开源的，GitHub 链接是：<a href="https://github.com/apple-oss-distributions/xnu">https://github.com/apple-oss-distributions/xnu</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件 IO 与 mmap</title>
      <link href="/posts/15823/"/>
      <url>/posts/15823/</url>
      
        <content type="html"><![CDATA[<h2 id="一、常规文件访问"><a href="#一、常规文件访问" class="headerlink" title="一、常规文件访问"></a>一、常规文件访问</h2><p>以 <code>NSUserDefaults</code> 为例，看下传统文件读写流程。</p><h3 id="1、NSUserDefaults-基本使用"><a href="#1、NSUserDefaults-基本使用" class="headerlink" title="1、NSUserDefaults 基本使用"></a>1、NSUserDefaults 基本使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUserDefaults</span> *defaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line"><span class="comment">// 写</span></span><br><span class="line">[defaults setObject:<span class="string">@&quot;testValue&quot;</span> forKey:<span class="string">@&quot;testKey&quot;</span>];</span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line"><span class="built_in">NSString</span> *value = [defaults objectForKey:<span class="string">@&quot;testKey&quot;</span>];</span><br></pre></td></tr></table></figure><p>iOS 还提供了强制同步的 API：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] synchronize];</span><br></pre></td></tr></table></figure><p>在早期的 API 中，往往需要开发者会主动调用 <code>synchronize</code> 以确保同步。但 Apple 当前<a href="https://developer.apple.com/documentation/foundation/nsuserdefaults/1414005-synchronize">文档</a>已经提示，不要再调用该 API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Waits for any pending asynchronous updates to the defaults database and returns; this method is unnecessary and shouldn&#x27;t be used.</span><br></pre></td></tr></table></figure><p>原因是 iOS 已经提供了更智能和高效的机制来自动管理 <code>NSUserDefaults</code> 数据的持久化，系统会在以下几个时机进行数据同步：</p><ul><li>应用进入后台时。</li><li>应用即将终止时。</li><li>系统检测到内存压力时。</li></ul><p>而开发者主动调用 <code>synchronize</code> 可能会带来一系列问题，如阻塞主线程、数据冲突等。</p><h3 id="2、NSUserDefaults-读、写流程"><a href="#2、NSUserDefaults-读、写流程" class="headerlink" title="2、NSUserDefaults 读、写流程"></a>2、NSUserDefaults 读、写流程</h3><h4 id="1-写流程"><a href="#1-写流程" class="headerlink" title="(1) 写流程"></a>(1) 写流程</h4><p><code>NSUserDefaults</code> 在调用类似 <code>setObject:forKey:</code> 写 API 后，数据同步时内部实际上是通过调用 <code>writeToFile:options:error:</code> 将数据写入磁盘的。<br><code>writeToFile:options:error:</code> 的内部实现会使用 <code>open</code>、<code>write</code> 和 <code>close</code> 系统调用来实现数据持久化：</p><ul><li>打开文件（<code>open</code>）：<ul><li>创建一个文件描述符，用于写操作。</li><li><code>int fd = open(filePath, O_WRONLY | O_CREAT | O_TRUNC, 0644);</code></li></ul></li><li>写入数据（<code>write</code>）：<ul><li>将序列化的 plist 数据写入文件。</li><li><code>ssize_t bytesWritten = write(fd, serializedData, length);</code></li></ul></li><li>关闭文件（<code>close</code>）：<ul><li>关闭文件描述符，保存更改。</li><li><code>close(fd);</code></li></ul></li></ul><p><strong>写主要流程总结：</strong></p><ul><li>在 <code>open</code> 系统调用时，就从用户空间切换到了内核空间，在内核空间获取到文件描述符 <code>fd</code> 后再返回给用户空间。即执行完 <code>open</code> 之后，就回到了用户空间。<ul><li><code>write</code> 也是系统调用，也会导致从用户空间切换到内核空间，在内核空间中，操作系统执行实际的数据写操作，其主要流程如下：<ul><li>内核从用户空间缓冲区读取数据，并暂时存储到内核缓冲区（页缓存）。</li><li>内核将数据从内核缓冲区写入到磁盘。<ul><li>如果缓存写（write-back）机制启用，数据写入到内核的缓存区后，不会立即写入到磁盘，当缓存区达到一定条件时再批量写入。</li></ul></li></ul></li></ul><p></p></li><li>数据写完成后，使用 <code>close</code> 系统调用关闭文件描述符，释放资源。<ul><li>内核会从进程的文件描述符表中移除对应条目，使该文件描述符变得无效。</li><li>内核会减少与文件描述符关联的文件对象的引用计数，如果减少后的引用计数为零，表示没有其他进程或文件描述符引用该文件对象，内核会释放与文件对象相关的所有资源。</li><li>内核更新文件的访问时间和修改时间，并将这些元数据和缓存的数据写入磁盘，以确保文件系统的一致性。</li></ul></li></ul><p><strong>其中：</strong></p><ul><li><strong>内核缓冲区</strong><ul><li>内核缓冲区是操作系统内核用来暂时存储数据的内存区域，是物理内存中的一部分。它们位于内核空间，用户态程序无法直接访问，前述的文件读取时，内核缓冲区指的是页缓存（page cache）。</li></ul></li><li><strong>用户空间缓冲区</strong><ul><li>用户空间缓冲区是由用户态程序分配并使用的内存区域，也是物理内存的一部分。它们位于用户空间，程序可以直接访问和操作这些区域。</li></ul></li></ul><h4 id="2-读流程"><a href="#2-读流程" class="headerlink" title="(2) 读流程"></a>(2) 读流程</h4><p>当使用 <code>NSUserDefaults</code> 的 <code>objectForKey</code> 方法来读取数据时，底层流程如下：</p><ul><li>读取内存缓存：<ul><li>调用 <code>objectForKey:</code> 方法时，<code>NSUserDefaults</code> 首先尝试从内存中的字典（缓存）中读取数据。</li><li><code>NSString *value = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;exampleKey&quot;];</code></li></ul></li><li>缓存未命中，读取文件：<ul><li>如果数据不在内存缓存中，则 <code>NSUserDefaults</code> 从磁盘的 plist 文件中读取数据。</li></ul></li><li>打开文件（<code>open</code>）：<ul><li>使用 open 系统调用以只读模式打开 plist 文件。</li><li><code>int fd = open(&quot;/path/to/plist&quot;, O_RDONLY);</code></li></ul></li><li>读取数据（<code>read</code>）：<ul><li>使用 <code>read</code> 系统调用将文件内容读入内存缓冲区。</li><li><code>ssize_t bytesRead = read(fd, buffer, bufferSize);</code></li></ul></li><li>关闭文件（<code>close</code>）：<ul><li>数据读取完成后，使用 <code>close</code> 系统调用关闭文件描述符，释放资源。</li><li><code>close(fd);</code></li></ul></li><li>反序列化数据：<ul><li>将从文件中读取的 plist 数据反序列化，并存入内存缓存，供后续读取。</li></ul></li></ul><p><strong>读主要流程总结：</strong></p><ul><li>在 <code>open</code> 系统调用时，就从用户空间切换到了内核空间，在内核空间获取到文件描述符 <code>fd</code> 后再返回给用户空间。即执行完 <code>open</code> 之后，就回到了用户空间。</li><li><code>read</code> 也是系统调用，也会导致从用户空间切换到内核空间，在内核空间中，操作系统执行实际的数据读取操作，并返回结果给用户空间，其主要流程如下：<ul><li>由于系统调用 <code>read</code>，CPU 切换到内核态，操作系统内核接管控制。</li><li>内核通过已打开的文件描述符找到对应的文件，先检查内核缓冲区是否已经缓存了所需的文件数据。<ul><li>如果内核缓冲区命中缓存，则将缓存拷贝至用户缓冲区。</li><li>如果内核缓冲区没有命中缓存，则先从磁盘读取数据到内核缓冲区，再将内核缓冲区缓存拷贝至用户空间缓冲区。</li></ul></li><li>将用户空间缓冲区中的内容返回。<ul><li>因为用户态进程只能访问用户空间的内容。</li></ul></li></ul></li><li>数据读取完成后，使用 <code>close</code> 系统调用关闭文件描述符，释放资源。</li></ul><h4 id="3-简单总结"><a href="#3-简单总结" class="headerlink" title="(3) 简单总结"></a>(3) 简单总结</h4><p>由前述的读写流程可知，读写的核心操作，分别是 <code>read</code>、<code>write</code> 两个系统调用。<br>对于上述 <code>read</code>、<code>write</code> 系统调用的主要流程，可用下图表示：<br><img src="/images/lix_blog_165.png"></p><p>由此可知，传统文件读写，存在下面两个对性能影响较大的操作：</p><ul><li>至少两次数据的拷贝。</li><li>需要将文件内容拷贝到用户空间缓冲区，增加内存占用。<ul><li>将 <code>read</code>、<code>write</code> 系统调用时参数指定大小的内容拷贝到用户空间缓冲区。</li></ul></li></ul><h2 id="二、mmap"><a href="#二、mmap" class="headerlink" title="二、mmap"></a>二、mmap</h2><h3 id="1、基本使用"><a href="#1、基本使用" class="headerlink" title="1、基本使用"></a>1、基本使用</h3><p><code>mmap</code> 是一个系统调用，它会从用户空间切换到内核空间执行相关操作，然后再返回到用户空间。它用于将文件映射到进程的虚拟内存，使得文件内容可以像内存一样被访问。<br><strong>mmap 函数原型如下：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *mmap(<span class="type">void</span> *addr, size_t length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, off_t offset);</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><code>addr</code>：请求映射的虚拟地址，如果设置为 NULL，则由系统决定地址。</li><li><code>length</code>：映射的字节数。</li><li><code>prot</code>：映射的保护标志，指定页面的可访问性（如 PROT_READ, PROT_WRITE）。</li><li><code>fd</code>：要映射的文件描述符。</li><li><code>offset</code>：文件中开始映射的偏移量。</li></ul><p>使用示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 文件路径</span></span><br><span class="line">        <span class="built_in">NSString</span> *fileName = <span class="string">@&quot;example.txt&quot;</span>;</span><br><span class="line">        <span class="built_in">NSString</span> *documentDirectory = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) firstObject];</span><br><span class="line">        <span class="built_in">NSString</span> *filePath = [documentDirectory stringByAppendingPathComponent:fileName];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">        <span class="keyword">if</span> (![fileManager fileExistsAtPath:filePath]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;File does not exist at path: %@&quot;</span>, filePath);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 打开文件，读写模式</span></span><br><span class="line">        <span class="type">int</span> fd = open([filePath fileSystemRepresentation], O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取文件大小</span></span><br><span class="line">        <span class="keyword">struct</span> stat sb;</span><br><span class="line">        <span class="keyword">if</span> (fstat(fd, &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Error getting file size&quot;</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size_t filesize = sb.st_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将文件映射到内存，读写模式</span></span><br><span class="line">        <span class="type">char</span> *mapped = mmap(<span class="literal">NULL</span>, filesize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mapped == MAP_FAILED) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Error mapping file&quot;</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件描述符</span></span><br><span class="line">        close(fd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件内容并打印到控制台</span></span><br><span class="line">        <span class="built_in">NSData</span> *fileData = [<span class="built_in">NSData</span> dataWithBytes:mapped length:filesize];</span><br><span class="line">        <span class="built_in">NSString</span> *fileContent = [[<span class="built_in">NSString</span> alloc] initWithData:fileData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Original file content: %@&quot;</span>, fileContent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改文件内容（假设文件内容是文本）</span></span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span> *newText = <span class="string">&quot;Hello, mmap!&quot;</span>;</span><br><span class="line">        size_t newTextLength = strlen(newText);</span><br><span class="line">        <span class="keyword">if</span> (newTextLength &lt;= filesize) &#123;</span><br><span class="line">            memcpy(mapped, newText, newTextLength);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Modified file content: %s&quot;</span>, mapped);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同步修改到文件</span></span><br><span class="line">            <span class="keyword">if</span> (msync(mapped, filesize, MS_SYNC) == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;Error syncing file&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;New text is larger than the file size, not modifying.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消映射</span></span><br><span class="line">        <span class="keyword">if</span> (munmap(mapped, filesize) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Error unmapping file&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述使用总结：</strong></p><ul><li><p>读文件</p><ul><li>打开文件 (<code>open</code>):<ul><li>调用 <code>open</code> 系统调用以只读模式打开文件，获得文件描述符。</li><li>示例: <code>int fd = open(&quot;example.txt&quot;, O_RDONLY);</code></li></ul></li><li>获取文件大小 (<code>fstat</code>):<ul><li>调用 <code>fstat</code> 获取文件的大小，以确定映射的长度。</li><li>示例: <code>struct stat sb; fstat(fd, &amp;sb); size_t filesize = sb.st_size;</code></li></ul></li><li>映射文件 (<code>mmap</code>):<ul><li>调用 <code>mmap</code> 将文件映射到内存，指定映射区域的保护标志为只读。</li><li>示例: <code>char *mapped = mmap(NULL, filesize, PROT_READ, MAP_SHARED, fd, 0);</code></li></ul></li><li>读取数据:<ul><li>通过访问映射的内存区域读取文件内容。</li><li>示例: <code>printf(&quot;File content: %s&quot;, mapped);</code></li></ul></li><li>取消映射 (<code>munmap</code>):<ul><li>调用 <code>munmap</code> 取消内存映射，释放映射区域。</li><li>示例: <code>munmap(mapped, filesize);</code></li></ul></li><li>关闭文件 (<code>close</code>):<ul><li>关闭文件描述符。</li><li>示例: <code>close(fd);</code></li></ul></li></ul></li><li><p>写文件</p><ul><li>打开文件 (<code>open</code>):<ul><li>调用 <code>open</code> 系统调用以读写模式打开文件，获得文件描述符。</li><li>示例: <code>int fd = open(&quot;example.txt&quot;, O_RDWR);</code></li></ul></li><li>获取文件大小 (<code>fstat</code>):<ul><li>调用 <code>fstat</code> 获取文件的大小，以确定映射的长度。</li><li>示例: <code>struct stat sb; fstat(fd, &amp;sb); size_t filesize = sb.st_size;</code></li></ul></li><li>映射文件 (<code>mmap</code>):<ul><li>调用 <code>mmap</code> 将文件映射到内存，指定映射区域的保护标志为读写。</li><li>示例: <code>char *mapped = mmap(NULL, filesize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</code></li></ul></li><li>修改数据:<ul><li>通过访问映射的内存区域修改文件内容。</li><li>示例: <code>memcpy(mapped, &quot;New content&quot;, strlen(&quot;New content&quot;));</code></li></ul></li><li>同步修改 (<code>msync</code>):<ul><li>调用 <code>msync</code> 将修改同步到磁盘。</li><li>示例: <code>msync(mapped, filesize, MS_SYNC);</code></li></ul></li><li>取消映射 (<code>munmap</code>):<ul><li>调用 <code>munmap</code> 取消内存映射，释放映射区域。</li><li>示例: <code>munmap(mapped, filesize);</code></li></ul></li><li>关闭文件 (<code>close</code>):<ul><li>关闭文件描述符。</li><li>示例: <code>close(fd);</code></li></ul></li></ul></li></ul><h3 id="2、mmap-原理"><a href="#2、mmap-原理" class="headerlink" title="2、mmap 原理"></a>2、mmap 原理</h3><h4 id="1-读"><a href="#1-读" class="headerlink" title="(1) 读"></a>(1) 读</h4><p>操作系统为每个进程分配了虚拟内存，<code>mmap</code> 则是将文件映射到进程的虚拟内存，使得文件内容可以像内存一样被访问。</p><p>注意，这里仅是映射，文件的内容并不会立即被拷贝到用户空间的虚拟内存中。<code>mmap</code> 只是将文件与进程的虚拟地址空间关联起来。映射区域的页面在物理内存中并不会马上被分配，文件的实际数据仍然驻留在磁盘上。</p><p>当首次访问进行虚拟内存映射区域时，操作系统通过缺页中断将需要的文件页面从磁盘加载到物理内存中。</p><p><strong>该主要流程如下：</strong></p><ul><li>映射文件到虚拟内存<ul><li>使用 <code>mmap</code> 系统调用将文件映射到进程的虚拟地址空间。此时，文件的内容还没有实际加载到物理内存中，只有一个虚拟内存区域被分配。</li></ul></li><li>访问映射的虚拟内存地址<ul><li>应用程序尝试访问映射的虚拟内存地址。这种访问通常包括读取操作。</li></ul></li><li>缺页中断<ul><li>MMU 将虚拟地址转换为物理地址时，发现该页不在物理内存中，产生一个缺页中断（Page Fault）。</li></ul></li><li>内核处理缺页中断<ul><li>内核捕获缺页中断，并检查相应的虚拟内存页表项。它会发现该页是映射的文件的一部分，而实际数据尚未加载。</li></ul></li><li>加载页面<ul><li>内核从磁盘读取对应的文件内容，将其加载到物理内存中。通常，这个操作会将整个页（通常是 4KB）读取到物理内存中。</li></ul></li><li>更新页表<ul><li>内核更新进程的页表，将虚拟地址映射到新的物理内存地址，并设置相应的权限（只读或读写等）。</li></ul></li><li>继续执行<ul><li>缺页中断处理完成后，进程重新开始执行，并继续访问已加载到内存中的数据。</li></ul></li></ul><p>该流程可用下图表示：<br><img src="/images/lix_blog_167.png"></p><p>相关更多内容可参考我的另一篇博客：<a href="https://www.lixkit.com/posts/29690/"> 《APP 启动优化 3-二进制重排》</a></p><h4 id="2-写"><a href="#2-写" class="headerlink" title="(2) 写"></a>(2) 写</h4><p><strong>写主要流程如下：</strong></p><ul><li>映射文件到虚拟内存<ul><li>与读流程相同，使用 <code>mmap</code> 系统调用将文件映射到进程的虚拟地址空间。</li></ul></li><li>访问映射的虚拟内存地址<ul><li>应用程序尝试写入映射的虚拟内存地址。这可能会触发缺页中断，如果该页尚未加载到物理内存中。</li></ul></li><li>缺页中断<ul><li>如果写入的页尚未在物理内存中，则会触发缺页中断，内核开始处理。</li></ul></li><li>加载页面<ul><li>内核从磁盘读取对应的文件内容，并将其加载到物理内存中。这通常是为了保持文件的一致性，即使是在写操作时。</li></ul></li><li>更新页表<ul><li>内核更新页表，将虚拟地址映射到物理内存中的副本页，并设置相应的权限（读写）。</li></ul></li><li>写入数据<ul><li>应用程序将数据写入物理内存。</li></ul></li><li>脏页标记<ul><li>修改的页被标记为脏页，表示内存中的数据与磁盘上的数据不同步。</li></ul></li><li>同步到磁盘<ul><li>内核的页回写机制负责将脏页的数据写回到磁盘。这个过程可以通过 <code>msync</code> 系统调用手动触发，也可以通过内核定期的页面回收机制自动进行。</li></ul></li><li>清除脏页标记<ul><li>一旦数据写回到磁盘，脏页标记被清除，表示内存和磁盘数据再次同步。</li></ul></li></ul><p>操作系统内核并不会立刻把 <code>mmap</code> 映射的页缓存同步到磁盘，同步内存到磁盘有 4 个时机：</p><ul><li>调用 <code>msync</code> 函数主动进行数据同步。</li><li>调用 <code>munmap</code> 函数对文件进行解除映射关系时。</li><li>进程退出时。</li><li>系统关机时。</li></ul><p>对于“进程退出时”、“系统关机时”两个时机，由操作系统自动完成，操作系统在对应时机自动完成同步到磁盘的工作。也就是说，一旦将内容写入到物理内存后，即使 APP 发生 Crash，操作系统也可以将这些数据写入到磁盘。</p><h4 id="3-简单总结-1"><a href="#3-简单总结-1" class="headerlink" title="(3) 简单总结"></a>(3) 简单总结</h4><p>使用 <code>mmap</code> 读写文件时，<code>mmap</code> 会在磁盘、进程虚拟内存之间建立内存映射关系。当进程读写文件时，是针对虚拟内存进行读写的，当 <code>MMU</code> 检测到物理内存中并不存在虚拟内存对应的内容时，会触发缺页中断，将文件内容拷贝到物理内存中。后续再对访问虚拟内存中的内容时，在 <code>MMU</code> 的配合下，就访问操作物理内存中对应的内容了。<br><img src="/images/lix_blog_168.png"></p><p>注意，虚拟内存地址空间实际上是一个映射表，指向物理内存中的实际数据，虚拟内存并不直接存储数据。进程访问虚拟内存时，是通过虚拟内存地址空间的映射关系，直接访问物理内存中的数据。所以访问虚拟内存时，并不涉及往虚拟内存的数据拷贝，只是地址的映射和访问。也就是说，文件内容会存在于两个地方：物理内存、磁盘。</p><p>该过程可以用下图表示：<br><img src="/images/lix_blog_169.png"></p><p><strong><code>mmap</code> 相较于传统文件读写方式，主要区别如下：</strong></p><ul><li>文件内容拷贝次数不同<ul><li>传统方式需要两次拷贝：<strong>磁盘 -&gt; 内核缓冲区 -&gt; 用户空间缓冲区</strong><ul><li>因为进程只能访问自己用户空间缓冲区，不能访问内核缓冲区，所以必须把内容拷贝到用户空间缓冲区才能访问。</li><li>内核缓冲区、用户空间缓冲区都是物理内存的一部分，所以同一份内容，会在物理内存中存在两份。</li></ul></li><li><code>mmap</code> 方式仅需一次拷贝：<strong>磁盘 -&gt; 物理内存</strong><ul><li>由于 <code>mmap</code> 有更少的数据拷贝次数，所以在效率更高、内存占用更少</li></ul></li></ul></li><li>文件内容加载时机不同<ul><li>传统方式：直接将文件内容加载到了物理内存。</li><li><code>mmap</code> 方式：访问具体内容时才会加载到物理内存。<ul><li>因为文件数据在访问时才被加载到内存中。相较于直接读取文件到内存缓冲区，<code>mmap</code> 不需要一次性加载整个文件，降低了内存使用的峰值。</li></ul></li></ul></li><li>写入时机不同<ul><li>传统方式：需要进程显式同步，进程如果发生 Crash，数据可能无法及时写入到磁盘。</li><li><code>mmap</code> 方式：操作系统可以自动完成，可以不需要进程参与。操作系统的页面缓存机制可以提高写入的可靠性，减少了数据丢失的风险。</li></ul></li></ul><h2 id="三、MMKV-与-mmap"><a href="#三、MMKV-与-mmap" class="headerlink" title="三、MMKV 与 mmap"></a>三、MMKV 与 mmap</h2><p>MMKV 是腾讯开源的高性能 Key&#x2F;Value 存储库，MMKV 使用 <code>mmap</code> 进行文件读写，数据序列化使用的是 protobuf 协议，其性能比传统文件读写方式更好。</p><p>其中 Protobuf（Protocol Buffers）是由 Google 开发的一种序列化数据格式，广泛用于数据的高效序列化和反序列化。Protobuf 提供了一种结构化数据的描述语言（.proto 文件），能够生成高效的二进制序列化代码，并支持多种编程语言。<br>.proto 后缀的文件(person.proto)消息结构示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">  int32 id = 1;</span><br><span class="line">  string name = 2;</span><br><span class="line">  string email = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Protobuf（Protocol Buffers）是一种轻量级、跨平台的序列化数据格式，常用于前后端或服务之间的数据交换。其通信流程通常包括以下步骤：</p><ul><li>定义消息结构（.proto 文件）<ul><li>开发者首先在 .proto 文件中定义数据结构，包括消息类型、字段类型和字段编号。</li><li>Protobuf 建议在修改 .proto 文件时，不要删除或更改已有字段的编号或类型，而是通过添加新字段的方式进行扩展。这样可以确保旧版本和新版本之间的兼容性。</li></ul></li><li>生成代码<ul><li>使用 protoc 编译器根据 .proto 文件生成客户端和服务端对应语言的代码（如 Java、Python、Objective-C 等）。这些代码包含了序列化和反序列化功能。</li><li>也就是说，各端使用相同或兼容的 .proto 文件生成代码。</li></ul></li><li>序列化（客户端或服务端）<ul><li>客户端或服务端将需要发送的数据对象序列化为 Protobuf 二进制格式。序列化是将数据结构按照字段编号和类型编码成紧凑的二进制数据。<ul><li>Protobuf 消息的每个字段，都有一个编号，例如前面 <code>Person</code> 的 <code>id</code> 编号为 1、<code>name</code> 编号为 2，在序列化为二进制时，字段名并不参与序列化，而是使用编号代替字段名。所以只要前、后端字段编号一样即可，字段名无须保持一致。</li></ul></li></ul></li><li>数据传输<ul><li>序列化后的二进制数据通过网络传输到另一端。由于 Protobuf 数据非常紧凑，传输效率较高。</li></ul></li><li>反序列化（客户端或服务端）<ul><li>接收端收到二进制数据后，使用生成的代码进行反序列化，将二进制数据转换回原始的对象结构（<code>Model</code>），供应用程序使用。</li></ul></li></ul><p>该过程可用下图表示：<br><img src="/images/lix_blog_170.png"></p><p>MMKV 的 <code>key</code> 限定 <code>string</code> 字符串类型，而 <code>value</code> 则多种多样（<code>int</code>&#x2F;<code>bool</code>&#x2F;<code>double</code> 等），MMKV 先将 <code>value</code> 通过 protobuf 协议序列化成统一的内存块（buffer），确保无论 <code>value</code> 是什么类型，存储使用的类型都是统一的，最后再将这些 KV 对象使用 protobuf 序列化并写入内存中。</p><p>该过程伪代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">message KV &#123;</span><br><span class="line">        string key = <span class="number">1</span>;</span><br><span class="line">        buffer value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)setInt32:(int32_t)value forKey:(<span class="built_in">NSString</span>*)key &#123;</span><br><span class="line">        auto data = PBEncode(value);</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> setData:data forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)setData:(<span class="built_in">NSData</span>*)data forKey:(<span class="built_in">NSString</span>*)key &#123;</span><br><span class="line">        auto kv = KV &#123; key, data &#125;;</span><br><span class="line">        auto buf = PBEncode(kv);</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> write:buf];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准 protobuf 不提供增量更新的能力，每次写入都必须全量写入。考虑到主要使用场景是频繁地进行写入更新，MMKV 需要有增量更新的能力：将增量 kv 对象序列化后，直接 append 到内存末尾；这样同一个 <code>key</code> 会有新旧若干份数据，最新的数据在最后；那么只需在程序启动第一次打开 MMKV 时，不断用后读入的 <code>value</code> 替换之前的值，就可以保证数据是最新有效的。</p><p>使用 <code>append</code> 实现增量更新带来了一个新的问题，就是不断 <code>append</code> 的话，文件大小会增长得不可控。例如同一个 <code>key</code> 不断更新的话，是可能耗尽几百 M 甚至上 G 空间，而事实上整个 kv 文件就这一个 <code>key</code>，不到 1k 空间就存得下。这明显是不可取的。我们需要在性能和空间上做个折中：以内存 <code>pagesize</code> 为单位申请空间，在空间用尽之前都是 <code>append</code> 模式；当 <code>append</code> 到文件末尾时，进行文件重整、<code>key</code> 排重，尝试序列化保存排重结果；排重后空间还是不够用的话，将文件扩大一倍，直到空间足够。</p><p>该过程伪代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)append:(<span class="built_in">NSData</span>*)data &#123;</span><br><span class="line">        <span class="keyword">if</span> (space &gt;= data.length) &#123;</span><br><span class="line">                append(fd, data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newData = unique(m_allKV);</span><br><span class="line">                <span class="keyword">if</span> (total_space &gt;= newData.length) &#123;</span><br><span class="line">                        write(fd, newData);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (total_space &lt; newData.length) &#123;</span><br><span class="line">                                total_space *= <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ftruncate(fd, total_space);</span><br><span class="line">                        write(fd, newData);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCD 底层原理 5 - 线程池</title>
      <link href="/posts/34692/"/>
      <url>/posts/34692/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>提到线程，不得不讲下 CPU，CPU 是计算机的“大脑”，负责着程序的执行和数据的处理。</p><p>现代 CPU 基本都是多核 CPU，这里的“核”是指 CPU 的<strong>物理核心</strong>，物理核心是真正的硬件单元，负责执行指令。物理核心在执行某些类型的指令（如内存访问）时，可能会发生等待，这时核心的其他执行单元如 ALU（算术逻辑单元）可能处于闲置状态。在支持超线程（Hyper-Threading）的 CPU 上，每个物理核心通常可以提供两个<strong>逻辑核心</strong>，使得当一个逻辑核心在等待时，另一个逻辑核心可以利用闲置的执行单元来提前执行其他线程的指令。通过逻辑核心，操作系统可以调度更多的线程同时执行，这增强了系统的并发能力和响应速度。</p><p>所以，<strong>CPU 逻辑核心数量代表了最大并发处理数量参考上限，在逻辑核心数的范围内，操作系统可以提供较高性能的线程调度。</strong></p><p>但是，这并不代表系统所能并发执行的线程数量一定小于 CPU 逻辑核心数量，操作系统可以通过上下文切换在单个逻辑核心上交替执行多个线程。虽然可以调度更多线程，但同时活跃的线程数超过逻辑核心数可能导致资源竞争和性能下降，所以我们在开发时，应尽量避免创建太多的线程。</p><p>对于开发者来说，需要使用 OC 或者 Swift 这类高级语言去开发一个 APP，编译器会将我们使用高级语言编写的代码，会经过编译器的编译处理，先将高级语言代码转换成汇编代码，最后再将汇编代码转成 CPU 可以执行的机器码。</p><p>只看 CPU 的单个核（物理核心），CPU 核从程序的入口地址开始，逐条读取并执行机器指令。每个核心按照程序计数器（PC）的指引，顺序执行指令，除非遇到控制流改变的指令（如跳转、条件分支）。由于 CPU 单个核一次只能执行一个指令，所以每个 CPU 核只可以同时执行一个线程。</p><p>现代操作系统通过时间分片（时间片轮转）的方式实现了单个核心“同时”执行多个线程，时间片是操作系统分配给每个线程的执行时间段（通常是几十毫秒）。一个线程在其时间片内运行，时间片结束时，操作系统再切换到另一个线程继续执行。线程可以有不同的优先级，操作系统可能会优先调度高优先级的线程。在 iOS 中，优先级可以通过 GCD 的 QoS（服务质量）等级进行设置。</p><p>也就是说，我们开发的 iOS APP 可以执行的最大线程数量，是可以远大于 CPU 核心数量的。</p><p><strong>在 GCD 多线程开发中，经常会涉及一个“线程池”的概念，在提到 GCD 线程池时，经常有人说“GCD 线程池中线程最大数量是 64 个“、“GCD 最多可以创建 64 个线程”，其实这个说法是不完全正确的。</strong></p><h2 id="二、线程最大数量测试"><a href="#二、线程最大数量测试" class="headerlink" title="二、线程最大数量测试"></a>二、线程最大数量测试</h2><p>新建一个 macOS 的 Command Line Tool 的工程，用来测试全局队列、并发队列、串行队列最多可以创建多少个线程。</p><p>首先，先打印当前设备有多少个逻辑核心：<br><img src="/images/lix_blog_231.png"><br>可以看到，当前设备 CPU 的物理核心是 6 个，逻辑核心是 12 个。</p><p>为了看清 CPU 繁忙（<strong>活跃线程数量超过逻辑核心数量</strong>）和 CPU 空闲时，最大可创建线程的数量，需要针对两种常见分别测试。</p><h3 id="1、全局并发队列"><a href="#1、全局并发队列" class="headerlink" title="1、全局并发队列"></a>1、全局并发队列</h3><h4 id="（1）CPU-繁忙"><a href="#（1）CPU-繁忙" class="headerlink" title="（1）CPU 繁忙"></a>（1）CPU 繁忙</h4><p>通过下面 Demo 测试 CPU 在繁忙情况下，使用全局并发队列最多可创建多少个线程：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  李峰峰博客 https://www.lixkit.com/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Lix.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">                    <span class="comment">// 占用 CPU，模拟 CPU 繁忙情况</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_233.png"></p><p>去掉一个主线程，可以看到全局并发队列在 CPU 繁忙的情况下，最多可以创建 12 个线程，与 CPU 逻辑核心数量一致。</p><h4 id="（2）CPU-空闲情况"><a href="#（2）CPU-空闲情况" class="headerlink" title="（2）CPU 空闲情况"></a>（2）CPU 空闲情况</h4><p>将上面 Demo 中的 while 无限循环改成 sleep，使其不一直占用 CPU，模拟 CPU 空闲情况：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="comment">// 不占用 CPU，模拟 CPU 空闲情况</span></span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_234.png"><br>同样去掉一个主线程，可以看到全局并发队列在 CPU 空闲的情况下，最多可以创建 64个线程。</p><h4 id="（3）结论"><a href="#（3）结论" class="headerlink" title="（3）结论"></a>（3）结论</h4><p>全局队列最多可创建线程数量：</p><ul><li>CPU 繁忙时：与 CPU 逻辑核心数量一致</li><li>CPU 空闲时：64 个</li></ul><h3 id="2、并发队列"><a href="#2、并发队列" class="headerlink" title="2、并发队列"></a>2、并发队列</h3><p>测试并发队列时，每次循环都创建新的队列，测试在 CPU 繁忙、空闲情况下分别最多可以创建多少个线程。</p><h4 id="（1）CPU-繁忙情况"><a href="#（1）CPU-繁忙情况" class="headerlink" title="（1）CPU 繁忙情况"></a>（1）CPU 繁忙情况</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.lixkit.demo.%lu&quot;</span>, i];</span><br><span class="line">            <span class="comment">// 每次循环都是新的队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(label.UTF8String, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">                    <span class="comment">// 占用 CPU，模拟 CPU 繁忙情况</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_235.png"><br>去掉一个主线程，CPU 繁忙情况下，并发队列最多可以创建 12 个线程，和逻辑核心数量一致。</p><h4 id="（2）CPU-空闲情况-1"><a href="#（2）CPU-空闲情况-1" class="headerlink" title="（2）CPU 空闲情况"></a>（2）CPU 空闲情况</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.lixkit.demo.%lu&quot;</span>, i];</span><br><span class="line">            <span class="comment">// 每次循环都是新的队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(label.UTF8String, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="comment">// 不占用 CPU，模拟 CPU 空闲情况</span></span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_236.png"><br>去掉一个主线程，CPU 空闲情况下，并发队列最多可以创建 64 个线程。</p><h4 id="（3）结论-1"><a href="#（3）结论-1" class="headerlink" title="（3）结论"></a>（3）结论</h4><p>并发队列最多可创建线程数量：</p><ul><li>CPU 繁忙时：与 CPU 逻辑核心数量一致</li><li>CPU 空闲时：64 个</li></ul><p>与全局并发队列表现一致。</p><h3 id="3、串行队列"><a href="#3、串行队列" class="headerlink" title="3、串行队列"></a>3、串行队列</h3><p>测试串行队列和并发队列类似，只需要将循环里创建的队列改成串行队列即可。</p><h4 id="（1）CPU-繁忙情况-1"><a href="#（1）CPU-繁忙情况-1" class="headerlink" title="（1）CPU 繁忙情况"></a>（1）CPU 繁忙情况</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.lixkit.demo.%lu&quot;</span>, i];</span><br><span class="line">            <span class="comment">// 每次循环都是新的队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(label.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">                    <span class="comment">// 占用 CPU，模拟 CPU 繁忙情况</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了串行队列任务能派发完毕，这里延迟 1 秒</span></span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_237.png"><br>去掉一个主线程，在 CPU 繁忙情况下，串行队列最多可创建 512 个线程。</p><h4 id="（2）CPU-空闲情况-2"><a href="#（2）CPU-空闲情况-2" class="headerlink" title="（2）CPU 空闲情况"></a>（2）CPU 空闲情况</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.lixkit.demo.%lu&quot;</span>, i];</span><br><span class="line">            <span class="comment">// 每次循环都是新的队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(label.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="comment">// 不占用 CPU，模拟 CPU 空闲情况</span></span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了串行队列任务能派发完毕，这里延迟 1 秒</span></span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_238.png"><br>去掉一个主线程，在 CPU 空闲情况下，串行队列最多可创建 512 个线程。</p><h4 id="（3）结论-2"><a href="#（3）结论-2" class="headerlink" title="（3）结论"></a>（3）结论</h4><p><strong>无论 CPU 是否空闲，串行队列都最多可以创建 512 个线程。</strong></p><h3 id="4、并发队列-串行队列"><a href="#4、并发队列-串行队列" class="headerlink" title="4、并发队列 + 串行队列"></a>4、并发队列 + 串行队列</h3><p>经过上面的测试可以发现，在 CPU 空闲情况下，并发队列相较于 CPU 繁忙时，可以创建更多数量的线程，最多可以创建 64 个线程。而串行队列，无论 CPU 是否空闲，都最多可以创建多达 512 个线程。</p><p>那么，在 CPU 空闲情况下下，同时使用并发队列和串行队列，最多可创建的线程数量，是 512 还是 512 + 64 &#x3D; 576 个呢？</p><p>接下来通过 Demo 测试下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  李峰峰博客 https://www.lixkit.com/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Lix.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="comment">// 串行队列</span></span><br><span class="line">            <span class="built_in">NSString</span> *serialLabel = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.lixkit.demo.serial.%lu&quot;</span>, i];</span><br><span class="line">            <span class="comment">// 每次循环都是新的队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(serialLabel.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="comment">// 不占用 CPU，模拟 CPU 空闲情况</span></span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 并发队列</span></span><br><span class="line">            <span class="built_in">NSString</span> *concurrentLabel = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.lixkit.demo.concurrent.%lu&quot;</span>, i];</span><br><span class="line">            <span class="comment">// 每次循环都是新的队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(concurrentLabel.UTF8String, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="comment">// 不占用 CPU，模拟 CPU 空闲情况</span></span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了串行队列任务能派发完毕，这里延迟 1 秒</span></span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_239.png"><br>可以看到，同时使用并发队列和串行队列，最终可创建的线程数量，还是最多 512 个。</p><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p>经过测试可以得出结论，关于不同队列可创建线程数量的结论如下：</p><ul><li><strong>全局队列、并发队列</strong><ul><li>CPU 繁忙时，最大可创建线程数量：为 CPU 逻辑核心数量。</li><li>CPU 空闲时，最大可创建线程数量：64 个。</li></ul></li><li><strong>串行队列</strong><ul><li>CPU 繁忙、空闲时，最大可创建线程数量均为：512 个。</li></ul></li><li><strong>并发队列 + 串行队列</strong><ul><li>两种队列一起使用，即使在 CPU 空闲时，最大可创建线程数量也为：512 个。</li></ul></li></ul><p>根据测试结果可知，“GCD 线程池中线程最大数量是 64 个“、“GCD 最多可以创建 64 个线程”这样的说法是不完全正确的。更准确的说法应该是：<strong>GCD 线程池中线程最大数量是 512 个，其中并发队列（含全局并发队列）最多可创建线程数量是 64 个，串行队列最多可创建线程数量是 512 个。其中，这个“线程池”是由内核 XNU 维护的。</strong></p><p>在上一篇文章<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a> 中已经分析过，<code>dispatch_async</code> 对于并发队列和串行队列申请线程的两个关键步骤如下：</p><ul><li><strong>初始化 <code>workqueue</code></strong><ul><li><code>pthread_workqueue_setup</code>（全局仅调用一次）初始化 <code>workqueue</code><ul><li>内部会调用 <code>workq_open</code> 函数（后续会分析该函数）</li></ul></li></ul></li><li><strong>申请线程</strong><ul><li><strong>并发队列</strong><ul><li>调用 <code>_pthread_workqueue_addthreads</code> 申请线程</li></ul></li><li><strong>串行队列</strong><ul><li>调用 <code>kevent_id</code> 申请线程</li></ul></li></ul></li></ul><p>接下来，分别看下两种申请线程的方式分别是如何实现的。</p><h2 id="三、并发队列申请线程"><a href="#三、并发队列申请线程" class="headerlink" title="三、并发队列申请线程"></a>三、并发队列申请线程</h2><h3 id="1、-pthread-workqueue-addthreads"><a href="#1、-pthread-workqueue-addthreads" class="headerlink" title="1、_pthread_workqueue_addthreads"></a>1、_pthread_workqueue_addthreads</h3><p>并发队列通过 <code>_pthread_workqueue_addthreads</code> 函数申请线程去执行任务，该函数是 libpthread 提供的一个函数，函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 申请线程执行任务</span></span><br><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">///   - numthreads: 表示需要创建的线程数</span></span><br><span class="line"><span class="comment">///   - priority: 线程的优先级</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_pthread_workqueue_addthreads(<span class="type">int</span> numthreads, <span class="type">pthread_priority_t</span> priority)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__libdispatch_workerfunction == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> EPERM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">    <span class="comment">// 针对 macOS 系统的特殊处理</span></span><br><span class="line">    priority &amp;= ~_PTHREAD_PRIORITY_SCHED_PRI_FLAG;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用内核系统调用 `__workq_kernreturn`，请求添加线程。</span></span><br><span class="line">    <span class="comment">// 参数说明：</span></span><br><span class="line">    <span class="comment">// - WQOPS_QUEUE_REQTHREADS: 操作码，表示请求添加线程。</span></span><br><span class="line">    <span class="comment">// - NULL: 传递给内核的附加数据，这里为 NULL。</span></span><br><span class="line">    <span class="comment">// - numthreads: 要添加的线程数量。</span></span><br><span class="line">    <span class="comment">// - (int)priority: 线程的优先级，转换为 int 类型传递给内核。</span></span><br><span class="line">    res = __workq_kernreturn(WQOPS_QUEUE_REQTHREADS, <span class="literal">NULL</span>, numthreads, (<span class="type">int</span>)priority);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果系统调用返回 -1，表示发生错误。</span></span><br><span class="line">    <span class="comment">// 使用 `errno` 获取具体的错误码，并将其作为返回值。</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        res = errno; <span class="comment">// 获取错误码。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果，0 表示成功，非 0 表示失败。</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该函数核心是调用 <code>__workq_kernreturn</code> 请求线程，并且调用  <code>__workq_kernreturn</code> 时，第一个参数传入的是 <code>WQOPS_QUEUE_REQTHREADS</code>。在<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a> 中已经分析过，调用 <code>_pthread_workqueue_addthreads</code> 时，传入的 <code>numthreads</code> 参数为 <code>1</code>，即每次请求一个线程。可以看到，这个 <code>numthreads</code> 参数也是透传给了 <code>__workq_kernreturn</code>。</p><h3 id="2、-workq-kernreturn"><a href="#2、-workq-kernreturn" class="headerlink" title="2、__workq_kernreturn"></a>2、__workq_kernreturn</h3><p><code>__workq_kernreturn</code> 是 XNU 内核提供的一个函数，<code>__workq_kernreturn</code> 本质是个系统调用，在内核态对应 <code>workq_kernreturn</code> 函数，该函数精简后的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">workq_kernreturn</span><span class="params">(<span class="keyword">struct</span> proc *p, <span class="keyword">struct</span> workq_kernreturn_args *uap, <span class="type">int32_t</span> *retval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (options) &#123;</span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WQOPS_QUEUE_REQTHREADS: &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * arg2 = number of threads to start</span></span><br><span class="line"><span class="comment">         * arg3 = priority</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        error = workq_reqthreads(p, arg2, arg3, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述逻辑中，如果 <code>options</code> 是 <code>WQOPS_QUEUE_REQTHREADS</code>，则会调用 <code>workq_reqthreads</code> 请求线程。</p><h3 id="3、workq-reqthreads"><a href="#3、workq-reqthreads" class="headerlink" title="3、workq_reqthreads"></a>3、workq_reqthreads</h3><p>在看 <code>workq_reqthreads</code> 函数之前，先看下几个关键的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WORKQUEUE_MAXTHREADS            512</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 512</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> wq_max_threads              = WORKQUEUE_MAXTHREADS; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 512 / 8 = 64</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> wq_max_constrained_threads  = WORKQUEUE_MAXTHREADS / <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>在前面几篇文章里，反复提到了 <code>workqueue</code>，这里看下 <code>workqueue</code> 的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前 workqueue 中的线程总数，包括运行中的线程、空闲线程和正在终止的线程。</span></span><br><span class="line">    <span class="type">uint16_t</span>        wq_nthreads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲的线程数</span></span><br><span class="line">    <span class="type">uint16_t</span>        wq_thidlecount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前进程结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>    *<span class="title">wq_proc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在运行任务的线程链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workq_uthread_head</span> <span class="title">wq_thrunlist</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新创建但尚未使用的线程列表，也属于空闲线程，但与 wq_thidlelist 分开存储</span></span><br><span class="line">    <span class="comment">// wq_thidlecount 数量计算包含了新建的线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workq_uthread_head</span> <span class="title">wq_thnewlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲线程链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workq_uthread_head</span> <span class="title">wq_thidlelist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>每个进程都有一个 <code>workqueue</code>，<code>workqueue</code> 中存储了一系列线程池管理相关的内容，包含线程总数、空闲的线程数等。其中，<code>workq_uthread_head</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TAILQ_HEAD(workq_uthread_head, uthread);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_HEAD(name, type)                                          \</span></span><br><span class="line"><span class="meta">__MISMATCH_TAGS_PUSH                                                    \</span></span><br><span class="line"><span class="meta">__NULLABILITY_COMPLETENESS_PUSH                                         \</span></span><br><span class="line"><span class="meta">struct name &#123;                                                           \</span></span><br><span class="line"><span class="meta">struct type *tqh_first; <span class="comment">/* first element */</span>                     \</span></span><br><span class="line"><span class="meta">struct type **tqh_last; <span class="comment">/* addr of last next element */</span>         \</span></span><br><span class="line"><span class="meta">TRACEBUF                                                        \</span></span><br><span class="line"><span class="meta">&#125;   </span></span><br></pre></td></tr></table></figure><p>所以，GCD 的线程池是使用双向链表的结构来存储线程的。</p><p>再继续看下 <code>workq_reqthreads</code> 函数，<code>workq_reqthreads</code> 是 GCD 请求线程的入口函数，该函数参数及实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GCD 请求线程的入口点，负责根据请求的线程数量和优先级，创建或分配线程，并将其绑定到工作队列中。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param p 当前进程的指针</span></span><br><span class="line"><span class="comment"> * @param reqcount 请求的线程数量</span></span><br><span class="line"><span class="comment"> * @param pp 线程优先级</span></span><br><span class="line"><span class="comment"> * @param cooperative 是否为协作线程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 返回 0 表示成功，非 0 表示失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">workq_reqthreads</span><span class="params">(<span class="keyword">struct</span> proc *p, <span class="type">uint32_t</span> reqcount, <span class="type">pthread_priority_t</span> pp, <span class="type">bool</span> cooperative)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 提取线程优先级的 QoS 值</span></span><br><span class="line">    <span class="type">thread_qos_t</span> qos = _pthread_priority_thread_qos(pp);</span><br><span class="line">    <span class="comment">// 获取当前进程的 workqueue</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue</span> *<span class="title">wq</span> =</span> proc_get_wqptr(p); </span><br><span class="line">    <span class="type">uint32_t</span> unpaced, upcall_flags = WQ_FLAG_THREAD_NEWSPI; </span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数校验：工作队列是否为空，线程请求数量是否合法，QoS 是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (wq == <span class="literal">NULL</span> || reqcount &lt;= <span class="number">0</span> || reqcount &gt; UINT16_MAX ||</span><br><span class="line">        qos == THREAD_QOS_UNSPECIFIED) &#123;</span><br><span class="line">        ret = EINVAL; <span class="comment">// 参数无效</span></span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志</span></span><br><span class="line">    WQ_TRACE_WQ(TRACE_wq_wqops_reqthreads | DBG_FUNC_NONE,</span><br><span class="line">        wq, reqcount, pp, cooperative);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配线程请求结构体</span></span><br><span class="line">    <span class="type">workq_threadreq_t</span> req = zalloc(workq_zone_threadreq);</span><br><span class="line">    priority_queue_entry_init(&amp;req-&gt;tr_entry);</span><br><span class="line">    req-&gt;tr_state = WORKQ_TR_STATE_NEW; </span><br><span class="line">    req-&gt;tr_qos   = qos; </span><br><span class="line">    <span class="type">workq_tr_flags_t</span> tr_flags = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果优先级包含超额提交标志，则设置相应标志</span></span><br><span class="line">    <span class="keyword">if</span> (pp &amp; _PTHREAD_PRIORITY_OVERCOMMIT_FLAG) &#123;</span><br><span class="line">        tr_flags |= WORKQ_TR_FLAG_OVERCOMMIT;</span><br><span class="line">        upcall_flags |= WQ_FLAG_THREAD_OVERCOMMIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是协作线程，则设置协作标志</span></span><br><span class="line">    <span class="keyword">if</span> (cooperative) &#123;</span><br><span class="line">        tr_flags |= WORKQ_TR_FLAG_COOPERATIVE;</span><br><span class="line">        upcall_flags |= WQ_FLAG_THREAD_COOPERATIVE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协作线程目前不支持并行请求多个线程</span></span><br><span class="line">        <span class="keyword">if</span> (reqcount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ret = ENOTSUP; <span class="comment">// 不支持的操作</span></span><br><span class="line">            <span class="keyword">goto</span> free_and_exit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验：线程请求不能同时是超额提交和协作线程</span></span><br><span class="line">    <span class="keyword">if</span> (workq_tr_is_cooperative(tr_flags) &amp;&amp;</span><br><span class="line">        workq_tr_is_overcommit(tr_flags)) &#123;</span><br><span class="line">        ret = EINVAL; <span class="comment">// 参数无效</span></span><br><span class="line">        <span class="keyword">goto</span> free_and_exit;</span><br><span class="line">    &#125;</span><br><span class="line">    req-&gt;tr_flags = tr_flags; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志</span></span><br><span class="line">    WQ_TRACE_WQ(TRACE_wq_thread_request_initiate | DBG_FUNC_NONE,</span><br><span class="line">        wq, workq_trace_req_id(req), req-&gt;tr_qos, reqcount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁 workqueue</span></span><br><span class="line">    workq_lock_spin(wq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、线程快速请求流程</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 workqueue 正在退出，则直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (_wq_exiting(wq)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> unlock_and_exit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当用户请求并行线程时，唤醒最多 (reqcount - 1) 个线程，</span></span><br><span class="line"><span class="comment">         * 以通知调度器当前的工作负载。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 最后一个请求或未通过准入检查的请求会被加入队列，</span></span><br><span class="line"><span class="comment">         * 并通过常规的创建线程路径处理。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果线程数量不足，则添加一个线程，但需要重新评估所有条件。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        unpaced = reqcount - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reqcount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 协作线程目前不支持并行请求多个线程</span></span><br><span class="line">            assert(!workq_threadreq_is_cooperative(req));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是非超额提交线程请求，则计算允许的并行线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (workq_threadreq_is_nonovercommit(req)) &#123;</span><br><span class="line">                unpaced = workq_constrained_allowance(wq, qos, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (unpaced &gt;= reqcount - <span class="number">1</span>) &#123;</span><br><span class="line">                    unpaced = reqcount - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验：并行线程创建路径目前不支持自定义工作循环参数</span></span><br><span class="line">        assert(!(req-&gt;tr_flags &amp; WORKQ_TR_FLAG_WL_PARAMS));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这是 workq_threadreq_bind_and_unlock() 的简化版本，负责绑定线程请求并解锁。</span></span><br><span class="line">        <span class="keyword">while</span> (unpaced &gt; <span class="number">0</span> &amp;&amp; wq-&gt;wq_thidlecount) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">uth</span>;</span></span><br><span class="line">            <span class="type">bool</span> needs_wakeup;</span><br><span class="line">            <span class="type">uint8_t</span> uu_flags = UT_WORKQ_EARLY_BOUND;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是超额提交请求，则设置相应标志</span></span><br><span class="line">            <span class="keyword">if</span> (workq_tr_is_overcommit(req-&gt;tr_flags)) &#123;</span><br><span class="line">                uu_flags |= UT_WORKQ_OVERCOMMIT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从空闲线程池中弹出一个线程</span></span><br><span class="line">            uth = workq_pop_idle_thread(wq, uu_flags, &amp;needs_wakeup);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新活动线程计数和调度计数</span></span><br><span class="line">            _wq_thactive_inc(wq, qos);</span><br><span class="line">            wq-&gt;wq_thscheduled_count[_wq_bucket(qos)]++;</span><br><span class="line">            workq_thread_reset_pri(wq, uth, req, <span class="comment">/*unpark*/</span> <span class="literal">true</span>); <span class="comment">// 重置线程优先级</span></span><br><span class="line">            wq-&gt;wq_fulfilled++; <span class="comment">// 增加已完成的线程请求计数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置线程的唤醒标志和请求</span></span><br><span class="line">            uth-&gt;uu_save.uus_workq_park_data.upcall_flags = upcall_flags;</span><br><span class="line">            uth-&gt;uu_save.uus_workq_park_data.thread_request = req;</span><br><span class="line">            <span class="keyword">if</span> (needs_wakeup) &#123;</span><br><span class="line">                workq_thread_wakeup(uth); <span class="comment">// 唤醒线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            unpaced--;</span><br><span class="line">            reqcount--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (unpaced &amp;&amp; wq-&gt;wq_nthreads &lt; wq_max_threads &amp;&amp;</span><br><span class="line">        (workq_add_new_idle_thread(p, wq, workq_unpark_continue,</span><br><span class="line">        <span class="literal">false</span>, <span class="literal">NULL</span>) == KERN_SUCCESS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 workqueue 正在退出，则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (_wq_exiting(wq)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> unlock_and_exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req-&gt;tr_count = (<span class="type">uint16_t</span>)reqcount;</span><br><span class="line">    <span class="comment">// 2、线程慢速请求流程</span></span><br><span class="line">    <span class="keyword">if</span> (workq_threadreq_enqueue(wq, req)) &#123;</span><br><span class="line">        <span class="comment">// 如果线程请求入队成功，则调度创建线程</span></span><br><span class="line">        workq_schedule_creator(p, wq, WORKQ_THREADREQ_CAN_CREATE_THREADS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁 workqueue</span></span><br><span class="line">    workq_unlock(wq); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">unlock_and_exit:</span><br><span class="line">    <span class="comment">// 解锁 workqueue</span></span><br><span class="line">    workq_unlock(wq); </span><br><span class="line">free_and_exit:</span><br><span class="line">    <span class="comment">// 释放线程请求结构体</span></span><br><span class="line">    zfree(workq_zone_threadreq, req); </span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>workq_reqthreads</code> 函数中 <code>workqueue *wq</code> 的获取方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前进程的 workqueue</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue</span> *<span class="title">wq</span> =</span> proc_get_wqptr(p); </span><br></pre></td></tr></table></figure><p>可以知道，每个进程都有一个共用的 <code>workqueue</code>。</p><p>从 <code>workq_reqthreads</code> 函数实现中可以看到有针对超额提交线程、受限线程等不同线程类型的处理逻辑，那超额提交线程、受限线程分别是什么呢？</p><p>GCD 在管理线程时，把线程大致分成了这么几类：</p><ul><li><strong>创建者线程（Creator Thread）</strong><ul><li>创建者线程是一个匿名线程，用来控制线程创建节奏。</li><li><code>workqueue</code> 只会有一个创建者线程。</li><li>创建者线程会被转换成普通工作线程传到用户态执行任务，并协调创建其他线程。</li></ul></li><li><strong>超额提交线程 (Overcommit Threads)</strong><ul><li>可以突破 CPU 最大并发限制的线程，可能会引发线程爆炸(Thread Explosion)，导致上下文切换开销剧增。<ul><li><strong>串行队列是 <code>Overcommit</code> 的</strong>，所以串行队列创建的是超额提交线程。</li></ul></li></ul></li><li><strong>受限线程 (Constrained Threads)</strong><ul><li>根据 CPU 最大并发能力限制最大并行线程数量的线程，可以避免过度使用系统资源。<ul><li><strong>并发队列（含全局队列）是非 <code>Overcommit</code> 的</strong>，所以并发队列创建的是受限线程。</li></ul></li></ul></li></ul><p>除此之外，还有管理线程、协作线程中，但这些不是本次分析的关注点。</p><p>在<a href="https://www.lixkit.com/posts/12465/">《GCD 底层原理 2 - dispatch_queue》</a> 中已经得出过结论：并发队列是非 <code>overcommit</code> 的，串行队列是 <code>overcommit</code> 的。由于走进 <code>workq_reqthreads</code> 函数的主要是并发队列，所以这里只关注非 <code>overcommit</code> 的情况即可。</p><p><code>workq_reqthreads</code> 中的线程请求逻辑中，根据请求的线程数量 <code>reqcount</code> 分成了两部分逻辑，根据两部分逻辑的特点，姑且称之为<strong>「快速请求流程」</strong>和<strong>「慢速请求流程」</strong>：</p><ul><li><strong>快速请求流程</strong><ul><li>为了能快速处理线程请求，加快线程调度速度。</li><li>当请求线程数量大于 1 时会先走快速请求流程。</li></ul></li><li><strong>慢速请求流程</strong><ul><li>更精细的线程调度方式，会根据所请求线程类型、优先级、CPU 负载情况，动态调整可创建线程数量。</li></ul></li></ul><p><strong><code>workq_reqthreads</code> 函数核心逻辑如下：</strong></p><ul><li><strong>获取当前进程的 <code>workqueue *wq</code></strong></li><li><strong>根据请求线程的数量 <code>reqcount</code> 决定走「快速请求流程」还是「慢速请求流程」</strong><ul><li><code>unpaced = reqcount - 1</code> 数量的请求走「快速请求流程」</li><li>剩余的 <code>1</code> 个请求走「慢速请求流程」</li></ul></li><li><strong>快速请求流程</strong><ul><li><font color=#ff0000>对于并发队列（队列是非 <code>overcommit</code> 的），则限制 <code>unpaced</code> 最大值为 CPU 逻辑核心数量</font><ul><li>这里调用 <code>workq_constrained_allowance</code> 获取 <code>unpaced</code> 最大值，该函数返回结果是 CPU 逻辑核心的数量</li></ul></li><li>如果线程池中的空闲线程数量 <code>wq_thidlecount</code> 足够，则通过 <code>while</code> 循环调用 <code>workq_pop_idle_thread</code> 从线程池中取 <code>unpaced</code> 个线程直接唤醒并使用。</li><li>如果线程池中的空闲线程已用完，且线程总数未达到上限 <code>wq_max_threads</code>（512），会调用 <code>workq_add_new_idle_thread</code> 创建新线程。否则将走慢速请求流程。</li><li>综上，对于并发队列，每次调用 <code>workq_reqthreads</code>，参与快速请求流程的线程请求数量最多是 CPU 逻辑核心的数量。</li></ul></li><li><strong>慢速请求流程</strong><ul><li>将线程请求入队，并调用 <code>workq_schedule_creator</code> 调度线程</li></ul></li></ul><p>但是，需要注意的是，并发队列调用 <code>workq_reqthreads</code> 时，<code>reqcount</code> 传入的参数是 <code>1</code>，且通过递归调用的方式多次调用 <code>workq_reqthreads</code> 每次申请一个线程（详情可看：<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a> ）。所以<strong>并发队列不会走进快速请求流程，而是直接走慢速请求流程。</strong></p><h3 id="4、workq-constrained-allowance"><a href="#4、workq-constrained-allowance" class="headerlink" title="4、workq_constrained_allowance"></a>4、workq_constrained_allowance</h3><p><code>workq_constrained_allowance</code> 函数用于根据 CPU 最大并发能力（CPU 逻辑核心数量）及受限线程数量限制，计算 CGD 是否还允许创建受限线程。</p><p>上面已经提到，在快速请求流程中，会调用 <code>workq_constrained_allowance</code> 获取并发队列最大参与快速请求流程的请求数量。但该函数有必要单独拿出来讲一下，<code>workq_constrained_allowance</code> 函数精简后的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算可以创建的受限制线程的数量</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">workq_constrained_allowance</span><span class="params">(<span class="keyword">struct</span> workqueue *wq, <span class="type">thread_qos_t</span> at_qos,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> uthread *uth, <span class="type">bool</span> may_start_timer, <span class="type">bool</span> record_failed_allowance)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(at_qos != WORKQ_THREAD_QOS_MANAGER);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录通过的许可数量，allowance_passed 是函数的返回值</span></span><br><span class="line">    <span class="type">uint32_t</span> allowance_passed = <span class="number">0</span>; </span><br><span class="line">    <span class="type">uint32_t</span> count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前已调度的受限线程数</span></span><br><span class="line">    <span class="type">uint32_t</span> max_count = wq-&gt;wq_constrained_threads_scheduled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果已调度线程数达到或超过最大受限线程数(64)，则不允许分配新线程</span></span><br><span class="line"><span class="comment">    * wq_max_constrained_threads = 64</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (max_count &gt;= wq_max_constrained_threads) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已调度线程数达到或超过最大线程数</span></span><br><span class="line">        allowance_passed = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 执行 out，直接返回 allowance_passed 的值 0</span></span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算剩余的可用线程数 max_count -= 64;</span></span><br><span class="line">    <span class="comment">// ⚠️ ：这里可能是一个 BUG</span></span><br><span class="line">    max_count -= wq_max_constrained_threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大并发数（CPU 逻辑核心数量）</span></span><br><span class="line">    count = wq_max_parallelism[_wq_bucket(at_qos)];</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果最大并发数大于活跃线程数和繁忙线程数之和，则允许分配新线程</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 活跃线程：正在执行任务（未被阻塞或挂起）的工作队列线程</span></span><br><span class="line"><span class="comment">    * 繁忙线程：线程被阻塞在时间窗口内（被阻塞的时间小于 200 微秒）的线程</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; thactive_count + busycount) &#123;</span><br><span class="line">        count -= thactive_count + busycount;</span><br><span class="line">        allowance_passed = MIN(count, max_count);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，不允许分配新线程</span></span><br><span class="line">        allowance_passed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回允许分配的新线程数量</span></span><br><span class="line">    <span class="keyword">return</span> allowance_passed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>wq_max_parallelism</code> 是个数组，在 <code>workq_open</code> 函数（<code>pthread_workqueue_setup</code> 中调用的该函数）中初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">workq_open</span><span class="params">(<span class="keyword">struct</span> proc *p, __unused <span class="keyword">struct</span> workq_open_args *uap,</span></span><br><span class="line"><span class="params">    __unused <span class="type">int32_t</span> *retval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wq_init_constrained_limit) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于逻辑 CPU 逻辑核心数量，决定每个优先级可同时运行的最大线程数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">thread_qos_t</span> qos = WORKQ_THREAD_QOS_MIN; qos &lt;= WORKQ_THREAD_QOS_MAX; qos++) &#123;</span><br><span class="line">            wq_max_parallelism[_wq_bucket(qos)] =</span><br><span class="line">                qos_max_parallelism(qos, QOS_PARALLELISM_COUNT_LOGICAL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">qos_max_parallelism</span><span class="params">(<span class="type">int</span> qos, <span class="type">uint64_t</span> options)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> SCHED(qos_max_parallelism)(qos, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">sched_qos_max_parallelism</span><span class="params">(__unused <span class="type">int</span> qos, <span class="type">uint64_t</span> options)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传入的选项决定返回逻辑 CPU 数量还是物理 CPU 数量</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp; QOS_PARALLELISM_COUNT_LOGICAL) &#123;</span><br><span class="line">    <span class="comment">// 返回 CPU 逻辑核心数量</span></span><br><span class="line">    <span class="comment">// workq_open 调用进来的时候，传的是 QOS_PARALLELISM_COUNT_LOGICAL</span></span><br><span class="line">        <span class="keyword">return</span> hinfo.logical_cpu;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则返回 CPU 物理核心数量</span></span><br><span class="line">        <span class="keyword">return</span> hinfo.physical_cpu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>workq_constrained_allowance</code> 函数中，有一段这样的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wq_max_constrained_threads = 64</span></span><br><span class="line"><span class="keyword">if</span> (max_count &gt;= wq_max_constrained_threads) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算剩余的可用线程数 max_count -= 64;</span></span><br><span class="line"><span class="comment">// ⚠️ ：这里可能是一个 BUG，因为走到这里，max_count 一定是小于 wq_max_constrained_threads 的</span></span><br><span class="line">max_count -= wq_max_constrained_threads;</span><br></pre></td></tr></table></figure><p>在计算 <code>max_count</code> 时，<code>max_count</code> 一定是小于 <code>wq_max_constrained_threads</code> 的，而 <code>max_count</code> 和 <code>wq_max_constrained_threads</code> 都是 <code>uint32_t</code> 类型（无符号整数），当一个较小的无符号整数减去一个较大的无符号整数时，会发生下溢，导致 <code>max_count</code> 变成一个很大的正数。</p><p>这个 XNU 的 BUG 则导致了后续 <code>MIN(count, max_count)</code> 结果一定是 <code>count</code>，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count -= thactive_count + busycount = CPU 逻辑核心数 -  (活跃线程数 + 繁忙线程数);</span><br></pre></td></tr></table></figure><p>从而导致了 <code>workq_constrained_allowance</code> 返回值一定是上面的计算结果，使 <code>MIN(count, max_count)</code> 的逻辑变得无意义。</p><p>更合理的计算方式应该是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面计算方式更合理，代表了剩余可创建线程的数量</span></span><br><span class="line">max_count = wq_max_constrained_threads - max_count;</span><br></pre></td></tr></table></figure><p>综上，<code>workq_constrained_allowance</code> 核心逻辑如下：</p><ul><li>如果已调度受限线程数超过超过最大受限线程数(64)，则不允许再新建线程，直接返回 0。</li><li>否则，判断是否满足 <code>CPU 逻辑核心数 &gt; (活跃线程数 + 繁忙线程数)</code>，<ul><li>如果满足，返回：<code>CPU 逻辑核心数 -  (活跃线程数 + 繁忙线程数)</code></li><li>如果不满足，返回 0，即不允许再创建线程</li></ul></li></ul><p><strong>活跃线程与繁忙线程：</strong></p><ul><li><strong>活跃线程</strong><ul><li>正在执行任务（未被阻塞或挂起）的工作队列线程。</li><li>活跃线程会占用 CPU 资源，所以需要严格控制活跃线程数量。</li></ul></li><li><strong>繁忙线程</strong><ul><li>线程被阻塞在时间窗口内（被阻塞的时间小于 200 微秒）的线程。<ul><li>这部分判断逻辑在 <code>workq_thread_is_busy</code> 函数中实现的。</li></ul></li><li>系统会记录线程阻塞的时间，如果线程在短时间窗口内被阻塞，会被视为”繁忙”线程，因为线程可能会很快被唤醒执行任务。繁忙线程本身不会消耗 CPU 资源。</li><li><strong>如果线程一直被阻塞，阻塞时间超过了时间窗口 200 微秒，则不统计在内了。</strong></li></ul></li></ul><h2 id="5、慢速请求流程（workq-schedule-creator）"><a href="#5、慢速请求流程（workq-schedule-creator）" class="headerlink" title="5、慢速请求流程（workq_schedule_creator）"></a>5、慢速请求流程（workq_schedule_creator）</h2><p>上面已经提到，并发队列调用 <code>workq_reqthreads</code> 时，<code>reqcount</code> 传入的参数是 <code>1</code>，且通过递归调用的方式多次调用 <code>workq_reqthreads</code> 每次申请 <code>1</code> 个线程（详情可看：<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a> ）。所以并发队列不会走进快速请求流程，而是直接走慢速请求流程。</p><p>慢速请求流程调用的是 <code>workq_schedule_creator</code>，该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">workq_schedule_creator</span><span class="params">(<span class="type">proc_t</span> p, <span class="keyword">struct</span> workqueue *wq,</span></span><br><span class="line"><span class="params">    <span class="type">workq_kern_threadreq_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">workq_threadreq_t</span> req;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">uth</span>;</span></span><br><span class="line">    <span class="comment">// 是否需要唤醒线程  </span></span><br><span class="line">    <span class="type">bool</span> needs_wakeup;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="comment">// 获取队列的当前的创建者线程</span></span><br><span class="line">    uth = wq-&gt;wq_creator; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wq-&gt;wq_reqcount) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 没有线程请求</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据线程优先级，为创建者线程选择一个适合的线程请求</span></span><br><span class="line"><span class="comment">    * 内部会调用 workq_constrained_allowance 做一次判断，超过最大可创建线程数量时 req 会为 NULL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    req = workq_threadreq_select_for_creator(wq);</span><br><span class="line">    <span class="keyword">if</span> (req == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有返回合适的线程请求</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uth) &#123;</span><br><span class="line">        <span class="comment">// 如果已经有一个创建者线程，根据需要调整优先级</span></span><br><span class="line">        <span class="keyword">if</span> (workq_thread_needs_priority_change(req, uth)) &#123;</span><br><span class="line">            workq_thread_reset_pri(wq, uth, req, <span class="comment">/*unpark*/</span> <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        assert(wq-&gt;wq_inheritor == get_machthread(uth));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wq-&gt;wq_thidlecount) &#123;</span><br><span class="line">        <span class="comment">// 如果没有创建者线程，优先从空闲线程中取一个线程作为创建者线程</span></span><br><span class="line">        wq-&gt;wq_creator = uth = workq_pop_idle_thread(wq, UT_WORKQ_OVERCOMMIT,</span><br><span class="line">            &amp;needs_wakeup);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needs_wakeup) &#123;</span><br><span class="line">            <span class="comment">// 唤醒线程</span></span><br><span class="line">            workq_thread_wakeup(uth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有空闲线程，需要创建一个新线程。</span></span><br><span class="line">        <span class="keyword">if</span> (__improbable(wq-&gt;wq_nthreads &gt;= wq_max_threads)) &#123;</span><br><span class="line">            <span class="comment">// 如果线程数已达上限，直接返回......</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; WORKQ_THREADREQ_SET_AST_ON_FAILURE) &#123;</span><br><span class="line">            <span class="comment">// 如果设置了失败时触发 AST，则设置 AST ......</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(flags &amp; WORKQ_THREADREQ_CAN_CREATE_THREADS)) &#123;</span><br><span class="line">            <span class="comment">// workq_reqthreads 中调用 workq_schedule_creator 时传了 WORKQ_THREADREQ_CAN_CREATE_THREADS，所以不会走此处分支</span></span><br><span class="line">            workq_schedule_immediate_thread_creation(wq);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((workq_add_new_idle_thread(p, wq,</span><br><span class="line">            workq_unpark_continue, <span class="literal">false</span>, <span class="literal">NULL</span>) == KERN_SUCCESS)) &#123;</span><br><span class="line">            <span class="comment">// 调用 workq_add_new_idle_thread 创建线程，并设置线程唤醒时执行 workq_unpark_continue 函数</span></span><br><span class="line">            <span class="keyword">goto</span> again;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果创建线程失败，调度延迟线程创建。</span></span><br><span class="line">            workq_schedule_delayed_thread_creation(wq, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>workq_schedule_creator</code> 函数中，多次提到线程（<code>uth</code>）和线程请求（<code>thread request</code>），<strong>线程和线程请求到底是什么关系呢？</strong></p><ul><li><strong>线程（<code>uth</code>）</strong><ul><li>线程（<code>uth</code>）是线程在内核态的形态，线程（<code>uth</code>）回传回用户空间，执行我们通过 <code>dispatch_async</code> 的 <code>block</code> 提交的具体任务。</li></ul></li><li><strong>线程请求（<code>thread request</code>）</strong><ul><li>线程请求（<code>thread request</code>）是任务在内核层面的描述，它不包含实际的 <code>dispatch_async</code> 的 <code>block</code> 任务，而是包含执行该任务所需的元数据，如 <code>QoS</code>、优先级、执行模式等。</li><li>线程（<code>uth</code>）需要根据线程请求（<code>thread request</code>）完成执行参数配置之后，才能提供给用户态执行任务。</li></ul></li></ul><p><strong>总结 <code>workq_schedule_creator</code> 函数逻辑如下：</strong></p><ul><li>如果进程 <code>workqueue</code> 的线程请求数量为 <code>0</code>，直接 <code>return</code>。</li><li>根据请求线程的优先级，调用 <code>workq_threadreq_select_for_creator</code> 按照高优先级优先的原则，为创建者线程选择一个合适的线程请求 <code>req</code>。<ul><li>选择线程请求时，会调用前面提到的 <code>workq_constrained_allowance</code> 判断是否还允许创建受限线程，如果不可以再创建线程，<code>workq_threadreq_select_for_creator</code> 会返回 <code>NULL</code>。</li><li>如果 <code>req</code> 为 <code>NULL</code>，则 <code>workq_schedule_creator</code> 函数会直接 <code>return</code>。</li></ul></li><li>如果创建者线程 <code>wq_creator</code> 已存在，根据线程请求 <code>req</code> 调整其优先级等参数。</li><li>如果创建者线程 <code>wq_creator</code> 不存在，则进入 <code>wq_creator</code> 创建流程：<ul><li><strong>步骤 1：</strong>是否有空闲线程，如果有，则调用 <code>workq_pop_idle_thread</code> 取一个空闲线程作为 <code>wq_creator</code>，并调用 <code>workq_thread_wakeup</code> 唤醒创建者线程 <code>wq_creator</code>。</li><li><strong>步骤 2：</strong>如果没有空闲线程，再判断当前线程总数是否已经达到 <code>wq_max_threads</code>（512），如果达到，不允许再创建 <code>wq_creator</code>。</li><li><strong>步骤 3：</strong>如果线程总数未达到 <code>wq_max_threads</code>（512），则：<ul><li>调用 <code>workq_add_new_idle_thread</code> 创建线程，<font color=#ff0000>并设置线程被唤醒后执行 <code>workq_unpark_continue</code> 函数。</font></li><li>执行 <code>goto again</code>，会前面重新走 <code>wq_creator</code> 创建流程，并在上面<strong>步骤 1</strong> 时，将这一步新建的线程作为空闲线程赋值给 <code>wq_creator</code> 并唤醒。</li></ul></li><li><strong>步骤 4：</strong>走到这里，说明由于前面各种条件限制，不允许再新建线程，则调用 <code>workq_schedule_delayed_thread_creation</code> 走延迟创建逻辑。<ul><li>在工作队列中安排一个延迟执行的线程创建任务。它会根据工作队列的当前状态和历史运行情况动态调整下次创建线程的时间间隔，实现自适应的线程创建策略。</li></ul></li></ul></li></ul><p>其中，从线程池取一个空闲线程调用的是 <code>workq_pop_idle_thread</code> 函数，该函数精简后实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> uthread *</span><br><span class="line"><span class="title function_">workq_pop_idle_thread</span><span class="params">(<span class="keyword">struct</span> workqueue *wq, <span class="type">uint16_t</span> uu_flags,</span></span><br><span class="line"><span class="params">    <span class="type">bool</span> *needs_wakeup)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">uth</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先从空闲线程链表中获取第一个线程</span></span><br><span class="line">    <span class="keyword">if</span> ((uth = TAILQ_FIRST(&amp;wq-&gt;wq_thidlelist))) &#123;</span><br><span class="line">        <span class="comment">// 如果空闲线程链表不为空，从链表中移除该线程</span></span><br><span class="line">        TAILQ_REMOVE(&amp;wq-&gt;wq_thidlelist, uth, uu_workq_entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果空闲线程链表为空，从新创建的线程链表中获取第一个线程</span></span><br><span class="line">        uth = TAILQ_FIRST(&amp;wq-&gt;wq_thnewlist);</span><br><span class="line">        TAILQ_REMOVE(&amp;wq-&gt;wq_thnewlist, uth, uu_workq_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将线程标记为运行状态</span></span><br><span class="line">    uth-&gt;uu_workq_flags |= UT_WORKQ_RUNNING | uu_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加工作队列的总调度线程计数</span></span><br><span class="line">    wq-&gt;wq_threads_scheduled++;</span><br><span class="line">    <span class="comment">// 减少空闲线程计数</span></span><br><span class="line">    wq-&gt;wq_thidlecount--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码实现可知，取空闲线程的关键逻辑如下：</p><ul><li>先从空闲线程 <code>wq_thidlelist</code> 里取一个线程。</li><li>空闲线程为空，则从新建线程链表 <code>wq_thnewlist</code> 中取一个线程。<ul><li><code>workq_add_new_idle_thread</code> 新建的线程会存到 <code>wq_thnewlist</code> 里。</li></ul></li><li>将取到的线程标记为运行状态，增加 <code>UT_WORKQ_RUNNING</code> 标记。<ul><li>所以，创建者线程 <code>wq_creator</code> 也会有 <code>UT_WORKQ_RUNNING</code> 标记。</li></ul></li><li>已调度线程数量 <code>wq_threads_scheduled ++</code>，空闲线程数量 <code>wq_thidlecount --</code>。</li><li>返回取到的空闲线程。</li></ul><h3 id="6、workq-unpark-continue"><a href="#6、workq-unpark-continue" class="headerlink" title="6、workq_unpark_continue"></a>6、workq_unpark_continue</h3><p>创建者线程 <code>wq_creator</code> 创建完成被唤醒后，会调用 <code>workq_unpark_continue</code> 函数。<code>workq_unpark_continue</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">workq_unpark_continue</span><span class="params">(<span class="type">void</span> *parameter __unused, <span class="type">wait_result_t</span> wr __unused)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">thread_t</span> th = current_thread();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">uth</span> =</span> get_bsdthread_info(th);</span><br><span class="line">    <span class="type">proc_t</span> p = current_proc();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue</span> *<span class="title">wq</span> =</span> proc_get_wqptr_fast(p); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁工作队列，确保线程安全。</span></span><br><span class="line">    workq_lock_spin(wq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前线程是创建者线程，并且满足让出条件：</span></span><br><span class="line"><span class="comment">     * - 如果当前线程的数量足以满足工作队列的需求，</span></span><br><span class="line"><span class="comment">     *   则避免将该创建者线程发送到用户空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (wq-&gt;wq_creator == uth &amp;&amp; workq_creator_should_yield(wq, uth)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果当前线程是创建者线程，并且当前活跃线程能够满足工作需求，</span></span><br><span class="line"><span class="comment">         * 则避免将该创建者线程发送到用户空间。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        uth-&gt;uu_save.uus_workq_park_data.fulfilled_snapshot = wq-&gt;wq_fulfilled; </span><br><span class="line">        uth-&gt;uu_save.uus_workq_park_data.yields++; </span><br><span class="line">        <span class="comment">// 解锁工作队列。</span></span><br><span class="line">        workq_unlock(wq); </span><br><span class="line">        <span class="comment">// 让出 CPU，并使其被唤醒后再次执行 workq_unpark_continue</span></span><br><span class="line">        thread_yield_with_continuation(workq_unpark_continue, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 标记代码不可达</span></span><br><span class="line">        __builtin_unreachable(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前线程标记为正在运行：</span></span><br><span class="line"><span class="comment">     * - 选择一个线程请求进行处理，或者将线程重新挂起。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 只有 workq_pop_idle_thread 会增加 UT_WORKQ_RUNNING 标记</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (__probable(uth-&gt;uu_workq_flags &amp; UT_WORKQ_RUNNING)) &#123;</span><br><span class="line">        workq_unpark_select_threadreq_or_park_and_unlock(p, wq, uth, WQ_SETUP_NONE);</span><br><span class="line">        <span class="comment">// 标记代码不可达。</span></span><br><span class="line">        __builtin_unreachable(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里，说明唤醒线程是为了销毁线程</span></span><br><span class="line">    <span class="keyword">if</span> (__probable(wr == THREAD_AWAKENED)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果线程被唤醒且状态为 THREAD_AWAKENED：</span></span><br><span class="line"><span class="comment">         * - 这是一个特殊情况，线程被设置为运行状态，但目的是为了销毁。</span></span><br><span class="line"><span class="comment">         * - 确保线程已经被标记为“死亡”状态（UT_WORKQ_DYING）。</span></span><br><span class="line"><span class="comment">         * - 确保线程不是新线程（UT_WORKQ_NEW 标志未设置）。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 断言目的：</span></span><br><span class="line"><span class="comment">         * 1. `uth-&gt;uu_workq_flags &amp; UT_WORKQ_DYING`：</span></span><br><span class="line"><span class="comment">         *    确保线程已经被标记为“死亡”状态，表明线程的生命周期即将结束。</span></span><br><span class="line"><span class="comment">         *    如果未设置该标志，说明逻辑存在问题，线程不应该进入此分支。</span></span><br><span class="line"><span class="comment">         * 2. `(uth-&gt;uu_workq_flags &amp; UT_WORKQ_NEW) == 0`：</span></span><br><span class="line"><span class="comment">         *    确保线程不是新创建的线程。新线程不应该直接进入“死亡”状态。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assert(uth-&gt;uu_workq_flags &amp; UT_WORKQ_DYING);</span><br><span class="line">        assert((uth-&gt;uu_workq_flags &amp; UT_WORKQ_NEW) == <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果线程被中断（THREAD_INTERRUPTED）：</span></span><br><span class="line"><span class="comment">         * - 这是一个兼容性处理，用于确保在用户空间调用 workq_thread_terminate()</span></span><br><span class="line"><span class="comment">         *   或 workq_exit() 时能够正确处理该线程。</span></span><br><span class="line"><span class="comment">         * - 增加工作队列的“死亡”线程计数（wq_thdying_count）。</span></span><br><span class="line"><span class="comment">         * - 标记线程为“死亡”状态（UT_WORKQ_DYING）。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 断言目的：</span></span><br><span class="line"><span class="comment">         * 1. `wr == THREAD_INTERRUPTED`：</span></span><br><span class="line"><span class="comment">         *    确保唤醒结果为 THREAD_INTERRUPTED，表明线程被中断唤醒。</span></span><br><span class="line"><span class="comment">         *    如果唤醒结果不是 THREAD_INTERRUPTED，说明逻辑存在问题。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assert(wr == THREAD_INTERRUPTED);</span><br><span class="line">        wq-&gt;wq_thdying_count++;</span><br><span class="line">        uth-&gt;uu_workq_flags |= UT_WORKQ_DYING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁线程逻辑</span></span><br><span class="line">    workq_unpark_for_death_and_unlock(p, wq, uth,</span><br><span class="line">        WORKQ_UNPARK_FOR_DEATH_WAS_IDLE, WQ_SETUP_NONE);</span><br><span class="line">    <span class="comment">// 标记代码不可达</span></span><br><span class="line">    __builtin_unreachable(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数中，多次出现了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_unreachable();</span><br></pre></td></tr></table></figure><p>是 GCC 和 Clang 编译器提供的一个内建函数，用于告诉编译器程序的某个代码路径是不可达的。如果代码在运行时真的到达了<code>__builtin_unreachable()</code>，会导致崩溃或其他未定义行为：<br><img src="/images/lix_blog_240.png"></p><p>而在 <code>workq_unpark_continue</code> 函数中，实际上是不会执行到 <code>__builtin_unreachable()</code> 的，因为 <code>__builtin_unreachable()</code> 上面所调用的函数，都是 <code>noreturn</code> 的，<strong>进去后就出不来了</strong>。</p><p><strong>总结 <code>workq_unpark_continue</code> 函数实现如下：</strong></p><ul><li>如果线程是创建者线程 <code>wq_creator</code>，则判断是否需要让出 CPU，如果需要，则让出 CPU 且使其被唤醒后（CPU 资源足够时）再次执行 <code>workq_unpark_continue</code>，并终止 <code>workq_unpark_continue</code> 执行。<ul><li>当正在工作的线程（占用 CPU）数量，超过了最大并发线程数（CPU 逻辑核心数量），则需要让出 CPU。</li></ul></li><li>如果线程被标记为运行状态（含 <code>UT_WORKQ_RUNNING</code> 标记），则调用 <code>workq_unpark_select_threadreq_or_park_and_unlock</code> 选择一个线程请求处理或挂起线程。<ul><li>所以，对于创建者线程 <code>wq_creator</code>，也会走此逻辑。</li></ul></li><li>否则，线程被唤醒是为了销毁线程，执行线程销毁的逻辑。</li></ul><h3 id="7、workq-unpark-select-threadreq-or-park-and-unlock"><a href="#7、workq-unpark-select-threadreq-or-park-and-unlock" class="headerlink" title="7、workq_unpark_select_threadreq_or_park_and_unlock"></a>7、workq_unpark_select_threadreq_or_park_and_unlock</h3><p>上一步提到，如果线程被标记为运行状态（含 <code>UT_WORKQ_RUNNING</code> 标记），则调用 <code>workq_unpark_select_threadreq_or_park_and_unlock</code> 选择一个线程请求处理或挂起线程，在前面已经提到，选择一个线程请求处理就是根据线程请求进行执行参数配置，完成参数配置之后，就会将配置好的线程传给用户态去执行具体任务。</p><p>分析源码后确认，只有 <code>workq_pop_idle_thread</code> 会增加 <code>UT_WORKQ_RUNNING</code> 标记，即从空闲线程中取出线程时增加了 <code>UT_WORKQ_RUNNING</code> 标记：</p><ul><li>快速请求流程中，从空闲线程取线程使用时。</li><li>慢速请求流程中，创建 <code>wq_creator</code> 时。</li></ul><p>所以，在上述两个场景中，都会走进 <code>workq_unpark_select_threadreq_or_park_and_unlock</code> 函数。</p><p><code>workq_unpark_select_threadreq_or_park_and_unlock</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">workq_unpark_select_threadreq_or_park_and_unlock</span><span class="params">(<span class="type">proc_t</span> p, <span class="keyword">struct</span> workqueue *wq,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> uthread *uth, <span class="type">uint32_t</span> setup_flags)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逻辑分支 1：配置线程并传给用户态执行具体任务</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 从代码上看，只有一个地方会配置 UT_WORKQ_EARLY_BOUND：</span></span><br><span class="line"><span class="comment">     * - workq_reqthreads 中取空闲线程后会设置 UT_WORKQ_EARLY_BOUND</span></span><br><span class="line"><span class="comment">     * - 说明 workq_reqthreads while 循环去线程缓存使用，线程唤醒时走这里的逻辑</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (uth-&gt;uu_workq_flags &amp; UT_WORKQ_EARLY_BOUND) &#123;</span><br><span class="line">        <span class="comment">// 如果线程是新创建的，设置首次使用标志</span></span><br><span class="line">        <span class="keyword">if</span> (uth-&gt;uu_workq_flags &amp; UT_WORKQ_NEW) &#123;</span><br><span class="line">            setup_flags |= WQ_SETUP_FIRST_USE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除线程的 NEW 和 EARLY_BOUND 标志</span></span><br><span class="line">        uth-&gt;uu_workq_flags &amp;= ~(UT_WORKQ_NEW | UT_WORKQ_EARLY_BOUND);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置并运行线程的任务</span></span><br><span class="line">        workq_setup_and_run(p, uth, setup_flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表示代码逻辑不应到达此处</span></span><br><span class="line">        __builtin_unreachable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑分支 2：选择线程请求处理或挂起线程</span></span><br><span class="line">    thread_freeze_base_pri(get_machthread(uth));</span><br><span class="line">    workq_select_threadreq_or_park_and_unlock(p, wq, uth, setup_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该函数可以分成两个逻辑分支：</strong></p><ul><li><strong>逻辑分支 1：</strong>配置线程并传给用户态执行具体任务。<ul><li>当线程配置了 <code>UT_WORKQ_EARLY_BOUND</code> 标志时，会走该逻辑分支。</li><li>只有 <code>workq_reqthreads</code> 中取空闲线程后会设置 <code>UT_WORKQ_EARLY_BOUND</code>，所以快速请求流程获取到的线程走此逻辑分支。</li><li>此逻辑分支核心逻辑是调用 <code>workq_setup_and_run</code> 将线程传给用户态执行具体任务。</li></ul></li><li><strong>逻辑分支 2：</strong>选择线程请求处理或挂起线程。<ul><li>由于创建 <code>wq_creator</code> 时，未无 <code>UT_WORKQ_EARLY_BOUND</code>，所以创建者线程 <code>wq_creator</code> 会走此分支。</li><li>此处调用的是 <code>workq_select_threadreq_or_park_and_unlock</code> 函数</li></ul></li></ul><h3 id="8、workq-select-threadreq-or-park-and-unlock"><a href="#8、workq-select-threadreq-or-park-and-unlock" class="headerlink" title="8、workq_select_threadreq_or_park_and_unlock"></a>8、workq_select_threadreq_or_park_and_unlock</h3><p>上面已经提到，创建线程 <code>wq_creator</code> 被唤醒后，最终会执行到 <code>workq_select_threadreq_or_park_and_unlock</code> 函数，选择一个线程请求处理，或者挂起线程。该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">workq_select_threadreq_or_park_and_unlock</span><span class="params">(<span class="type">proc_t</span> p, <span class="keyword">struct</span> workqueue *wq,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> uthread *uth, <span class="type">uint32_t</span> setup_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化变量</span></span><br><span class="line">    <span class="type">workq_threadreq_t</span> req = <span class="literal">NULL</span>; <span class="comment">// 当前选中的线程请求</span></span><br><span class="line">    <span class="type">bool</span> is_creator = (wq-&gt;wq_creator == uth); <span class="comment">// 判断当前线程是否为创建者线程</span></span><br><span class="line">    <span class="type">bool</span> schedule_creator = <span class="literal">false</span>; <span class="comment">// 是否需要调度新的创建者线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (......) &#123;</span><br><span class="line">        <span class="keyword">goto</span> park; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_creator) &#123;</span><br><span class="line">        wq-&gt;wq_creator = <span class="literal">NULL</span>; <span class="comment">// 清除创建者线程标记</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (......) &#123;</span><br><span class="line">        <span class="keyword">goto</span> park_thawed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wq-&gt;wq_fulfilled++;</span><br><span class="line">    schedule_creator = workq_threadreq_dequeue(wq, req,</span><br><span class="line">        cooperative_sched_count_changed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果以下任一条件为真，调用 workq_schedule_creator，再次进入慢速请求流程：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * - 我们当前是创建者线程，所以工作队列可能需要一个新的创建者</span></span><br><span class="line"><span class="comment">     * - 我们正在绑定的请求是最高优先级的，现有创建者的优先级可能需要调整以反映下一个最高优先级的线程请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (is_creator || schedule_creator) &#123;</span><br><span class="line">        <span class="comment">// 再次进入慢速请求流程</span></span><br><span class="line">        workq_schedule_creator(p, wq, WORKQ_THREADREQ_CAN_CREATE_THREADS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁工作队列</span></span><br><span class="line">    workq_unlock(wq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果线程请求已完成，则释放其内存</span></span><br><span class="line">    <span class="keyword">if</span> (req) &#123;</span><br><span class="line">        zfree(workq_zone_threadreq, req);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程并运行</span></span><br><span class="line">    workq_setup_and_run(p, uth, setup_flags); <span class="comment">// 切换到用户空间执行</span></span><br><span class="line">    __builtin_unreachable();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程挂起逻辑</span></span><br><span class="line">park:</span><br><span class="line">    <span class="comment">// 解冻线程的基础优先级</span></span><br><span class="line">    thread_unfreeze_base_pri(get_machthread(uth));</span><br><span class="line">park_thawed:</span><br><span class="line">    <span class="comment">// 挂起线程并解锁工作队列</span></span><br><span class="line">    workq_park_and_unlock(p, wq, uth, setup_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述逻辑可知，当线程需要挂起时（例如：队列正在退出、没有线程请求或达到最大并发数量限制时），会将创建者线程 <code>wq_creator</code> 挂起（解冻优先级等待下次调度或放入空闲线程中）。否则，将：</p><ul><li>先将 <code>workqueue</code> 的 <code>wq_creator</code> 置为 <code>NULL</code>。</li><li>新建一个创建者线程 <code>wq_creator</code> 供下次使用。</li><li>将调用 <code>workq_setup_and_run</code> 将旧的创建者线程 <code>wq_creator</code> 传到用户态执行具体任务。</li></ul><p>所以，这里就看出了创建者线程 <code>wq_creator</code> 的工作流程：作为工作线程传到用户态执行具体任务，并再次通过慢速请求流程创建一个新的创建者线程 <code>wq_creator</code>，循环执行此 <code>wq_creator</code> 的工作。</p><h3 id="9、workq-setup-and-run"><a href="#9、workq-setup-and-run" class="headerlink" title="9、workq_setup_and_run"></a>9、workq_setup_and_run</h3><p>根据前面逻辑分析结果，有两种场景会调用 <code>workq_setup_and_run</code> 函数：</p><ul><li><strong>快速请求流程，从空闲线程中取出线程使用时。</strong></li><li><strong>慢速请求流程，创建者线程 <code>wq_creator</code> 处理线程请求时。</strong></li></ul><p><code>workq_setup_and_run</code> 函数主要作用是配置线程，并将线程传到用户态执行具体任务。该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">workq_setup_and_run</span><span class="params">(<span class="type">proc_t</span> p, <span class="keyword">struct</span> uthread *uth, <span class="type">int</span> setup_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程 uth 各种参数配置 ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 pthread 提供的 workq_setup_thread 函数</span></span><br><span class="line">    pthread_functions-&gt;workq_setup_thread(p, th, vmap, uth-&gt;uu_workq_stackaddr,</span><br><span class="line">        uth-&gt;uu_workq_thport, <span class="number">0</span>, setup_flags, upcall_flags);</span><br><span class="line"></span><br><span class="line">    __builtin_unreachable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>workq_setup_thread</code> 函数是由 pthread 提供的，在 libpthread 开源仓库中。<code>workq_setup_thread</code> 的主要逻辑是通过设置线程寄存器的状态，使其跳转到指定的函数，这里函数主要执行路径是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start_wqthread</span><br><span class="line">⬇️</span><br><span class="line">_pthread_wqthread</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_worker_thread2</span><br></pre></td></tr></table></figure><p>到这里，就和上篇文章<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a>）中并发队列申请线程并执行任务的内容对应上了。</p><h3 id="10、总结"><a href="#10、总结" class="headerlink" title="10、总结"></a>10、总结</h3><p>可以使用下图表示并发队列线程池管理逻辑：<br><img src="/images/lix_blog_241.png"></p><h2 id="四、串行队列申请线程"><a href="#四、串行队列申请线程" class="headerlink" title="四、串行队列申请线程"></a>四、串行队列申请线程</h2><p>上篇文章<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a>）中有分析过，串行队列是基于 <code>Workloop</code> 的，通过 <code>kevent_id</code> 系统调用的方式申请线程。并且对于串行队列，当有任务需要执行时，每个串行队列只会开启一个线程去执行任务。从这一点其实也可看出，<strong>队列、Workloop、线程是一一对应且绑定的。</strong></p><p>根据前面测试结果也可以看出，虽然每个串行队列在执行任务期间只会创建一个线程，但是有很多个不同的串行队列时，就可以创建很多个线程，最高可以创建 512 个线程，可以超过 CPU 逻辑核心数量。</p><p>而并发队列却需要考虑 CPU 负载情况，限制了最大并发线程数量不超过 CPU 逻辑核心数量，且线程总数不超过 64 个，XNU 这么设计，至少有下面两个好处：</p><ul><li>每个串行队列在任一时刻只有一个任务在执行，对 CPU 的消耗相对较少，系统需要确保足够的线程资源使串行队列不被阻塞，如果限制太严格，可能导致队列任务无法及时调度。</li><li>并发队列主要为计算密集型任务设计，目标是最大化 CPU 利用率，超过 CPU 逻辑核心数量的线程会增加上下文切换成本，会导致性能的降低。所以需要限制线程数量以确保 CPU 能高性能处理任务。</li></ul><h3 id="1、kevent-id"><a href="#1、kevent-id" class="headerlink" title="1、kevent_id"></a>1、kevent_id</h3><p>串行队列是基于 <code>Workloop</code> 并通过 <code>kevent_id</code> 系统调用的方式申请线程的，<code>kevent_id</code> 函数主要逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kevent_id</span><span class="params">(<span class="keyword">struct</span> proc *p, <span class="keyword">struct</span> kevent_id_args *uap, <span class="type">int32_t</span> *retval)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前线程的 uthread 结构体</span></span><br><span class="line">    <span class="type">uthread_t</span> uth = current_uthread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程绑定的工作队列线程请求 (workq_threadreq_t)</span></span><br><span class="line">    <span class="type">workq_threadreq_t</span> kqr = uth-&gt;uu_kqr_bound;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取当前线程绑定的 workloop</span></span><br><span class="line">    kqu.kqwl = kqr ? kqr_kqworkloop(kqr) : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程绑定了 workloop</span></span><br><span class="line">    <span class="keyword">if</span> (kqu.kqwl &amp;&amp; kqu.kqwl-&gt;kqwl_dynamicid == uap-&gt;id) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 增加 workloop 的引用计数，确保在后续操作中不会被释放</span></span><br><span class="line">        kqworkloop_retain(kqu.kqwl);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__improbable(kevent_args_requesting_events(flags, uap-&gt;nevents))) &#123;</span><br><span class="line">        <span class="comment">// 如果用户请求的事件数量不符合要求，返回 EXDEV 错误</span></span><br><span class="line">        <span class="keyword">return</span> EXDEV;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程未绑定工作循环队列，或者队列的动态 ID 不匹配</span></span><br><span class="line">        <span class="comment">// 调用 kqworkloop_get_or_create 函数，尝试获取或创建一个新的 workloop</span></span><br><span class="line">        error = kqworkloop_get_or_create(p, uap-&gt;id, <span class="literal">NULL</span>, <span class="literal">NULL</span>, flags, &amp;kqu.kqwl);</span><br><span class="line">        <span class="keyword">if</span> (__improbable(error)) &#123;</span><br><span class="line">            <span class="comment">// 如果获取或创建失败，返回错误码</span></span><br><span class="line">            <span class="keyword">return</span> error; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 kevent_modern_internal 函数，处理事件列表和更改列表</span></span><br><span class="line">    <span class="keyword">return</span> kevent_modern_internal(kqu, uap-&gt;changelist, uap-&gt;nchanges,</span><br><span class="line">                                  uap-&gt;eventlist, uap-&gt;nevents, flags, kectx, retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述主要逻辑是根据工作队列线程请求判断对应的 <code>workloop</code> 是否存在，如果不存在则新建，如果存在则直接获取。其中，是通过调用 <code>kqworkloop_get_or_create</code> 函数获取或新建 <code>workloop</code> 的。</p><h3 id="2、kqworkloop-get-or-create"><a href="#2、kqworkloop-get-or-create" class="headerlink" title="2、kqworkloop_get_or_create"></a>2、kqworkloop_get_or_create</h3><p><code>kqworkloop_get_or_create</code> 函数用于获取或新建 <code>workloop</code>，该函数主要实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">kqworkloop_get_or_create</span><span class="params">(<span class="keyword">struct</span> proc *p, <span class="type">kqueue_id_t</span> id,</span></span><br><span class="line"><span class="params">    <span class="type">workq_threadreq_param_t</span> *trp,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> workq_threadreq_extended_param_s *trp_extended,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="keyword">struct</span> kqworkloop **kqwlp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前进程的文件描述符表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filedesc</span> *<span class="title">fdp</span> =</span> &amp;p-&gt;p_fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 加锁哈希表</span></span><br><span class="line">        kqhash_lock(fdp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果哈希表尚未初始化，则初始化它</span></span><br><span class="line">        <span class="keyword">if</span> (__improbable(fdp-&gt;fd_kqhash == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">// 初始化哈希表</span></span><br><span class="line">            kqworkloop_hash_init(fdp); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在哈希表中查找指定 id 的 workloop </span></span><br><span class="line">        kqwl = kqworkloop_hash_lookup_locked(fdp, id);</span><br><span class="line">        <span class="keyword">if</span> (kqwl) &#123;</span><br><span class="line">            <span class="comment">// 找到了 workloop</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未找到 workloop，尝试新建一个</span></span><br><span class="line">        <span class="keyword">if</span> (__probable(alloc_kqwl == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            alloc_kqwl = zalloc_flags(kqworkloop_zone, Z_NOWAIT | Z_ZERO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__probable(alloc_kqwl)) &#123;</span><br><span class="line">            <span class="comment">// 新建 workloop 成功</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将新分配的工作循环队列插入到哈希表中</span></span><br><span class="line">            kqworkloop_hash_insert_locked(fdp, id, alloc_kqwl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解锁哈希表</span></span><br><span class="line">            kqhash_unlock(fdp); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (trp &amp;&amp; (trp-&gt;trp_flags &amp; TRP_BOUND_THREAD)) &#123;</span><br><span class="line">                <span class="comment">// 申请线程，并将线程与 workloop 绑定</span></span><br><span class="line">                error = workq_kern_threadreq_permanent_bind(p, &amp;alloc_kqwl-&gt;kqwl_request);</span><br><span class="line">                <span class="keyword">if</span> (error != KERN_SUCCESS) &#123;</span><br><span class="line">                    <span class="comment">// 如果绑定失败，释放引用计数并删除 workloop</span></span><br><span class="line">                    kqworkloop_release(alloc_kqwl);</span><br><span class="line">                    alloc_kqwl = <span class="literal">NULL</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> error;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 绑定成功 ......</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 赋值新建的 workloop</span></span><br><span class="line">            *kqwlp = alloc_kqwl; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁哈希表</span></span><br><span class="line">    kqhash_unlock(fdp); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从该函数中可以看出队列对应的 <code>workloop</code> 存储在哈希表中，<code>workloop</code> 获取和新建逻辑如下：</p><ul><li>判断哈希表是否初始化，如果没有则先初始化。</li><li>根据队列 <code>id</code> 从哈希表中获取 <code>workloop</code>。</li><li>如果哈希表中没找到，则新建一个 <code>workloop</code>，同时：<ul><li>将新建的 <code>workloop</code> 插入哈希表。</li><li>调用 <code>workq_kern_threadreq_permanent_bind</code> 函数申请线程，并将线程与 <code>workloop</code> 绑定。<ul><li>调用 <code>workq_kern_threadreq_permanent_bind</code> 时，传入的线程请求（<code>kqr</code>）是从 <code>workloop</code> 中获取的（<code>&amp;alloc_kqwl-&gt;kqwl_request</code>）。所以线程请求（<code>kqr</code>）已经和 <code>workloop</code> 是绑定的关系。</li></ul></li></ul></li></ul><h3 id="3、workq-kern-threadreq-permanent-bind"><a href="#3、workq-kern-threadreq-permanent-bind" class="headerlink" title="3、workq_kern_threadreq_permanent_bind"></a>3、workq_kern_threadreq_permanent_bind</h3><p>关于该函数，源码中给出了注释去解释该函数的作用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * An entry point for kevent to request a newly created workqueue thread</span><br><span class="line"> * and bind it permanently to the given workqueue thread request.</span><br><span class="line"> *</span><br><span class="line"> * It currently only supports fixed scheduler priority thread requests.</span><br><span class="line"> *</span><br><span class="line"> * The newly created thread counts towards wq_nthreads. This function returns</span><br><span class="line"> * an error if we are above that limit. There is no concept of delayed thread</span><br><span class="line"> * creation for such specially configured kqworkloops.</span><br><span class="line"> *</span><br><span class="line"> * If successful, the newly created thread will be parked in</span><br><span class="line"> * workq_bound_thread_initialize_and_unpark_continue waiting for</span><br><span class="line"> * new incoming events.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>即该函数是通过 <code>kevent</code>&#x2F;<code>kevent_id</code> 请求线程的入口点，会将线程、线程请求、<code>workloop</code> 进行绑定。新创建的线程计入 <code>wq_nthreads</code>。<strong>新创建的线程将在有任务需要处理时候，会被唤醒并调用 <code>workq_bound_thread_initialize_and_unpark_continue</code> 函数。</strong></p><p><code>workq_kern_threadreq_permanent_bind</code> 函数主要实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">workq_kern_threadreq_permanent_bind</span><span class="params">(<span class="keyword">struct</span> proc *p, <span class="keyword">struct</span> workq_threadreq_s *kqr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">kern_return_t</span> ret = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 用于存储新创建的线程</span></span><br><span class="line">    <span class="type">thread_t</span> new_thread = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">// 获取当前进程的 workqueue</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue</span> *<span class="title">wq</span> =</span> proc_get_wqptr_fast(p); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    workq_lock_spin(wq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前线程数是否已达到最大限制 512</span></span><br><span class="line">    <span class="keyword">if</span> (wq-&gt;wq_nthreads &gt;= wq_max_threads) &#123;</span><br><span class="line">        <span class="comment">// 如果线程数已达上限 512，返回错误码 EDOM</span></span><br><span class="line">        ret = EDOM; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// QoS 相关配置</span></span><br><span class="line">        <span class="keyword">if</span> (kqr-&gt;tr_flags &amp; WORKQ_TR_FLAG_WL_OUTSIDE_QOS) &#123;</span><br><span class="line">            <span class="comment">// 提取 workloop 参数</span></span><br><span class="line">            <span class="type">workq_threadreq_param_t</span> trp = kqueue_threadreq_workloop_param(kqr); </span><br><span class="line"></span><br><span class="line">            <span class="type">thread_qos_t</span> qos = thread_workq_qos_for_pri(trp.trp_pri); </span><br><span class="line">            <span class="keyword">if</span> (qos == THREAD_QOS_UNSPECIFIED) &#123;</span><br><span class="line">                qos = WORKQ_THREAD_QOS_ABOVEUI;</span><br><span class="line">            &#125;</span><br><span class="line">            kqr-&gt;tr_qos = qos; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置线程请求的计数为 1</span></span><br><span class="line">        kqr-&gt;tr_count = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用 workq_add_new_idle_thread 创建一个新的空闲线程。</span></span><br><span class="line"><span class="comment">         * 该函数会在创建线程时释放并重新获取工作队列锁。</span></span><br><span class="line"><span class="comment">         * 如果成功，new_thread 会指向新创建的线程。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ret = workq_add_new_idle_thread(p, wq,</span><br><span class="line">            workq_bound_thread_initialize_and_unpark_continue,</span><br><span class="line">            <span class="literal">true</span>, &amp;new_thread);</span><br><span class="line">        <span class="keyword">if</span> (ret == KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">uth</span> =</span> get_bsdthread_info(new_thread);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (kqr-&gt;tr_flags &amp; WORKQ_TR_FLAG_WL_OUTSIDE_QOS) &#123;</span><br><span class="line">                workq_thread_reset_pri(wq, uth, kqr, <span class="comment">/*unpark*/</span> <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 将线程请求（kqr）与新创建的线程（uth）进行初步关联，并设置线程的调度属性（如 QoS、优先级等）</span></span><br><span class="line"><span class="comment">             * 为后续的 kqr、uth 正式绑定提交做好准备</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            kqueue_threadreq_bind_prepost(p, kqr, uth); </span><br><span class="line">            <span class="comment">// 设置线程为永久绑定</span></span><br><span class="line">            uth-&gt;uu_workq_flags |= UT_WORKQ_PERMANENT_BIND; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    workq_unlock(wq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果线程创建成功，则提交绑定。</span></span><br><span class="line">    <span class="keyword">if</span> (ret == KERN_SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将线程请求（kqr）与新创建的线程（uth）正式绑定</span></span><br><span class="line">        kqueue_threadreq_bind_commit(p, new_thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结该函数逻辑如下：</p><ul><li>判断当前线程总数 <code>wq_nthreads</code> 是否大于等于 <code>wq_max_threads</code>（512），如果达到了上限数量 512，则不允许再新建线程。<ul><li>等待有线程释放后再被调度获取线程。</li><li>前面并发队列申请的线程，也会增加 <code>wq_nthreads</code> 计数，这就是一开始的测试中串行队列、并发队列一起使用时，线程总数仍然不能超过 512 的原因。</li></ul></li><li><strong>如果线程总数未达上限 512，则调用 <code>workq_add_new_idle_thread</code> 新建一个线程，并设置线程被唤醒后执行 <code>workq_bound_thread_initialize_and_unpark_continue</code> 函数。</strong></li><li>将线程请求（<code>kqr</code>）与新创建的线程（<code>uth</code>）进行初步关联，并设置线程的调度属性（如 <code>QoS</code>、优先级等），为后续的 <code>kqr</code>、<code>uth</code> 正式绑定提交做好准备。</li><li>将线程请求（<code>kqr</code>）与新创建的线程（<code>uth</code>）正式绑定。<ul><li>由于线程请求（<code>kqr</code>）已经和 <code>workloop</code> 是绑定的关系了，所以这一步实际上也是将线程（<code>uth</code>）与 <code>workloop</code> 进行绑定。</li></ul></li></ul><h3 id="4、workq-bound-thread-initialize-and-unpark-continue"><a href="#4、workq-bound-thread-initialize-and-unpark-continue" class="headerlink" title="4、workq_bound_thread_initialize_and_unpark_continue"></a>4、workq_bound_thread_initialize_and_unpark_continue</h3><p>前面创建的线程将在有任务需要处理时候，会被唤醒并调用 <code>workq_bound_thread_initialize_and_unpark_continue</code> 函数，该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">workq_bound_thread_initialize_and_unpark_continue</span><span class="params">(<span class="type">void</span> *parameter __unused,</span></span><br><span class="line"><span class="params">    <span class="type">wait_result_t</span> wr)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前线程的 uthread 结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">uth</span> =</span> get_bsdthread_info(current_thread()); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__probable(wr == THREAD_AWAKENED)) &#123; </span><br><span class="line">        <span class="comment">// 唤醒线程是为了执行任务</span></span><br><span class="line">        <span class="comment">// 确保 UT_WORKQ_RUNNING 和 UT_WORKQ_DYING 标志不会同时存在。</span></span><br><span class="line">        assert((uth-&gt;uu_workq_flags &amp; (UT_WORKQ_RUNNING | UT_WORKQ_DYING)) != (UT_WORKQ_RUNNING | UT_WORKQ_DYING));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保线程已永久绑定到工作循环。</span></span><br><span class="line">        assert(workq_thread_is_permanently_bound(uth));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uth-&gt;uu_workq_flags &amp; UT_WORKQ_RUNNING) &#123; </span><br><span class="line">            <span class="comment">// 如果线程处于运行状态。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清除新线程标志</span></span><br><span class="line">            assert(uth-&gt;uu_workq_flags &amp; UT_WORKQ_NEW); </span><br><span class="line">            uth-&gt;uu_workq_flags &amp;= ~UT_WORKQ_NEW; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 workloop 绑定的线程请求 kqr</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">workq_threadreq_s</span> *<span class="title">kqr</span> =</span> uth-&gt;uu_kqr_bound; </span><br><span class="line">            <span class="keyword">if</span> (kqr-&gt;tr_work_interval) &#123;</span><br><span class="line">                <span class="type">kern_return_t</span> kr;</span><br><span class="line">                kr = kern_work_interval_explicit_join(get_machthread(uth), kqr-&gt;tr_work_interval); <span class="comment">// 加入工作间隔。</span></span><br><span class="line">        </span><br><span class="line">                <span class="keyword">if</span> (kr == KERN_SUCCESS) &#123;</span><br><span class="line">                    uth-&gt;uu_workq_flags |= UT_WORKQ_WORK_INTERVAL_JOINED; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    uth-&gt;uu_workq_flags |= UT_WORKQ_WORK_INTERVAL_FAILED; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重置线程的 CPU 使用百分比限制</span></span><br><span class="line">            workq_thread_reset_cpupercent(kqr, uth); </span><br><span class="line">            <span class="comment">// 将线程传到用户态去执行具体任务</span></span><br><span class="line">            workq_bound_thread_setup_and_run(uth, WQ_SETUP_FIRST_USE); </span><br><span class="line"></span><br><span class="line">            __builtin_unreachable();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果线程未处于运行状态，说明绑定的 workloop 正在被销毁。</span></span><br><span class="line"><span class="comment">             * 线程被唤醒以清理资源并解除绑定。</span></span><br><span class="line"><span class="comment">             * 加断言确保线程被标记为“死亡”状态。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            assert(uth-&gt;uu_workq_flags &amp; UT_WORKQ_DYING);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 唤醒线程是因为线程被中断 (THREAD_INTERRUPTED)，需解除线程与 workloop 的绑定</span></span><br><span class="line"><span class="comment">         * 例如：用户强杀 APP、信号中断、系统资源限制等。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        assert(wr == THREAD_INTERRUPTED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前进程</span></span><br><span class="line">        <span class="type">proc_t</span> p = current_proc(); </span><br><span class="line">        <span class="comment">// 获取工作队列</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">workqueue</span> *<span class="title">wq</span> =</span> proc_get_wqptr_fast(p); </span><br><span class="line">        workq_lock_spin(wq); </span><br><span class="line">        assert(workq_thread_is_permanently_bound(uth)); </span><br><span class="line">        workq_unlock(wq);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程的终止逻辑依赖于线程已经完成绑定，所以终止前需要确保是已经绑定的</span></span><br><span class="line">        kqueue_threadreq_bind_commit(p, get_machthread(uth)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 终止绑定线程</span></span><br><span class="line">    workq_kern_bound_thread_terminate(uth-&gt;uu_kqr_bound); </span><br><span class="line">    __builtin_unreachable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数核心逻辑如下：</p><ul><li>如果唤醒线程是为了执行任务，则调用  <code>workq_bound_thread_setup_and_run</code> 将线程传到用户态去执行任务。</li><li>如果唤醒线程，是因为线程被中断（<code>INTERRUPTED</code>），则将线程与 <code>workloop</code> 解绑，并走线程退出逻辑。<ul><li>如下场景会导致线程被中断：<ul><li>用户强制杀死 APP。</li><li>用户态 APP 主动调用 <code>exit()</code> 或 <code>abort()</code> 终止进程。</li><li>用户态 APP 注册了信号处理程序，但未处理某些信号（如 <code>SIGKILL</code>），当这些信号到达时，线程会被中断。</li><li>在高并发场景下，APP 创建了大量线程，导致系统资源耗尽。</li></ul></li></ul></li></ul><p>其中，<code>workq_bound_thread_setup_and_run</code> 内部最终还是通过前面分析过的 <code>workq_setup_thread</code> 将任务传到 <code>pthread</code> 的。<code>workq_setup_thread</code> 的主要逻辑是通过设置线程寄存器的状态，使其跳转到指定的函数，对于串行队列，函数主要执行路径是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start_wqthread</span><br><span class="line">⬇️</span><br><span class="line">_pthread_wqthread</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_workloop_worker_thread</span><br></pre></td></tr></table></figure><p>后续就是串行队列中具体任务的执行逻辑了，详见<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a>。</p><p>到这里，应该都可以发现串行队列、并发队列在申请线程上，除了最大线程数量的差异，还有个请求路径上的差异：串行队列是直接通过 <code>kevent_id</code> 系统调用申请线程的，而并发队列是先调用 <code>pthread</code> 提供的 <code>_pthread_workqueue_addthreads</code> 函数申请线程，再由该函数进入内核态申请线程，两者差异可以用下图表示：<br><img src="/images/lix_blog_242.png"></p><h3 id="5、总结-1"><a href="#5、总结-1" class="headerlink" title="5、总结"></a>5、总结</h3><p>从线程申请逻辑上看，串行队列申请线程要比并发队列简单的多，可以用下图总结串行队列线程管理的流程：<br><img src="/images/lix_blog_243.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCD 底层原理 4 - dispatch_async</title>
      <link href="/posts/50907/"/>
      <url>/posts/50907/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><code>dispatch_async</code> 是用于将任务异步提交到指定调度队列的函数。它允许调用者线程继续执行，而不必等待任务的完成。</p><p><code>dispatch_async</code> 特点：</p><ul><li><strong>会开启新线程</strong><ul><li><code>dispatch_async</code> 提交的任务不会阻塞调用者线程。调用者线程可以继续执行后续代码，而任务会被异步地添加到队列中。</li><li>无论将任务提交到并发队列还是串行队列，都会开启新线程。<ul><li>主队列除外，提交到主队列的任务，会在主线程执行。</li><li>串行队列在有任务需要执行时，只会开启一个线程去执行任务。</li></ul></li></ul></li><li><strong>任务顺序</strong><ul><li><strong>串行队列</strong><ul><li>在串行队列上，<code>dispatch_async</code> 提交的任务会按照提交的顺序依次执行，确保任务之间的顺序性。</li></ul></li><li><strong>并发队列</strong><ul><li>在并发队列上，<code>dispatch_async</code> 提交的任务可以并行执行，具体执行顺序取决于系统的线程调度。</li></ul></li></ul></li></ul><p><strong>使用示例：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.lixkit.concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 任务 1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 任务 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="二、dispatch-async"><a href="#二、dispatch-async" class="headerlink" title="二、dispatch_async"></a>二、dispatch_async</h2><p><code>dispatch_async</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dispatch_async</span><span class="params">(<span class="type">dispatch_queue_t</span> dq, <span class="type">dispatch_block_t</span> work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1、新建或者从缓存中获取 dispatch continuation 对象</span></span><br><span class="line">    <span class="type">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 continuation 的标志，表示这个 continuation 在执行完后应该被销毁</span></span><br><span class="line">    <span class="type">uintptr_t</span> dc_flags = DC_FLAG_CONSUME;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存储服务质量(QoS)信息</span></span><br><span class="line">    <span class="type">dispatch_qos_t</span> qos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、初始化 continuation 对象（为 continuation 中各成员赋值）</span></span><br><span class="line">    <span class="comment">// 设置要执行的 block、优先级等</span></span><br><span class="line">    <span class="comment">// 返回与这个任务相关的服务质量(QoS)级别</span></span><br><span class="line">    qos = _dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, dc_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将初始化好的 continuation 异步提交到指定的队列</span></span><br><span class="line">    <span class="comment">// 传入目标队列、continuation 对象、QoS 信息和标志</span></span><br><span class="line">    _dispatch_continuation_async(dq, dc, qos, dc-&gt;dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述主要逻辑如下：</p><ul><li><strong>获取 <code>continuation</code> 对象</strong><ul><li><code>_dispatch_continuation_alloc</code></li></ul></li><li><strong>初始化 <code>continuation</code> 对象</strong>（为 <code>continuation</code> 中各成员赋值）<ul><li><code>_dispatch_continuation_init</code></li></ul></li><li><strong>提交 <code>continuation</code> 到指定的队列</strong><ul><li><code>_dispatch_continuation_async</code></li></ul></li></ul><p>接下来，基于源码分别看下这几部分逻辑。</p><h2 id="三、-dispatch-continuation-alloc"><a href="#三、-dispatch-continuation-alloc" class="headerlink" title="三、 _dispatch_continuation_alloc"></a>三、 _dispatch_continuation_alloc</h2><p><code>_dispatch_continuation_alloc</code> 函数用于获取 <code>continuation</code> 对象，<code>continuation</code> 对象是对任务的包装，其中存储了任务、优先级、上下文等信息。</p><p><code>continuation</code> 是 <code>dispatch_continuation_t</code> 类型，<code>dispatch_continuation_t</code> 是一个指向 <code>dispatch_continuation_s</code> 结构体的指针，<code>dispatch_continuation_s</code> 的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> &#123;</span></span><br><span class="line">    DISPATCH_CONTINUATION_HEADER(continuation);</span><br><span class="line">&#125; *<span class="type">dispatch_continuation_t</span>;</span><br></pre></td></tr></table></figure><p>将其涉及的宏完全展开后，结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> &#123;</span></span><br><span class="line"> <span class="comment">// 虚函数表指针 &amp; 标志位</span></span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">     <span class="type">const</span> <span class="type">void</span> *__ptrauth_objc_isa_pointer do_vtable; <span class="comment">// 指向虚函数表的指针</span></span><br><span class="line">     <span class="type">uintptr_t</span> dc_flags;                               <span class="comment">// 用于存储各种标志位</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 优先级、缓存计数或填充</span></span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">     <span class="type">pthread_priority_t</span> dc_priority; <span class="comment">// 任务的优先级</span></span><br><span class="line">     <span class="type">int</span> dc_cache_cnt;               <span class="comment">// 缓存计数器</span></span><br><span class="line">     <span class="type">uintptr_t</span> dc_pad;               <span class="comment">// 用于对齐的填充</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指向下一个 continuation 的指针</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 初始化当前 dispatch_continuation_s 的线程的上下文凭证（包含活动 ID 等元数据）</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">voucher_s</span> *<span class="title">dc_voucher</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 要执行的函数</span></span><br><span class="line"> <span class="type">dispatch_function_t</span> dc_func;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 函数的上下文或参数</span></span><br><span class="line"> <span class="type">void</span> *dc_ctxt;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 额外的数据，如组对象等</span></span><br><span class="line"> <span class="type">void</span> *dc_data;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 其他用途的指针</span></span><br><span class="line"> <span class="type">void</span> *dc_other;</span><br><span class="line">&#125; *<span class="type">dispatch_continuation_t</span>;</span><br></pre></td></tr></table></figure><p>从 <code>dispatch_continuation_s</code> 结构可以看出，<code>dispatch_continuation_s</code> 是一个链表结构，其中的 <code>do_next</code> 则是指向下一个 <code>continuation</code>。</p><p><code>_dispatch_continuation_alloc</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_continuation_t</span></span><br><span class="line">_dispatch_continuation_alloc(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 尝试从缓存中读取一个 continuation 对象</span></span><br><span class="line">    <span class="type">dispatch_continuation_t</span> dc =</span><br><span class="line">            _dispatch_continuation_alloc_cacheonly();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果缓存分配失败(返回 NULL)</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!dc)) &#123;</span><br><span class="line">        <span class="comment">// 从堆上分配一个新的 continuation 对象</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_alloc_from_heap();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要逻辑为先从缓存中读取 <code>continuation</code> 对象，如果缓存不存在，再去新建一个 <code>continuation</code> 对象。</p><p>这里重点看下 <code>continuation</code> 缓存读取的逻辑，根据上述源码可知，缓存的读取是调用 <code>_dispatch_continuation_alloc_cacheonly</code> 函数获取的，该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_continuation_t</span></span><br><span class="line">_dispatch_continuation_alloc_cacheonly(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从当前线程存储空间中获取一个缓存的 continuation 对象</span></span><br><span class="line">    <span class="type">dispatch_continuation_t</span> dc = (<span class="type">dispatch_continuation_t</span>)</span><br><span class="line">            _dispatch_thread_getspecific(dispatch_cache_key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果成功获取到缓存的 continuation 对象</span></span><br><span class="line">    <span class="keyword">if</span> (likely(dc)) &#123;</span><br><span class="line">        <span class="comment">// 将线程存储空间中的 continuation 缓存更新为下一个对象</span></span><br><span class="line">        <span class="comment">// 这样可以维护一个 continuation 对象的链表作为缓存</span></span><br><span class="line">        _dispatch_thread_setspecific(dispatch_cache_key, dc-&gt;do_next);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回获取到的 continuation 对象(可能为 NULL 如果缓存为空)</span></span><br><span class="line">    <span class="keyword">return</span> dc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面提到 <code>continuation</code> 是一个链表结构，而其中 <code>do_next</code> 则是指向当前节点的下一个节点。</p><p>可以看到，上述主要逻辑是先从线程从当前线程存储空间中获取一个缓存的 <code>continuation</code>。如果取到，则将缓存更新为 <code>continuation</code> 的下个节点对象 <code>do_next</code>。</p><p>对于缓存不存在时新建的那个 <code>continuation</code>，也会在使用完释放时存入缓存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_free(<span class="type">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    dc = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_continuation_t</span></span><br><span class="line">_dispatch_continuation_free_cacheonly(<span class="type">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 将 continuation 放入线程缓存池</span></span><br><span class="line">    _dispatch_thread_setspecific(dispatch_cache_key, dc);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_continuation_alloc</code> 函数主要逻辑如下：</p><ul><li>从当前线程存储空间中获取一个缓存的 <code>continuation</code> 对象 <code>dc</code>。</li><li>如果读取成功，则将当前线程缓存的 <code>continuation</code> 对象设置为 <code>dc</code> 的下一个对象（<code>dc-&gt;do_next</code>）。</li><li>如果缓存没有读取到，则创建新的 <code>continuation</code>。<ul><li>这个新建的 <code>continuation</code> 在使用完成后，设置成线程缓存的 <code>continuation</code>。</li></ul></li></ul><p>结合上述源码可以知道，每个线程都利用 <code>continuation</code> 链表实现了一个 <code>continuation</code> 缓存池，<code>continuation</code> 不再使用后将会放入缓存池待下次使用，这么设计有下面两个好处：</p><ul><li>通过重用这些对象，可以减少频繁创建和销毁对象的开销，提高性能。</li><li>每个线程维护自己的缓存，可以减少多线程同时分配内存时的锁竞争。</li></ul><h2 id="四、-dispatch-continuation-init"><a href="#四、-dispatch-continuation-init" class="headerlink" title="四、_dispatch_continuation_init"></a>四、_dispatch_continuation_init</h2><p><code>_dispatch_continuation_init</code> 函数用于初始化 <code>continuation</code> 对象，该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_qos_t</span></span><br><span class="line">_dispatch_continuation_init(<span class="type">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="type">dispatch_queue_class_t</span> dqu, <span class="type">dispatch_block_t</span> work,</span><br><span class="line">        <span class="type">dispatch_block_flags_t</span> flags, <span class="type">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 复制传入的 block 对象，确保其在异步执行时仍然有效</span></span><br><span class="line">    <span class="type">void</span> *ctxt = _dispatch_Block_copy(work);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 continuation 的标志，表明它包含一个 block 且已被分配内存</span></span><br><span class="line">    dc_flags |= DC_FLAG_BLOCK | DC_FLAG_ALLOCATED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 block 是否包含私有数据</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">        <span class="comment">// 如果包含私有数据，设置 continuation 的标志和上下文</span></span><br><span class="line">        dc-&gt;dc_flags = dc_flags;</span><br><span class="line">        dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">        <span class="comment">// 调用慢速初始化路径，它会处理所有私有数据相关的设置</span></span><br><span class="line">        <span class="comment">// 注意：这个函数会初始化所有字段，但要求 dc_flags 和 dc_ctxt 已被设置</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_init_slow(dc, dqu, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 block 的执行函数</span></span><br><span class="line">    <span class="type">dispatch_function_t</span> func = _dispatch_Block_invoke(work);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了 CONSUME 标志，使用特殊的函数来在执行后释放 block</span></span><br><span class="line">    <span class="keyword">if</span> (dc_flags &amp; DC_FLAG_CONSUME) &#123;</span><br><span class="line">        func = _dispatch_call_block_and_release;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数指针方式初始化 continuation</span></span><br><span class="line">    <span class="comment">// 这个函数会设置 continuation 的函数、上下文、优先级等信息</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_continuation_init_f(dc, dqu, ctxt, func, flags, dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述逻辑，会先调用 <code>_dispatch_block_has_private_data</code> 函数检查 <code>block</code> 是否包含私有数据，关于 <code>_dispatch_block_has_private_data</code> 函数，<a href="https://www.lixkit.com/posts/42034/">《GCD 底层原理 3 - dispatch_sync》</a> 中有解释，我们常规使用传入的 <code>block</code> 是不包含私有数据的。所以最终会执行 <code>_dispatch_continuation_init_f</code> 函数。</p><p><code>_dispatch_continuation_init_f</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_qos_t</span></span><br><span class="line">_dispatch_continuation_init_f(<span class="type">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="type">dispatch_queue_class_t</span> dqu, <span class="type">void</span> *ctxt, <span class="type">dispatch_function_t</span> f,</span><br><span class="line">        <span class="type">dispatch_block_flags_t</span> flags, <span class="type">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化优先级为 0</span></span><br><span class="line">    <span class="type">pthread_priority_t</span> pp = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 continuation 的标志，包括已分配标志和传入的额外标志</span></span><br><span class="line">    dc-&gt;dc_flags = dc_flags | DC_FLAG_ALLOCATED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 continuation 的函数和上下文</span></span><br><span class="line">    dc-&gt;dc_func = f;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     在这个上下文中，DISPATCH_BLOCK_HAS_PRIORITY 表示优先级不应该被传播，只有当处理程序有优先级时才从处理程序中获取。</span></span><br><span class="line"><span class="comment">     如果没有设置 DISPATCH_BLOCK_HAS_PRIORITY 标志，则传播当前优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; DISPATCH_BLOCK_HAS_PRIORITY)) &#123;</span><br><span class="line">        pp = _dispatch_priority_propagate();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     为 continuation 的 dc_voucher 赋值，该函数内部会读取当前线程的 voucher，并赋值给 dc_voucher</span></span><br><span class="line"><span class="comment">     voucher 中携带了各种上下文信息，包括但不限于活动 ID、重要性等元数据。</span></span><br><span class="line"><span class="comment">     这些信息可以在不同的执行上下文（如线程、进程）之间传递，支持复杂的分布式系统中的上下文传递、活动追踪和资源管理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    _dispatch_continuation_voucher_set(dc, flags);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为 continuation 的 dc_priority 赋值，并返回对应 QoS</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_continuation_priority_set(dc, dqu, pp, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，该函数主要是为 <code>continuation</code> 各成员进行赋值，例如 <code>dc_flags</code>、<code>dc_func</code>、<code>dc_voucher</code>、<code>dc_priority</code> 等。</p><p>该函数中涉及到对 <code>_dispatch_priority_propagate</code>、<code>_dispatch_continuation_voucher_set</code>、<code>_dispatch_continuation_priority_set</code> 的函数调用，接下来分别分析下三个函数的实现逻辑。</p><h3 id="1、-dispatch-priority-propagate"><a href="#1、-dispatch-priority-propagate" class="headerlink" title="1、_dispatch_priority_propagate"></a>1、_dispatch_priority_propagate</h3><p>先看下 <code>_dispatch_continuation_init_f</code> 函数源码中优先级 <code>pp</code> 的赋值，从源码可知调用该函数时，传入的 <code>flags</code> 参数值是 <code>0</code>，所以最终会调用 <code>_dispatch_priority_propagate</code> 函数，该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">static</span> <span class="keyword">inline</span> <span class="type">pthread_priority_t</span></span><br><span class="line"> _dispatch_priority_propagate(<span class="type">void</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> _dispatch_priority_compute_propagated(<span class="number">0</span>,</span><br><span class="line"> DISPATCH_PRIORITY_PROPAGATE_CURRENT);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pthread_priority_t</span></span><br><span class="line">_dispatch_priority_compute_propagated(<span class="type">pthread_priority_t</span> pp,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果设置了 DISPATCH_PRIORITY_PROPAGATE_CURRENT 标志，则使用当前线程的优先级</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DISPATCH_PRIORITY_PROPAGATE_CURRENT) &#123;</span><br><span class="line"><span class="comment">// 使用当前线程存储的优先级值</span></span><br><span class="line">        pp = _dispatch_get_priority();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除优先级中的所有标志位，只保留纯粹的优先级值</span></span><br><span class="line">    pp = _pthread_priority_strip_all_flags(pp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不是同步 IPC 调用，且优先级高于 USER_INITIATED 级别，则进行限制</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; DISPATCH_PRIORITY_PROPAGATE_FOR_SYNC_IPC) &amp;&amp;</span><br><span class="line">            pp &gt; _dispatch_qos_to_pp(DISPATCH_QOS_USER_INITIATED)) &#123;</span><br><span class="line">        <span class="comment">// 将 QOS 限制在用户发起级别 (USER_INITIATED)</span></span><br><span class="line">        <span class="comment">// 这是为了解决 rdar://16681262 和 rdar://16998036 中提到的问题</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_qos_to_pp(DISPATCH_QOS_USER_INITIATED);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回计算得到的优先级</span></span><br><span class="line">    <span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pthread_priority_t</span></span><br><span class="line">_dispatch_get_priority(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从线程存储空间中获取当前线程优先级</span></span><br><span class="line">    <span class="comment">// dispatch_priority_key 是一个线程特定数据的键，用于存储当前线程的优先级</span></span><br><span class="line">    <span class="comment">// _dispatch_thread_getspecific 函数用于获取与该键关联的值</span></span><br><span class="line">    <span class="type">pthread_priority_t</span> pp = (<span class="type">uintptr_t</span>)</span><br><span class="line">            _dispatch_thread_getspecific(dispatch_priority_key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合函数调用时的参数值，总结上述主要逻辑如下：</p><ul><li>从当前线程存储空间中获取当前线程优先级，并赋值给 <code>pp</code>。</li><li>移除优先级中的所有标志位，只保留纯粹的优先级值。</li><li>如果优先级高于 <code>USER_INITIATED</code> 级别，则限制为 <code>USER_INITIATED</code>。</li></ul><p><strong>这里的优先级 <code>pp</code> 是 <code>pthread_priority_t</code> 类型，它和 <code>Qos</code> 什么关系呢？</strong><br><code>pthread_priority_t</code> 和 <code>QoS</code> (Quality of Service) 有密切的关系。在 GCD 中，它们用于表示任务的优先级和服务质量。它们之间的关系如下：</p><ul><li><code>pthread_priority_t</code> 是一个更底层的表示，它包含了 <code>QoS</code> 信息以及其他一些标志位。</li><li><code>QoS</code> 是一个更高级的抽象，它定义了几个离散的优先级级别，如 <code>USER_INTERACTIVE</code>、<code>USER_INITIATED</code>、<code>UTILITY</code> 等。</li><li><code>pthread_priority_t</code> 可以通过位操作来包含 <code>QoS</code> 信息。通常，<code>QoS</code> 值被编码在 <code>pthread_priority_t</code> 的高位字节中。</li><li>可以使用一些宏或函数在 <code>pthread_priority_t</code> 和 <code>QoS</code> 之间进行转换，例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 pthread_priority_t 提取 QoS</span></span><br><span class="line"><span class="type">dispatch_qos_t</span> qos = _dispatch_qos_from_pp(pthread_priority);</span><br><span class="line"><span class="comment">// 从 QoS 创建 pthread_priority_t</span></span><br><span class="line"><span class="type">pthread_priority_t</span> pp = _dispatch_qos_to_pp(qos);</span><br></pre></td></tr></table></figure></li><li><code>pthread_priority_t</code> 除了包含 <code>QoS</code> 信息外，还可以包含其他标志，如相对优先级、覆盖标志等。</li><li>在实际使用中，通常会使用 <code>QoS</code> 级别来设置任务优先级，而系统内部会将其转换为 <code>pthread_priority_t</code> 来进行更细粒度的调度控制。</li></ul><p>可以通过一个简单示例，打印下默认 <code>Qos</code>：<br><img src="/images/lix_blog_226.png"><br>可以看到，默认 <code>Qos</code> 是 <code>USER_INITIATED</code>。</p><h3 id="2、-dispatch-continuation-voucher-set"><a href="#2、-dispatch-continuation-voucher-set" class="headerlink" title="2、_dispatch_continuation_voucher_set"></a>2、_dispatch_continuation_voucher_set</h3><p><code>_dispatch_continuation_init_f</code> 函数中，会调用 <code>_dispatch_continuation_voucher_set</code> 函数为 <code>continuation</code> 的 <code>dc_voucher</code> 赋值，根据前述 <code>dispatch_continuation_s</code> 结构可知，<code>dc_voucher</code> 是 <code>voucher_s</code> 类型。</p><p>完全展开后的 <code>voucher_s</code> 结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">voucher_s</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * isa 指针，指向对象的类信息。</span></span><br><span class="line"><span class="comment">     * 使用了 `__ptrauth_objc_isa_pointer` 进行指针认证（Pointer Authentication）。</span></span><br><span class="line"><span class="comment">     * 这是一个防止指针篡改的安全机制。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">voucher_vtable_s</span> *__<span class="title">ptrauth_objc_isa_pointer</span> <span class="title">os_obj_isa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用计数（Reference Count）。</span></span><br><span class="line"><span class="comment">     * 用于管理对象的生命周期，表示当前有多少地方引用了该对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> os_obj_ref_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交叉引用计数（Cross Reference Count）。</span></span><br><span class="line"><span class="comment">     * 用于管理对象的交叉引用，通常在对象之间存在复杂依赖关系时使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> os_obj_xref_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * voucher 的哈希表节点，用于将 voucher 对象加入到哈希表中。</span></span><br><span class="line"><span class="comment">     * 包含双向链表的前后指针。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">voucher_hash_entry_s</span> &#123;</span></span><br><span class="line">        <span class="type">uintptr_t</span> vhe_next;      <span class="comment">// 指向下一个节点</span></span><br><span class="line">        <span class="type">uintptr_t</span> vhe_prev_ptr;  <span class="comment">// 指向前一个节点的指针</span></span><br><span class="line">    &#125; v_list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Mach voucher 端口。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">mach_voucher_t</span> v_kvoucher;</span><br><span class="line">    <span class="type">mach_voucher_t</span> v_ipc_kvoucher;</span><br><span class="line"></span><br><span class="line">    <span class="type">voucher_t</span> v_kvbase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Firehose 日志系统的活动 ID。</span></span><br><span class="line"><span class="comment">     * 用于跟踪与该 voucher 相关的活动。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">firehose_activity_id_t</span> v_activity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建该活动的进程 ID。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint64_t</span> v_activity_creator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父活动的 ID。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">firehose_activity_id_t</span> v_parent_activity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 布尔值，表示该 voucher 是否具有重要性标志。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v_kv_has_importance:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VOUCHER_ENABLE_RECIPE_OBJECTS</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配方数据的偏移量和大小（仅在启用 `VOUCHER_ENABLE_RECIPE_OBJECTS` 时存在）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">size_t</span> v_recipe_extra_offset;</span><br><span class="line">    <span class="type">mach_voucher_attr_recipe_size_t</span> v_recipe_extra_size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; voucher_s;</span><br></pre></td></tr></table></figure><p><code>voucher_s</code> 不是本次源码分析的重点，且涉及内容较多，不再逐个字段分析。</p><p><code>_dispatch_continuation_voucher_set</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_voucher_set(<span class="type">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="type">dispatch_block_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用于存储 voucher 的指针，voucher_t 是一个指向 voucher_s 结构体的指针</span></span><br><span class="line">    <span class="type">voucher_t</span> v = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     _dispatch_continuation_voucher_set 从不会被调用于带有私有数据或设置了 DISPATCH_BLOCK_HAS_VOUCHER 标志的块。</span></span><br><span class="line"><span class="comment">     只有 _dispatch_continuation_init_slow 处理这个标志位。</span></span><br><span class="line"><span class="comment">     这个断言确保传入的 flags 不包含 DISPATCH_BLOCK_HAS_VOUCHER 标志，因为带有该标志的块应该由 _dispatch_continuation_init_slow 函数处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dispatch_assert(!(flags &amp; DISPATCH_BLOCK_HAS_VOUCHER));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有设置 DISPATCH_BLOCK_NO_VOUCHER 标志</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; DISPATCH_BLOCK_NO_VOUCHER)) &#123;</span><br><span class="line">        <span class="comment">// 复制当前线程的 voucher</span></span><br><span class="line">        <span class="comment">// _voucher_copy() 函数会增加 voucher 的引用计数</span></span><br><span class="line">        v = _voucher_copy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将复制的 voucher 赋值给 continuation 的 dc_voucher 字段</span></span><br><span class="line">    dc-&gt;dc_voucher = v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调试输出</span></span><br><span class="line">    _dispatch_voucher_debug(<span class="string">&quot;continuation[%p] set&quot;</span>, dc-&gt;dc_voucher, dc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录 ktrace 日志</span></span><br><span class="line">    _dispatch_voucher_ktrace_dc_push(dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>_voucher_copy</code> 函数用于复制当前线程的 <code>voucher</code>，其相关实现逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制当前线程关联的 voucher</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">voucher_t</span></span><br><span class="line">_voucher_copy(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程关联的 voucher</span></span><br><span class="line">    <span class="type">voucher_t</span> voucher = _voucher_get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 voucher 存在，增加其引用计数</span></span><br><span class="line">    <span class="comment">// _voucher_retain 函数会增加 voucher 的引用计数，确保 voucher 在使用期间不会被释放</span></span><br><span class="line">    <span class="keyword">if</span> (voucher) _voucher_retain(voucher);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回 voucher（可能是 NULL，如果当前线程没有关联的 voucher）</span></span><br><span class="line">    <span class="keyword">return</span> voucher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前线程关联的 voucher</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">voucher_t</span></span><br><span class="line">_voucher_get(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     从线程存储空间中，使用 dispatch_voucher_key 这个 Key 获取关联的 voucher。</span></span><br><span class="line"><span class="comment">     这个函数实际上是在线程本地存储中查找与 dispatch_voucher_key 关联的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_thread_getspecific(dispatch_voucher_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码可知，上述核心逻辑为读取当前线程的 <code>voucher</code>，并赋值给 <code>dc_voucher</code>。</p><h3 id="3、-dispatch-continuation-priority-set"><a href="#3、-dispatch-continuation-priority-set" class="headerlink" title="3、_dispatch_continuation_priority_set"></a>3、_dispatch_continuation_priority_set</h3><p>该函数主要是为 <code>continuation</code> 的 <code>dc_priority</code> 赋值，并返回对应 <code>QoS</code>，函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_qos_t</span></span><br><span class="line">_dispatch_continuation_priority_set(<span class="type">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="type">dispatch_queue_class_t</span> dqu,</span><br><span class="line">        <span class="type">pthread_priority_t</span> pp, <span class="type">dispatch_block_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化 QoS 为未指定状态</span></span><br><span class="line">    <span class="type">dispatch_qos_t</span> qos = DISPATCH_QOS_UNSPECIFIED;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">    <span class="comment">// 获取实际的调度队列对象</span></span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(pp)) &#123;</span><br><span class="line">        <span class="comment">// 检查是否强制执行 QoS 类别</span></span><br><span class="line">        <span class="type">bool</span> enforce = (flags &amp; DISPATCH_BLOCK_ENFORCE_QOS_CLASS);</span><br><span class="line">        <span class="comment">// 检查队列是否设置了优先级下限标志</span></span><br><span class="line">        <span class="type">bool</span> is_floor = (dq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_FLOOR);</span><br><span class="line">        <span class="comment">// 检查队列是否有请求的优先级</span></span><br><span class="line">        <span class="type">bool</span> dq_has_qos = (dq-&gt;dq_priority &amp; DISPATCH_PRIORITY_REQUESTED_MASK);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enforce) &#123;</span><br><span class="line">            <span class="comment">// 如果强制执行 QoS 类别，则在优先级中添加强制标志</span></span><br><span class="line">            pp |= _PTHREAD_PRIORITY_ENFORCE_FLAG;</span><br><span class="line">            <span class="comment">// 从优先级中提取 QoS 值</span></span><br><span class="line">            qos = _dispatch_qos_from_pp_unsafe(pp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_floor &amp;&amp; dq_has_qos) &#123;</span><br><span class="line">            pp = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，从优先级中提取 QoS 值</span></span><br><span class="line">            qos = _dispatch_qos_from_pp_unsafe(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将计算后的优先级设置到 continuation 的 dc_priority 字段</span></span><br><span class="line">    dc-&gt;dc_priority = pp;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    (<span class="type">void</span>)dc; (<span class="type">void</span>)dqu; (<span class="type">void</span>)pp; (<span class="type">void</span>)flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、-dispatch-continuation-async"><a href="#五、-dispatch-continuation-async" class="headerlink" title="五、_dispatch_continuation_async"></a>五、_dispatch_continuation_async</h2><p>在前面完成 <code>continuation</code> 的初始化之后，将会调用 <code>_dispatch_continuation_async</code> 函数将初始化好的 <code>continuation</code> 异步提交到指定的队列。</p><p><code>_dispatch_continuation_async</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_async(<span class="type">dispatch_queue_class_t</span> dqu,</span><br><span class="line">        <span class="type">dispatch_continuation_t</span> dc, <span class="type">dispatch_qos_t</span> qos, <span class="type">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果启用了调试内省功能（DISPATCH_INTROSPECTION 宏定义）</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_INTROSPECTION</span></span><br><span class="line">    <span class="comment">// 检查是否设置了 DC_FLAG_NO_INTROSPECTION 标志</span></span><br><span class="line">    <span class="comment">// 如果未设置该标志，则将当前 continuation 对象推送到调试追踪系统中</span></span><br><span class="line">    <span class="keyword">if</span> (!(dc_flags &amp; DC_FLAG_NO_INTROSPECTION)) &#123;</span><br><span class="line">        <span class="comment">// 调用 _dispatch_trace_item_push 函数，将 continuation 对象记录到调试追踪中</span></span><br><span class="line">        _dispatch_trace_item_push(dqu, dc);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 如果未启用调试内省功能，避免未使用的参数警告</span></span><br><span class="line">    (<span class="type">void</span>)dc_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 continuation 对象推送到目标队列中</span></span><br><span class="line">    <span class="comment">// dx_push 是一个虚函数调用，具体实现取决于队列的类型</span></span><br><span class="line">    <span class="comment">// 参数说明：</span></span><br><span class="line">    <span class="comment">// - dqu._dq: 目标队列</span></span><br><span class="line">    <span class="comment">// - dc: continuation 对象</span></span><br><span class="line">    <span class="comment">// - qos: 服务质量（QoS）级别</span></span><br><span class="line">    <span class="keyword">return</span> dx_push(dqu._dq, dc, qos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现中，重点是对 <code>dx_push</code> 这个宏的调用，其他的都是日志、调试相关。</p><p><code>dx_push</code> 宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> dx_push(x, y, z) dx_vtable(x)-&gt;dq_push(x, y, z)</span></span><br></pre></td></tr></table></figure><p>可以知道，这里是访问队列虚表的 <code>dq_push</code> 函数进行调用。结合在另篇文章<a href="https://www.lixkit.com/posts/12465/">《GCD 底层原理 2 - dispatch_queue》</a> 中的内容可知，串行队列、并发队列的虚表如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列的虚表</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> _<span class="title">dispatch_queue_serial_vtable</span> =</span> &#123;</span><br><span class="line">    ._os_obj_xref_dispose = _dispatch_xref_dispose,</span><br><span class="line">    ._os_obj_dispose = _dispatch_dispose,</span><br><span class="line">    ._os_obj_vtable = &#123;</span><br><span class="line">        .do_kind = <span class="string">&quot;queue_serial&quot;</span>,</span><br><span class="line">        .do_type        = DISPATCH_QUEUE_SERIAL_TYPE,</span><br><span class="line">        .do_dispose     = _dispatch_lane_dispose,</span><br><span class="line">        .do_debug       = _dispatch_queue_debug,</span><br><span class="line">        .do_invoke      = _dispatch_lane_invoke,</span><br><span class="line"></span><br><span class="line">        .dq_activate    = _dispatch_lane_activate,</span><br><span class="line">        .dq_wakeup      = _dispatch_lane_wakeup,</span><br><span class="line">        .dq_push        = _dispatch_lane_push,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发队列的虚表</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> _<span class="title">dispatch_queue_concurrent_vtable</span> =</span> &#123;</span><br><span class="line">    ._os_obj_xref_dispose = _dispatch_xref_dispose,</span><br><span class="line">    ._os_obj_dispose = _dispatch_dispose,</span><br><span class="line">    ._os_obj_vtable = &#123;</span><br><span class="line">        .do_kind = <span class="string">&quot;queue_concurrent&quot;</span>,</span><br><span class="line">        .do_type = DISPATCH_QUEUE_CONCURRENT_TYPE,</span><br><span class="line">        .do_dispose = _dispatch_lane_dispose,</span><br><span class="line">        .do_debug = _dispatch_queue_debug,</span><br><span class="line">        .do_invoke = _dispatch_lane_invoke,</span><br><span class="line">        .dq_activate = _dispatch_lane_activate,</span><br><span class="line">        .dq_wakeup = _dispatch_lane_wakeup,</span><br><span class="line">        .dq_push = _dispatch_lane_concurrent_push,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，前面对 <code>dx_push</code> 的调用：</p><ul><li>串行队列调用的是 <code>_dispatch_lane_push</code> 函数。</li><li>并发队列调用的是 <code>_dispatch_lane_concurrent_push</code> 函数。</li></ul><p>接下来，分别看下将任务提交到串行队列、并发队列的逻辑。</p><h3 id="1、提交到串行队列"><a href="#1、提交到串行队列" class="headerlink" title="1、提交到串行队列"></a>1、提交到串行队列</h3><h4 id="（1）-dispatch-lane-push"><a href="#（1）-dispatch-lane-push" class="headerlink" title="（1）_dispatch_lane_push"></a>（1）_dispatch_lane_push</h4><p><code>dispatch_async</code> 将任务提交到串行队列时，调用 <code>dx_push</code> 实际调用的是 <code>_dispatch_lane_push</code> 函数，该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_lane_push(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="type">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化唤醒标志</span></span><br><span class="line">    <span class="type">dispatch_wakeup_flags_t</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用于存储队列中的前一个对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为等待对象（例如 dispatch_sync 同步调用的上下文）</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_object_is_waiter(dou))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_lane_push_waiter(dq, dou._dsc, qos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保队列不是全局对象</span></span><br><span class="line">    dispatch_assert(!_dispatch_object_is_global(dq));</span><br><span class="line">    <span class="comment">// 计算并更新服务质量（QoS）</span></span><br><span class="line">    qos = _dispatch_queue_push_qos(dq, qos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     注意：如果我们要调用 dx_wakeup()，必须在推送的项目可能被出队之前保留队列，这意味着：</span></span><br><span class="line"><span class="comment">        - 如果我们需要覆盖，则在交换尾部之前</span></span><br><span class="line"><span class="comment">        - 如果我们使队列变为非空，则在设置头部之前</span></span><br><span class="line"><span class="comment">     否则，如果在这些操作和调用 dx_wakeup() 之间被抢占，当 _dispatch_lane_drain 调用队列中的块时，这些块可能会释放队列的最后一个引用。</span></span><br><span class="line"><span class="comment">     参见 &lt;rdar://problem/6932776&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     将新元素 dou._do 添加到队列的尾部。</span></span><br><span class="line"><span class="comment">     原子地更新队列的尾指针，使其指向新添加的元素。</span></span><br><span class="line"><span class="comment">     返回之前的尾部元素 prev。</span></span><br><span class="line"><span class="comment">        - 如果 prev 为 NULL，说明队列之前是空的，这个新元素就是第一个元素。</span></span><br><span class="line"><span class="comment">        - 如果 prev 不为 NULL，说明队列中已经有元素，新元素被添加到最后。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    prev = os_mpsc_push_update_tail(os_mpsc(dq, dq_items), dou._do, do_next);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(os_mpsc_push_was_empty(prev))) &#123;</span><br><span class="line">        <span class="comment">// 如果之前队列为空，增加队列的引用计数</span></span><br><span class="line">        _dispatch_retain_2_unsafe(dq);</span><br><span class="line">        <span class="comment">// 设置唤醒标志，表示需要消耗引用计数并标记队列为脏</span></span><br><span class="line">        flags = DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(_dispatch_queue_need_override(dq, qos))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里存在一个竞争条件，_dispatch_queue_need_override 可能会读取到过时的 dq_state 值。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 如果读取到的是同一轮 drain 操作中的过时值，由于最大 QoS 是单调递增的，</span></span><br><span class="line"><span class="comment">         * 过时的读取只会导致不必要的覆盖尝试，这是无害的。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 假设读取到上一轮 drain 操作中的过时值在实际中不会发生。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加队列的引用计数，防止队列被过早销毁</span></span><br><span class="line">        _dispatch_retain_2_unsafe(dq);</span><br><span class="line">        <span class="comment">// 设置唤醒标志，表示需要消耗引用计数</span></span><br><span class="line">        flags = DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     更新队列中新添加节点的前驱节点指针</span></span><br><span class="line"><span class="comment">     如果 prev 不为 NULL（队列不为空）：</span></span><br><span class="line"><span class="comment">        - 将 prev 节点的 do_next 字段设置为新节点 dou._do。</span></span><br><span class="line"><span class="comment">        - 这样就把新节点链接到了队列的末尾。</span></span><br><span class="line"><span class="comment">     如果 prev 为 NULL（队列之前为空）：</span></span><br><span class="line"><span class="comment">        - 直接将队列的头指针设置为新节点 dou._do。</span></span><br><span class="line"><span class="comment">        - 这处理了队列从空变为非空的情况。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    os_mpsc_push_update_prev(os_mpsc(dq, dq_items), prev, dou._do, do_next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了唤醒标志，调用 dx_wakeup 函数唤醒队列</span></span><br><span class="line">        <span class="keyword">return</span> dx_wakeup(dq, qos, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的参数 <code>dq</code> 是 <code>dispatch_lane_t</code> 类型，在另篇文章<a href="https://www.lixkit.com/posts/12465/">《GCD 底层原理 2 - dispatch_queue》</a> 中分析了 <code>dispatch_lane_t</code> 结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_s</span> &#123;</span></span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dq_items_head</span>;</span> <span class="comment">// 队列头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dq_items_tail</span>;</span> <span class="comment">// 队列尾</span></span><br><span class="line">    dispatch_unfair_lock_s dq_sidelock; <span class="comment">// 辅助锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch_queue_s 包含的其他字段 ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，将源码中的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prev = os_mpsc_push_update_tail(os_mpsc(dq, dq_items), dou._do, do_next);</span><br></pre></td></tr></table></figure><p>宏完全展开后，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prev = (&#123;</span><br><span class="line">    <span class="comment">// 声明一个临时变量 _tl 并将 dou._do 赋值给它</span></span><br><span class="line">    __typeof__(__c11_atomic_load((__typeof__(*(&amp;(dq)-&gt;dq_items_head)) <span class="keyword">_Atomic</span> *)(&amp;(dq)-&gt;dq_items_head), memory_order_relaxed)) _tl = (dou._do);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 _tl 的 do_next 指针设置为 NULL</span></span><br><span class="line">    __c11_atomic_store((__typeof__((*(_tl)).do_next) <span class="keyword">_Atomic</span> *)(&amp;(_tl)-&gt;do_next), <span class="literal">NULL</span>, memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将队列的尾指针地址存储到线程特定数据中</span></span><br><span class="line">    _dispatch_thread_setspecific(dispatch_enqueue_key, (<span class="type">void</span> *) (&amp;(dq)-&gt;dq_items_tail));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子地交换队列的尾指针,将新节点 _tl 设置为新的尾节点</span></span><br><span class="line">    <span class="comment">// 返回交换前的旧尾节点作为 prev</span></span><br><span class="line">    atomic_exchange_explicit((__typeof__(*(&amp;(dq)-&gt;dq_items_tail)) <span class="keyword">_Atomic</span> *)(&amp;(dq)-&gt;dq_items_tail), _tl, memory_order_release);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看出，这部分逻辑将任务作为节点添加到队列的尾部，并将 <code>dq_items_tail</code> 指向这个新节点（<code>continuation</code>），<code>prev</code> 为之前的尾部指针，可以理解为上一个节点。</p><p>将源码中的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os_mpsc_push_update_prev(os_mpsc(dq, dq_items), prev, dou._do, do_next);</span><br></pre></td></tr></table></figure><p>宏完全展开后，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    <span class="comment">// 原子地加载队列的头部指针，使用 relaxed 内存序</span></span><br><span class="line">    __typeof__(atomic_load_explicit(_os_atomic_c11_atomic(&amp;(dq)-&gt;dq_items_head), memory_order_relaxed)) _prev = (prev);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (likely(_prev)) &#123;</span><br><span class="line">        <span class="comment">// 如果 _prev 不为 NULL，说明队列不为空</span></span><br><span class="line">        <span class="comment">// 将新元素 dou._do 设置为 _prev 的下一个元素</span></span><br><span class="line">        <span class="comment">// 使用 relaxed 内存序，因为这个操作不需要同步</span></span><br><span class="line">        (<span class="type">void</span>)atomic_store_explicit(_os_atomic_c11_atomic(&amp;(_prev)-&gt;do_next), dou._do, memory_order_relaxed);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 _prev 为 NULL，说明队列为空</span></span><br><span class="line">        <span class="comment">// 将新元素 dou._do 设置为队列的头部</span></span><br><span class="line">        <span class="comment">// 使用 relaxed 内存序，因为入队操作的同步已经在之前的 os_mpsc_push_update_tail 中完成</span></span><br><span class="line">        (<span class="type">void</span>)atomic_store_explicit(_os_atomic_c11_atomic(&amp;(dq)-&gt;dq_items_head), dou._do, memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除入队者的标识，可能是用于调试或跟踪目的</span></span><br><span class="line">    _dispatch_clear_enqueuer();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这部分逻辑是将上一步返回的 <code>prev</code> 的 <code>do_next</code> 指向当前任务节点。</p><p><strong>这里入队的操作，为什么分成两部分去做呢？</strong><br>从入队宏命名上，也可以看出这是 <code>MPSC</code> 队列，<code>MPSC</code> 是 “Multiple Producer, Single Consumer” 的缩写，表示多生产者单消费者队列。这是一种并发数据结构，允许多个生产者线程向队列中添加数据，而只有一个消费者线程从队列中提取数据。</p><p><code>MPSC</code> 队列的特性：</p><ul><li><strong>多生产者</strong><ul><li>多个生产者线程可以同时向队列中添加数据。这需要在并发环境下确保数据的一致性和正确性。</li></ul></li><li><strong>单消费者</strong><ul><li>只有一个消费者线程从队列中提取数据。这简化了消费者端的同步问题，因为不需要处理多个消费者之间的竞争。</li></ul></li></ul><p><code>os_mpsc_push_update_tail</code> 和 <code>os_mpsc_push_update_prev</code> 是配合使用的，它们共同完成了将新节点添加到多生产者单消费者（<code>MPSC</code>）队列的操作。这两个宏的作用：</p><ul><li><code>os_mpsc_push_update_tail</code><ul><li>这个函数主要负责更新队列的尾指针。</li><li>它将新节点添加到队列的末尾，并返回之前的尾节点。</li><li>但是，它并不会更新之前尾节点的 <code>do_next</code> 指针。</li></ul></li><li><code>os_mpsc_push_update_prev</code><ul><li>这个函数负责更新前一个节点（之前的尾节点）的 <code>do_next</code> 指针，使其指向新节点。<br><img src="/images/lix_blog_227.png"></li></ul></li></ul><p>将一个复杂的原子操作（同时更新尾指针和前一个节点的 do_next 指针）分解为两个简单的原子操作。简单的原子操作通常比复杂的原子操作更高效，尤其是在高并发情况下。</p><p>从这里也可以看出，管理任务的队列 <code>dispatch_lane_t</code>，是使用单向链表实现的。</p><p>总结 <code>_dispatch_lane_push</code> 函数核心逻辑：</p><ul><li>将任务作为节点添加到队列的尾部，并将 <code>dq_items_tail</code> 指向这个新节点（<code>continuation</code>），并返回 <code>prev</code>（之前的尾部节点）。</li><li>其他关键参数配置。</li><li><code>prev</code> 的 <code>do_next</code> 指向当前任务节点。</li><li>调用 <code>dx_wakeup</code> 唤醒队列。</li></ul><p>其中，<code>dx_wakeup</code> 宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> dx_wakeup(x, y, z) dx_vtable(x)-&gt;dq_wakeup(x, y, z)</span></span><br></pre></td></tr></table></figure><p>所以对于串行队列，这里实际调用的是 <code>_dispatch_lane_wakeup</code> 函数</p><h4 id="（2）-dispatch-lane-wakeup"><a href="#（2）-dispatch-lane-wakeup" class="headerlink" title="（2）_dispatch_lane_wakeup"></a>（2）_dispatch_lane_wakeup</h4><p><code>_dispatch_lane_wakeup</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_queue_wakeup(<span class="type">dispatch_queue_class_t</span> dqu, <span class="type">dispatch_qos_t</span> qos,</span><br><span class="line">        <span class="type">dispatch_wakeup_flags_t</span> flags, <span class="type">dispatch_queue_wakeup_target_t</span> target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line">    <span class="type">uint64_t</span> old_state, new_state, enqueue = DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">    <span class="comment">// 确保目标不是等待事件状态</span></span><br><span class="line">    dispatch_assert(target != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有目标且不消耗引用计数,增加引用计数并设置消耗标志</span></span><br><span class="line">    <span class="keyword">if</span> (target &amp;&amp; !(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">        _dispatch_retain_2(dq);</span><br><span class="line">        flags |= DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理屏障完成的情况</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; DISPATCH_WAKEUP_BARRIER_COMPLETE)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         _dispatch_lane_class_barrier_complete() 处理常规队列和源需要评估的内容，但前者可能有同步切换需要执行，这是 _dispatch_lane_class_barrier_complete()，不处理的，只有 _dispatch_lane_barrier_complete() 处理。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         _dispatch_lane_wakeup() 是为普通队列调用 _dispatch_lane_barrier_complete() 的函数，这里只针对非队列类型。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断言确保当前对象是源类型</span></span><br><span class="line">        dispatch_assert(dx_metatype(dq) == _DISPATCH_SOURCE_TYPE);</span><br><span class="line">        <span class="comment">// 获取唤醒的 QoS</span></span><br><span class="line">        qos = _dispatch_queue_wakeup_qos(dq, qos);</span><br><span class="line">        <span class="comment">// 调用 _dispatch_lane_class_barrier_complete 处理屏障完成</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_lane_class_barrier_complete(upcast(dq)._dl, qos,</span><br><span class="line">                flags, target, DISPATCH_QUEUE_SERIAL_DRAIN_OWNED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理有目标的情况</span></span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        <span class="comment">// 如果目标是管理队列，设置相应的入队标志</span></span><br><span class="line">        <span class="keyword">if</span> (target == DISPATCH_QUEUE_WAKEUP_MGR) &#123;</span><br><span class="line">            enqueue = DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取唤醒的 QoS</span></span><br><span class="line">        qos = _dispatch_queue_wakeup_qos(dq, qos);</span><br><span class="line">        <span class="comment">// 原子地更新队列状态</span></span><br><span class="line">        os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, &#123;</span><br><span class="line">            <span class="comment">// 合并新的 QoS 到状态中</span></span><br><span class="line">            new_state = _dq_state_merge_qos(old_state, qos);</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; DISPATCH_WAKEUP_CLEAR_ACTIVATING) &#123;</span><br><span class="line">                <span class="comment">// 当事件正在被传递到源，因为其 unote 在 ACTIVATING 状态有机会被清除之前就被注册了，我们不希望唤醒失败，这可能导致优先级反转。相反，允许这些唤醒完成挂起的激活。</span></span><br><span class="line">                <span class="keyword">if</span> (_dq_state_is_activating(old_state)) &#123;</span><br><span class="line">                    new_state &amp;= ~DISPATCH_QUEUE_ACTIVATING;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             检查是否需要设置入队标志</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             _dq_state_is_suspended:</span></span><br><span class="line"><span class="comment">             用于判断队列是否处于挂起状态。</span></span><br><span class="line"><span class="comment">             通过检查 DISPATCH_QUEUE_SUSPEND_BITS_MASK 位是否被设置来确定。</span></span><br><span class="line"><span class="comment">             挂起状态通常表示队列暂时不能处理任务。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             _dq_state_is_enqueued:</span></span><br><span class="line"><span class="comment">             用于判断队列是否已被入队。</span></span><br><span class="line"><span class="comment">             检查 DISPATCH_QUEUE_ENQUEUED 或 DISPATCH_QUEUE_ENQUEUED_ON_MGR 位是否被设置。</span></span><br><span class="line"><span class="comment">             入队状态表示队列已被调度，等待执行。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             _dq_state_drain_locked:</span></span><br><span class="line"><span class="comment">             用于判断队列是否被锁定（正在被某个线程处理）。</span></span><br><span class="line"><span class="comment">             检查 DISPATCH_QUEUE_DRAIN_OWNER_MASK 位是否被设置。</span></span><br><span class="line"><span class="comment">             锁定状态表示队列当前正在被某个线程独占处理，其他线程需等待。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (likely(!_dq_state_is_suspended(new_state) &amp;&amp;</span><br><span class="line">                    !_dq_state_is_enqueued(old_state) &amp;&amp;</span><br><span class="line">                    (!_dq_state_drain_locked(old_state) ||</span><br><span class="line">                    enqueue != DISPATCH_QUEUE_ENQUEUED_ON_MGR))) &#123;</span><br><span class="line">                <span class="comment">// 更新 new_state</span></span><br><span class="line">                new_state |= enqueue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; DISPATCH_WAKEUP_MAKE_DIRTY) &#123;</span><br><span class="line">                <span class="comment">// 更新 new_state</span></span><br><span class="line">                new_state |= DISPATCH_QUEUE_DIRTY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (new_state == old_state) &#123;</span><br><span class="line">                <span class="comment">// 状态没有变化，放弃循环</span></span><br><span class="line">                os_atomic_rmw_loop_give_up(<span class="keyword">goto</span> done);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qos) &#123;</span><br><span class="line">        <span class="comment">// 有人试图覆盖队列的最后一个工作项</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原子地更新队列状态</span></span><br><span class="line">        os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, &#123;</span><br><span class="line">            <span class="comment">// 避免在我们能应用覆盖之前项目被排空导致的虚假覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (!_dq_state_drain_locked(old_state) &amp;&amp;</span><br><span class="line">                !_dq_state_is_enqueued(old_state)) &#123;</span><br><span class="line">                os_atomic_rmw_loop_give_up(<span class="keyword">goto</span> done);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 合并新的 QoS 到状态中</span></span><br><span class="line">            new_state = _dq_state_merge_qos(old_state, qos);</span><br><span class="line">            <span class="keyword">if</span> (_dq_state_is_base_wlh(old_state) &amp;&amp;</span><br><span class="line">                    !_dq_state_is_suspended(old_state) &amp;&amp;</span><br><span class="line">                    <span class="comment">/* &lt;rdar://problem/63179930&gt; */</span></span><br><span class="line">                    !_dq_state_is_enqueued_on_manager(old_state)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 始终为层级结构中的所有队列上的异步入队操作设置已入队位 (rdar://62447289)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                 场景：</span></span><br><span class="line"><span class="comment">                 - Mach 通道 DM</span></span><br><span class="line"><span class="comment">                 - 目标是 TQ</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                 线程 1：</span></span><br><span class="line"><span class="comment">                 - 持有 (TQ) 的锁，无争用同步</span></span><br><span class="line"><span class="comment">                 - 在 DM 上以低 QoS 触发唤醒，导致其具有：</span></span><br><span class="line"><span class="comment">                   max_qos = UT，已入队 = 1</span></span><br><span class="line"><span class="comment">                 - DM 到 TQ 的入队操作尚未发生。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                 线程 2：</span></span><br><span class="line"><span class="comment">                 - 一个传入的 IN IPC 正在服务线程上合并</span></span><br><span class="line"><span class="comment">                 - DM 的 QoS 为 UT，已入队 = 1，没有进一步的入队操作，</span></span><br><span class="line"><span class="comment">                   但我们需要一个额外的覆盖，并通过这段代码来处理 TQ。</span></span><br><span class="line"><span class="comment">                 - 这导致 TQ 被“暂存”，这需要设置已入队位，否则 try_lock_wlh()</span></span><br><span class="line"><span class="comment">                   会报错，并且唤醒引用计数会不正确。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                new_state |= enqueue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (new_state == old_state) &#123;</span><br><span class="line">                <span class="comment">// 如果状态没有变化，放弃循环</span></span><br><span class="line">                os_atomic_rmw_loop_give_up(<span class="keyword">goto</span> done);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        target = DISPATCH_QUEUE_WAKEUP_TARGET;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HAVE_PTHREAD_WORKQUEUE_QOS</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有 QoS 和 target，直接完成</span></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     old_state ^ new_state 对旧状态和新状态进行异或操作，得到两者之间发生变化的位。</span></span><br><span class="line"><span class="comment">     &amp; enqueue 将异或结果与入队标志进行按位与操作，检查入队标志位是否发生了变化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (likely((old_state ^ new_state) &amp; enqueue)) &#123;</span><br><span class="line">        <span class="type">dispatch_queue_t</span> tq;</span><br><span class="line">        <span class="keyword">if</span> (target == DISPATCH_QUEUE_WAKEUP_TARGET) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             上面的 rmw_loop 没有获取屏障，因为队列的最后一个块异步到该队列并不是一个不常见的模式，在这种情况下，获取屏障将完全无用。</span></span><br><span class="line"><span class="comment">             因此，使用依赖顺序来读取 targetq 指针。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            os_atomic_thread_fence(dependency);</span><br><span class="line">            tq = os_atomic_load_with_dependency_on2o(dq, do_targetq,</span><br><span class="line">                    (<span class="type">long</span>)new_state);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tq = target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 断言确保新状态已入队</span></span><br><span class="line">        dispatch_assert(_dq_state_is_enqueued(new_state));</span><br><span class="line">        <span class="comment">// 将队列推送到目标队列</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_push_queue(tq, dq, new_state);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">    <span class="comment">// 检查是否需要处理 QoS 覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely((old_state ^ new_state) &amp; DISPATCH_QUEUE_MAX_QOS_MASK)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_dq_state_should_override(new_state)) &#123;</span><br><span class="line">            <span class="comment">// 如果需要覆盖，调用相应的函数处理</span></span><br><span class="line">            <span class="keyword">return</span> _dispatch_queue_wakeup_with_override(dq, new_state,</span><br><span class="line">                    flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HAVE_PTHREAD_WORKQUEUE_QOS</span></span></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// 如果设置了消耗标志，释放引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (likely(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_release_2_tailcall(dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码进行精简，最终会走该函数走进  <code>_dispatch_queue_push_queue</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_queue_wakeup(<span class="type">dispatch_queue_class_t</span> dqu, <span class="type">dispatch_qos_t</span> qos,</span><br><span class="line">        <span class="type">dispatch_wakeup_flags_t</span> flags, <span class="type">dispatch_queue_wakeup_target_t</span> target)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> old_state, new_state, enqueue = DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理有目标的情况</span></span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，这里会增加 DISPATCH_QUEUE_ENQUEUED 标志</span></span><br><span class="line">        new_state |= enqueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely((old_state ^ new_state) &amp; enqueue)) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将队列推送到目标队列</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_push_queue(tq, dq, new_state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_queue_push_queue</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_queue_push_queue(<span class="type">dispatch_queue_t</span> tq, <span class="type">dispatch_queue_class_t</span> dq,</span><br><span class="line"><span class="type">uint64_t</span> dq_state, <span class="type">dispatch_wakeup_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_assert(flags &amp; DISPATCH_EVENT_LOOP_CONSUME_2);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_USE_KEVENT_WORKLOOP</span></span><br><span class="line">    <span class="keyword">if</span> (likely(_dq_state_is_base_wlh(dq_state))) &#123;</span><br><span class="line">        _dispatch_trace_runtime_event(worker_request, dq._dq, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_event_loop_poke((<span class="type">dispatch_wlh_t</span>)dq._dq, dq_state,DISPATCH_EVENT_LOOP_CONSUME_2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DISPATCH_USE_KEVENT_WORKLOOP</span></span></span><br><span class="line">    _dispatch_trace_item_push(tq, dq);</span><br><span class="line">    <span class="keyword">return</span> dx_push(tq, dq,_dq_state_max_qos(dq_state));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据在另篇文章<a href="https://www.lixkit.com/posts/12465/">《GCD 底层原理 2 - dispatch_queue》</a> 提到的串行队列 <code>dq_state</code> 为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq_state = (DISPATCH_QUEUE_STATE_INIT_VALUE(dq_width) | DISPATCH_QUEUE_ROLE_BASE_WLH)</span><br></pre></td></tr></table></figure><p>所以这里会调用 <code>_dispatch_event_loop_poke</code> 函数，该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_event_loop_poke(<span class="type">dispatch_wlh_t</span> wlh, <span class="type">uint64_t</span> dq_state, <span class="type">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (wlh == DISPATCH_WLH_MANAGER) &#123;</span><br><span class="line">        dispatch_kevent_s ke = (dispatch_kevent_s)&#123;</span><br><span class="line">            .ident  = <span class="number">1</span>,</span><br><span class="line">            .filter = EVFILT_USER,</span><br><span class="line">            .fflags = NOTE_TRIGGER,</span><br><span class="line">            .udata = (<span class="type">dispatch_kevent_udata_t</span>)DISPATCH_WLH_MANAGER,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_kq_deferred_update(DISPATCH_WLH_ANON, &amp;ke);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wlh &amp;&amp; wlh != DISPATCH_WLH_ANON) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_USE_KEVENT_WORKLOOP</span></span><br><span class="line">        <span class="type">dispatch_queue_t</span> dq = (<span class="type">dispatch_queue_t</span>)wlh;</span><br><span class="line">        dispatch_assert(_dq_state_is_base_wlh(dq_state));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(unlikely(_dq_state_is_enqueued_on_manager(dq_state))) &#123;</span><br><span class="line">            dispatch_assert(!(flags &amp; DISPATCH_EVENT_LOOP_OVERRIDE));</span><br><span class="line">            dispatch_assert(flags &amp; DISPATCH_EVENT_LOOP_CONSUME_2);</span><br><span class="line">            _dispatch_trace_item_push(&amp;_dispatch_mgr_q, dq);</span><br><span class="line">            <span class="keyword">return</span> dx_push(_dispatch_mgr_q._as_dq, dq, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">dispatch_deferred_items_t</span> ddi = _dispatch_deferred_items_get();</span><br><span class="line">        <span class="keyword">if</span> (ddi &amp;&amp; ddi-&gt;ddi_wlh == wlh) &#123;</span><br><span class="line">            <span class="keyword">return</span> _dispatch_kevent_workloop_poke_self(ddi, dq_state, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_kevent_workloop_poke(wlh, dq_state, flags);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        (<span class="type">void</span>)dq_state; (<span class="type">void</span>)flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DISPATCH_USE_KEVENT_WORKLOOP</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    DISPATCH_INTERNAL_CRASH(wlh, <span class="string">&quot;Unsupported wlh configuration&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据函数中判断条件可知，这里会执行 <code>_dispatch_kevent_workloop_poke</code> 函数。</p><p><code>_dispatch_kevent_workloop_poke</code> 这个函数名中，有一个 <code>workloop</code>，这个 <code>workloop</code> 是什么呢？</p><p>接下来先看下什么是 <code>Workqueue</code> 与 <code>Workloop</code>。</p><h4 id="（3）Workqueue-与-Workloop"><a href="#（3）Workqueue-与-Workloop" class="headerlink" title="（3）Workqueue 与 Workloop"></a>（3）Workqueue 与 Workloop</h4><p>GCD 通过 <code>Workqueue</code> 和 <code>Workloop</code> 两种机制实现了灵活的任务管理。</p><h5 id="Workqueue"><a href="#Workqueue" class="headerlink" title="Workqueue"></a>Workqueue</h5><p><code>Workqueue</code> 是 XNU 内核提供的基于线程池的任务调度机制，旨在高效地管理并发任务。它是 GCD 的底层实现之一，能够动态调整线程池的大小以适应当前的任务负载。</p><p><strong>Workqueue 特点：</strong></p><ul><li><strong>线程池管理</strong><ul><li><code>Workqueue</code> 使用线程池来执行任务，线程可以被多个任务复用，从而减少线程创建和销毁的开销。</li></ul></li><li><strong>并发任务调度</strong><ul><li>适合处理大量并发任务，任务之间没有严格的顺序要求。</li></ul></li><li><strong>动态扩展</strong><ul><li>根据任务的数量和优先级，<code>Workqueue</code> 可以动态增加或减少线程池中的线程。</li></ul></li></ul><p>其中，线程池的管理是通过 <code>pthread_workqueue</code> 相关接口与内核进行交互的，<code>pthread_workqueue</code> 是 <code>pthread</code> 的扩展，专门用于高效的任务调度和线程管理。GCD 通过调用 <code>pthread_workqueue</code> 接口，将任务分发到内核的 <code>Workqueue</code>，内核的 <code>Workqueue</code> 接收到任务后，会从线程池中分配线程来执行任务。<br><img src="/images/lix_blog_228.png"><br><code>Workqueue</code> 在 GCD 中一个很重要的应用场景就是并发队列的异步派发，关于这一点后续内容会分析。</p><h5 id="Workloop"><a href="#Workloop" class="headerlink" title="Workloop"></a>Workloop</h5><p><code>Workloop</code> 是基于 <code>Workqueue</code> 构建的更高级抽象。<code>Workqueue</code> 提供了线程池和并发任务调度的基础设施，而 <code>Workloop</code> 在此基础上增加了任务顺序性和事件驱动支持，专注于管理任务的顺序性和事件驱动，能够更好地支持串行任务和基于事件的任务调度。</p><p>任务被提交到串行队列后，GCD 会将任务分配到 <code>Workloop</code>，<code>Workloop</code> 会按照任务的提交顺序依次执行任务。</p><p>简单总结一下：</p><ul><li><p><code>Workqueue</code></p><ul><li>基于线程池的任务调度机制，适合处理并发任务。</li><li>通过动态调整线程池的大小和优先级，最大化利用系统资源。</li><li>主要用于 GCD 的并发队列。</li></ul></li><li><p><code>Workloop</code></p><ul><li>基于事件驱动的任务调度机制，专注于任务的顺序性和上下文切换。</li><li>支持事件监听和优先级调度，适合处理串行任务和事件驱动任务。</li><li>主要用于 GCD 的串行队列。</li></ul></li></ul><h4 id="（4）-dispatch-kevent-workloop-poke"><a href="#（4）-dispatch-kevent-workloop-poke" class="headerlink" title="（4）_dispatch_kevent_workloop_poke"></a>（4）_dispatch_kevent_workloop_poke</h4><p>该函数源码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_kevent_workloop_poke(<span class="type">dispatch_wlh_t</span> wlh, <span class="type">uint64_t</span> dq_state,</span><br><span class="line">        <span class="type">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个 kevent 结构体，用于描述工作循环事件</span></span><br><span class="line">    dispatch_kevent_s ke;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> action;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言</span></span><br><span class="line">    dispatch_assert(_dq_state_is_enqueued_on_target(dq_state));</span><br><span class="line">    dispatch_assert(!_dq_state_is_enqueued_on_manager(dq_state));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据队列状态获取对应的操作类型</span></span><br><span class="line">    <span class="comment">// 该函数会根据 `dq_state` 的值，返回一个与工作循环相关的操作标志</span></span><br><span class="line">    action = _dispatch_event_loop_get_action_for_state(dq_state);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充 kevent 结构体</span></span><br><span class="line">    _dispatch_kq_fill_workloop_event(&amp;ke, action, wlh, dq_state);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 `_dispatch_kq_poll` 函数，向内核提交 kevent 并等待处理结果</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_kq_poll(wlh, &amp;ke, <span class="number">1</span>, &amp;ke, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, kev_flags)) &#123;</span><br><span class="line">        <span class="comment">// 如果 `_dispatch_kq_poll` 返回非零，表示发生错误</span></span><br><span class="line">        _dispatch_kevent_workloop_drain_error(&amp;ke, <span class="number">0</span>);</span><br><span class="line">        __builtin_unreachable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; DISPATCH_EVENT_LOOP_OVERRIDE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_release_tailcall((<span class="type">dispatch_queue_t</span>)wlh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DISPATCH_EVENT_LOOP_CONSUME_2) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_release_2_tailcall((<span class="type">dispatch_queue_t</span>)wlh);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又看到了熟悉的 <code>_dispatch_kq_poll</code> 函数，在<a href="https://www.lixkit.com/posts/42034/">《GCD 底层原理 3 - dispatch_sync》</a> 中也针对这个函数做过分析，有需要可以参考这篇文章里 <code>_dispatch_kq_poll</code> 相关内容。</p><p>该函数内部调用了 <code>_dispatch_kq_fill_workloop_event</code>，从这一点也可以看出串行队列是基于 <code>Workloop</code> 的。</p><p><code>_dispatch_kq_fill_workloop_event</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_kq_fill_workloop_event(<span class="type">dispatch_kevent_t</span> ke, <span class="type">int</span> which,</span><br><span class="line">        <span class="type">dispatch_wlh_t</span> wlh, <span class="type">uint64_t</span> dq_state)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = (<span class="type">dispatch_queue_t</span>)wlh;</span><br><span class="line">    <span class="type">dispatch_qos_t</span> qos = _dq_state_max_qos(dq_state);</span><br><span class="line">    <span class="type">pthread_priority_t</span> pp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> fflags = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint16_t</span> action = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (which) &#123;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_ASYNC:</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_ASYNC_FROM_SYNC:</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_ASYNC_QOS_UPDATE:</span><br><span class="line">        dispatch_assert(_dq_state_is_base_wlh(dq_state));</span><br><span class="line">        dispatch_assert(_dq_state_is_enqueued_on_target(dq_state));</span><br><span class="line">        action = EV_ADD | EV_ENABLE;</span><br><span class="line">        mask |= DISPATCH_QUEUE_ROLE_MASK;</span><br><span class="line">        mask |= DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">        mask |= DISPATCH_QUEUE_MAX_QOS_MASK;</span><br><span class="line">        fflags |= NOTE_WL_IGNORE_ESTALE;</span><br><span class="line">        fflags |= NOTE_WL_UPDATE_QOS;</span><br><span class="line">        <span class="keyword">if</span> (_dq_state_in_uncontended_sync(dq_state)) &#123;</span><br><span class="line">            fflags |= NOTE_WL_DISCOVER_OWNER;</span><br><span class="line">            mask |= DISPATCH_QUEUE_UNCONTENDED_SYNC;</span><br><span class="line">        &#125;</span><br><span class="line">        pp = _dispatch_kevent_workloop_priority(dq, which, qos);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_SYNC:</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_TRANSFER:</span><br><span class="line">        fflags |= NOTE_WL_IGNORE_ESTALE;</span><br><span class="line">        <span class="comment">/* FALLTHROUGH */</span></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_ASYNC_LEAVE:</span><br><span class="line">        dispatch_assert(!_dq_state_is_enqueued_on_target(dq_state));</span><br><span class="line">        action = EV_ADD | EV_DELETE | EV_ENABLE;</span><br><span class="line">        mask |= DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_RETARGET:</span><br><span class="line">        action = EV_ADD | EV_DELETE | EV_ENABLE;</span><br><span class="line">        fflags |= NOTE_WL_END_OWNERSHIP;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        DISPATCH_INTERNAL_CRASH(which, <span class="string">&quot;Invalid transition&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ke = (dispatch_kevent_s)&#123;</span><br><span class="line">        .ident  = (<span class="type">uintptr_t</span>)wlh,</span><br><span class="line">        .filter = EVFILT_WORKLOOP,</span><br><span class="line">        .flags  = action,</span><br><span class="line">        .fflags = fflags | NOTE_WL_THREAD_REQUEST,</span><br><span class="line">        .qos    = (__typeof__(ke-&gt;qos))pp,</span><br><span class="line">        .udata  = (<span class="type">uintptr_t</span>)wlh,</span><br><span class="line"></span><br><span class="line">        .ext[EV_EXTIDX_WL_ADDR]  = (<span class="type">uintptr_t</span>)&amp;dq-&gt;dq_state,</span><br><span class="line">        .ext[EV_EXTIDX_WL_MASK]  = mask,</span><br><span class="line">        .ext[EV_EXTIDX_WL_VALUE] = dq_state,</span><br><span class="line">    &#125;;</span><br><span class="line">    _dispatch_kevent_wlh_debug(_dispatch_workloop_actions[which], ke);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数最终创建的 <code>ke</code> 中有个 <code>NOTE_WL_THREAD_REQUEST</code> 配置，该配置的作用是请求内核分配一个线程去处理当前任务。</p><p>再次进入 <code>_dispatch_kq_poll</code> 这个函数，其精简后的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_dispatch_kq_poll(<span class="type">dispatch_wlh_t</span> wlh, <span class="type">dispatch_kevent_t</span> ke, <span class="type">int</span> n,</span><br><span class="line">        <span class="type">dispatch_kevent_t</span> ke_out, <span class="type">int</span> n_out, <span class="type">void</span> *buf, <span class="type">size_t</span> *avail,</span><br><span class="line">        <span class="type">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 dispatch_once_f 确保 _dispatch_kq_init 仅被执行一次</span></span><br><span class="line">    dispatch_once_f(&amp;_dispatch_kq_poll_pred, &amp;kq_initialized, _dispatch_kq_init);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(wlh == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wlh == DISPATCH_WLH_ANON) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        r = kevent_id((<span class="type">uintptr_t</span>)wlh, ke, n, ke_out, n_out, buf, avail, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分主要逻辑如下：</p><ul><li><strong>初始化，会调用一次 <code>_dispatch_kq_init</code>。</strong></li><li><strong>进行 <code>kevent_id</code> 系统调用。</strong></li></ul><p>其中，<code>_dispatch_kq_init</code> 的执行逻辑中，会调用到 <code>_dispatch_root_queues_init_once</code> 函数，执行路径如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_kq_init</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_kevent_workqueue_init</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_root_queues_init</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_root_queues_init_once</span><br></pre></td></tr></table></figure><p>精简后的 <code>_dispatch_root_queues_init_once</code> 实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queues_init_once(<span class="type">void</span> *context DISPATCH_UNUSED)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作队列配置。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pthread_workqueue_config</span> <span class="title">cfg</span> =</span> &#123;</span><br><span class="line">        .version = PTHREAD_WORKQUEUE_CONFIG_VERSION, </span><br><span class="line">        .flags = <span class="number">0</span>, </span><br><span class="line">        .workq_cb = <span class="number">0</span>, <span class="comment">// workqueue 回调函数</span></span><br><span class="line">        .kevent_cb = <span class="number">0</span>, <span class="comment">// kevent/kevent_id 事件回调函数</span></span><br><span class="line">        .workloop_cb = <span class="number">0</span>, <span class="comment">// workloop 回调函数</span></span><br><span class="line">        .queue_serialno_offs = dispatch_queue_offsets.dqo_serialnum, </span><br><span class="line">        .queue_label_offs = dispatch_queue_offsets.dqo_label, </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!_dispatch_kevent_workqueue_enabled)) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wq_supported &amp; WORKQ_FEATURE_WORKLOOP) &#123;</span><br><span class="line">        <span class="comment">// 设置各回调函数。</span></span><br><span class="line">        cfg.workq_cb = _dispatch_worker_thread2;</span><br><span class="line">        cfg.kevent_cb = (<span class="type">pthread_workqueue_function_kevent_t</span>) _dispatch_kevent_worker_thread;</span><br><span class="line">        cfg.workloop_cb = (<span class="type">pthread_workqueue_function_workloop_t</span>) _dispatch_workloop_worker_thread;</span><br><span class="line">        <span class="comment">// 调用 pthread_workqueue_setup 函数，设置工作循环。</span></span><br><span class="line">        r = pthread_workqueue_setup(&amp;cfg, <span class="keyword">sizeof</span>(cfg));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wq_supported &amp; WORKQ_FEATURE_KEVENT) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果系统不支持任何工作队列特性，触发崩溃。</span></span><br><span class="line">        DISPATCH_INTERNAL_CRASH(wq_supported, <span class="string">&quot;Missing Kevent WORKQ support&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述关键逻辑如下：</p><ul><li>配置 <code>workqueue</code> 回调函数<ul><li><code>workq_cb = _dispatch_worker_thread2</code></li></ul></li><li>配置 <code>workloop</code> 回调函数<ul><li><code>workloop_cb = _dispatch_workloop_worker_thread</code></li></ul></li><li>调用 <code>pthread_workqueue_setup</code> 进行上述配置</li></ul><p>前面已经分析过，串行队列是基于 <code>Workloop</code>，最终会执行 <code>workloop</code> 回调函数 <code>workloop_cb</code>。</p><p>当前面 <code>kevent_id</code> 系统调用执行完成后，内核会进行线程的的创建和分配。之后将会从内核态切换到用户态的 <code>start_wqthread</code> 函数，<code>start_wqthread</code> 函数中，会继续调用 <code>_pthread_wqthread</code> 函数，<code>_pthread_wqthread</code> 负责管理线程生命周期，并从工作队列中提取任务交由上面配置回调函数执行。</p><p>由于串行队列是基于 <code>Workloop</code> 的，所以 <code>_pthread_wqthread</code> 会将任务交给 <code>workloop</code> 回调函数 <code>workloop_cb</code> 执行，即 <code>_dispatch_workloop_worker_thread</code> 函数。</p><p><code>_dispatch_workloop_worker_thread</code> 函数中，会先调用 <code>_dispatch_root_queue_drain_deferred_wlh</code> 函数，再调用 <code>_dispatch_lane_invoke</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start_wqthread</span><br><span class="line">⬇️</span><br><span class="line">_pthread_wqthread</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_workloop_worker_thread</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_root_queue_drain_deferred_wlh</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_lane_invoke</span><br></pre></td></tr></table></figure><p>相关调用堆栈如下：<br><img src="/images/lix_blog_229.png"></p><h4 id="（5）-dispatch-root-queue-drain-deferred-wlh"><a href="#（5）-dispatch-root-queue-drain-deferred-wlh" class="headerlink" title="（5）_dispatch_root_queue_drain_deferred_wlh"></a>（5）_dispatch_root_queue_drain_deferred_wlh</h4><p>该函数精简后的逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queue_drain_deferred_wlh(<span class="type">dispatch_deferred_items_t</span> ddi</span><br><span class="line">DISPATCH_PERF_MON_ARGS_PROTO)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = ...;</span><br><span class="line">    dispatch_invoke_context_s dic = ...;</span><br><span class="line">    <span class="comment">// 注意这里的标志位，后续关键逻辑还会用到</span></span><br><span class="line">    <span class="type">dispatch_invoke_flags_t</span> flags = DISPATCH_INVOKE_WORKER_DRAIN |</span><br><span class="line">DISPATCH_INVOKE_REDIRECTING_DRAIN | DISPATCH_INVOKE_WLH;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取 drain 锁</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_queue_drain_try_lock_wlh(dq, &amp;dq_state)) &#123;</span><br><span class="line">        <span class="comment">// 获取 drain 锁成功，调用 _dispatch_lane_invoke</span></span><br><span class="line">        dx_invoke(dq, &amp;dic, flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中获取 <code>drain</code> 锁的的函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dispatch_queue_drain_try_lock_wlh(<span class="type">dispatch_queue_t</span> dq, <span class="type">uint64_t</span> *dq_state)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> old_state, new_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义锁定位，包含当前线程的锁值、队列宽度已满标志以及屏障操作标志</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     定义锁标志位</span></span><br><span class="line"><span class="comment">     其中，_dispatch_lock_value_for_self 会获取当前线程 tid 并：</span></span><br><span class="line"><span class="comment">     tid &amp; DLOCK_OWNER_MASK</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">uint64_t</span> lock_bits = _dispatch_lock_value_for_self() | DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子读-修改-写循环尝试更新队列状态</span></span><br><span class="line">    os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, acquire, &#123;</span><br><span class="line">        <span class="comment">// 初始化新状态为旧状态</span></span><br><span class="line">        new_state = old_state;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列处于挂起状态</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dq_state_is_suspended(old_state))) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             清除队列的入队标志</span></span><br><span class="line"><span class="comment">             清除 DISPATCH_QUEUE_ENQUEUED 标志后，调度系统会认为该队列不需要被处理，因此不会将其分配给线程或工作循环。</span></span><br><span class="line"><span class="comment">             这通常用于暂停队列的执行，直到队列被显式恢复（resume）。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            new_state &amp;= ~DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列已经被锁定</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(_dq_state_drain_locked(old_state))) &#123;</span><br><span class="line">            <span class="comment">// 如果队列处于非争用的同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (_dq_state_in_uncontended_sync(old_state)) &#123;</span><br><span class="line">                <span class="comment">// 设置接收到同步等待的标志</span></span><br><span class="line">                new_state |= DISPATCH_QUEUE_RECEIVED_SYNC_WAIT;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则放弃更新并退出循环</span></span><br><span class="line">                os_atomic_rmw_loop_give_up(<span class="keyword">break</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列未被锁定且未挂起</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 增加标志位</span></span><br><span class="line">            new_state &amp;= DISPATCH_QUEUE_DRAIN_PRESERVED_BITS_MASK;</span><br><span class="line">            new_state |= lock_bits;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查旧状态是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!_dq_state_is_base_wlh(old_state) || !_dq_state_is_enqueued_on_target(old_state) || _dq_state_is_enqueued_on_manager(old_state))) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_SIZEOF_PTR == 4</span></span><br><span class="line">        <span class="comment">// 如果是 32 位架构，右移 32 位以获取高位状态</span></span><br><span class="line">        old_state &gt;&gt;= <span class="number">32</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 如果状态无效，触发内部崩溃并记录状态</span></span><br><span class="line">        DISPATCH_INTERNAL_CRASH(old_state, <span class="string">&quot;Invalid wlh state&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入了 dq_state 指针，则更新其值为新状态</span></span><br><span class="line">    <span class="keyword">if</span> (dq_state) *dq_state = new_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     _dispatch_queue_drain_try_unlock 会清除的标志位：</span></span><br><span class="line"><span class="comment">     - DLOCK_OWNER_MASK：会使下面 _dq_state_drain_locked(old_state) 返回 false</span></span><br><span class="line"><span class="comment">     - DISPATCH_QUEUE_RECEIVED_OVERRIDE</span></span><br><span class="line"><span class="comment">     - DISPATCH_QUEUE_RECEIVED_SYNC_WAIT</span></span><br><span class="line"><span class="comment">     - DLOCK_FAILED_TRYLOCK_BIT</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回队列是否未挂起且未被锁定</span></span><br><span class="line">    <span class="keyword">return</span> !_dq_state_is_suspended(old_state) &amp;&amp; !_dq_state_drain_locked(old_state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述获取 <code>drain</code> 锁的主要逻辑如下：</p><ul><li>如果队列未被挂起，并且未被锁定，可以获取锁，返回值为 <code>true</code>。<ul><li>此时会同时设置一系列标志位 <code>lock_bits</code>：<ul><li><code>tid &amp; DLOCK_OWNER_MASK</code><ul><li>设置了该标志位后，<code>_dq_state_drain_locked</code> 会返回 true</li></ul></li><li><code>DISPATCH_QUEUE_WIDTH_FULL_BIT</code></li><li><code>DISPATCH_QUEUE_IN_BARRIER</code></li></ul></li></ul></li><li>如果队列被挂起，或者已被锁定，无法获取锁，返回值为 <code>false</code>。</li></ul><p>其中，函数的返回值是队列是否未挂起且未被锁定，上面已经提到，是否被锁定，取决于是否设置了 <code>tid &amp; DLOCK_OWNER_MASK</code> 标志位。在后续调用的 <code>_dispatch_queue_drain_try_unlock</code> 函数(后面分析会提到)中，会清除锁定标志位，使队列重新变成未锁定状态。</p><p>而当我们显示调用了 GCD 的 <code>dispatch_suspend</code> 时候，会使队列变成挂起状态。<code>dispatch_suspend</code> 不是本次分析的重点，所以在获取 <code>drain</code> 锁的逻辑里，我们只需要关注队列是否被锁定即可。</p><p>所以，<code>_dispatch_root_queue_drain_deferred_wlh</code> 函数核心逻辑是先尝试获取锁，如果获取成功，则调用 <code>dx_invoke</code> 开始执行任务。如果获取锁失败，代表当前串行队列中的任务正在其他线程被执行。<br>根据 <code>dx_invoke</code> 宏的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> dx_invoke(x, y, z) dx_vtable(x)-&gt;do_invoke(x, y, z)</span></span><br></pre></td></tr></table></figure><p>结合前面提到的串行队列虚表可知，这里实际是调用 <code>_dispatch_lane_invoke</code> 函数。</p><h4 id="（6）-dispatch-lane-invoke"><a href="#（6）-dispatch-lane-invoke" class="headerlink" title="（6）_dispatch_lane_invoke"></a>（6）_dispatch_lane_invoke</h4><p><code>_dispatch_lane_invoke</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_lane_invoke(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_invoke_context_t</span> dic,</span><br><span class="line"><span class="type">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注意这里的第 4 个参数 invoke 传的是 _dispatch_lane_invoke2</span></span><br><span class="line">    _dispatch_queue_class_invoke(dq, dic, flags, <span class="number">0</span>, _dispatch_lane_invoke2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_queue_class_invoke(<span class="type">dispatch_queue_class_t</span> dqu,</span><br><span class="line"><span class="type">dispatch_invoke_context_t</span> dic, <span class="type">dispatch_invoke_flags_t</span> flags,</span><br><span class="line"><span class="type">dispatch_invoke_flags_t</span> const_restrict_flags,</span><br><span class="line"><span class="type">_dispatch_queue_class_invoke_handler_t</span> invoke)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     对于串行队列，从 _dispatch_root_queue_drain_deferred_wlh 走进来的时候传了 DISPATCH_INVOKE_WLH</span></span><br><span class="line"><span class="comment">     所以，不会走到 _dispatch_queue_drain_try_lock</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (likely(flags &amp; DISPATCH_INVOKE_WLH)) &#123;</span><br><span class="line">        <span class="comment">// 标记队列为已拥有并已入队</span></span><br><span class="line">        owned = DISPATCH_QUEUE_SERIAL_DRAIN_OWNED | DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试获取队列的 drain 锁，串行队列因为传了 DISPATCH_INVOKE_WLH 参数，所以不会走到这里</span></span><br><span class="line">        owned = _dispatch_queue_drain_try_lock(dq, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果成功获取了队列的 drain 锁</span></span><br><span class="line">    <span class="keyword">if</span> (likely(owned)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        <span class="comment">// invoke 传的是 _dispatch_lane_invoke2，所以这里执行的实际是 _dispatch_lane_invoke2 函数</span></span><br><span class="line">        tq = invoke(dq, dic, flags, &amp;owned);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果目标队列需要重新入队</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(tq != DISPATCH_QUEUE_WAKEUP_NONE &amp;&amp; tq != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解锁，这里调用了 _dispatch_queue_drain_try_unlock 函数，使其他线程可以重新获取 drain 锁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_dispatch_queue_drain_try_unlock(dq, owned, tq == DISPATCH_QUEUE_WAKEUP_NONE)) &#123;</span><br><span class="line">            <span class="comment">// 解锁失败 ......</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果目标队列不为空</span></span><br><span class="line">    <span class="keyword">if</span> (tq) &#123;</span><br><span class="line">        <span class="comment">// 完成队列的调用并返回</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_invoke_finish(dq, dic, tq, owned);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 否则，释放队列并返回</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_release_2_tailcall(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述主要逻辑如下：</p><ul><li>调用 <code>_dispatch_lane_invoke2</code> 函数执行任务。</li><li>调用 <code>_dispatch_queue_drain_try_unlock</code> 解锁。<ul><li>这里解锁后，会使下次调用 <code>_dispatch_root_queue_drain_deferred_wlh</code> 时可以成功获取到 <code>drain</code> 解锁。</li></ul></li></ul><p>接下来看下 <code>_dispatch_lane_invoke2</code> 函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_queue_wakeup_target_t</span></span><br><span class="line">_dispatch_lane_invoke2(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_invoke_context_t</span> dic,</span><br><span class="line"><span class="type">dispatch_invoke_flags_t</span> flags, <span class="type">uint64_t</span> *owned)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_queue_t</span> otq = dq-&gt;do_targetq;</span><br><span class="line">    <span class="type">dispatch_queue_t</span> cq = _dispatch_queue_get_current();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(cq != otq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> otq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_width == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_lane_serial_drain(dq, dic, flags, owned);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_lane_concurrent_drain(dq, dic, flags, owned);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前的文章里已经提到，串行队列的 <code>dq_width</code> 为 <code>1</code>，所以这里会继续调用 <code>_dispatch_lane_serial_drain</code> 函数。</p><h4 id="（7）-dispatch-lane-serial-drain"><a href="#（7）-dispatch-lane-serial-drain" class="headerlink" title="（7）_dispatch_lane_serial_drain"></a>（7）_dispatch_lane_serial_drain</h4><p><code>_dispatch_lane_serial_drain</code> 函数 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_wakeup_target_t</span></span><br><span class="line">_dispatch_lane_serial_drain(<span class="type">dispatch_lane_class_t</span> dqu,</span><br><span class="line"><span class="type">dispatch_invoke_context_t</span> dic, <span class="type">dispatch_invoke_flags_t</span> flags,</span><br><span class="line"><span class="type">uint64_t</span> *owned)</span><br><span class="line">&#123;</span><br><span class="line">    flags &amp;= ~(<span class="type">dispatch_invoke_flags_t</span>)DISPATCH_INVOKE_REDIRECTING_DRAIN;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_lane_drain(dqu._dl, dic, flags, owned, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里最继续执行 <code>_dispatch_lane_drain</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列的处理分为两种类型（串行/并发）和两种模式（重定向或非重定向）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 串行</span></span><br><span class="line"><span class="comment"> * ~~~~~~</span></span><br><span class="line"><span class="comment"> * 串行处理适用于串行队列（宽度 == 1）。它不支持重定向模式（因为没有意义），并将所有的任务视为屏障任务。</span></span><br><span class="line"><span class="comment"> * 在串行模式下，记录操作非常少，大部分循环都被优化掉了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当队列的宽度增长到大于 1 时，串行处理会停止。</span></span><br><span class="line"><span class="comment"> * 通过串行处理可以防止任何递归的处理被重定向。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 并发</span></span><br><span class="line"><span class="comment"> * ~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> * 在非重定向模式下（即目标队列之一是串行队列），非屏障任务和屏障任务都会在处理线程的上下文中运行。</span></span><br><span class="line"><span class="comment"> * 即使是较慢的非屏障任务也会被全部标记，以便它们可以向 `dispatch_sync()` 迈进，从而将它们全部串行化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在重定向模式下，非屏障任务会被向下重定向。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当队列的宽度变为 1 时，并发处理会停止，从而队列处理切换到更高效的串行模式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="type">static</span> <span class="type">dispatch_queue_wakeup_target_t</span></span><br><span class="line">_dispatch_lane_drain(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_invoke_context_t</span> dic,</span><br><span class="line">        <span class="type">dispatch_invoke_flags_t</span> flags, <span class="type">uint64_t</span> *owned_ptr, <span class="type">bool</span> serial_drain)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取队列的目标队列（通常是父队列）</span></span><br><span class="line">    <span class="type">dispatch_queue_t</span> orig_tq = dq-&gt;do_targetq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程帧，用于保存当前线程的上下文信息</span></span><br><span class="line">    dispatch_thread_frame_s dtf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义当前任务和下一个任务的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dc</span> =</span> <span class="literal">NULL</span>, *next_dc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义队列状态和拥有的宽度</span></span><br><span class="line">    <span class="type">uint64_t</span> dq_state, owned = *owned_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空（没有任务），直接返回 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!dq-&gt;dq_items_tail)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推入线程帧，保存当前队列的上下文</span></span><br><span class="line">    _dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是串行模式或当前任务是屏障任务</span></span><br><span class="line">    <span class="keyword">if</span> (serial_drain || _dq_state_is_in_barrier(owned)) &#123;</span><br><span class="line">        <span class="comment">// 设置拥有的状态为屏障模式</span></span><br><span class="line">        owned = DISPATCH_QUEUE_IN_BARRIER;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，仅保留队列宽度相关的状态</span></span><br><span class="line">        owned &amp;= DISPATCH_QUEUE_WIDTH_MASK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的头部任务</span></span><br><span class="line">    dc = _dispatch_queue_get_head(dq);</span><br><span class="line">    <span class="keyword">goto</span> first_iteration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环，用于处理队列中的任务</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        dispatch_assert(dic-&gt;dic_barrier_waiter == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前任务设置为下一个任务</span></span><br><span class="line">        dc = next_dc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前任务为空</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!dc)) &#123;</span><br><span class="line">            <span class="comment">// 如果队列为空，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (!dq-&gt;dq_items_tail) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，获取队列的头部任务</span></span><br><span class="line">            dc = _dispatch_queue_get_head(dq);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要返回内核，执行相关操作</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_needs_to_return_to_kernel())) &#123;</span><br><span class="line">            _dispatch_return_to_kernel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果串行模式与队列宽度不匹配，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(serial_drain != (dq-&gt;dq_width == <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要缩小队列宽度，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!(flags &amp; DISPATCH_INVOKE_DISABLED_NARROWING) &amp;&amp;</span><br><span class="line">                _dispatch_queue_drain_should_narrow(dic))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是工作循环模式，检查队列的最大 QoS</span></span><br><span class="line">        <span class="keyword">if</span> (likely(flags &amp; DISPATCH_INVOKE_WORKLOOP_DRAIN)) &#123;</span><br><span class="line">            <span class="type">dispatch_workloop_t</span> dwl = (<span class="type">dispatch_workloop_t</span>)_dispatch_get_wlh();</span><br><span class="line">            <span class="keyword">if</span> (unlikely(_dispatch_queue_max_qos(dwl) &gt; dwl-&gt;dwl_drained_qos)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">first_iteration:</span><br><span class="line">        <span class="comment">// 加载队列的当前状态</span></span><br><span class="line">        dq_state = os_atomic_load(&amp;dq-&gt;dq_state, relaxed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列被挂起，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dq_state_is_suspended(dq_state))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果目标队列发生变化，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(orig_tq != dq-&gt;do_targetq)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是串行模式或当前任务是屏障任务</span></span><br><span class="line">        <span class="keyword">if</span> (serial_drain || _dispatch_object_is_barrier(dc)) &#123;</span><br><span class="line">            <span class="comment">// 如果不是串行模式且未拥有屏障状态，尝试升级为屏障模式</span></span><br><span class="line">            <span class="keyword">if</span> (!serial_drain &amp;&amp; owned != DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!_dispatch_queue_try_upgrade_full_width(dq, owned)) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> out_with_no_width;</span><br><span class="line">                &#125;</span><br><span class="line">                owned = DISPATCH_QUEUE_IN_BARRIER;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前任务是同步等待者且未绑定线程，设置屏障等待者</span></span><br><span class="line">            <span class="keyword">if</span> (_dispatch_object_is_sync_waiter(dc) &amp;&amp;</span><br><span class="line">                    !(flags &amp; DISPATCH_INVOKE_THREAD_BOUND)) &#123;</span><br><span class="line">                dic-&gt;dic_barrier_waiter = dc;</span><br><span class="line">                <span class="keyword">goto</span> out_with_barrier_waiter;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 弹出队列头部任务</span></span><br><span class="line">            next_dc = _dispatch_queue_pop_head(dq, dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前状态是屏障模式，释放屏障状态并更新宽度</span></span><br><span class="line">            <span class="keyword">if</span> (owned == DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">                os_atomic_xor2o(dq, dq_state, owned, release);</span><br><span class="line">                owned = dq-&gt;dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(owned == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果未拥有宽度，尝试获取宽度</span></span><br><span class="line">                <span class="keyword">if</span> (_dispatch_object_is_waiter(dc)) &#123;</span><br><span class="line">                    _dispatch_queue_reserve_sync_width(dq);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_dispatch_queue_try_acquire_async(dq)) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> out_with_no_width;</span><br><span class="line">                &#125;</span><br><span class="line">                owned = DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 弹出队列头部任务</span></span><br><span class="line">            next_dc = _dispatch_queue_pop_head(dq, dc);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前任务是等待者，处理等待者逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (_dispatch_object_is_waiter(dc)) &#123;</span><br><span class="line">                owned -= DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">                _dispatch_non_barrier_waiter_redirect_or_wake(dq, dc);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是重定向模式，处理重定向逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; DISPATCH_INVOKE_REDIRECTING_DRAIN) &#123;</span><br><span class="line">                owned -= DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">                _dispatch_continuation_redirect_push(dq, dc,</span><br><span class="line">                        _dispatch_queue_max_qos(dq));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行当前任务</span></span><br><span class="line">        _dispatch_continuation_pop_inline(dc, dic, flags, dq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前状态是屏障模式，更新宽度</span></span><br><span class="line">    <span class="keyword">if</span> (owned == DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">        owned += dq-&gt;dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有未完成的任务，调整拥有的宽度</span></span><br><span class="line">    <span class="keyword">if</span> (dc) &#123;</span><br><span class="line">        owned = _dispatch_queue_adjust_owned(dq, owned, dc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新拥有的状态</span></span><br><span class="line">    *owned_ptr &amp;= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">    *owned_ptr |= owned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出线程帧，恢复上下文</span></span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有任务，返回目标队列；否则返回 NULL</span></span><br><span class="line">    <span class="keyword">return</span> dc ? dq-&gt;do_targetq : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">out_with_no_width:</span><br><span class="line">    <span class="comment">// 如果没有宽度，更新状态并弹出线程帧</span></span><br><span class="line">    *owned_ptr &amp;= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">    <span class="keyword">return</span> DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT;</span><br><span class="line"></span><br><span class="line">out_with_barrier_waiter:</span><br><span class="line">    <span class="comment">// 如果不允许同步等待者，触发崩溃</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; DISPATCH_INVOKE_DISALLOW_SYNC_WAITERS)) &#123;</span><br><span class="line">        DISPATCH_INTERNAL_CRASH(<span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;Deferred continuation on source, mach channel or mgr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出线程帧，恢复上下文</span></span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标队列</span></span><br><span class="line">    <span class="keyword">return</span> dq-&gt;do_targetq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_lane_drain</code> 函数主要逻辑就是按照先进先出的顺序，逐个执行串行队列中的各个任务。</p><h3 id="2、提交到并发队列"><a href="#2、提交到并发队列" class="headerlink" title="2、提交到并发队列"></a>2、提交到并发队列</h3><p>再回头看下 <code>_dispatch_continuation_async</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_async(<span class="type">dispatch_queue_class_t</span> dqu,</span><br><span class="line">        <span class="type">dispatch_continuation_t</span> dc, <span class="type">dispatch_qos_t</span> qos, <span class="type">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dx_push(dqu._dq, dc, qos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面已经提到，对于并发队列，<code>dx_push</code> 实际调用的是 <code>_dispatch_lane_concurrent_push</code> 函数。</p><h4 id="（1）-dispatch-lane-concurrent-push"><a href="#（1）-dispatch-lane-concurrent-push" class="headerlink" title="（1）_dispatch_lane_concurrent_push"></a>（1）_dispatch_lane_concurrent_push</h4><p>该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_lane_concurrent_push(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="type">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     模拟器的回退路径，用于协作队列</span></span><br><span class="line"><span class="comment">     检查队列是否为协作队列，且任务对象是否支持协作队列</span></span><br><span class="line"><span class="comment">     如果不支持，则触发崩溃，提示不支持将任务目标设置为协作根队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_queue_is_cooperative(dq) &amp;&amp;</span><br><span class="line">            !_dispatch_object_supported_on_cooperative_queue(dou))) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(dou._do,</span><br><span class="line">            <span class="string">&quot;Cannot target the cooperative root queue - not implemented&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;rdar://problem/24738102&amp;24743140&gt; 保留非屏障宽度</span></span><br><span class="line">    <span class="comment">// 如果仅设置了 ENQUEUED 位（而不是屏障宽度等效位），则不会失败</span></span><br><span class="line">    <span class="comment">// 因此需要检查当前线程是否在此调用之前已将任务入队，否则可能会破坏任务的顺序</span></span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_items_tail == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            !_dispatch_object_is_waiter(dou) &amp;&amp; <span class="comment">// 检查任务是否为等待者</span></span><br><span class="line">            !_dispatch_object_is_barrier(dou) &amp;&amp; <span class="comment">// 检查任务是否为屏障任务</span></span><br><span class="line">            _dispatch_queue_try_acquire_async(dq)) &#123; <span class="comment">// 尝试异步获取队列</span></span><br><span class="line">        <span class="comment">// 将任务重定向推送到队列中</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_redirect_push(dq, dou, qos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 _dispatch_lane_push</span></span><br><span class="line">    _dispatch_lane_push(dq, dou, qos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数的 <code>if</code> 判断条件里，<code>dq-&gt;dq_items_tail</code> 一定是 <code>NULL</code>（具体原因后续会分析）。并且根据其他几个判断条件可知，这里会调用 <code>_dispatch_continuation_redirect_push</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_redirect_push(<span class="type">dispatch_lane_t</span> dl,</span><br><span class="line">        <span class="type">dispatch_object_t</span> dou, <span class="type">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = dl-&gt;do_targetq;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意，这里传入的 dq 是 do_targetq，不是当前 dp，do_targetq 是从根队列数组 _dispatch_root_queues 中取出的对应的根队列（root queue）</span></span><br><span class="line">    dx_push(dq, dou, qos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这里又调用了熟悉的 <code>dx_push</code> 宏，但是传入的并不是我们创建的并发队列，而是并发队列的 <code>do_targetq</code>。</p><p>在之前的文章<a href="https://www.lixkit.com/posts/12465/">《GCD 底层原理 2 - dispatch_queue》</a> 中已经分析了，结论是并发队列和串行队列都是从根队列数组 <code>_dispatch_root_queues</code> 中取出的对应的根队列（<code>root queue</code>）。创建并发队列时，返回的是 <code>_dispatch_root_queues</code> 数组 <code>index = 9</code> 的元素（<code>DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS</code>），即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS] = &#123;</span><br><span class="line">    DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">    .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">    .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS),</span><br><span class="line">    .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">    .dq_priority = _dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT),</span><br><span class="line">    .dq_label = <span class="string">&quot;com.apple.root.default-qos&quot;</span>,</span><br><span class="line">    .dq_serialnum = <span class="number">13</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>所以这里调用 <code>dx_push</code> 时传入的实际上是对应的 <code>root queue</code>。而对于 <code>root queue</code>，其 <code>dx_push</code> 对应的函数是 <code>_dispatch_root_queue_push</code>，所以对于后续往队列 <code>push</code> 任务，都是在对应的 <code>root queue</code> 上的，而不是在当然任务 <code>dq</code> 上的。<strong>这也是 <code>_dispatch_lane_concurrent_push</code> 里的判断条件 <code>dq-&gt;dq_items_tail</code> 为 <code>NULL</code> 的原因。</strong></p><h4 id="（2）-dispatch-root-queue-push"><a href="#（2）-dispatch-root-queue-push" class="headerlink" title="（2）_dispatch_root_queue_push"></a>（2）_dispatch_root_queue_push</h4><p>该函数精简后的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_root_queue_push(<span class="type">dispatch_queue_global_t</span> rq, <span class="type">dispatch_object_t</span> dou,</span><br><span class="line"><span class="type">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_root_queue_push_needs_override(rq, qos)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_root_queue_push_override(rq, dou, qos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_root_queue_push_inline(rq, dou, dou, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>_dispatch_root_queue_push_needs_override</code>、<code>_dispatch_root_queue_push_override</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要覆盖当前队列的优先级</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dispatch_root_queue_push_needs_override(<span class="type">dispatch_queue_global_t</span> rq,</span><br><span class="line">        <span class="type">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 外部传进来的 qos 是 dq 的，而不是 dq-&gt;do_targetq 的。</span></span><br><span class="line">    <span class="comment">// 而 rq 是  dq-&gt;do_targetq，即 root queue</span></span><br><span class="line">    <span class="type">dispatch_qos_t</span> fallback = _dispatch_priority_fallback_qos(rq-&gt;dq_priority);</span><br><span class="line">    <span class="keyword">if</span> (fallback) &#123;</span><br><span class="line">        <span class="comment">// 如果存在 QoS，且当 QoS 不等于回退  fallback，则需要覆盖</span></span><br><span class="line">        <span class="keyword">return</span> qos &amp;&amp; qos != fallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的当前 QoS</span></span><br><span class="line">    <span class="type">dispatch_qos_t</span> rqos = _dispatch_priority_qos(rq-&gt;dq_priority);</span><br><span class="line">    <span class="comment">// 如果当前 QoS 存在且小于传入的 QoS，则需要覆盖</span></span><br><span class="line">    <span class="keyword">return</span> rqos &amp;&amp; qos &gt; rqos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行优先级覆盖操作</span></span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queue_push_override(<span class="type">dispatch_queue_global_t</span> orig_rq,</span><br><span class="line">        <span class="type">dispatch_object_t</span> dou, <span class="type">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uintptr_t</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列是否设置了超额提交标志</span></span><br><span class="line">    <span class="keyword">if</span> (orig_rq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了超额提交标志，添加 DISPATCH_QUEUE_OVERCOMMIT 标志</span></span><br><span class="line">        flags |= DISPATCH_QUEUE_OVERCOMMIT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_dispatch_queue_is_cooperative(orig_rq)) &#123;</span><br><span class="line">        <span class="comment">// 如果是协作队列，添加 DISPATCH_QUEUE_COOPERATIVE 标志</span></span><br><span class="line">        flags |= DISPATCH_QUEUE_COOPERATIVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 QoS 和标志获取目标根队列</span></span><br><span class="line">    <span class="type">dispatch_queue_global_t</span> rq = _dispatch_get_root_queue(qos, flags);</span><br><span class="line">    <span class="comment">// 获取调度对象的 continuation</span></span><br><span class="line">    <span class="type">dispatch_continuation_t</span> dc = dou._dc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果调度对象是重定向类型</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_is_redirection(dc)) &#123;</span><br><span class="line">        <span class="comment">// 不需要双重包装，直接设置原始队列为函数上下文</span></span><br><span class="line">        dc-&gt;dc_func = (<span class="type">void</span> *)orig_rq;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 分配一个新的 continuation</span></span><br><span class="line">        dc = _dispatch_continuation_alloc();</span><br><span class="line">        <span class="comment">// 设置 continuation 的虚表为 OVERRIDE_OWNING 类型</span></span><br><span class="line">        dc-&gt;do_vtable = DC_VTABLE(OVERRIDE_OWNING);</span><br><span class="line">、        dc-&gt;dc_ctxt = dc;</span><br><span class="line">        dc-&gt;dc_other = orig_rq;</span><br><span class="line">        dc-&gt;dc_data = dou._do;</span><br><span class="line">        dc-&gt;dc_priority = DISPATCH_NO_PRIORITY;</span><br><span class="line">        dc-&gt;dc_voucher = DISPATCH_NO_VOUCHER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 continuation 推送到目标根队列</span></span><br><span class="line">    _dispatch_root_queue_push_inline(rq, dc, dc, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最终会调用到 <code>_dispatch_root_queue_push_inline</code> 函数。</p><h4 id="（3）-dispatch-root-queue-push-inline"><a href="#（3）-dispatch-root-queue-push-inline" class="headerlink" title="（3）_dispatch_root_queue_push_inline"></a>（3）_dispatch_root_queue_push_inline</h4><p>该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queue_push_inline(<span class="type">dispatch_queue_global_t</span> dq,</span><br><span class="line"><span class="type">dispatch_object_t</span> _head, <span class="type">dispatch_object_t</span> _tail, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">hd</span> =</span> _head._do, *tl = _tail._do;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(os_mpsc_push_list(os_mpsc(dq, dq_items), hd, tl, do_next))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_root_queue_poke_and_wakeup(dq, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其中涉及到的宏展开后实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queue_push_inline(<span class="type">dispatch_queue_global_t</span> dq,</span><br><span class="line">        <span class="type">dispatch_object_t</span> _head, <span class="type">dispatch_object_t</span> _tail, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 提取任务链表的起始和结束节点，这两个节点表示需要处理的一组任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">hd</span> =</span> _head._do, *tl = _tail._do;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个本地变量 _token 来表示队列中新的尾部元素</span></span><br><span class="line">    __typeof__(atomic_load_explicit((__typeof__(*(&amp;_os_mpsc_head(dq, dq_items))) <span class="keyword">_Atomic</span> *)(&amp;_os_mpsc_head(dq, dq_items)), memory_order_relaxed)) _token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 _tail 更新为队列的新尾部，并获取之前的尾部元素（即 _token）</span></span><br><span class="line">    _token = os_mpsc_push_update_tail((dq, dq_items), tl, do_next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将链表的头部（hd）与新尾部（tl）链接在一起</span></span><br><span class="line">    os_mpsc_push_update_prev((dq, dq_items), _token, hd, do_next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     检查如果队列在插入这个任务链前是空的，则需要分配线程去处理队列中的任务。</span></span><br><span class="line"><span class="comment">     如果 _token == NULL，说明这是个新队列首次插入任务，或者队列中的任务已被处理完。</span></span><br><span class="line"><span class="comment">     如果插入任务后，发现还没有分配线程处理这个队列中的任务，就需要分配线程去处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((_token) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_root_queue_poke_and_wakeup(dq, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又看到了前面总结过的 <code>MPSC</code> 队列操作。</p><p>总结该函数逻辑如下：</p><ul><li>通过 <code>MPSC</code> 队列操作将任务插入队列尾部。</li><li>分配线程去处理队列中的任务。<ul><li>调用 <code>_dispatch_root_queue_poke_and_wakeup</code> 函数<ul><li>传参 <code>n = 1</code></li><li>传参 <code>floor = 0</code></li></ul></li></ul></li></ul><p>其中，<code>_dispatch_root_queue_poke_and_wakeup</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_root_queue_poke_and_wakeup(<span class="type">dispatch_queue_global_t</span> dq, <span class="type">int</span> n, <span class="type">int</span> <span class="built_in">floor</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !DISPATCH_USE_INTERNAL_WORKQUEUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">    <span class="keyword">if</span> (likely(dx_type(dq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE ||</span><br><span class="line">            dx_type(dq) == DISPATCH_QUEUE_COOPERATIVE_ROOT_TYPE))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> old_pending, new_pending;</span><br><span class="line">        os_atomic_rmw_loop2o(dq, dgq_pending, old_pending, new_pending, release, &#123;</span><br><span class="line">            new_pending = old_pending ?: n;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (old_pending &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _dispatch_root_queue_debug(<span class="string">&quot;worker thread request still pending &quot;</span></span><br><span class="line">                    <span class="string">&quot;for global queue: %p&quot;</span>, dq);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !DISPATCH_USE_INTERNAL_WORKQUEUE</span></span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_root_queue_poke_slow(dq, n, <span class="built_in">floor</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要逻辑是调用 <code>_dispatch_root_queue_poke_slow</code> 函数，且第二个参数 <code>n = 1</code>。</p><h4 id="（4）-dispatch-root-queue-poke-slow"><a href="#（4）-dispatch-root-queue-poke-slow" class="headerlink" title="（4） _dispatch_root_queue_poke_slow"></a>（4） _dispatch_root_queue_poke_slow</h4><p>精简后的 <code>_dispatch_root_queue_poke_slow</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queue_poke_slow(<span class="type">dispatch_queue_global_t</span> dq, <span class="type">int</span> n, <span class="type">int</span> <span class="built_in">floor</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数 n = 1，所以 remaining = 1</span></span><br><span class="line">    <span class="type">int</span> remaining = n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    _dispatch_root_queues_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dx_type(dq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        r = _pthread_workqueue_addthreads(remaining,</span><br><span class="line">                _dispatch_priority_to_pp_prefer_fallback(dq-&gt;dq_priority));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>_dispatch_root_queues_init</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queues_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_once_f(&amp;_dispatch_root_queues_pred, <span class="literal">NULL</span>,</span><br><span class="line">_dispatch_root_queues_init_once);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又调用了 <code>_dispatch_root_queues_init_once</code> 函数，关于该函数在前面串行队列部分已经分析过，函数中关键逻辑如下：</p><ul><li>配置 <code>workqueue</code> 回调函数<ul><li><code>workq_cb = _dispatch_worker_thread2</code></li></ul></li><li>配置 <code>workloop</code> 回调函数<ul><li><code>workloop_cb = _dispatch_workloop_worker_thread</code></li></ul></li></ul><p>而且前面也已经分析过，并发队列是基于 <code>workqueue</code> 的，从 <code>_dispatch_root_queue_poke_slow</code> 函数实现也可以看到，函数逻辑中没有涉及到像串行队列那样的 <code>workloop</code> 的配置。所以在 <code>_dispatch_root_queue_poke_slow</code> 函数中，调用 <code>_pthread_workqueue_addthreads</code> 完成线程的分配之后，会执行 <code>workqueue</code> 回调函数<code> _dispatch_worker_thread2</code>。</p><p><code>_pthread_workqueue_addthreads</code> 函数有两个参数：</p><ul><li><strong>numthreads</strong><ul><li>要请求的线程数量</li></ul></li><li><strong>priority</strong><ul><li>线程优先级</li></ul></li></ul><p><font color=#ff0000>而上面调用 <code>_pthread_workqueue_addthreads</code> 函数时，传入的 <code>numthreads</code> 参数为 <code>1</code>，表示请求分配一个线程去处理任务。</font></p><p>按照经验来看，<code>dispatch_async</code> + 并发队列，是会分配多个线程去处理各个任务的。为什么这一步却只请求一个线程去处理任务呢？后面会分析原因。</p><h4 id="（5）-dispatch-worker-thread2"><a href="#（5）-dispatch-worker-thread2" class="headerlink" title="（5）_dispatch_worker_thread2"></a>（5）_dispatch_worker_thread2</h4><p>该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_worker_thread2(<span class="type">pthread_priority_t</span> pp)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="type">dispatch_queue_global_t</span> dq; <span class="comment">// 全局队列。</span></span><br><span class="line">    <span class="type">dispatch_invoke_flags_t</span> invoke_flags = <span class="number">0</span>; <span class="comment">// 调用标志初始化。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uintptr_t</span> rq_flags = <span class="number">0</span>; <span class="comment">// 队列标志初始化。</span></span><br><span class="line">    <span class="keyword">if</span> (cooperative) &#123;</span><br><span class="line">        <span class="comment">// 如果是合作线程，设置合作队列标志和调用标志。</span></span><br><span class="line">        rq_flags |= DISPATCH_QUEUE_COOPERATIVE;</span><br><span class="line">        invoke_flags |= DISPATCH_INVOKE_COOPERATIVE_DRAIN;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是超额提交线程，设置超额提交标志。</span></span><br><span class="line">        rq_flags |= (overcommit ? DISPATCH_QUEUE_OVERCOMMIT : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据优先级和标志获取对应的全局队列。</span></span><br><span class="line">    dq = _dispatch_get_root_queue(_dispatch_qos_from_pp(pp), rq_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置调用标志</span></span><br><span class="line">    invoke_flags |= DISPATCH_INVOKE_WORKER_DRAIN | DISPATCH_INVOKE_REDIRECTING_DRAIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 root queue 中提取任务并执行。</span></span><br><span class="line">    _dispatch_root_queue_drain(dq, dq-&gt;dq_priority, invoke_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数中，主要是调用了 <code>_dispatch_root_queue_drain</code> 函数去执行具体任务。</p><h4 id="（6）-dispatch-root-queue-drain"><a href="#（6）-dispatch-root-queue-drain" class="headerlink" title="（6）_dispatch_root_queue_drain"></a>（6）_dispatch_root_queue_drain</h4><p><code>_dispatch_root_queue_drain</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_root_queue_drain(<span class="type">dispatch_queue_global_t</span> dq,</span><br><span class="line">        <span class="type">dispatch_priority_t</span> pri, <span class="type">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前线程与队列关联</span></span><br><span class="line">    _dispatch_queue_set_current(dq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个指向调度对象的指针 item，用于存储从队列中弹出的任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">item</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化调度上下文 dic，用于存储调度过程中的相关信息</span></span><br><span class="line">    dispatch_invoke_context_s dic = &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环处理队列中的任务，直到队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (likely(item = _dispatch_root_queue_drain_one(dq))) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹出并执行队列中的任务</span></span><br><span class="line">        _dispatch_continuation_pop_inline(item, &amp;dic, flags, dq);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前线程与队列取消关联</span></span><br><span class="line">    _dispatch_queue_set_current(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数核心逻辑如下：</p><ul><li>将当前线程与队列关联。<ul><li>确保任务执行期间，GCD 能正确识别当前线程所属队列，防止线程池中的线程后续任务调度混乱。</li></ul></li><li>使用 <code>while</code> 循环，按照 <code>FIFO</code> 顺序取出一个任务 <code>item</code>。<ul><li>取任务调用的 <code>_dispatch_root_queue_drain_one</code> 函数。</li></ul></li><li><code>while</code> 循环中，弹出并执行的上一步取出的任务 <code>item</code>。<ul><li>调用 <code>_dispatch_continuation_pop_inline</code> 函数。</li></ul></li><li>所有任务处理完成后，将当前线程与队列取消关联。</li></ul><p>这里需要重点看下 <code>_dispatch_root_queue_drain_one</code> 函数，这是实现多线程并发执行的关键。</p><h4 id="（7）-dispatch-root-queue-drain-one"><a href="#（7）-dispatch-root-queue-drain-one" class="headerlink" title="（7）_dispatch_root_queue_drain_one"></a>（7）_dispatch_root_queue_drain_one</h4><p>该函数内部实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *</span></span><br><span class="line"><span class="class">_<span class="title">dispatch_root_queue_drain_one</span>(<span class="title">dispatch_queue_global_t</span> <span class="title">dq</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">head</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    <span class="comment">// MEDIATOR 值同时充当“锁”和信号的作用。</span></span><br><span class="line">    <span class="comment">// 将队列的头部指针交换为 DISPATCH_ROOT_QUEUE_MEDIATOR，表示当前线程正在处理队列。</span></span><br><span class="line">    head = os_atomic_xchg2o(dq, dq_items_head,</span><br><span class="line">            DISPATCH_ROOT_QUEUE_MEDIATOR, relaxed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列头部为空，检查是否与并发入队操作发生竞争。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(head == <span class="literal">NULL</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次交换 tail 指针会告诉入队线程可以安全地写入 head 指针。</span></span><br><span class="line">        <span class="comment">// 如果 CAS 操作失败，说明有并发入队操作使队列变为非空。</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!os_atomic_cmpxchg2o(dq, dq_items_head,</span><br><span class="line">                DISPATCH_ROOT_QUEUE_MEDIATOR, <span class="literal">NULL</span>, relaxed))) &#123;</span><br><span class="line">            <span class="comment">// 与并发入队线程竞争，重新尝   提取任务。</span></span><br><span class="line">            <span class="keyword">goto</span> start;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 tail 指针不为空，说明有并发入队操作尚未完成。</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(dq-&gt;dq_items_tail)) &#123; <span class="comment">// &lt;rdar://problem/14416349&gt;</span></span><br><span class="line">            <span class="comment">// head 被设置为 MEDIATOR，表示之前 head 为空，但 tail 有值。</span></span><br><span class="line">            <span class="comment">// 等待入队操作完成。</span></span><br><span class="line">            <span class="keyword">if</span> (__DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(dq,</span><br><span class="line">                    _dispatch_root_queue_head_tail_quiesced)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列仍然为空，记录调试信息并返回 NULL。</span></span><br><span class="line">        _dispatch_root_queue_debug(<span class="string">&quot;no work on global queue: %p&quot;</span>, dq);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 head 是 MEDIATOR，说明与另一个线程竞争失败。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(head == DISPATCH_ROOT_QUEUE_MEDIATOR)) &#123;</span><br><span class="line">        <span class="comment">// 等待 MEDIATOR 被清除。</span></span><br><span class="line">        <span class="keyword">if</span> (likely(__DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(dq,</span><br><span class="line">                _dispatch_root_queue_mediator_is_gone))) &#123;</span><br><span class="line">            <span class="keyword">goto</span> start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复 head 指针为正常值。</span></span><br><span class="line">    <span class="comment">// 如果 next 为空，说明当前任务可能是最后一个任务。</span></span><br><span class="line">    next = head-&gt;do_next;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!next)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将队列头部指针设置为 NULL。</span></span><br><span class="line">        os_atomic_store2o(dq, dq_items_head, <span class="literal">NULL</span>, relaxed);</span><br><span class="line">        <span class="comment">// 将 tail 指针也设置为 NULL，确保队列为空的状态一致性。</span></span><br><span class="line">        <span class="keyword">if</span> (os_atomic_cmpxchg2o(dq, dq_items_tail, head, <span class="literal">NULL</span>, release)) &#123;</span><br><span class="line">            <span class="comment">// head 和 tail 都为 NULL，队列为空。</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 CAS 失败，说明有新的任务被入队。</span></span><br><span class="line">        next = os_mpsc_get_next(head, do_next, &amp;dq-&gt;dq_items_tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新队列头部指针为下一个任务。</span></span><br><span class="line">    os_atomic_store2o(dq, dq_items_head, next, relaxed);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️ 注意，这里调用了 _dispatch_root_queue_poke 函数，内部会再次调用 _dispatch_root_queue_poke_slow</span></span><br><span class="line">    _dispatch_root_queue_poke(dq, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数核心逻辑有两部分：</p><ul><li>按照 <code>FIFO</code> 顺序取一个任务并返回，交由外面 <code>_dispatch_continuation_pop_inline</code> 函数取执行任务。</li><li>调用 <code>_dispatch_root_queue_poke</code> 函数。<ul><li>该函数内部会再次调用 <code>_dispatch_root_queue_poke_slow</code> 函数。</li></ul></li></ul><p><code>_dispatch_root_queue_poke</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_root_queue_poke(<span class="type">dispatch_queue_global_t</span> dq, <span class="type">int</span> n, <span class="type">int</span> <span class="built_in">floor</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_dispatch_queue_class_probe(dq)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !DISPATCH_USE_INTERNAL_WORKQUEUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">    <span class="keyword">if</span> (likely(dx_type(dq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE ||</span><br><span class="line">            dx_type(dq) == DISPATCH_QUEUE_COOPERATIVE_ROOT_TYPE))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!os_atomic_cmpxchg2o(dq, dgq_pending, <span class="number">0</span>, n, release))) &#123;</span><br><span class="line">            _dispatch_root_queue_debug(<span class="string">&quot;worker thread request still pending &quot;</span></span><br><span class="line">                    <span class="string">&quot;for global queue: %p&quot;</span>, dq);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !DISPATCH_USE_INTERNAL_WORKQUEUE</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用了 _dispatch_root_queue_poke_slow 函数</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_root_queue_poke_slow(dq, n, <span class="built_in">floor</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里再次调用了 <code>_dispatch_root_queue_poke_slow</code> 函数，上面已经提到 _<code>dispatch_root_queue_poke_slow</code> 会请求分配 1 个线程去执行任务。</p><p>这个“循环”的执行链路如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_root_queue_poke_slow</span><br><span class="line">⬇️</span><br><span class="line">_pthread_workqueue_addthreads // 申请分配 1 个线程去执行任务</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_worker_thread2</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_root_queue_drain // 调用 _dispatch_root_queue_drain_one 取出 1 个任务并执行</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_root_queue_drain_one</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_root_queue_poke_slow // 新一轮循环，申请 1 个线程执行 1 个任务</span><br><span class="line">⬇️</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这里就是 <code>dispatch_async</code> + 并发队列的多线程并发执行的关键逻辑了：<font color=#ff0000><strong>每次申请 <code>1</code> 个线程去执行 <code>1</code> 个任务，在从队列取任务的同时，同时去申请新的线程执行下个任务，这样就达到了多个线程并发执行任务的目的。而具体哪个任务先执行，则取决于的线程调度先后。</strong></font></p><p>这里用到了“任务窃取优化”：<br>新创建的线程立即进入 <code>_dispatch_root_queue_drain</code> 循环，尝试从队列中窃取任务执行。提高多核 CPU 利用率，减少任务排队时间。</p><h4 id="（8）-dispatch-continuation-pop-inline"><a href="#（8）-dispatch-continuation-pop-inline" class="headerlink" title="（8）_dispatch_continuation_pop_inline"></a>（8）_dispatch_continuation_pop_inline</h4><p>这里再回头简单看下上一步取出的任务，是如何执行的。执行时调用的是 <code>_dispatch_continuation_pop_inline</code> 函数，该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_pop_inline(<span class="type">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="type">dispatch_invoke_context_t</span> dic, <span class="type">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="type">dispatch_queue_class_t</span> dqu)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_pthread_root_queue_observer_hooks_t</span> observer_hooks =</span><br><span class="line">            _dispatch_get_pthread_root_queue_observer_hooks();</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_will_execute(dqu._dq);</span><br><span class="line">    flags &amp;= _DISPATCH_INVOKE_PROPAGATE_MASK;</span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dx_type(dou._do) == DISPATCH_SWIFT_JOB_TYPE) &#123;</span><br><span class="line">            dx_invoke(dou._dsjc, <span class="literal">NULL</span>,</span><br><span class="line">                    _dispatch_invoke_flags_to_swift_invoke_flags(flags));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dx_invoke(dou._dq, dic, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_continuation_invoke_inline(dou, flags, dqu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dqu._dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面主要逻辑是判断传入的任务是否有虚函数表，如果有的话调用 <code>dx_invoke</code> 宏执行任务，否则调用 <code>_dispatch_continuation_invoke_inline</code> 宏执行任务。</p><p>由于传进来的任务，是前面包装好的 <code>continuation</code>，是没有虚函数表的，所以这里会继续调用 <code>_dispatch_continuation_invoke_inline</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_continuation_invoke_inline(<span class="type">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="type">dispatch_invoke_flags_t</span> flags, <span class="type">dispatch_queue_class_t</span> dqu)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    <span class="comment">// 使用自动释放池包装调度项的执行，确保在执行过程中管理内存</span></span><br><span class="line">    dispatch_invoke_with_autoreleasepool(flags, &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> dc_flags = dc-&gt;dc_flags;</span><br><span class="line">        <span class="comment">// 将调度项重新放回缓存中，以便快速回收和复用，这样可以减少内存分配的开销，提高性能</span></span><br><span class="line">        _dispatch_continuation_voucher_adopt(dc, dc_flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(dc_flags &amp; DC_FLAG_NO_INTROSPECTION)) &#123;</span><br><span class="line">            _dispatch_trace_item_pop(dqu, dou);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果设置了 DC_FLAG_CONSUME 标志，则释放调度项的缓存</span></span><br><span class="line">        <span class="keyword">if</span> (dc_flags &amp; DC_FLAG_CONSUME) &#123;</span><br><span class="line">            dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dc1 = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果设置了 DC_FLAG_GROUP_ASYNC 标志，表示这是一个异步任务组，调用专门的函数处理任务组的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc_flags &amp; DC_FLAG_GROUP_ASYNC)) &#123;</span><br><span class="line">            _dispatch_continuation_with_group_invoke(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，调用调度项的回调函数</span></span><br><span class="line">            _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">            <span class="comment">// 记录调度项的完成事件</span></span><br><span class="line">            _dispatch_trace_item_complete(dc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓存释放失败，则将调度项释放到缓存限制中</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc1)) &#123;</span><br><span class="line">            _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 增加性能监控的工作项计数</span></span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述核心逻辑如下：</p><ul><li>使用 <code>autoreleasepool</code> 包裹调度项的执行，确保在执行过程中管理内存。</li><li>判断是否是 <code>dispatch_group</code> 任务组。<ul><li>如果是 <code>dispatch_group</code> 任务组，调用 <code>_dispatch_continuation_with_group_invoke</code> 执行。</li><li>如果是普通任务，调用 <code>_dispatch_client_callout</code> 执行任务。</li></ul></li><li>释放 <code>continuation</code>，存到线程的 <code>continuation</code> 缓存池。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>可以用下图表示 <code>dispatch_async</code> + 串行队列&#x2F;并发队列的逻辑：<br><img src="/images/lix_blog_230.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCD 底层原理 3 - dispatch_sync</title>
      <link href="/posts/42034/"/>
      <url>/posts/42034/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><code>dispatch_sync</code> 用于将一个任务同步地提交到指定的调度队列，并等待该任务完成后才返回。调用者线程会被阻塞，直到任务执行完毕。<code>dispatch_sync</code> 在需要确保任务在某个队列上按顺序执行，前一个任务完成之前，后续任务不会执行。</p><p><code>dispatch_sync</code> 特点：</p><ul><li><strong>不会开启新线程</strong><ul><li><code>dispatch_sync</code> 在调用时，不会创建新的线程来执行任务。它会在指定的队列上同步地执行任务。</li></ul></li><li><strong>按照顺序执行</strong><ul><li><strong>串行队列</strong><ul><li>在串行队列上，<code>dispatch_sync</code> 提交的任务会按照队列中的顺序依次执行，确保任务之间的顺序性。</li></ul></li><li><strong>并发队列</strong><ul><li>同一个线程使用 <code>dispatch_sync</code> 往并发队列提交任务，任务会按照提交顺序执行，因为每个调用会阻塞调用线程，直到当前任务完成。</li><li>不同线程使用 <code>dispatch_sync</code> 往同一并发队列提交任务，任务的执行顺序是不可预测的，因为并发队列会并行处理任务，具体顺序取决于系统调度。</li></ul></li></ul></li></ul><p><strong>使用示例：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.lixkit.serialQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="二、dispatch-sync"><a href="#二、dispatch-sync" class="headerlink" title="二、dispatch_sync"></a>二、dispatch_sync</h2><p><code>dispatch_sync</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dispatch_sync</span><span class="params">(<span class="type">dispatch_queue_t</span> dq, <span class="type">dispatch_block_t</span> work)</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> dc_flags = DC_FLAG_BLOCK; <span class="comment">// 初始化标志变量 dc_flags，表示任务是一个 Block</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查任务是否包含私有数据</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">        <span class="comment">// 如果任务包含私有数据，调用 _dispatch_sync_block_with_privdata 处理</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_block_with_privdata(dq, work, dc_flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务不包含私有数据，调用 _dispatch_sync_f 同步执行任务</span></span><br><span class="line">    _dispatch_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述逻辑中，先判断传入的 <code>block</code> 是否包含私有数据，当我们通过前面的示例方式调用 <code>dispatch_sync</code>，传入的 <code>block</code> 是不包含私有数据的。当传入的 <code>block</code> 是通过下面方式创建的时候，<code>block</code> 中才会包含私有数据：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t block = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>dispatch_block_create</code> 用于创建一个带有附加控制信息的 <code>Block</code>，这些附加信息可以包括优先级、屏障标志、凭证等。例如，<code>dispatch_block_create</code> 的第 1 个参数传 <code>DISPATCH_BLOCK_BARRIER</code>，可以创建一个屏障 <code>Block</code>。在并发队列中，屏障 <code>Block</code> 可以确保在其前面的任务完成后才开始执行，并在其后面的任务开始之前完成。例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t block = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123;</span><br><span class="line">    <span class="comment">// 执行一些需要屏障的操作</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交到队列</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, block);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在需要时取消</span></span><br><span class="line">dispatch_block_cancel(block);</span><br></pre></td></tr></table></figure><p>关于 <code>dispatch_block_create</code> 不是本次源码分析的重点，这里不再深究。也就是说，我们常规使用 <code>dispatch_sync</code> 执行串行、并发队列时，实际会调用 <code>_dispatch_sync_f</code> 函数。</p><h2 id="三、-dispatch-sync-f"><a href="#三、-dispatch-sync-f" class="headerlink" title="三、_dispatch_sync_f"></a>三、_dispatch_sync_f</h2><p><code>_dispatch_sync_f</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_sync_f(<span class="type">dispatch_queue_t</span> dq, <span class="type">void</span> *ctxt, <span class="type">dispatch_function_t</span> func,</span><br><span class="line">        <span class="type">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> _dispatch_sync_f_inline(<span class="type">dispatch_queue_t</span> dq, <span class="type">void</span> *ctxt,</span><br><span class="line">                                           <span class="type">dispatch_function_t</span> func, <span class="type">uintptr_t</span> dc_flags) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列的宽度为 1（串行队列的 dq_width 为 1）</span></span><br><span class="line">    <span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 1、串行队列执行逻辑</span></span><br><span class="line">        <span class="comment">// 对于串行队列，调用 _dispatch_barrier_sync_f 执行任务</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、并发队列执行逻辑</span></span><br><span class="line">    <span class="comment">// 检查队列的类型是否是 _DISPATCH_LANE_TYPE</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">        <span class="comment">// 如果队列类型不支持 dispatch_sync，触发崩溃</span></span><br><span class="line">        DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">&quot;Queue type doesn&#x27;t support dispatch_sync&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将调度队列转换为 dispatch_lane_t 类型</span></span><br><span class="line">    <span class="type">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局并发队列和绑定到非调度线程的队列总是进入慢速路径</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dl))) &#123;</span><br><span class="line">        <span class="comment">// 如果无法保留同步宽度，调用 _dispatch_sync_f_slow 处理</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, <span class="number">0</span>, dl, dc_flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果目标队列存在目标队列，表示递归目标队列</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="comment">// 调用 _dispatch_sync_recurse 递归处理</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func, dc_flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始同步调度任务的内省</span></span><br><span class="line">    _dispatch_introspection_sync_begin(dl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步调用并完成任务</span></span><br><span class="line">    _dispatch_sync_invoke_and_complete(dl, ctxt, func DISPATCH_TRACE_ARG(</span><br><span class="line">        _dispatch_trace_item_sync_push_pop(dq, ctxt, func, dc_flags)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要分成两部分看：串行队列执行逻辑、并发队列执行逻辑。</p><p>在前面分析 dispatch_queue_create 的源码时候就已经知道：</p><ul><li>创建串行队列时，<code>dq_width = 1</code></li><li>创建并发队列时，<code>dq_width = 4094</code></li></ul><p>所以对于串行队列，会进入 <code>_dispatch_barrier_sync_f</code> 函数的执行逻辑，并发队列走剩余的逻辑。</p><h2 id="四、-dispatch-barrier-sync-f"><a href="#四、-dispatch-barrier-sync-f" class="headerlink" title="四、_dispatch_barrier_sync_f"></a>四、_dispatch_barrier_sync_f</h2><p>根据前面源码可知，对于串行队列，会通过 <code>likely(dq-&gt;dq_width == 1)</code> 的判断，进入 <code>_dispatch_barrier_sync_f</code> 函数的执行逻辑。</p><p><code>_dispatch_barrier_sync_f</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_barrier_sync_f(<span class="type">dispatch_queue_t</span> dq, <span class="type">void</span> *ctxt,</span><br><span class="line">        <span class="type">dispatch_function_t</span> func, <span class="type">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_barrier_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> _dispatch_barrier_sync_f_inline(<span class="type">dispatch_queue_t</span> dq, <span class="type">void</span> *ctxt,</span><br><span class="line">                                                   <span class="type">dispatch_function_t</span> func, <span class="type">uintptr_t</span> dc_flags) &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的线程 ID</span></span><br><span class="line">    dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列的类型是否是 _DISPATCH_LANE_TYPE</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">        <span class="comment">// 如果队列类型不支持 dispatch_sync，触发崩溃</span></span><br><span class="line">        DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">&quot;Queue type doesn&#x27;t support dispatch_sync&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将调度队列转换为 dispatch_lane_t 类型</span></span><br><span class="line">    <span class="type">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取屏障锁</span></span><br><span class="line">    <span class="comment">// 更正确的做法是将刚刚获取屏障锁的线程的 QoS 合并到队列状态中。</span></span><br><span class="line">    <span class="comment">// 但是这对于快速路径来说太昂贵了，所以跳过它。</span></span><br><span class="line">    <span class="comment">// 所选择的折衷是，如果较低优先级线程上的入队与此快速路径争用，</span></span><br><span class="line">    <span class="comment">// 该线程可能会收到无用的覆盖。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 全局并发队列和绑定到非调度线程的队列总是进入慢速路径，</span></span><br><span class="line">    <span class="comment">// 参见 DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dl, tid))) &#123;</span><br><span class="line">        <span class="comment">// 获取屏障锁失败，调用 _dispatch_sync_f_slow 处理</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, DC_FLAG_BARRIER, dl,</span><br><span class="line">                                     DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取屏障锁成功，继续执行</span></span><br><span class="line">    <span class="comment">// 如果目标队列也存在目标队列，表示需要递归目标队列</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dl-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="comment">// 调用 _dispatch_sync_recurse 递归处理，并返回</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func,</span><br><span class="line">                                      DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始同步调度任务的内省，这一步主要是用于记录日志和调试</span></span><br><span class="line">    _dispatch_introspection_sync_begin(dl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务，并重置 dq_state、唤醒线程</span></span><br><span class="line">    _dispatch_lane_barrier_sync_invoke_and_complete(dl, ctxt, func</span><br><span class="line">                                                    DISPATCH_TRACE_ARG(_dispatch_trace_item_sync_push_pop(</span><br><span class="line">                                                        dq, ctxt, func, dc_flags | DC_FLAG_BARRIER)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述核心逻辑如下：</p><ul><li><strong>获取屏障锁</strong><ul><li>屏障锁用于确保在执行任务时，队列中的其他任务不会同时执行。</li><li>获取屏障锁成功：意味着当前队列空闲，可以执行任务。</li><li>获取屏障锁失败：意味着当前队列非空闲，正在执行其他任务。<ul><li>此时会执行 <code>_dispatch_sync_f_slow</code> 函数。</li></ul></li></ul></li><li><strong>递归目标队列（如果有必要）</strong></li><li><strong>执行任务，并重置 <code>dq_state</code>、唤醒线程</strong></li></ul><p>接下来，通过源码详细看下各部分逻辑。</p><h3 id="1、获取屏障锁"><a href="#1、获取屏障锁" class="headerlink" title="1、获取屏障锁"></a>1、获取屏障锁</h3><p>获取屏障锁逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试获取屏障锁</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dl, tid))) &#123;</span><br><span class="line">    <span class="comment">// 如果无法获取屏障锁，表示队列非空闲，调用 _dispatch_sync_f_slow 处理，并返回</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, DC_FLAG_BARRIER, dl,</span><br><span class="line">                                 DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取屏障锁调用的是 <code>_dispatch_queue_try_acquire_barrier_sync</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dispatch_queue_try_acquire_barrier_sync(<span class="type">dispatch_queue_class_t</span> dq, <span class="type">uint32_t</span> tid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_queue_try_acquire_barrier_sync_and_suspend(dq._dl, tid, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部调用的  <code>_dispatch_queue_try_acquire_barrier_sync_and_suspend</code> 函数，内部涉及到一系列宏定义，将该函数完全展开后逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dispatch_queue_try_acquire_barrier_sync_and_suspend(<span class="type">dispatch_lane_t</span> dq,</span><br><span class="line">        <span class="type">uint32_t</span> tid, <span class="type">uint64_t</span> suspend_count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算队列的初始状态值，基于队列的宽度</span></span><br><span class="line">    <span class="type">uint64_t</span> init  = DISPATCH_QUEUE_STATE_INIT_VALUE(dq-&gt;dq_width);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新的状态值，组合了多个标志位和信息</span></span><br><span class="line">    <span class="type">uint64_t</span> value = DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER |</span><br><span class="line">            _dispatch_lock_value_from_tid(tid) | <span class="comment">// 从线程 ID 生成锁值</span></span><br><span class="line">            DISPATCH_QUEUE_UNCONTENDED_SYNC |    <span class="comment">// 表示同步操作未被争用</span></span><br><span class="line">            (suspend_count * DISPATCH_QUEUE_SUSPEND_INTERVAL); <span class="comment">// 根据挂起计数计算状态增量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> old_state, new_state; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子操作循环尝试更新队列状态</span></span><br><span class="line">    <span class="type">bool</span> _result = <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">// 定义 _p 为指向 dq_state 字段的指针</span></span><br><span class="line">    __typeof__(&amp;(dq)-&gt;dq_state) _p = &amp;(dq)-&gt;dq_state;  </span><br><span class="line">    <span class="comment">// 使用原子加载操作读取当前字段的值，并保存到 old_state 中</span></span><br><span class="line">    old_state = os_atomic_load(_p, relaxed);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从 dq_state 中取出 role</span></span><br><span class="line">        <span class="type">uint64_t</span> role = old_state &amp; DISPATCH_QUEUE_ROLE_MASK;</span><br><span class="line">        <span class="comment">// 检查当前状态是否等于初始状态加上角色信息</span></span><br><span class="line">        <span class="keyword">if</span> (old_state != (init | role)) &#123;  </span><br><span class="line">            <span class="comment">// 队列非空闲状态，放弃更新并退出 do while 循环。</span></span><br><span class="line">            <span class="comment">// 函数返回 false，表示队列是非空闲状态</span></span><br><span class="line">            os_atomic_rmw_loop_give_up(<span class="keyword">break</span>); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列是空闲状态</span></span><br><span class="line">        <span class="comment">// 将 role 信息保存到 value 上，生成新的 dq_state</span></span><br><span class="line">        new_state = value | role;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试将当前字段的值从 old_state 更新为 new_state，如果更新成功，返回 true</span></span><br><span class="line"><span class="comment">         * _p 指向 dq_state</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 比较：</span></span><br><span class="line"><span class="comment">         *      比较 _p 所指向的共享变量的当前值(dq_state)与 old_state 是否相等。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 交换：</span></span><br><span class="line"><span class="comment">         *      如果相等，则将 _p 所指向的共享变量的值(dq_state)更新为 new_state，交换操作成功。</span></span><br><span class="line"><span class="comment">         *      如果不相等，则将 _p 的当前值(dq_state)写入 old_state，交换操作失败。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 返回结果：</span></span><br><span class="line"><span class="comment">         *      返回一个布尔值，表示交换是否成功。</span></span><br><span class="line"><span class="comment">         *      如果成功，返回 true，代表队列进入非空闲状态</span></span><br><span class="line"><span class="comment">         *      否则，返回 false，并在下一次循环中使用更新后的 old_state 重新尝试。</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        _result = os_atomic_cmpxchgvw(_p, old_state, new_state, &amp;old_state, acquire); </span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (unlikely(!_result));  <span class="comment">// 如果交换未成功，继续循环尝试</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _result;  <span class="comment">// 返回结果，表示交换是否成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述逻辑可知，是利用 <code>dq_state</code> 实现获取屏障锁逻辑，在上一篇 <code>dispatch_queue</code> 源码分析的文章里，已经知道串行队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DISPATCH_QUEUE_ROLE_BASE_WLH 是 role</span></span><br><span class="line">dq_state = (DISPATCH_QUEUE_STATE_INIT_VALUE(dq_width) | DISPATCH_QUEUE_ROLE_BASE_WLH) = <span class="number">0x001ffe2000000000</span>;</span><br></pre></td></tr></table></figure><p>所以首次执行 <code>_dispatch_queue_try_acquire_barrier_sync_and_suspend</code> 函数时，一定满足下面条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">old_state == (init | role)</span><br></pre></td></tr></table></figure><p>所以会继续执行 <code>dq_state</code> 的赋值逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_state = value | role;</span><br></pre></td></tr></table></figure><p>赋值完成后，<code>_result</code> 值为 <code>true</code>，并且 <code>_dispatch_queue_try_acquire_barrier_sync_and_suspend</code> 函数返回 <code>true</code>，获取屏障锁成功。</p><p>这里，我们可以通过一个 Demo 验证下这部分逻辑：<br><img src="/images/lix_blog_220.png"></p><p>根据上述 Demo 打印结果也可以看出利用 <code>dq_state</code> 实现获取屏障锁逻辑：</p><ul><li><code>dq_state</code> 初始值满足 <code>dq_state == (init | role)</code>，允许获取屏障锁。</li><li>获取屏障锁后，<code>dq_state</code> 被修改（<code>dq_state = value | role</code>），<code>dq_state</code> 不再满 <code>dq_state == (init | role)</code>，后续提交的任务将无法再获取屏障锁。</li><li>任务执行结束后，<code>dq_state</code> 会重置回初始值，下个任务可以获取屏障锁。</li></ul><h3 id="2、递归目标队列"><a href="#2、递归目标队列" class="headerlink" title="2、递归目标队列"></a>2、递归目标队列</h3><p>上一步屏障锁如果获取成功，则会继续执行递归目标队列的逻辑，该逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果目标队列也存在目标队列，表示需要递归目标队列</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(dl-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">    <span class="comment">// 调用 _dispatch_sync_recurse 递归处理，并返回</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func,</span><br><span class="line">                                  DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述主要逻辑是检查 <code>do_targetq</code> 是否也存在 <code>do_targetq</code>，如果存在，则需要递归队列。</p><p><strong>那么，什么情况下<code> do_targetq</code> 也存在 <code>do_targetq</code> 呢？</strong></p><p>比较常见的一个场景是利用 <code>dispatch_set_target_queue</code> 函数设置目标队列，<code>dispatch_set_target_queue</code> 的主要目的是将一个 <code>queue</code> 的任务调度到另一个 <code>queue</code>。当你设置一个 <code>queue</code> 的目标 <code>queue</code> 后，原 <code>queue</code> 中的任务将在目标 <code>queue</code> 中执行，这样可以确保任务的优先级和调度策略与目标 <code>queue</code> 一致。</p><p><code>dispatch_set_target_queue</code> 使用示例如下：<br><img src="/images/lix_blog_221.png"><br>上述示例中，虽然任务是通过 <code>dispatch_async</code> 提交到 <code>concurrentQueue</code> 队列上的，由于设置了 <code>concurrentQueue</code> 的目标队列是 <code>serialQueue</code>，所以任务会在 <code>serialQueue</code> 上执行，最终任务串行执行。</p><p>这里调用 <code>_dispatch_sync_recurse</code> 函数内部与后续正常执行任务的逻辑基本一致，这里就不再单独分析。</p><h3 id="3、执行任务，并重置-dq-state、唤醒线程"><a href="#3、执行任务，并重置-dq-state、唤醒线程" class="headerlink" title="3、执行任务，并重置 dq_state、唤醒线程"></a>3、执行任务，并重置 dq_state、唤醒线程</h3><p>在上一步获取屏障锁成功后，最终会执行 <code>_dispatch_lane_barrier_sync_invoke_and_complete</code> 函数执行任务并重置 <code>dq_state</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_lane_barrier_sync_invoke_and_complete(<span class="type">dispatch_lane_t</span> dq,</span><br><span class="line">        <span class="type">void</span> *ctxt, <span class="type">dispatch_function_t</span> func DISPATCH_TRACE_ARG(<span class="type">void</span> *dc))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    _dispatch_sync_function_invoke_inline(dq, ctxt, func);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 完成跟踪项，标记当前任务或事件的完成，主要用来日志记录、调试</span></span><br><span class="line">    _dispatch_trace_item_complete(dc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测当前队列状态，如果队列末尾存在任务或宽度大于1，则说明需要进行额外处理</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dq-&gt;dq_items_tail || dq-&gt;dq_width &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 调用 barrier 完成函数以处理当前的队列状态</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_lane_barrier_complete(dq, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常见的状态检查，具体是检查旧状态中是否有需要处理的标志位</span></span><br><span class="line">    <span class="comment">// 指定某些状态需要进一步处理，只有 _dispatch_*_barrier_complete() 能够妥善处理这些状态</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> fail_unlock_mask = DISPATCH_QUEUE_SUSPEND_BITS_MASK |</span><br><span class="line">            DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_DIRTY |</span><br><span class="line">            DISPATCH_QUEUE_RECEIVED_OVERRIDE |</span><br><span class="line">            DISPATCH_QUEUE_RECEIVED_SYNC_WAIT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存储队列的旧状态和新状态</span></span><br><span class="line">    <span class="type">uint64_t</span> old_state, new_state;</span><br><span class="line">    <span class="comment">// 用于唤醒的标志位</span></span><br><span class="line">    <span class="type">dispatch_wakeup_flags_t</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子操作来更新队列状态，确保在多线程环境下的安全性</span></span><br><span class="line">    os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, &#123;</span><br><span class="line">        <span class="comment">// 更新新状态，表示从旧状态中去掉串行排水拥有的信息</span></span><br><span class="line">        new_state = old_state - DISPATCH_QUEUE_SERIAL_DRAIN_OWNED;</span><br><span class="line">        <span class="comment">// 清除解除锁定的标志位</span></span><br><span class="line">        new_state &amp;= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;</span><br><span class="line">        <span class="comment">// 清除最大优先级的标志位</span></span><br><span class="line">        new_state &amp;= ~DISPATCH_QUEUE_MAX_QOS_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查旧状态是否存在需要特殊处理的标志位</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(old_state &amp; fail_unlock_mask)) &#123;</span><br><span class="line">            <span class="comment">// 如果存在这样的标志，则放弃原子操作并调用完成函数，进行后期处理</span></span><br><span class="line">            os_atomic_rmw_loop_give_up(&#123;</span><br><span class="line">                <span class="keyword">return</span> _dispatch_lane_barrier_complete(dq, <span class="number">0</span>, flags);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列的状态是基于工作环的状态，确保事件循环没有被当前线程持有</span></span><br><span class="line">    <span class="keyword">if</span> (_dq_state_is_base_wlh(old_state)) &#123;</span><br><span class="line">        _dispatch_event_loop_assert_not_owned((<span class="type">dispatch_wlh_t</span>)dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行任务调用的是 <code>_dispatch_sync_function_invoke_inline</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_sync_function_invoke_inline(<span class="type">dispatch_queue_class_t</span> dq, <span class="type">void</span> *ctxt,</span><br><span class="line">        <span class="type">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_thread_frame_s dtf;</span><br><span class="line">    _dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    _dispatch_client_callout(ctxt, func);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述执行任务主要是通过执行 <code>_dispatch_client_callout</code> 函数，关于 <code>_dispatch_client_callout</code> 函数，在另一篇文章<a href="https://www.lixkit.com/posts/33519/">《GCD 底层原理 1 - dispatch_once》</a> 中有总结，其核心逻辑就是执行具体任务。</p><p><code>_dispatch_sync_function_invoke_inline</code> 中其他的逻辑是线程调度相关，这部分不是本次分析重点，暂时忽略这部分逻辑。</p><p><code>_dispatch_lane_barrier_sync_invoke_and_complete</code> 除了任务的执行外，还有这两部分逻辑：</p><ul><li><strong>重置 dq_state</strong><ul><li>前面已经提到，任务执行完成后，会重置 <code>dq_state</code>，使后续往队列新提交的任务可以成功获取屏障锁。</li></ul></li><li><strong>唤醒线程</strong><ul><li>如果 <code>dispatch_sync</code> 往串行队列中提交的任务还没有执行完成，再次使用 <code>dispatch_sync</code> 往相同队列提交新任务时，会获取屏障锁失败走 <code>_dispatch_sync_f_slow</code> 的逻辑，<code>_dispatch_sync_f_slow</code> 中会使线程阻塞等待上个任务的完成。当上个任务执行完成后，会唤醒阻塞的线程继续执行任务。</li></ul></li></ul><p>在分析唤醒线程的逻辑前，我们先分析下 <code>_dispatch_sync_f_slow</code> 中阻塞线程的逻辑。</p><h2 id="五、-dispatch-sync-f-slow"><a href="#五、-dispatch-sync-f-slow" class="headerlink" title="五、_dispatch_sync_f_slow"></a>五、_dispatch_sync_f_slow</h2><p>在前面获取屏障锁失败后，会执行 <code>_dispatch_sync_f_slow</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_sync_f_slow(<span class="type">dispatch_queue_class_t</span> top_dqu, <span class="type">void</span> *ctxt,</span><br><span class="line">        <span class="type">dispatch_function_t</span> func, <span class="type">uintptr_t</span> top_dc_flags,</span><br><span class="line">        <span class="type">dispatch_queue_class_t</span> dqu, <span class="type">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取顶层和当前调度队列</span></span><br><span class="line">    <span class="type">dispatch_queue_t</span> top_dq = top_dqu._dq; </span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = dqu._dq; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前队列没有目标队列，直接调用同步函数执行</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_function_invoke(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程的优先级</span></span><br><span class="line">    <span class="type">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化同步上下文结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_sync_context_s</span> <span class="title">dsc</span> =</span> &#123;</span><br><span class="line">        .dc_flags    = DC_FLAG_SYNC_WAITER | dc_flags,  <span class="comment">// 设置标志位，表示当前是同步等待者</span></span><br><span class="line">        .dc_func     = _dispatch_async_and_wait_invoke,  <span class="comment">// 设置要调用的函数</span></span><br><span class="line">        .dc_ctxt     = &amp;dsc,                              <span class="comment">// 将自身的上下文传递</span></span><br><span class="line">        .dc_other    = top_dq,                           <span class="comment">// 保存顶层队列</span></span><br><span class="line">        .dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG, <span class="comment">// 设置优先级</span></span><br><span class="line">        .dc_voucher  = _voucher_get(),                    <span class="comment">// 获取当前的凭证</span></span><br><span class="line">        .dsc_func    = func,                              <span class="comment">// 设置传入的函数</span></span><br><span class="line">        .dsc_ctxt    = ctxt,                              <span class="comment">// 设置传入的上下文</span></span><br><span class="line">        .dsc_waiter  = _dispatch_tid_self(),              <span class="comment">// 获取当前线程的 ID</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于日志、调试</span></span><br><span class="line">    _dispatch_trace_item_push(top_dq, &amp;dsc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞线程，等待队列的所有权</span></span><br><span class="line">    __DISPATCH_WAIT_FOR_QUEUE__(&amp;dsc, dq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 dsc_func 是否被清空，如果为 NULL，表示块在其他线程上运行</span></span><br><span class="line">    <span class="keyword">if</span> (dsc.dsc_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// dsc_func 被清空意味着这个块在其他线程上运行</span></span><br><span class="line">        <span class="type">dispatch_queue_t</span> stop_dq = dsc.dc_other;  <span class="comment">// 获取停止队列</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_complete_recurse(top_dq, stop_dq, top_dc_flags); <span class="comment">// 完成同步操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始同步的内省过程（用于调试）</span></span><br><span class="line">    _dispatch_introspection_sync_begin(top_dq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于日志、调试</span></span><br><span class="line">    _dispatch_trace_item_pop(top_dq, &amp;dsc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务，并重置 dq_state、唤醒线程</span></span><br><span class="line">    _dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func, top_dc_flags</span><br><span class="line">            DISPATCH_TRACE_ARG(&amp;dsc)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数核心逻辑如下：</p><ul><li><strong>阻塞线程，等待上个任务执行结束</strong><ul><li>执行 <code>__DISPATCH_WAIT_FOR_QUEUE__</code> 函数</li></ul></li><li><strong>解除阻塞后，执行当前任务，并重置 dq_state、唤醒线程</strong><ul><li>执行 <code>_dispatch_sync_invoke_and_complete_recurse</code> 函数</li></ul></li></ul><h3 id="1、阻塞线程"><a href="#1、阻塞线程" class="headerlink" title="1、阻塞线程"></a>1、阻塞线程</h3><p><code>_dispatch_sync_f_slow</code> 中，阻塞线程是通过调用 <code>__DISPATCH_WAIT_FOR_QUEUE__</code> 函数实现的，该函数源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__DISPATCH_WAIT_FOR_QUEUE__(<span class="type">dispatch_sync_context_t</span> dsc, <span class="type">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前队列的状态</span></span><br><span class="line">    <span class="comment">// dq_state = dq_state | DISPATCH_QUEUE_RECEIVED_SYNC_WAIT;</span></span><br><span class="line">    <span class="type">uint64_t</span> dq_state = _dispatch_wait_prepare(dq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查当前队列是否已被调用线程拥有</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dq_state_drain_locked_by(dq_state, dsc-&gt;dsc_waiter))) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH((<span class="type">uintptr_t</span>)dq_state,</span><br><span class="line">                <span class="string">&quot;dispatch_sync called on queue &quot;</span></span><br><span class="line">                <span class="string">&quot;already owned by current thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交到主线程的块必须在主线程上运行，</span></span><br><span class="line">    <span class="comment">// dispatch_async_and_wait 也在远程上下文中执行，而不是当前线程。</span></span><br><span class="line">    <span class="comment">// 对于这两种情况，我们需要保存帧链接，以便于 _dispatch_async_and_wait_invoke 使用</span></span><br><span class="line">    _dispatch_thread_frame_save_state(&amp;dsc-&gt;dsc_dtf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_dq_state_is_suspended(dq_state) ||</span><br><span class="line">            _dq_state_is_base_anon(dq_state)) &#123;</span><br><span class="line">        dsc-&gt;dc_data = DISPATCH_WLH_ANON; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_dq_state_is_base_wlh(dq_state)) &#123;</span><br><span class="line">        dsc-&gt;dc_data = (<span class="type">dispatch_wlh_t</span>)dq;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_wait_compute_wlh(upcast(dq)._dl, dsc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsc-&gt;dc_data == DISPATCH_WLH_ANON) &#123;</span><br><span class="line">        dsc-&gt;dsc_override_qos_floor = dsc-&gt;dsc_override_qos =</span><br><span class="line">                (<span class="type">uint8_t</span>)_dispatch_get_basepri_override_qos_floor(); <span class="comment">// 获取基础优先级</span></span><br><span class="line">        _dispatch_thread_event_init(&amp;dsc-&gt;dsc_event); <span class="comment">// 初始化线程事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前的同步上下文</span></span><br><span class="line">    _dispatch_set_current_dsc((<span class="type">void</span> *) dsc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前上下文推入队列，设置优先级</span></span><br><span class="line">    dx_push(dq, dsc, _dispatch_qos_from_pp(dsc-&gt;dc_priority));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录运行时事件</span></span><br><span class="line">    _dispatch_trace_runtime_event(sync_wait, dq, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dsc-&gt;dc_data == DISPATCH_WLH_ANON) &#123;</span><br><span class="line">        <span class="comment">// 阻塞线程</span></span><br><span class="line">        _dispatch_thread_event_wait(&amp;dsc-&gt;dsc_event); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dsc-&gt;dsc_wlh_self_wakeup) &#123;</span><br><span class="line">        <span class="comment">// 阻塞线程</span></span><br><span class="line">        _dispatch_event_loop_wait_for_ownership(dsc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除当前的同步上下文</span></span><br><span class="line">    _dispatch_clear_current_dsc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsc-&gt;dc_data == DISPATCH_WLH_ANON) &#123;</span><br><span class="line">        _dispatch_thread_event_destroy(&amp;dsc-&gt;dsc_event);</span><br><span class="line">        <span class="comment">// 如果 _dispatch_sync_waiter_wake() 给了当前线程一个优先级覆盖，</span></span><br><span class="line">        <span class="comment">// 确保根队列看到它。</span></span><br><span class="line">        <span class="keyword">if</span> (dsc-&gt;dsc_override_qos &gt; dsc-&gt;dsc_override_qos_floor) &#123;</span><br><span class="line">            _dispatch_set_basepri_override_qos(dsc-&gt;dsc_override_qos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述逻辑中，先看这个判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_dq_state_is_suspended(dq_state) ||</span><br><span class="line">        _dq_state_is_base_anon(dq_state)) &#123;</span><br><span class="line">    dsc-&gt;dc_data = DISPATCH_WLH_ANON; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (_dq_state_is_base_wlh(dq_state)) &#123;</span><br><span class="line">    dsc-&gt;dc_data = (<span class="type">dispatch_wlh_t</span>)dq;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _dispatch_wait_compute_wlh(upcast(dq)._dl, dsc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述判断条件涉及的函数源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dq_state_is_suspended(<span class="type">uint64_t</span> dq_state)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dq_state &amp; DISPATCH_QUEUE_SUSPEND_BITS_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dq_state_is_base_anon(<span class="type">uint64_t</span> dq_state)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dq_state &amp; DISPATCH_QUEUE_ROLE_BASE_ANON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dq_state_is_base_wlh(<span class="type">uint64_t</span> dq_state)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dq_state &amp; DISPATCH_QUEUE_ROLE_BASE_WLH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面的源码分析可以知道，<code>dq_state</code> 是不包含 <code>DISPATCH_QUEUE_SUSPEND_BITS_MASK</code> 信息的，所以 <code>_dq_state_is_suspended</code> 的判断返回 <code>false</code>。</p><p>再根据另一篇文章 <a href="https://www.lixkit.com/posts/12465">《GCD 底层原理 2 - dispatch_queue》</a> 中分析得到的结论：</p><ul><li>串行队列，<code>role = DISPATCH_QUEUE_ROLE_BASE_WLH</code>;</li><li>并发队列时，<code>role = DISPATCH_QUEUE_ROLE_BASE_ANON</code>;</li></ul><p>所以对于串行队列，会走进第二个 <code>if</code> 分支里。</p><p>所以对于后面的这个判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dsc-&gt;dc_data == DISPATCH_WLH_ANON) &#123;</span><br><span class="line">    <span class="comment">// 阻塞线程</span></span><br><span class="line">    _dispatch_thread_event_wait(&amp;dsc-&gt;dsc_event); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dsc-&gt;dsc_wlh_self_wakeup) &#123;</span><br><span class="line">    <span class="comment">// 阻塞线程</span></span><br><span class="line">    _dispatch_event_loop_wait_for_ownership(dsc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将执行 <code>_dispatch_event_loop_wait_for_ownership</code> 函数实现阻塞逻辑，该函数的完整源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _dispatch_event_loop_wait_for_ownership(<span class="type">dispatch_sync_context_t</span> dsc) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_USE_KEVENT_WORKLOOP</span></span><br><span class="line">    <span class="comment">// 从同步上下文中获取工作循环句柄</span></span><br><span class="line">    <span class="type">dispatch_wlh_t</span> wlh = dsc-&gt;dc_data;</span><br><span class="line">    <span class="comment">// 定义事件结构数组，用于存储待处理事件</span></span><br><span class="line">    dispatch_kevent_s ke[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 设置事件标志</span></span><br><span class="line">    <span class="comment">// 注意，这里设置了 KEVENT_FLAG_IMMEDIATE</span></span><br><span class="line">    <span class="type">uint32_t</span> kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS; </span><br><span class="line">    <span class="type">uint64_t</span> dq_state; <span class="comment">// 队列状态变量</span></span><br><span class="line">    <span class="type">int</span> i, n = <span class="number">0</span>; <span class="comment">// 计数器变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子加载队列的状态</span></span><br><span class="line">    dq_state = os_atomic_load2o((<span class="type">dispatch_queue_t</span>)wlh, dq_state, relaxed);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     检查队列状态，并创建 dispatch_kevent_t</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     _dq_state_drain_locked 函数：</span></span><br><span class="line"><span class="comment">     是否满足 dq_state &amp; DLOCK_OWNER_MASK != 0</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     _dq_state_is_enqueued_on_target 函数：</span></span><br><span class="line"><span class="comment">     是否满足 dq_state &amp; DISPATCH_QUEUE_ENQUEUED = true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!_dq_state_drain_locked(dq_state) &amp;&amp; _dq_state_is_enqueued_on_target(dq_state)) &#123;</span><br><span class="line">        <span class="comment">// 此时，如果入队操作与服务线程正在处理同一项目发生竞争，可能导致队列被错误标记</span></span><br><span class="line">        <span class="comment">// 为已入队而实际是空队列。这是一个潜在的优先级反转情况。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 如果线程请求被选择来处理事件，但未能进入用户空间进行锁定，</span></span><br><span class="line">        <span class="comment">// 因此，每个同步等待者都必须等待服务线程消耗事件请求。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 为避免优先级反转，这里需要驱动一次以确保处理事件。</span></span><br><span class="line">        _dispatch_kq_fill_workloop_event(&amp;ke[n++], DISPATCH_WORKLOOP_ASYNC, wlh, dq_state);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_dq_state_received_sync_wait(dq_state)) &#123; <span class="comment">// dq_state &amp; DISPATCH_QUEUE_RECEIVED_SYNC_WAIT ？</span></span><br><span class="line">        <span class="comment">// 如果队列处于同步等待状态，则填充同步等待事件</span></span><br><span class="line">        _dispatch_kq_fill_workloop_sync_event(&amp;ke[n++], DISPATCH_WORKLOOP_SYNC_DISCOVER, wlh, dq_state, _dq_state_drain_owner(dq_state));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="comment">// 填充同步等待事件，并准备进行等待</span></span><br><span class="line">    _dispatch_kq_fill_workloop_sync_event(&amp;ke[n++], DISPATCH_WORKLOOP_SYNC_WAIT, wlh, dq_state, dsc-&gt;dsc_waiter);</span><br><span class="line">    <span class="comment">// 查询处理事件</span></span><br><span class="line">    n = _dispatch_kq_poll(wlh, ke, n, ke, n, <span class="literal">NULL</span>, <span class="literal">NULL</span>, kev_flags);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理返回的事件</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ke[i].fflags &amp; NOTE_WL_SYNC_WAIT) &#123;</span><br><span class="line">            flags = DISPATCH_KEVENT_WORKLOOP_ALLOW_EINTR; <span class="comment">// 如果是同步等待事件，允许中断</span></span><br><span class="line">        &#125;</span><br><span class="line">        _dispatch_kevent_workloop_drain_error(&amp;ke[i], flags); <span class="comment">// 检查并处理错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有事件被处理</span></span><br><span class="line">    <span class="keyword">if</span> (n) &#123;</span><br><span class="line">        dispatch_assert(n == <span class="number">1</span> &amp;&amp; (ke[<span class="number">0</span>].fflags &amp; NOTE_WL_SYNC_WAIT)); <span class="comment">// 确保只有一个待处理事件</span></span><br><span class="line">        _dispatch_kevent_wlh_debug(<span class="string">&quot;restarting&quot;</span>, &amp;ke[<span class="number">0</span>]); <span class="comment">// 调试用，记录重启情况</span></span><br><span class="line">        dq_state = ke[<span class="number">0</span>].ext[EV_EXTIDX_WL_VALUE]; <span class="comment">// 更新队列状态</span></span><br><span class="line">        n = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">goto</span> again;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查需要取消的状态</span></span><br><span class="line">    <span class="keyword">if</span> (dsc-&gt;dsc_waiter_needs_cancel) &#123;</span><br><span class="line">        _dispatch_event_loop_cancel_waiter(dsc); <span class="comment">// 取消等待者</span></span><br><span class="line">        dsc-&gt;dsc_waiter_needs_cancel = <span class="literal">false</span>; <span class="comment">// 重置状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有存储资源需要释放</span></span><br><span class="line">    <span class="keyword">if</span> (dsc-&gt;dsc_release_storage) &#123;</span><br><span class="line">        _dispatch_queue_release_storage(dsc-&gt;dc_data); <span class="comment">// 释放队列存储</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码逻辑中各个判断条件，去除执行不到的逻辑分支，仅保留核心逻辑，精简后的 <code>_dispatch_event_loop_wait_for_ownership</code> 函数逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _dispatch_event_loop_wait_for_ownership(<span class="type">dispatch_sync_context_t</span> dsc) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    dispatch_kevent_s ke[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 设置事件标志</span></span><br><span class="line">    <span class="comment">// 注意，这里设置了 KEVENT_FLAG_IMMEDIATE</span></span><br><span class="line">    <span class="type">uint32_t</span> kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="comment">// 填充同步等待事件，并准备进行等待</span></span><br><span class="line">    _dispatch_kq_fill_workloop_sync_event(&amp;ke[n++], DISPATCH_WORKLOOP_SYNC_WAIT, wlh, dq_state, dsc-&gt;dsc_waiter);</span><br><span class="line">    <span class="comment">// 查询处理事件</span></span><br><span class="line">    n = _dispatch_kq_poll(wlh, ke, n, ke, n, <span class="literal">NULL</span>, <span class="literal">NULL</span>, kev_flags);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有事件被处理</span></span><br><span class="line">    <span class="keyword">if</span> (n) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        n = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">goto</span> again;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看上去，线程的阻塞是通过不停的 <code>goto again</code> 实现的，其实不然。先进去看下 <code>_dispatch_kq_poll</code> 函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_dispatch_kq_poll(<span class="type">dispatch_wlh_t</span> wlh, <span class="type">dispatch_kevent_t</span> ke, <span class="type">int</span> n,</span><br><span class="line">        <span class="type">dispatch_kevent_t</span> ke_out, <span class="type">int</span> n_out, <span class="type">void</span> *buf, <span class="type">size_t</span> *avail,</span><br><span class="line">        <span class="type">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用于标识 kqueue 是否已初始化</span></span><br><span class="line">    <span class="type">bool</span> kq_initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 dispatch_once_f 确保 _dispatch_kq_init 仅被执行一次，用于初始化 kqueue</span></span><br><span class="line">    dispatch_once_f(&amp;_dispatch_kq_poll_pred, &amp;kq_initialized, _dispatch_kq_init);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(kq_initialized)) &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程是进行初始化的线程，事件循环需要内存压力源和调试通道，但创建这些会递归调用 _dispatch_kq_poll()，因此不能在 dispatch once 内进行初始化</span></span><br><span class="line">        _dispatch_memorypressure_init();</span><br><span class="line">        _voucher_activity_debug_channel_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !DISPATCH_USE_KEVENT_QOS</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; KEVENT_FLAG_ERROR_EVENTS) &#123;</span><br><span class="line">        <span class="comment">// 如果不使用 kevent_qos 并且标志包含 KEVENT_FLAG_ERROR_EVENTS</span></span><br><span class="line">        <span class="comment">// 模拟 KEVENT_FLAG_ERROR_EVENTS</span></span><br><span class="line">        <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">            ke[r].flags |= EV_RECEIPT; <span class="comment">// 添加 EV_RECEIPT 标志用于接收错误事件的回执</span></span><br><span class="line">        &#125;</span><br><span class="line">        n_out = n; <span class="comment">// 设置输出事件数量</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="keyword">if</span> (unlikely(wlh == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果工作循环句柄 wlh 为 NULL，触发内部崩溃，因为这是无效的</span></span><br><span class="line">        DISPATCH_INTERNAL_CRASH(wlh, <span class="string">&quot;Invalid wlh&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wlh == DISPATCH_WLH_ANON) &#123;</span><br><span class="line">        <span class="comment">// 获取 kqueue 文件描述符</span></span><br><span class="line">        <span class="type">int</span> kqfd = _dispatch_kq_fd();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_USE_KEVENT_QOS</span></span><br><span class="line">        <span class="keyword">if</span> (_dispatch_kevent_workqueue_enabled) &#123;</span><br><span class="line">            flags |= KEVENT_FLAG_WORKQ; <span class="comment">// 如果启用了工作队列，添加 KEVENT_FLAG_WORKQ 标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用 kevent_qos 进行事件轮询，处理 QoS（服务质量）相关的事件</span></span><br><span class="line">        r = kevent_qos(kqfd, ke, n, ke_out, n_out, buf, avail, flags);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        (<span class="type">void</span>)buf;</span><br><span class="line">        (<span class="type">void</span>)avail;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timeout_immediately</span> =</span> &#123;&#125;, *timeout = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; KEVENT_FLAG_IMMEDIATE) timeout = &amp;timeout_immediately;</span><br><span class="line">        <span class="comment">// 调用 kevent 进行事件轮询</span></span><br><span class="line">        r = kevent(kqfd, ke, n, ke_out, n_out, timeout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_USE_KEVENT_WORKLOOP</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果使用工作循环</span></span><br><span class="line">        flags |= KEVENT_FLAG_WORKLOOP; <span class="comment">// 添加 KEVENT_FLAG_WORKLOOP 标志</span></span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; KEVENT_FLAG_ERROR_EVENTS)) &#123;</span><br><span class="line">            flags |= KEVENT_FLAG_DYNAMIC_KQ_MUST_EXIST; <span class="comment">// 如果未设置错误事件标志，添加动态 kqueue 必须存在标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 kevent_id 进行工作循环事件的轮询</span></span><br><span class="line">        r = kevent_id((<span class="type">uintptr_t</span>)wlh, ke, n, ke_out, n_out, buf, avail, flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DISPATCH_USE_KEVENT_WORKLOOP</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// kevent、kevent_id 一般在发生错误的时候返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(r == <span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果 kevent 调用返回 -1，则根据 errno 进行错误处理</span></span><br><span class="line">        <span class="type">int</span> err = errno;</span><br><span class="line">        <span class="keyword">switch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">case</span> ENOMEM:</span><br><span class="line">            _dispatch_temporary_resource_shortage(); <span class="comment">// 处理临时资源短缺</span></span><br><span class="line">            <span class="comment">/* FALLTHROUGH */</span></span><br><span class="line">        <span class="keyword">case</span> EINTR:</span><br><span class="line">            <span class="keyword">goto</span> retry; <span class="comment">// 如果被信号中断，重试操作</span></span><br><span class="line">        <span class="keyword">case</span> EBADF:</span><br><span class="line">            DISPATCH_CLIENT_CRASH(err, <span class="string">&quot;Do not close random Unix descriptors&quot;</span>); <span class="comment">// 文件描述符错误，导致客户端崩溃</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISPATCH_USE_KEVENT_WORKLOOP</span></span><br><span class="line">        <span class="keyword">case</span> ENOENT:</span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; KEVENT_FLAG_ERROR_EVENTS) &amp;&amp;</span><br><span class="line">                    (flags &amp; KEVENT_FLAG_DYNAMIC_KQ_MUST_EXIST)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 在某些情况下，忽略错误并返回 0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* FALLTHROUGH */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DISPATCH_USE_KEVENT_WORKLOOP</span></span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            DISPATCH_CLIENT_CRASH(err, <span class="string">&quot;Unexpected error from kevent&quot;</span>); <span class="comment">// 其他错误导致客户端崩溃</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r; <span class="comment">// 返回处理的事件数量或状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述源码可知，<code>_dispatch_kq_poll</code> 内部核心逻辑是对 <code>kevent/kevent_id</code> 的调用。根据内部判断条件可以看出对于串行队列，会调用 <code>kevent_id</code> 函数。<code>_dispatch_kq_poll</code> 返回值实际上就是 <code>kevent/kevent_id</code> 函数的返回值。</p><p><strong>kevent 和 kevent_id 是什么呢？</strong><br><code>kevent</code> 通常与 <code>kqueue</code> 结合使用，它们提供了一种高效的方式来监控事件的发生。</p><ul><li><strong>kqueue</strong><ul><li>事件通知接口，它允许应用程序监控多个事件源，并在事件发生时获取通知。</li><li>用内核级的事件通知机制，减少了用户空间和内核空间之间的上下文切换，提高了性能。</li></ul></li><li><strong>kevent</strong><ul><li>是一个系统调用，通过 <code>kevent()</code> 系统调用，将事件注册到 kqueue 中。</li><li>使用 <code>kevent()</code> 系统调用，可以等待事件发生并获取已触发的事件列表。</li></ul></li></ul><p><code>kevent</code> 函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kevent</span><span class="params">(<span class="type">int</span> kq,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> kevent *changelist, <span class="type">int</span> nchanges,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> kevent *eventlist, <span class="type">int</span> nevents,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span>;</span><br></pre></td></tr></table></figure><p>各参数含义如下：</p><ul><li><code>kq</code><ul><li><code>kqueue</code> 描述符，可以使用<code> kqueue()</code> 系统调用获取 kq，用于标识一个事件队列。</li></ul></li><li><code>changelist</code><ul><li>指定要添加、修改或删除的事件。</li></ul></li><li><code>nchanges</code><ul><li><code>changelist</code> 数组中的元素数量。</li></ul></li><li><code>eventlist</code><ul><li>用于接收已经发生的事件。调用成功返回后，这个数组包含了触发的事件信息。</li></ul></li><li><code>nevents</code><ul><li><code>eventlist</code> 数组的大小，指定可以返回的最大事件数量。</li></ul></li><li><code>timeout</code><ul><li>指定等待事件发生的超时时间。如果为 <code>NULL</code>，<code>kevent()</code> 系统调用将阻塞线程直到监听的事件发生。</li></ul></li></ul><p><code>kevent</code> 返回一个正整数，表示已发生的事件的数量。<code>kevent_id</code> 与 <code>kevent</code> 核心功能是一样的，<code>kevent_id</code> 是 <code>kevent</code> 的变体，提供了更细粒度的事件管理。可以在 Apple 开源的 XNU 源码中看到 kevent&#x2F;kevent_id 实现逻辑，链接：<a href="https://github.com/apple-oss-distributions/xnu">apple-oss-distributions&#x2F;xnu</a>。</p><p>总结来说，<code>kevent/kevent_id</code> 是一个系统调用，可以用来监听注册的事件的发生，其返回了已发生的事件的数量。</p><p>但是，从 <code>_dispatch_event_loop_wait_for_ownership</code> 中 <code>kev_flags</code> 的配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置事件标志</span></span><br><span class="line"><span class="comment">// 注意，这里设置了 KEVENT_FLAG_IMMEDIATE</span></span><br><span class="line"><span class="type">uint32_t</span> kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS; </span><br></pre></td></tr></table></figure><p>这里有两个配置：</p><ul><li><code>KEVENT_FLAG_IMMEDIATE</code><ul><li>使 <code>kevent_id/kevent</code> 是非阻塞的，即调用立刻返回，不用等到事件发生时再返回，所以增加了该配置后会使调用不阻塞线程。</li></ul></li><li><code>KEVENT_FLAG_ERROR_EVENTS</code><ul><li>即使发生错误也要返回事件，如果在处理 <code>changelist</code> 时遇到错误，会将错误信息作为一个事件返回给用户，而不是直接返回错误码。</li></ul></li></ul><p>所以，从表面上看，调用 <code>kevent_id</code> 函数的时候，是非阻塞的，同时也说明了 <code>_dispatch_kq_poll</code> 函数是非阻塞的。<code>kevent_id</code> 返回了本次调用监听到的发生的事件的数量(含错误事件数量)，由于 <code>kevent_id</code> 函数的调用是非阻塞的，所以根本没有机会等到监听的事件的发生，也就是说 <code>_dispatch_kq_poll</code> 正常情况下返回都是 0。</p><p>而 <code>_dispatch_event_loop_wait_for_ownership</code> 函数的实现中，只有 <code>_dispatch_kq_poll</code> 返回值大于 <code>0</code> 时，才会 <code>goto again</code> 逻辑。所以，<code>_dispatch_event_loop_wait_for_ownership</code> 对线程的阻塞，不是靠不停 <code>goto again</code> 实现的。</p><p>那么问题就来了，既然不会不停地 <code>goto again</code>，看起来，<code>_dispatch_event_loop_wait_for_ownership</code> 对线程的阻塞，只能是靠 <code>kevent_id</code> 函数了。但是 <code>kevent_id</code> 不是配置了 <code>KEVENT_FLAG_IMMEDIATE</code> 之后，就变成了非阻塞的了吗？</p><p><strong><code>kevent_id</code> 到底会不会阻塞线程呢？</strong><br>忽略其他参数配置，单纯从 <code>kevent_id</code> 传入 <code>KEVENT_FLAG_IMMEDIATE</code> 这个参数看，<code>kevent_id</code> 确实不会阻塞线程。但是，需要再看下传入的 <code>dispatch_kevent_s</code> 信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_kq_fill_workloop_sync_event(&amp;ke[n++], DISPATCH_WORKLOOP_SYNC_WAIT, wlh, dq_state, dsc-&gt;dsc_waiter);</span><br></pre></td></tr></table></figure><p>这里 <code>_dispatch_kq_fill_workloop_sync_event</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_kq_fill_workloop_sync_event(<span class="type">dispatch_kevent_t</span> ke, <span class="type">int</span> which,</span><br><span class="line">        <span class="type">dispatch_wlh_t</span> wlh, <span class="type">uint64_t</span> dq_state, dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = (<span class="type">dispatch_queue_t</span>)wlh;</span><br><span class="line">    <span class="type">pthread_priority_t</span> pp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> fflags = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint16_t</span> action = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (which) &#123;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_SYNC_DISCOVER:</span><br><span class="line">        dispatch_assert(_dq_state_received_sync_wait(dq_state));</span><br><span class="line">        dispatch_assert(_dq_state_in_uncontended_sync(dq_state));</span><br><span class="line">        action = EV_ADD | EV_DISABLE;</span><br><span class="line">        fflags = NOTE_WL_SYNC_WAKE | NOTE_WL_DISCOVER_OWNER |</span><br><span class="line">                NOTE_WL_IGNORE_ESTALE;</span><br><span class="line">        mask = DISPATCH_QUEUE_ROLE_MASK | DISPATCH_QUEUE_RECEIVED_SYNC_WAIT |</span><br><span class="line">                DISPATCH_QUEUE_UNCONTENDED_SYNC;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_SYNC_WAIT:</span><br><span class="line">        action = EV_ADD | EV_DISABLE;</span><br><span class="line">        fflags = NOTE_WL_SYNC_WAIT;</span><br><span class="line">        pp     = _dispatch_get_priority();</span><br><span class="line">        <span class="keyword">if</span> (_dispatch_qos_from_pp(pp) == <span class="number">0</span>) &#123;</span><br><span class="line">            pp = _dispatch_qos_to_pp(DISPATCH_QOS_DEFAULT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_SYNC_FAKE:</span><br><span class="line">        action = EV_ADD | EV_DISABLE;</span><br><span class="line">        fflags = NOTE_WL_SYNC_WAKE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_SYNC_WAKE:</span><br><span class="line">        dispatch_assert(_dq_state_drain_locked_by(dq_state, tid));</span><br><span class="line">        action = EV_ADD | EV_DISABLE;</span><br><span class="line">        fflags = NOTE_WL_SYNC_WAKE | NOTE_WL_DISCOVER_OWNER;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_SYNC_END:</span><br><span class="line">        action = EV_DELETE | EV_ENABLE;</span><br><span class="line">        fflags = NOTE_WL_SYNC_WAKE | NOTE_WL_END_OWNERSHIP;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        DISPATCH_INTERNAL_CRASH(which, <span class="string">&quot;Invalid transition&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ke = (dispatch_kevent_s)&#123;</span><br><span class="line">        .ident  = tid,</span><br><span class="line">        .filter = EVFILT_WORKLOOP,</span><br><span class="line">        .flags  = action,</span><br><span class="line">        .fflags = fflags,</span><br><span class="line">        .udata  = (<span class="type">uintptr_t</span>)wlh,</span><br><span class="line">        .qos    = (__typeof__(ke-&gt;qos))pp,</span><br><span class="line"></span><br><span class="line">        .ext[EV_EXTIDX_WL_MASK] = mask,</span><br><span class="line">        .ext[EV_EXTIDX_WL_VALUE] = dq_state,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (fflags &amp; NOTE_WL_DISCOVER_OWNER) &#123;</span><br><span class="line">        ke-&gt;ext[EV_EXTIDX_WL_ADDR] = (<span class="type">uintptr_t</span>)&amp;dq-&gt;dq_state;</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_kevent_wlh_debug(_dispatch_workloop_actions[which], ke);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于传入的 <code>which</code> 参数是 <code>DISPATCH_WORKLOOP_SYNC_WAIT</code>，所以<code> ke</code> 的 <code>fflags</code> 的值是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fflags = NOTE_WL_SYNC_WAIT</span><br></pre></td></tr></table></figure><p><code>NOTE_WL_SYNC_WAIT</code> 不是在 libdispatch 定义的，是在 <a href="https://github.com/apple-oss-distributions/xnu">XNU</a> 中定义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * data/hint fflags for EVFILT_WORKLOOP, shared with userspace</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The ident for thread requests should be the dynamic ID of the workloop</span></span><br><span class="line"><span class="comment"> * The ident for each sync waiter must be unique to that waiter [for this workloop]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Commands:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @const NOTE_WL_SYNC_WAIT [in/out]</span></span><br><span class="line"><span class="comment"> * This bit is set when the caller is waiting to become the owner of a workloop.</span></span><br><span class="line"><span class="comment"> * If the NOTE_WL_SYNC_WAKE bit is already set then the caller is not blocked,</span></span><br><span class="line"><span class="comment"> * else it blocks until it is set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The QoS field of the knote is used to push on other owners or servicers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @const NOTE_WL_SYNC_WAKE [in/out]</span></span><br><span class="line"><span class="comment"> * Marks the waiter knote as being eligible to become an owner</span></span><br><span class="line"><span class="comment"> * This bit can only be set once, trying it again will fail with EALREADY.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This modifier doesn&#x27;t affect NOTE_WL_END_OWNERSHIP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOTE_WL_SYNC_WAIT        0x00000004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOTE_WL_SYNC_WAKE        0x00000008</span></span><br></pre></td></tr></table></figure><p>与 <code>NOTE_WL_SYNC_WAIT</code> 对应的，还有个 <code>NOTE_WL_SYNC_WAKE</code>，两者作用如下：</p><ul><li><code>NOTE_WL_SYNC_WAIT</code><ul><li>这个标志表示调用者正在等待成为工作循环的所有者。</li><li>如果<strong>设置了这个标志，调用线程会阻塞</strong>，直到它被唤醒成为所有者。</li><li>可以用来实现线程间的同步，让一个线程等待获得工作循环的所有权。</li></ul></li><li><code>NOTE_WL_SYNC_WAKE</code><ul><li>这个标志用于标记等待的 <code>knote</code> 可以成为所有者了。</li><li>设置这个标志<strong>会唤醒之前因 <code>NOTE_WL_SYNC_WAIT</code> 而阻塞的线程</strong>。</li></ul></li></ul><p>所以，由于传入的 <code>ke</code>(<code>dispatch_kevent_s</code>) 信息配置了 <code>NOTE_WL_SYNC_WAIT</code>，所以及时调用 <code>kevent_id</code> 时配置了 <code>KEVENT_FLAG_IMMEDIATE</code>，<code>kevent_id</code> 仍然会阻塞线程，直到使用 <code>NOTE_WL_SYNC_WAKE</code> 再次唤醒被阻塞的线程。</p><h3 id="2、唤醒阻塞的线程"><a href="#2、唤醒阻塞的线程" class="headerlink" title="2、唤醒阻塞的线程"></a>2、唤醒阻塞的线程</h3><p>经过上一步的分析，线程的阻塞、唤醒逻辑就比较清晰了。</p><p>再回头看下 <code>_dispatch_sync_f_slow</code> 实现逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_sync_f_slow(<span class="type">dispatch_queue_class_t</span> top_dqu, <span class="type">void</span> *ctxt,</span><br><span class="line">        <span class="type">dispatch_function_t</span> func, <span class="type">uintptr_t</span> top_dc_flags,</span><br><span class="line">        <span class="type">dispatch_queue_class_t</span> dqu, <span class="type">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞线程，等待队列的所有权</span></span><br><span class="line">    __DISPATCH_WAIT_FOR_QUEUE__(&amp;dsc, dq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务，并重置 dq_state、唤醒线程</span></span><br><span class="line">    _dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func, top_dc_flags</span><br><span class="line">            DISPATCH_TRACE_ARG(&amp;dsc)); <span class="comment">// 传递追踪参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_sync_invoke_and_complete_recurse</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_sync_invoke_and_complete_recurse(<span class="type">dispatch_queue_class_t</span> dq,</span><br><span class="line">        <span class="type">void</span> *ctxt, <span class="type">dispatch_function_t</span> func, <span class="type">uintptr_t</span> dc_flags</span><br><span class="line">        DISPATCH_TRACE_ARG(<span class="type">void</span> *dc))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    _dispatch_sync_function_invoke_inline(dq, ctxt, func);</span><br><span class="line">    _dispatch_trace_item_complete(dc);</span><br><span class="line">    <span class="comment">// 重置 dq_state、唤醒线程</span></span><br><span class="line">    _dispatch_sync_complete_recurse(dq._dq, <span class="literal">NULL</span>, dc_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_sync_complete_recurse(<span class="type">dispatch_queue_t</span> dq, <span class="type">dispatch_queue_t</span> stop_dq,</span><br><span class="line">        <span class="type">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> barrier = (dc_flags &amp; DC_FLAG_BARRIER);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dq == stop_dq) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (barrier) &#123;</span><br><span class="line">            dx_wakeup(dq, <span class="number">0</span>, DISPATCH_WAKEUP_BARRIER_COMPLETE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _dispatch_lane_non_barrier_complete(upcast(dq)._dl, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dq = dq-&gt;do_targetq;</span><br><span class="line">        barrier = (dq-&gt;dq_width == <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (unlikely(dq-&gt;do_targetq));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，再回头看下调用 <code>_dispatch_sync_f_slow</code> 函数地方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试获取屏障锁</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dl, tid))) &#123;</span><br><span class="line">    <span class="comment">// 如果无法获取屏障锁，调用 _dispatch_sync_f_slow 处理</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, DC_FLAG_BARRIER, dl,</span><br><span class="line">                                 DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的 <code>dc_flags</code> 实际为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dc_flags = DC_FLAG_BARRIER | dc_flags;</span><br></pre></td></tr></table></figure><p>所以，<code>_dispatch_sync_complete_recurse</code> 里 <code>barrier</code> 为 <code>true</code>，因此会执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dx_wakeup(dq, <span class="number">0</span>, DISPATCH_WAKEUP_BARRIER_COMPLETE);</span><br></pre></td></tr></table></figure><p><code>dx_wakeup</code> 是个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> dx_wakeup(x, y, z) dx_vtable(x)-&gt;dq_wakeup(x, y, z)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dx_vtable(x) (&amp;(x)-&gt;do_vtable-&gt;_os_obj_vtable)</span></span><br></pre></td></tr></table></figure><p>将宏完全展开：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;(dq)-&gt;do_vtable-&gt;_os_obj_vtable-&gt;dq_wakeup(dq, <span class="number">0</span>, DISPATCH_WAKEUP_BARRIER_COMPLETE)</span><br></pre></td></tr></table></figure><p>到这里，就需要再回头看下另篇文章<a href="https://www.lixkit.com/posts/12465">《GCD 底层原理 2 - dispatch_queue》</a>里的关于串行队列虚表 <code>vtable</code> 的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> _<span class="title">dispatch_queue_serial_vtable</span> =</span> &#123;</span><br><span class="line">    ._os_obj_xref_dispose = _dispatch_xref_dispose,</span><br><span class="line">    ._os_obj_dispose = _dispatch_dispose,</span><br><span class="line">    ._os_obj_vtable = &#123;</span><br><span class="line">        .do_kind = <span class="string">&quot;queue_serial&quot;</span>,</span><br><span class="line">        .do_type        = DISPATCH_QUEUE_SERIAL_TYPE,</span><br><span class="line">        .do_dispose     = _dispatch_lane_dispose,</span><br><span class="line">        .do_debug       = _dispatch_queue_debug,</span><br><span class="line">        .do_invoke      = _dispatch_lane_invoke,</span><br><span class="line"></span><br><span class="line">        .dq_activate    = _dispatch_lane_activate,</span><br><span class="line">        .dq_wakeup      = _dispatch_lane_wakeup,</span><br><span class="line">        .dq_push        = _dispatch_lane_push,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以，前面 <code>dx_wakeup</code> 的调用，实际调用的是 <code>_dispatch_lane_wakeup</code> 函数，该函数实现源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_lane_wakeup(<span class="type">dispatch_lane_class_t</span> dqu, <span class="type">dispatch_qos_t</span> qos,</span><br><span class="line">        <span class="type">dispatch_wakeup_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_queue_wakeup_target_t</span> target = DISPATCH_QUEUE_WAKEUP_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; DISPATCH_WAKEUP_BARRIER_COMPLETE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_lane_barrier_complete(dqu, qos, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_dispatch_queue_class_probe(dqu)) &#123;</span><br><span class="line">        target = DISPATCH_QUEUE_WAKEUP_TARGET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_queue_wakeup(dqu, qos, flags, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过下面函数执行路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_wakeup</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_workloop_barrier_complete</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_event_loop_end_ownership</span><br></pre></td></tr></table></figure><p>会调用到 <code>_dispatch_event_loop_end_ownership</code> 函数，<code>_dispatch_event_loop_end_ownership</code> 函数核心逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_event_loop_end_ownership(<span class="type">dispatch_wlh_t</span> wlh, <span class="type">uint64_t</span> old_state,</span><br><span class="line">        <span class="type">uint64_t</span> new_state, <span class="type">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS;</span><br><span class="line">    dispatch_kevent_s ke[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_dq_state_in_uncontended_sync(old_state)) &#123;</span><br><span class="line">        dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line">        _dispatch_kq_fill_workloop_sync_event(&amp;ke[n++],</span><br><span class="line">                DISPATCH_WORKLOOP_SYNC_END, wlh, new_state, tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_kq_poll(wlh, ke, n, ke, n, <span class="literal">NULL</span>, <span class="literal">NULL</span>, kev_flags)) &#123;</span><br><span class="line">        _dispatch_kevent_workloop_drain_error(&amp;ke[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        __builtin_unreachable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又看到了熟悉的逻辑：</p><ul><li>调用 <code>_dispatch_kq_fill_workloop_sync_event</code> 创建 <code>ke</code>。</li><li>调用 <code>_dispatch_kq_poll</code>。</li></ul><p>这里调用 <code>_dispatch_kq_fill_workloop_sync_event</code> 时，传入的是 <code>DISPATCH_WORKLOOP_SYNC_END</code>，结合前面提到的 <code>_dispatch_kq_fill_workloop_sync_event</code> 源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_kq_fill_workloop_sync_event(<span class="type">dispatch_kevent_t</span> ke, <span class="type">int</span> which,</span><br><span class="line">        <span class="type">dispatch_wlh_t</span> wlh, <span class="type">uint64_t</span> dq_state, dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (which) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_WORKLOOP_SYNC_END:</span><br><span class="line">        action = EV_DELETE | EV_ENABLE;</span><br><span class="line">        fflags = NOTE_WL_SYNC_WAKE | NOTE_WL_END_OWNERSHIP;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        DISPATCH_INTERNAL_CRASH(which, <span class="string">&quot;Invalid transition&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ke = (dispatch_kevent_s)&#123;</span><br><span class="line">        .ident  = tid,</span><br><span class="line">        .filter = EVFILT_WORKLOOP,</span><br><span class="line">        .flags  = action,</span><br><span class="line">        .fflags = fflags,</span><br><span class="line">        .udata  = (<span class="type">uintptr_t</span>)wlh,</span><br><span class="line">        .qos    = (__typeof__(ke-&gt;qos))pp,</span><br><span class="line"></span><br><span class="line">        .ext[EV_EXTIDX_WL_MASK] = mask,</span><br><span class="line">        .ext[EV_EXTIDX_WL_VALUE] = dq_state,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以知道，这里 <code>fflags</code> 配置的是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fflags = NOTE_WL_SYNC_WAKE | NOTE_WL_END_OWNERSHIP;</span><br></pre></td></tr></table></figure><p>结合前面 <code>NOTE_WL_SYNC_WAIT</code>、<code>NOTE_WL_SYNC_WAKE</code> 相关内容可以知道，配置了 <code>NOTE_WL_SYNC_WAKE</code> 之后，在 <code>_dispatch_kq_poll</code> 内部调用的 <code>kevent_id</code>，会使当前唤醒当前被阻塞的线程，开始执行当前任务。</p><p>除此之外，在前面获取屏障锁成功之后的逻辑，所调用的 <code>_dispatch_lane_barrier_sync_invoke_and_complete</code> 函数，内部也是基本相同的唤起阻塞线程的逻辑。</p><p>可以使用一个简单的 Demo 验证这个流程：<br><img src="/images/lix_blog_222.png"><br>添加一个 <code>Symbolic</code> 断点，当调用到 <code>kevent_id</code> 函数时候，打印出调用堆栈：<br><img src="/images/lix_blog_223.png"><br>编译运行，打印信息如下：<br><img src="/images/lix_blog_224.png"><br>可以看到，打印的堆栈信息，和前面分析得出的结论一致。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>前面总结了使用 <code>dispatch_sync</code> 往串行队列提交任务的源码执行逻辑，对于 <code>dispatch_sync</code> 往并发队列提交任务的处理流程，将在后续分析 <code>dispatch_async</code> 源码时一起分析。</p><p>可以用下图表示上述的源码逻辑：<br><img src="/images/lix_blog_225.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCD 底层原理 2 - dispatch_queue</title>
      <link href="/posts/12465/"/>
      <url>/posts/12465/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Grand Central Dispatch（GCD）是 iOS 中一个强大的多线程编程框架，GCD 提供了一种高效、低级别的方式来管理并发任务。</p><p>GCD 是使用队列来调度任务的执行的，GCD 队列主要有这几种：</p><ul><li><strong>队列（Queue）</strong><ul><li>串行队列：任务按顺序执行，一个任务完成后才开始下一个任务。</li><li>并发队列：允许多个任务同时执行，任务的开始顺序是确定的，但完成顺序不一定。</li></ul></li><li><strong>主队列（Main Queue）</strong><ul><li>一个特殊的串行队列，用于在主线程上执行任务，通常用于更新 UI。</li><li>所有提交到主队列的任务，无论使用 dispatch_sync 还是 dispatch_async，都将在主线程执行。</li></ul></li><li><strong>全局并发队列（Global Concurrent Queue）</strong><ul><li>系统提供的并发队列，按不同优先级划分。</li></ul></li></ul><p>GCD 任务是指需要执行的代码块，有同步或异步执行两种方式：</p><ul><li><strong>同步执行（dispatch_sync）</strong>：阻塞当前线程，直到任务完成。</li><li><strong>异步执行（dispatch_async）</strong>：立即返回，不阻塞当前线程，任务在后台执行。</li></ul><p>其中，创建队列是通过 GCD 的 <code>dispatch_queue_create</code> 进行创建的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个串行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">&quot;com.lixkit.serialQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建一个并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">&quot;com.lixkit.concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><p>接下来，通过 <a href="(https://github.com/apple-oss-distributions/libdispatch)">libdispatch</a> 源码，看 <code>dispatch_queue_create</code>  实现原理。</p><h2 id="二、DISPATCH-QUEUE-SERIAL-DISPATCH-QUEUE-CONCURRENT"><a href="#二、DISPATCH-QUEUE-SERIAL-DISPATCH-QUEUE-CONCURRENT" class="headerlink" title="二、DISPATCH_QUEUE_SERIAL &amp; DISPATCH_QUEUE_CONCURRENT"></a>二、DISPATCH_QUEUE_SERIAL &amp; DISPATCH_QUEUE_CONCURRENT</h2><p>前面已经提到，创建队列是通过 <code>dispatch_queue_create</code> 进行创建的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个串行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">&quot;com.lixkit.serialQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建一个并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">&quot;com.lixkit.concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><p>创建串行队列和并发队列，用到了这两个宏：</p><ul><li><code>DISPATCH_QUEUE_SERIAL</code></li><li><code>DISPATCH_QUEUE_CONCURRENT</code></li></ul><h3 id="1、DISPATCH-QUEUE-SERIAL"><a href="#1、DISPATCH-QUEUE-SERIAL" class="headerlink" title="1、DISPATCH_QUEUE_SERIAL"></a>1、DISPATCH_QUEUE_SERIAL</h3><p><code>DISPATCH_QUEUE_SERIAL</code> 用于创建串行队列，这是个宏，其本质是 <code>NULL</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_SERIAL NULL</span></span><br></pre></td></tr></table></figure><h3 id="2、DISPATCH-QUEUE-CONCURRENT"><a href="#2、DISPATCH-QUEUE-CONCURRENT" class="headerlink" title="2、DISPATCH_QUEUE_CONCURRENT"></a>2、DISPATCH_QUEUE_CONCURRENT</h3><p><code>DISPATCH_QUEUE_CONCURRENT</code> 也是一个宏，且其定义中使用了一系列的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_CONCURRENT \</span></span><br><span class="line"><span class="meta">        DISPATCH_GLOBAL_OBJECT(dispatch_queue_attr_t, \</span></span><br><span class="line"><span class="meta">        _dispatch_queue_attr_concurrent)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_GLOBAL_OBJECT(type, object) ((OS_OBJECT_BRIDGE type)&amp;(object))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> _<span class="title">dispatch_queue_attr_concurrent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_OBJECT_BRIDGE __bridge</span></span><br></pre></td></tr></table></figure><p>将其完全展开后定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_CONCURRENT \</span></span><br><span class="line"><span class="meta">    ((__bridge dispatch_queue_attr_t)&amp;(_dispatch_queue_attr_concurrent))</span></span><br></pre></td></tr></table></figure><p>即 <code>DISPATCH_QUEUE_CONCURRENT</code> 是 <code>dispatch_queue_attr_t</code> 类型的指针，该指针是由全局变量 <code>_dispatch_queue_attr_concurrent</code> 的地址强制转换成的。</p><p><code>_dispatch_queue_attr_concurrent</code> 是什么呢？<br>上面提到，<code>DISPATCH_QUEUE_CONCURRENT</code> 是由全局变量 <code>_dispatch_queue_attr_concurrent</code> 转换成的，那么 <code>_dispatch_queue_attr_concurrent</code> 具体是什么呢？</p><p>可以看下 <code>init.c</code> 中下述源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DISPATCH_QUEUE_CONCURRENT resp. _dispatch_queue_attr_concurrent is aliased</span></span><br><span class="line"><span class="comment">// to array member [0] and their properties must match!</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> _<span class="title">dispatch_queue_attrs</span>[] =</span> &#123;</span><br><span class="line">    [<span class="number">0</span> ... DISPATCH_QUEUE_ATTR_COUNT - <span class="number">1</span>] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_attr),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在注释中明确提到， <code>DISPATCH_QUEUE_CONCURRENT</code> 和 <code>_dispatch_queue_attr_concurrent</code> 都是  <code>_dispatch_queue_attrs</code> 数组第 <code>0</code> 个元素的别名。即：<code>DISPATCH_QUEUE_CONCURRENT</code> 本质是  <code>_dispatch_queue_attrs</code> 数组第 <code>0</code> 个元素。</p><p>在上述 <code>_dispatch_queue_attrs</code> 数组的定义中，<code>DISPATCH_QUEUE_ATTR_COUNT</code> 宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QOS_USER_INTERACTIVE   ((dispatch_qos_t)6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QOS_MAX                DISPATCH_QOS_USER_INTERACTIVE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QOS_MIN_RELATIVE_PRIORITY (-15)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_QOS_COUNT (DISPATCH_QOS_MAX + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_PRIO_COUNT (1 - QOS_MIN_RELATIVE_PRIORITY)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_INACTIVE_COUNT 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_COUNT  ( \</span></span><br><span class="line"><span class="meta">        DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT * \</span></span><br><span class="line"><span class="meta">        DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT * \</span></span><br><span class="line"><span class="meta">        DISPATCH_QUEUE_ATTR_QOS_COUNT * \</span></span><br><span class="line"><span class="meta">        DISPATCH_QUEUE_ATTR_PRIO_COUNT * \</span></span><br><span class="line"><span class="meta">        DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT * \</span></span><br><span class="line"><span class="meta">        DISPATCH_QUEUE_ATTR_INACTIVE_COUNT )</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>DISPATCH_QUEUE_ATTR_COUNT</code> 是一系列宏参与乘法计算，其最终计算结果是 <code>4032</code>。</p><p><code>DISPATCH_GLOBAL_OBJECT_HEADER</code> 宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_GLOBAL_OBJECT_HEADER(name) \</span></span><br><span class="line"><span class="meta">    .do_vtable = DISPATCH_VTABLE(name), \</span></span><br><span class="line"><span class="meta">    .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, \</span></span><br><span class="line"><span class="meta">    .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_VTABLE(name) DISPATCH_OBJC_CLASS(name)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_OBJC_CLASS(name)   (&amp;DISPATCH_CLASS_SYMBOL(name))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_CLASS_SYMBOL(name) _dispatch_##name##_vtable</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_OBJECT_GLOBAL_REFCNT       _OS_OBJECT_GLOBAL_REFCNT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OS_OBJECT_GLOBAL_REFCNT INT_MAX</span></span><br></pre></td></tr></table></figure><p>将 <code>DISPATCH_GLOBAL_OBJECT_HEADER(queue_attr)</code> 完全展开后如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.do_vtable = (&amp;_dispatch_queue_attr_vtable), <span class="comment">// 通过宏展开得出虚函数表指针</span></span><br><span class="line">.do_ref_cnt = INT_MAX, <span class="comment">// 全局对象的引用计数</span></span><br><span class="line">.do_xref_cnt = INT_MAX <span class="comment">// 全局对象的弱引用计数</span></span><br></pre></td></tr></table></figure><p>综上， <code>_dispatch_queue_attrs</code> 实际定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DISPATCH_QUEUE_CONCURRENT 和 _dispatch_queue_attr_concurrent 本质是 _dispatch_queue_attrs 数组第 0 个元素</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> _<span class="title">dispatch_queue_attrs</span>[] =</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 GNU C 的范围设计符号初始化数组</span></span><br><span class="line">    <span class="comment">// [0 ... 4032 - 1] 指定数组的每个元素（从索引 0 到 4031，共计 4032 个元素）都被初始化为相同的值</span></span><br><span class="line">    [<span class="number">0</span> ... <span class="number">4032</span> - <span class="number">1</span>] = &#123;</span><br><span class="line">        <span class="comment">// 初始化 do_vtable 成员为指向 _dispatch_queue_attr_vtable 的指针</span></span><br><span class="line">        <span class="comment">// 这个指针用于指向虚函数表，定义了该结构体的行为和方法</span></span><br><span class="line">        .do_vtable = (&amp;_dispatch_queue_attr_vtable), <span class="comment">// 指向虚函数表的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 do_ref_cnt 成员为 INT_MAX</span></span><br><span class="line">        <span class="comment">// 这表示全局对象的引用计数，通常设置为 INT_MAX 以防止对象被释放</span></span><br><span class="line">        .do_ref_cnt = INT_MAX, <span class="comment">// 全局对象的引用计数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 do_xref_cnt 成员为 INT_MAX</span></span><br><span class="line">        <span class="comment">// 这表示全局对象的弱引用计数，同样设置为 INT_MAX，以确保对象在程序运行期间始终有效</span></span><br><span class="line">        .do_xref_cnt = INT_MAX <span class="comment">// 全局对象的弱引用计数</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尽管 <code>_dispatch_queue_attrs</code> 中 <code>4032</code> 个元素的初始值相同，但实际使用过程中会根据不同的条件或配置修改特定元素的属性，以支持不同的队列行为或策略。通过 <code>_dispatch_queue_attrs</code> 数组索引直接访问属性组合，而不是在运行时计算或生成新的组合，提升了访问的速度和效率。而 <code>DISPATCH_QUEUE_CONCURRENT</code> 则是 <code>_dispatch_queue_attrs</code> 数组的第 <code>0</code> 个元素。</p><h2 id="三、dispatch-queue-create"><a href="#三、dispatch-queue-create" class="headerlink" title="三、dispatch_queue_create"></a>三、dispatch_queue_create</h2><p><code>dispatch_queue_create</code> 函数源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_t</span></span><br><span class="line"><span class="title function_">dispatch_queue_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *label, <span class="type">dispatch_queue_attr_t</span> attr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_lane_create_with_target(label, attr,</span><br><span class="line">            DISPATCH_TARGET_QUEUE_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、参数-label-attr"><a href="#1、参数-label-attr" class="headerlink" title="1、参数 label &amp; attr"></a>1、参数 label &amp; attr</h3><h4 id="（1）label-参数"><a href="#（1）label-参数" class="headerlink" title="（1）label 参数"></a>（1）label 参数</h4><p><code>char *</code> 类型的参数，用于为队列指定一个标识符，通常是一个描述性的字符串。label 参数对队列的功能和行为没有影响，主要用于调试和日志记录，帮助开发者识别和跟踪不同的队列。经常使用反向域名格式（如 <code>&quot;com.lixkit.serialQueue&quot;</code>），以确保标签的唯一性和可读性。</p><h4 id="（2）attr-参数"><a href="#（2）attr-参数" class="headerlink" title="（2）attr 参数"></a>（2）attr 参数</h4><p><code>attr</code> 参数，直接从方法定义上看是 <code>dispatch_queue_attr_t</code> 类型，实际上，其源码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_DECL(dispatch_queue_attr);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_DECL(name) typedef struct name##_s *name##_t</span></span><br></pre></td></tr></table></figure><p>这意味着 <code>dispatch_queue_attr_t</code> 是 <code>struct dispatch_queue_attr_s</code> 的指针类型，<code>dispatch_queue_attr_s</code> 的定义涉及到一系列宏定义和其他结构体的嵌套，将其完全展开后源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     对象系统的基础类型</span></span><br><span class="line"><span class="comment">     _as_os_obj 是一个零长度数组，用于类型转换和内存布局</span></span><br><span class="line"><span class="comment">     在对象系统中，这个字段用于支持对象模型的基础结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> _<span class="title">as_os_obj</span>[0];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     do_vtable 是一个指向虚函数表的指针</span></span><br><span class="line"><span class="comment">     这个指针用于支持方法的动态分派，类似于C++中的虚函数机制</span></span><br><span class="line"><span class="comment">     __ptrauth_objc_isa_pointer 是一个指针认证标记，增强安全性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_vtable_s</span> *__<span class="title">ptrauth_objc_isa_pointer</span> <span class="title">do_vtable</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     强引用计数</span></span><br><span class="line"><span class="comment">     用于跟踪对象的引用次数，确保对象在被引用时不会被释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> do_ref_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     弱引用计数</span></span><br><span class="line"><span class="comment">     用于管理对象的弱引用关系，允许对象在没有强引用时被释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> do_xref_cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、返回值-dispatch-queue-t"><a href="#2、返回值-dispatch-queue-t" class="headerlink" title="2、返回值 dispatch_queue_t"></a>2、返回值 dispatch_queue_t</h3><p><code>dispatch_queue_create</code> 的返回值是 <code>dispatch_queue_t</code>，<code>dispatch_queue_t</code> 是一个指向 <code>dispatch_queue_s</code> 结构体的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">dispatch_queue_t</span>;</span></span><br></pre></td></tr></table></figure><p><code>dispatch_queue_s</code> 是一个复杂的结构体，包含了许多宏定义和其他结构体的嵌套。完全展开后的 <code>dispatch_queue_s</code> 源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line">    <span class="comment">// 作为基础对象的一部分，允许类型转换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> _<span class="title">as_do</span>[0];</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部对象头部定义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> _<span class="title">as_os_obj</span>[0];</span> <span class="comment">// 零长度数组，用于类型转换</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_vtable_s</span> *__<span class="title">ptrauth_objc_isa_pointer</span> <span class="title">do_vtable</span>;</span> <span class="comment">// 虚表指针，用于方法调度</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> do_ref_cnt;  <span class="comment">// 对象的引用计数</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> do_xref_cnt; <span class="comment">// 交叉引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> <span class="comment">// 下一个队列对象的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> <span class="comment">// 目标队列指针</span></span><br><span class="line">    <span class="type">void</span> *do_ctxt; <span class="comment">// 上下文指针</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">dispatch_function_t</span> DISPATCH_FUNCTION_POINTER do_finalizer; <span class="comment">// 终结器函数</span></span><br><span class="line">        <span class="type">void</span> *do_introspection_ctxt; <span class="comment">// 自省上下文</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *__dq_opaque1; <span class="comment">// 指针大小的字段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 32位整数，表示队列的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint64_t</span> <span class="keyword">volatile</span> dq_state; <span class="comment">// 队列状态</span></span><br><span class="line">        dispatch_lock dq_state_lock; <span class="comment">// 队列状态锁</span></span><br><span class="line">        <span class="type">uint32_t</span> dq_state_bits; <span class="comment">// 队列状态位</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LP64 全局队列缓存行边界</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dq_serialnum; <span class="comment">// 队列的序列号</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dq_label; <span class="comment">// 队列标签，用于标识队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，用于存储队列的标志和宽度</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> <span class="keyword">volatile</span> dq_atomic_flags; <span class="comment">// 队列的原子标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">const</span> <span class="type">uint16_t</span> dq_width; <span class="comment">// 队列的宽度，表示并发能力</span></span><br><span class="line">            <span class="type">const</span> <span class="type">uint16_t</span> __dq_opaque2; <span class="comment">// 额外的占位符字段</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">dispatch_priority_t</span> dq_priority; <span class="comment">// 队列优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，用于指向特定的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_specific_head_s</span> *<span class="title">dq_specific_head</span>;</span> <span class="comment">// 特定数据的头部</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_refs_s</span> *<span class="title">ds_refs</span>;</span> <span class="comment">// 源引用</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_timer_source_refs_s</span> *<span class="title">ds_timer_refs</span>;</span> <span class="comment">// 定时器源引用</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_recv_refs_s</span> *<span class="title">dm_recv_refs</span>;</span> <span class="comment">// Mach 消息接收引用</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_channel_callbacks_s</span> <span class="title">const</span> *<span class="title">dch_callbacks</span>;</span> <span class="comment">// 通道回调</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> dq_sref_cnt; <span class="comment">// 队列的强引用计数</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">8</span>))); <span class="comment">// 结构体按 8 字节对齐</span></span><br></pre></td></tr></table></figure><p>在 <code>dispatch_queue_s</code> 中，有多个匿名联合体，例如对于其中的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合体，用于存储队列的标志和宽度</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> <span class="keyword">volatile</span> dq_atomic_flags; <span class="comment">// 队列的原子标志</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">const</span> <span class="type">uint16_t</span> dq_width; <span class="comment">// 队列的宽度，表示并发能力</span></span><br><span class="line">        <span class="type">const</span> <span class="type">uint16_t</span> __dq_opaque2; <span class="comment">// 额外的占位符字段</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匿名联合体中还有个匿名结构体，该数据结构总结如下：</p><ul><li>联合体（<code>union</code>）<ul><li>联合体中的所有成员共享同一段内存。</li><li><code>dq_atomic_flags</code> 和下面的匿名结构体共享同一段内存，对 <code>dq_atomic_flags</code> 赋值实际上就是对下面的结构体赋值。</li><li><code>dq_atomic_flags</code> 是 <code>32</code> 位的无符号整数类型，其占用了 <code>32</code> 位的内存区域。</li></ul></li><li>匿名结构体<ul><li>上述源码中结构体是匿名的，包含两个 <code>uint16_t</code> 类型的成员：<code>dq_width</code> 和 <code>__dq_opaque2</code>，即各自分别占用 <code>16</code> 位内存。</li><li>由于结构体的成员在内存中的排序是按照它们声明的顺序依次排列的，所以 <code>dq_width</code> 和 <code>__dq_opaque2</code> 分别占用 <code>dq_atomic_flags</code> 的低 <code>16</code> 位和高 <code>16</code> 位。</li></ul></li></ul><h3 id="3、-dispatch-lane-create-with-target"><a href="#3、-dispatch-lane-create-with-target" class="headerlink" title="3、_dispatch_lane_create_with_target"></a>3、_dispatch_lane_create_with_target</h3><p>再回头看下 <code>dispatch_queue_create</code> 函数的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_t</span></span><br><span class="line"><span class="title function_">dispatch_queue_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *label, <span class="type">dispatch_queue_attr_t</span> attr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_lane_create_with_target(label, attr,</span><br><span class="line">            DISPATCH_TARGET_QUEUE_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>dispatch_queue_create</code> 函数内部主要是调用了 <code>_dispatch_lane_create_with_target</code> 函数。</p><p>其中第三个参数 <code>DISPATCH_TARGET_QUEUE_DEFAULT</code> 本质是个 <code>NULL</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @const DISPATCH_TARGET_QUEUE_DEFAULT</span></span><br><span class="line"><span class="comment"> * @discussion Constant to pass to the dispatch_queue_create_with_target(),</span></span><br><span class="line"><span class="comment"> * dispatch_set_target_queue() and dispatch_source_create() functions to</span></span><br><span class="line"><span class="comment"> * indicate that the default target queue for the object type in question</span></span><br><span class="line"><span class="comment"> * should be used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_TARGET_QUEUE_DEFAULT NULL</span></span><br><span class="line">```c</span><br><span class="line">`_dispatch_lane_create_with_target` 实现源码如下：</span><br><span class="line">```c</span><br><span class="line"><span class="type">static</span> <span class="type">dispatch_queue_t</span></span><br><span class="line">_dispatch_lane_create_with_target(<span class="type">const</span> <span class="type">char</span> *label, <span class="type">dispatch_queue_attr_t</span> dqa,</span><br><span class="line">        <span class="type">dispatch_queue_t</span> tq, <span class="type">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、生成 dqai</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成 dqai：将传入的队列属性转换为结构体 dispatch_queue_attr_info_t 类型的 dqai</span></span><br><span class="line">    <span class="comment">// dqai 中包含了队列的服务质量（QoS）、相对优先级、超额提交属性、自动释放频率、并发性和非活动状态等信息。</span></span><br><span class="line">    <span class="type">dispatch_queue_attr_info_t</span> dqai = _dispatch_queue_attr_to_info(dqa);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取服务质量（QoS）信息。</span></span><br><span class="line">    <span class="comment">// 服务质量（QoS）是指任务的优先级，影响任务调度的优先级和资源分配。</span></span><br><span class="line">    <span class="type">dispatch_qos_t</span> qos = dqai.dqai_qos;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">    <span class="comment">// 如果不支持 pthread 的 QoS，并且 QoS 是用户交互级别，则降级为用户发起级别。</span></span><br><span class="line">    <span class="comment">// 用户交互级别：用于需要立即响应用户交互的任务，优先级最高。</span></span><br><span class="line">    <span class="comment">// 用户发起级别：用于用户主动发起的任务，优先级高于默认级别。</span></span><br><span class="line">    <span class="keyword">if</span> (qos == DISPATCH_QOS_USER_INTERACTIVE) &#123;</span><br><span class="line">        dqai.dqai_qos = qos = DISPATCH_QOS_USER_INITIATED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 QoS 是维护级别，则降级为后台级别。</span></span><br><span class="line">    <span class="comment">// 维护级别：用于系统维护任务，优先级低。</span></span><br><span class="line">    <span class="comment">// 后台级别：用于后台运行的任务，优先级低于默认级别。</span></span><br><span class="line">    <span class="keyword">if</span> (qos == DISPATCH_QOS_MAINTENANCE) &#123;</span><br><span class="line">        dqai.dqai_qos = qos = DISPATCH_QOS_BACKGROUND;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !HAVE_PTHREAD_WORKQUEUE_QOS</span></span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  2、创建 tq</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提取超额提交属性。</span></span><br><span class="line">    <span class="comment">// 超额提交：允许队列超出系统建议的并发限制，可能会导致资源争用。</span></span><br><span class="line">    <span class="type">_dispatch_queue_attr_overcommit_t</span> overcommit = dqai.dqai_overcommit;</span><br><span class="line">    <span class="comment">// 如果指定了超额提交并且有目标队列。</span></span><br><span class="line">    <span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified &amp;&amp; tq) &#123;</span><br><span class="line">        <span class="comment">// 如果目标队列不是全局队列，则崩溃。</span></span><br><span class="line">        <span class="comment">// 目标队列：队列的执行目标队列，可以是全局队列或其他队列。</span></span><br><span class="line">        <span class="keyword">if</span> (tq-&gt;do_targetq) &#123;</span><br><span class="line">            DISPATCH_CLIENT_CRASH(tq, <span class="string">&quot;Cannot specify both overcommit and &quot;</span></span><br><span class="line">                    <span class="string">&quot;a non-global target queue&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果目标队列是全局根队列。</span></span><br><span class="line">    <span class="comment">// 根队列：GCD 提供的全局并发队列，系统级别的队列。</span></span><br><span class="line">    <span class="keyword">if</span> (tq &amp;&amp; dx_type(tq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// 处理属性和目标队列之间的差异，以属性为准。</span></span><br><span class="line">        <span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) &#123;</span><br><span class="line">                overcommit = _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                overcommit = _dispatch_queue_attr_overcommit_disabled;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 QoS 未指定，则从目标队列中获取。</span></span><br><span class="line">        <span class="keyword">if</span> (qos == DISPATCH_QOS_UNSPECIFIED) &#123;</span><br><span class="line">            qos = _dispatch_priority_qos(tq-&gt;dq_priority);</span><br><span class="line">        &#125;</span><br><span class="line">        tq = <span class="literal">NULL</span>; <span class="comment">// 清除目标队列引用。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tq &amp;&amp; _dispatch_queue_is_cooperative(tq)) &#123;</span><br><span class="line">        <span class="comment">// 如果目标队列是协作型根队列，则崩溃（未实现）。</span></span><br><span class="line">        <span class="comment">// 协作型根队列：一种特殊的根队列，尚未实现。</span></span><br><span class="line">        DISPATCH_CLIENT_CRASH(tq, <span class="string">&quot;Cannot target object to cooperative root queue - not implemented&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tq &amp;&amp; !tq-&gt;do_targetq) &#123;</span><br><span class="line">        <span class="comment">// 如果目标是 pthread 或 runloop 根队列，不允许设置 QoS 或超额提交。</span></span><br><span class="line">        <span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">            DISPATCH_CLIENT_CRASH(tq, <span class="string">&quot;Cannot specify an overcommit attribute &quot;</span></span><br><span class="line">                    <span class="string">&quot;and use this kind of target queue&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果未指定超额提交，串行队列默认开启超额提交。即：串行队列是 overcommit 的，并发队列是非 overcommit 的</span></span><br><span class="line">        <span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">            overcommit = dqai.dqai_concurrent ?</span><br><span class="line">                    _dispatch_queue_attr_overcommit_disabled :</span><br><span class="line">                    _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有目标队列，根据 QoS 获取根队列。</span></span><br><span class="line">    <span class="comment">// dispatch_queue_create 函数，tq 参数是 DISPATCH_TARGET_QUEUE_DEFAULT 宏，即 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> flags = (overcommit == _dispatch_queue_attr_overcommit_enabled) ? DISPATCH_QUEUE_OVERCOMMIT : <span class="number">0</span>;</span><br><span class="line">        tq = _dispatch_get_root_queue(</span><br><span class="line">                qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">                    flags)-&gt;_as_dq;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!tq)) &#123;</span><br><span class="line">            DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、初始化队列 dq</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch_queue_create 函数，legacy 参数传的 true</span></span><br><span class="line">    <span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">        <span class="comment">// 如果指定了非传统属性，则使用非传统类。</span></span><br><span class="line">        <span class="comment">// 非传统属性：例如非活动状态或自动释放频率。</span></span><br><span class="line">        <span class="comment">// 非传统类：指不使用传统的队列类。</span></span><br><span class="line">        <span class="keyword">if</span> (dqai.dqai_inactive || dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">            legacy = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *vtable;</span><br><span class="line">    <span class="type">dispatch_queue_flags_t</span> dqf = legacy ? DQF_MUTABLE : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据并发属性选择虚函数表。</span></span><br><span class="line">    <span class="comment">// 虚函数表：包含对象方法指针的表，用于动态调度。</span></span><br><span class="line">    <span class="keyword">if</span> (dqai.dqai_concurrent) &#123;</span><br><span class="line">        <span class="comment">// 宏展开后：vtable = &amp;_dispatch_queue_concurrent_vtable</span></span><br><span class="line">        vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 宏展开后：vtable = &amp;_dispatch_queue_serial_vtable</span></span><br><span class="line">        vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置自动释放频率标志。</span></span><br><span class="line">    <span class="comment">// 自动释放频率：控制自动释放池的刷新频率。</span></span><br><span class="line">    <span class="keyword">switch</span> (dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_NEVER:</span><br><span class="line">        dqf |= DQF_AUTORELEASE_NEVER;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM:</span><br><span class="line">        dqf |= DQF_AUTORELEASE_ALWAYS;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有标签，复制标签并设置需要释放标志。</span></span><br><span class="line">    <span class="keyword">if</span> (label) &#123;</span><br><span class="line">        <span class="comment">// 调用 _dispatch_strdup_if_mutable 函数创建标签的副本</span></span><br><span class="line">        <span class="comment">// _dispatch_strdup_if_mutable 函数总是调用 strdup 创建一个新的字符串副本</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *tmp = _dispatch_strdup_if_mutable(label);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查新创建的副本（tmp）是否与原始标签（label）不同</span></span><br><span class="line">        <span class="comment">// 如果 tmp != label，说明创建了一个新的字符串副本，内存地址不同</span></span><br><span class="line">        <span class="keyword">if</span> (tmp != label) &#123;</span><br><span class="line">            <span class="comment">// 设置 DQF_LABEL_NEEDS_FREE 标志，表示需要在适当的时候释放这个标签</span></span><br><span class="line">            <span class="comment">// 这样做是为了在队列销毁时能够正确释放标签内存，避免内存泄漏</span></span><br><span class="line">            dqf |= DQF_LABEL_NEEDS_FREE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将标签变量更新为新创建的副本</span></span><br><span class="line">            <span class="comment">// 这样后续操作将使用这个新的标签副本，而不是原始标签</span></span><br><span class="line">            label = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 分配内存</span></span><br><span class="line">    <span class="comment">// 注意，dq 是 dispatch_lane_t 类型</span></span><br><span class="line">    <span class="type">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_lane_s));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.2 初始化</span></span><br><span class="line">    _dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">            DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">            (dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置队列标签和优先级。</span></span><br><span class="line">    dq-&gt;dq_label = label;</span><br><span class="line">    dq-&gt;dq_priority = _dispatch_priority_make((<span class="type">dispatch_qos_t</span>)dqai.dqai_qos,</span><br><span class="line">            dqai.dqai_relpri);</span><br><span class="line">    <span class="comment">// 如果开启超额提交，设置相应标志。</span></span><br><span class="line">    <span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">        dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列不是非活动状态，继承目标队列的优先级和工作循环。</span></span><br><span class="line">    <span class="keyword">if</span> (!dqai.dqai_inactive) &#123;</span><br><span class="line">        _dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">        _dispatch_lane_inherit_wlh_from_target(dq, tq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保留目标队列引用。</span></span><br><span class="line">    _dispatch_retain(tq);</span><br><span class="line">    <span class="comment">// 设置目标 targetq 为 tq</span></span><br><span class="line">    dq-&gt;do_targetq = tq;</span><br><span class="line">    <span class="comment">// 调试输出。</span></span><br><span class="line">    _dispatch_object_debug(dq, <span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="comment">// 返回创建的队列。</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述逻辑比较多，可以将上面逻辑拆分成下面这部分：</p><ul><li><strong>生成 <code>dqai</code>（<code>dispatch_queue_attr_info_t</code>）</strong></li><li><strong>创建 <code>tq</code>（<code>dispatch_queue_t</code>）</strong></li><li><strong>初始化队列 <code>dq</code>（<code>dispatch_lane_t</code>）</strong><ul><li>分配内存</li><li>初始化</li></ul></li><li><strong><code>dq</code> 其他配置</strong></li></ul><p>接下来，基于源码分别看下上述各部分逻辑。</p><h4 id="（1）生成-dqai"><a href="#（1）生成-dqai" class="headerlink" title="（1）生成 dqai"></a>（1）生成 dqai</h4><p><code>dqai</code> 是 <code>dispatch_queue_attr_info_t</code> 结构体类型，<code>dqai</code> 中包含了队列的服务质量（QoS）、相对优先级、超额提交属性、自动释放频率、并发性和非活动状态等信息。</p><p><code>dispatch_queue_attr_info_t</code> 结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_info_s</span> &#123;</span></span><br><span class="line">    <span class="comment">// 服务质量（QoS），占用 8 位。</span></span><br><span class="line">    <span class="comment">// QoS 决定了任务的优先级，影响调度和资源分配。</span></span><br><span class="line">    <span class="type">dispatch_qos_t</span> dqai_qos : <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对优先级，占用 8 位。</span></span><br><span class="line">    <span class="comment">// 这是相对于服务质量（QoS）的优先级调整值，用于进一步微调任务的调度优先级。</span></span><br><span class="line">    <span class="type">int</span> dqai_relpri : <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超额提交属性，占用 2 位。</span></span><br><span class="line">    <span class="comment">// 指示队列是否允许超出系统建议的并发限制。</span></span><br><span class="line">    <span class="comment">// 可能的值可以表示启用、禁用或未指定。</span></span><br><span class="line">    <span class="type">uint16_t</span> dqai_overcommit : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动释放频率，占用 2 位。</span></span><br><span class="line">    <span class="comment">// 控制自动释放池的刷新频率，可能的值包括从不、每个工作项或默认。</span></span><br><span class="line">    <span class="type">uint16_t</span> dqai_autorelease_frequency : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发性属性，占用 1 位。</span></span><br><span class="line">    <span class="comment">// 指示队列是并发队列（多个任务可以同时执行）还是串行队列（任务按顺序执行）。</span></span><br><span class="line">    <span class="type">uint16_t</span> dqai_concurrent : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非活动状态，占用 1 位。</span></span><br><span class="line">    <span class="comment">// 指示队列是否在初始化时处于非活动状态。</span></span><br><span class="line">    <span class="comment">// 非活动队列在激活之前不会调度任务。</span></span><br><span class="line">    <span class="type">uint16_t</span> dqai_inactive : <span class="number">1</span>;</span><br><span class="line">&#125; <span class="type">dispatch_queue_attr_info_t</span>;</span><br></pre></td></tr></table></figure><p>生成 <code>dqai</code> 是通过 <code>_dispatch_queue_attr_to_info</code> 函数实现的，<code>_dispatch_queue_attr_to_info</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_attr_info_t</span></span><br><span class="line">_dispatch_queue_attr_to_info(<span class="type">dispatch_queue_attr_t</span> dqa)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化一个队列属性信息结构体，用于存储解析后的队列属性。</span></span><br><span class="line">    <span class="comment">// 这个结构体包含了服务质量（QoS）、相对优先级、超额提交设置、自动释放频率、并发性和非活动状态等信息。</span></span><br><span class="line">    <span class="type">dispatch_queue_attr_info_t</span> dqai = &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入的队列属性为空，则返回默认初始化的结构体。</span></span><br><span class="line">    <span class="keyword">if</span> (!dqa) <span class="keyword">return</span> dqai;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查传入的队列属性是否在有效范围内。</span></span><br><span class="line">    <span class="comment">// 如果不在范围内，则崩溃，因为这意味着传入了无效的队列属性。</span></span><br><span class="line">    <span class="keyword">if</span> (dqa &lt; _dispatch_queue_attrs ||</span><br><span class="line">            dqa &gt;= &amp;_dispatch_queue_attrs[DISPATCH_QUEUE_ATTR_COUNT]) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(dqa-&gt;do_vtable, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算索引值，用于解析不同的属性。</span></span><br><span class="line">    <span class="comment">// 这里使用的是一个偏移量计算方法，根据不同的属性组合得出唯一的索引。</span></span><br><span class="line">    <span class="type">size_t</span> idx = (<span class="type">size_t</span>)(dqa - _dispatch_queue_attrs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析非活动状态属性。</span></span><br><span class="line">    <span class="comment">// 通过索引对非活动状态的总数取模，判断该属性是否设置。</span></span><br><span class="line">    dqai.dqai_inactive = (idx % DISPATCH_QUEUE_ATTR_INACTIVE_COUNT);</span><br><span class="line">    <span class="comment">// 更新索引，准备解析下一个属性。</span></span><br><span class="line">    idx /= DISPATCH_QUEUE_ATTR_INACTIVE_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并发性属性。</span></span><br><span class="line">    <span class="comment">// 通过索引对并发性属性的总数取模，判断队列是并发还是串行。</span></span><br><span class="line">    dqai.dqai_concurrent = !(idx % DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT);</span><br><span class="line">    <span class="comment">// 更新索引，准备解析下一个属性。</span></span><br><span class="line">    idx /= DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析相对优先级属性。</span></span><br><span class="line">    <span class="comment">// 通过索引对优先级属性的总数取模，获取相对优先级值。</span></span><br><span class="line">    dqai.dqai_relpri = -(<span class="type">int</span>)(idx % DISPATCH_QUEUE_ATTR_PRIO_COUNT);</span><br><span class="line">    <span class="comment">// 更新索引，准备解析下一个属性。</span></span><br><span class="line">    idx /= DISPATCH_QUEUE_ATTR_PRIO_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析服务质量（QoS）属性。</span></span><br><span class="line">    <span class="comment">// 通过索引对 QoS 属性的总数取模，获取 QoS 值。</span></span><br><span class="line">    dqai.dqai_qos = idx % DISPATCH_QUEUE_ATTR_QOS_COUNT;</span><br><span class="line">    <span class="comment">// 更新索引，准备解析下一个属性。</span></span><br><span class="line">    idx /= DISPATCH_QUEUE_ATTR_QOS_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析自动释放频率属性。</span></span><br><span class="line">    <span class="comment">// 通过索引对自动释放频率属性的总数取模，获取自动释放频率。</span></span><br><span class="line">    dqai.dqai_autorelease_frequency =</span><br><span class="line">            idx % DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;</span><br><span class="line">    <span class="comment">// 更新索引，准备解析下一个属性。</span></span><br><span class="line">    idx /= DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析超额提交属性。</span></span><br><span class="line">    <span class="comment">// 通过索引对超额提交属性的总数取模，获取超额提交设置。</span></span><br><span class="line">    dqai.dqai_overcommit = idx % DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;</span><br><span class="line">    <span class="comment">// 更新索引，准备解析下一个属性。</span></span><br><span class="line">    idx /= DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回解析后的队列属性信息结构体。</span></span><br><span class="line">    <span class="keyword">return</span> dqai;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面已经提到，当创建串行队列时，<code>attr</code> 参数为 <code>DISPATCH_QUEUE_SERIAL</code>，本质为 <code>NULL</code>。此时 <code>_dispatch_queue_attr_to_info</code> 函数返回值为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_attr_info_t</span> dqai = &#123;</span><br><span class="line">    .dqai_qos = <span class="number">0</span>,</span><br><span class="line">    .dqai_relpri = <span class="number">0</span>,</span><br><span class="line">    .dqai_overcommit = <span class="number">0</span>,</span><br><span class="line">    .dqai_autorelease_frequency = <span class="number">0</span>,</span><br><span class="line">    .dqai_concurrent = <span class="number">0</span>, <span class="comment">// 串行队列</span></span><br><span class="line">    .dqai_inactive = <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当创建并发队列时，<code>attr</code> 参数为 <code>DISPATCH_QUEUE_CONCURRENT</code>，此时 <code>_dispatch_queue_attr_to_info</code> 函数返回值为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_attr_info_t dqai = &#123;</span><br><span class="line">    .dqai_qos = 0,</span><br><span class="line">    .dqai_relpri = 0,</span><br><span class="line">    .dqai_overcommit = 0,</span><br><span class="line">    .dqai_autorelease_frequency = 0,</span><br><span class="line">    .dqai_concurrent = 1, // 并发队列</span><br><span class="line">    .dqai_inactive = 0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以，当创建串行、并发队列时，<code>_dispatch_queue_attr_to_info</code> 函数返回的结果仅 <code>dqai_concurrent</code> 值不同，分别是 <code>0</code> 和 <code>1</code>。</p><h4 id="（2）创建-tq"><a href="#（2）创建-tq" class="headerlink" title="（2）创建 tq"></a>（2）创建 tq</h4><p>根据前述源码，在创建 tq 前需要先获取超额提交属性 <code>overcommit</code>，<br><code>dispatch_queue_create</code> 函数在调用时 <code>_dispatch_lane_create_with_target</code>，<code>tq</code> 参数传入的是 <code>DISPATCH_TARGET_QUEUE_DEFAULT</code>，前面已经提到，<code>DISPATCH_TARGET_QUEUE_DEFAULT</code> 本质是个 <code>NULL</code>，所以会走调用下面的 if 分支：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">    overcommit = dqai.dqai_concurrent ?</span><br><span class="line">            _dispatch_queue_attr_overcommit_disabled :</span><br><span class="line">            _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，创建串行队列时，<code>overcommi</code>t 为 <code>_dispatch_queue_attr_overcommit_enabled</code>。创建并发队列时，<code>overcommit</code> 为 <code>_dispatch_queue_attr_overcommit_enabled</code>。</p><p>从此处可以得到一个结论：串行队列是 <code>overcommit</code> 的，并发队列是非 <code>overcommit</code> 的。</p><p>接下来进入 <code>tq</code> 的创建逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有目标队列，根据 QoS 获取根队列。</span></span><br><span class="line"><span class="comment">// dispatch_queue_create 函数，tq 参数是 DISPATCH_TARGET_QUEUE_DEFAULT 宏，即 NULL</span></span><br><span class="line"><span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> flags = (overcommit == _dispatch_queue_attr_overcommit_enabled) ? DISPATCH_QUEUE_OVERCOMMIT : <span class="number">0</span>;</span><br><span class="line">    tq = _dispatch_get_root_queue(</span><br><span class="line">            qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">                flags)-&gt;_as_dq;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!tq)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>_dispatch_get_root_queue</code> 实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_queue_global_t</span></span><br><span class="line">_dispatch_get_root_queue(<span class="type">dispatch_qos_t</span> qos, <span class="type">uintptr_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查 QoS 是否在有效范围内。如果不在范围内，则触发崩溃。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(qos &lt; DISPATCH_QOS_MIN || qos &gt; DISPATCH_QOS_MAX)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Corrupted priority&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> add_on = <span class="number">0</span>; <span class="comment">// 初始化索引偏移量为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据标志设置索引偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DISPATCH_QUEUE_OVERCOMMIT) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了 OVERCOMMIT 标志，使用 OVERCOMMIT 偏移量</span></span><br><span class="line">        add_on = DISPATCH_ROOT_QUEUE_IDX_OFFSET_OVERCOMMIT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; DISPATCH_QUEUE_COOPERATIVE) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了 COOPERATIVE 标志，使用 COOPERATIVE 偏移量</span></span><br><span class="line">        add_on = DISPATCH_ROOT_QUEUE_IDX_OFFSET_COOPERATIVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并返回指向合适的全局根队列的指针</span></span><br><span class="line">    <span class="comment">// 计算公式为：3 * (qos - 1) + add_on</span></span><br><span class="line">    <span class="comment">// 其中，3 是每个 QoS 级别有三个不同类型的队列（普通、超额提交、协作）</span></span><br><span class="line">    <span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">3</span> * (qos - <span class="number">1</span>) + add_on];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先看下 <code>_dispatch_root_queues</code>，<code>_dispatch_root_queues</code> 是一个 <code>dispatch_queue_global_s</code> 类型的数组，先看下 <code>dispatch_queue_global_s</code> 的定义，<code>dispatch_queue_global_s</code> 的定义涉及击到一系列宏，将其完全展开后如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_global_s</span> &#123;</span></span><br><span class="line">    <span class="comment">// 零长度数组，用于类型转换为 dispatch_queue_s</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> _<span class="title">as_dq</span>[0];</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch 对象头部定义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> _<span class="title">as_do</span>[0];</span> <span class="comment">// 零长度数组，用于类型转换为 dispatch_object_s</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> _<span class="title">as_os_obj</span>[0];</span> <span class="comment">// 零长度数组，用于类型转换为 _os_object_s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的虚表指针，用于方法调度</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> *__<span class="title">ptrauth_objc_isa_pointer</span> <span class="title">do_vtable</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的引用计数</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> do_ref_cnt;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交叉引用计数</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> do_xref_cnt; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个队列对象的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标队列指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文指针</span></span><br><span class="line">    <span class="type">void</span> *do_ctxt; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，包含终结器函数或自省上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">dispatch_function_t</span> DISPATCH_FUNCTION_POINTER do_finalizer; </span><br><span class="line">        <span class="type">void</span> *do_introspection_ctxt; </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针大小的字段，指向队列尾部的对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_tail</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池大小</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> dgq_thread_pool_size; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针大小的字段，指向队列头部的对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_head</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起的线程数</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> dgq_pending; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，用于存储队列的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint64_t</span> <span class="keyword">volatile</span> dq_state; <span class="comment">// 队列状态</span></span><br><span class="line">        dispatch_lock dq_state_lock; <span class="comment">// 队列状态锁</span></span><br><span class="line">        <span class="type">uint32_t</span> dq_state_bits; <span class="comment">// 队列状态位</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LP64 全局队列缓存行边界</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dq_serialnum; <span class="comment">// 队列的序列号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列标签，用于标识队列</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dq_label; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，用于存储队列的标志和宽度</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> <span class="keyword">volatile</span> dq_atomic_flags; <span class="comment">// 队列的原子标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">const</span> <span class="type">uint16_t</span> dq_width; <span class="comment">// 队列的宽度，即：队列能够同时处理的任务的数量</span></span><br><span class="line">            <span class="type">const</span> <span class="type">uint16_t</span> __dq_opaque2; <span class="comment">// 额外的占位符字段</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列优先级</span></span><br><span class="line">    <span class="type">dispatch_priority_t</span> dq_priority; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，用于指向特定的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_specific_head_s</span> *<span class="title">dq_specific_head</span>;</span> <span class="comment">// 特定数据的头部</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_refs_s</span> *<span class="title">ds_refs</span>;</span> <span class="comment">// 源引用</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_timer_source_refs_s</span> *<span class="title">ds_timer_refs</span>;</span> <span class="comment">// 定时器源引用</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_recv_refs_s</span> *<span class="title">dm_recv_refs</span>;</span> <span class="comment">// Mach 消息接收引用</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_channel_callbacks_s</span> <span class="title">const</span> *<span class="title">dch_callbacks</span>;</span> <span class="comment">// 通道回调</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的强引用计数</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> dq_sref_cnt; </span><br><span class="line">&#125; __attribute__((__aligned__(<span class="number">64</span>))); <span class="comment">// 结构体按 64 字节对齐</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>dispatch_queue_global_s</code> 与前面提到的 <code>dispatch_queue_s</code> 结构几乎是一样的，最大的区别是 <code>dispatch_queue_global_s</code> 中多了个 <code>struct dispatch_queue_s _as_dq[0]; </code> 的零长数组，意味着可以通过 <code>_as_dq</code> 将 <code>dispatch_queue_global_s</code> 转成 <code>dispatch_queue_s</code>。</p><p>这种设计在 libdispatch 的源码中非常常见，通常用于类型转换或类型兼容性，这种设计的原理是：</p><ul><li><strong>内存布局和对齐</strong><ul><li>在 C 语言中，结构体的内存布局是由其成员的声明顺序决定的。编译器会按照声明的顺序为每个成员分配内存，并根据目标平台的对齐要求进行对齐。</li><li>零长度数组在内存中不占用空间，但它的存在可以影响后续成员的对齐和布局。</li></ul></li><li><strong>类型转换的目的</strong><ul><li>当一个结构体包含另一个结构体的零长度数组时，编译器会将该数组视作一个指向数组元素类型的指针。这意味着，在内存布局上，该结构体的起始位置与零长度数组的元素类型的起始位置一致。</li><li>通过这种方式，包含零长度数组的结构体可以与数组元素类型具有相同的内存起始布局，从而实现类型兼容。</li></ul></li><li><strong>类型兼容性的实现</strong><ul><li>例如，<code>dispatch_queue_global_s</code> 包含 <code>struct dispatch_queue_s _as_dq[0]</code>，这意味着在内存布局上，<code>dispatch_queue_global_s</code> 的起始位置与 <code>dispatch_queue_s</code> 的起始位置一致。</li><li>这允许通过 <code>_as_dq</code> 指针将 <code>dispatch_queue_global_s</code> 视作 <code>dispatch_queue_s</code>，因为它们在内存中的起始位置是相同的。</li></ul></li><li><strong>实现多态性</strong><ul><li>这种设计模式允许使用不同类型的结构体通过相同的接口进行操作，实现多态性和灵活性。</li><li>通过零长度数组或灵活数组成员，开发者可以在不增加内存开销的情况下，实现类型之间的灵活转换。</li></ul></li></ul><p><code>_dispatch_root_queues</code> 的定义中也涉及到一系列宏定义，将 <code>_dispatch_root_queues</code> 内部宏定义完全展开后，实际内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_global_s</span> _<span class="title">dispatch_root_queues</span>[] =</span> &#123;</span><br><span class="line">    <span class="comment">// MAINTENANCE QOS</span></span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_MAINTENANCE, <span class="number">0</span>),</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.maintenance-qos&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS_OVERCOMMIT),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_MAINTENANCE, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.maintenance-qos.overcommit&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS_COOPERATIVE] = &#123;</span><br><span class="line">        .do_vtable = DISPATCH_VTABLE(queue_concurrent),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_MAINTENANCE, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_COOPERATIVE,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.maintenance-qos.cooperative&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">6</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// BACKGROUND QOS</span></span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_BACKGROUND, <span class="number">0</span>),</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.background-qos&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">7</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS_OVERCOMMIT),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_BACKGROUND, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.background-qos.overcommit&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">8</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS_COOPERATIVE] = &#123;</span><br><span class="line">        .do_vtable = DISPATCH_VTABLE(queue_concurrent),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_BACKGROUND, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_COOPERATIVE,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.background-qos.cooperative&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">9</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// UTILITY QOS</span></span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_UTILITY, <span class="number">0</span>),</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.utility-qos&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">10</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS_OVERCOMMIT),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_UTILITY, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.utility-qos.overcommit&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">11</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS_COOPERATIVE] = &#123;</span><br><span class="line">        .do_vtable = DISPATCH_VTABLE(queue_concurrent),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_UTILITY, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_COOPERATIVE,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.utility-qos.cooperative&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">12</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// DEFAULT QOS</span></span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT),</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.default-qos&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">13</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.default-qos.overcommit&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">14</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_COOPERATIVE] = &#123;</span><br><span class="line">        .do_vtable = DISPATCH_VTABLE(queue_concurrent),</span><br><span class="line">        .dq_priority = _dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT) | DISPATCH_PRIORITY_FLAG_COOPERATIVE,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.default-qos.cooperative&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">15</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// USER_INITIATED QOS</span></span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_USER_INITIATED, <span class="number">0</span>),</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">16</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS_OVERCOMMIT),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_USER_INITIATED, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos.overcommit&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">17</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS_COOPERATIVE] = &#123;</span><br><span class="line">        .do_vtable = DISPATCH_VTABLE(queue_concurrent),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_USER_INITIATED, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_COOPERATIVE,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos.cooperative&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">18</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// USER_INTERACTIVE QOS</span></span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_USER_INTERACTIVE, <span class="number">0</span>),</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">19</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS_OVERCOMMIT),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_USER_INTERACTIVE, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos.overcommit&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">20</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS_COOPERATIVE] = &#123;</span><br><span class="line">        .do_vtable = DISPATCH_VTABLE(queue_concurrent),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_USER_INTERACTIVE, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_COOPERATIVE,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos.cooperative&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">21</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据源码可知，<code>_dispatch_root_queues</code> 本质就是一个数组，数组的 <code>index</code> 是个枚举，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS = <span class="number">0</span>,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS_COOPERATIVE,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS_COOPERATIVE,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS_COOPERATIVE,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_COOPERATIVE,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS_COOPERATIVE,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS_COOPERATIVE,</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_IDX_COUNT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据枚举定义也可以看出，数组的 <code>index</code> 是通过不同的调度策略进行拼接的，<code>_dispatch_get_root_queue</code> 中会根据不同的策略计算出对应的 <code>index</code> 从 <code>_dispatch_root_queues</code> 数组中取值。</p><p>再回到 <code>_dispatch_get_root_queue</code> 函数，看创建串行、并发队列时，传入的 <code>index</code>，经过计算可以知道，创建串行队列时，<code>index = 10</code>，创建并发队列时 <code>index = 9</code>。</p><p>所以创建串行队列时，返回的是 <code>_dispatch_root_queues</code> 数组 <code>index = 10</code> 的元素（<code>DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT</code>），即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">    DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">    .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">    .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT),</span><br><span class="line">    .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">    .dq_priority = _dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">    .dq_label = <span class="string">&quot;com.apple.root.default-qos.overcommit&quot;</span>,</span><br><span class="line">    .dq_serialnum = <span class="number">14</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>创建并发队列时，返回的是 <code>_dispatch_root_queues</code> 数组 <code>index = 9</code> 的元素（<code>DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS</code>），即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS] = &#123;</span><br><span class="line">    DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">    .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">    .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS),</span><br><span class="line">    .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">    .dq_priority = _dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT),</span><br><span class="line">    .dq_label = <span class="string">&quot;com.apple.root.default-qos&quot;</span>,</span><br><span class="line">    .dq_serialnum = <span class="number">13</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这里创建完成的 <code>tq</code> 会在前述的 <code>_dispatch_lane_create_with_target</code> 后续逻辑中被设置成队列的 <code>do_targetq</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">dispatch_queue_t</span></span><br><span class="line">_dispatch_lane_create_with_target(<span class="type">const</span> <span class="type">char</span> *label, <span class="type">dispatch_queue_attr_t</span> dqa,</span><br><span class="line">        <span class="type">dispatch_queue_t</span> tq, <span class="type">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> flags = (overcommit == _dispatch_queue_attr_overcommit_enabled) ? DISPATCH_QUEUE_OVERCOMMIT : <span class="number">0</span>;</span><br><span class="line">        tq = _dispatch_get_root_queue(</span><br><span class="line">                qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">                    flags)-&gt;_as_dq;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    dq-&gt;do_targetq = tq;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以对于自定义的队列，无论是串行队列还是并发队列，其 <code>do_targetq</code> 都是从根队列数组 <code>_dispatch_root_queues</code> 中取出的对应的根队列（root queue）。</p><h4 id="（3）初始化队列-dq（dispatch-lane-t）"><a href="#（3）初始化队列-dq（dispatch-lane-t）" class="headerlink" title="（3）初始化队列 dq（dispatch_lane_t）"></a>（3）初始化队列 dq（dispatch_lane_t）</h4><p><code>_dispatch_lane_create_with_target</code> 函数中，创建的 <code>dq</code> 是 <code>dispatch_lane_t</code> 类型，那 <code>dispatch_lane_t</code> 和前面提到的 <code>dispatch_queue_s</code> 类型是什么关系呢？</p><p><code>dispatch_lane_t</code> 是一个指向 <code>dispatch_lane_s</code> 结构体的指针类型。<code>dispatch_lane_s</code> 是 <code>dispatch_queue_s</code> 的子类型，继承了队列的基本功能，并扩展了用于任务调度的字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_s</span> &#123;</span></span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dq_items_head</span>;</span> <span class="comment">// 队列头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dq_items_tail</span>;</span> <span class="comment">// 队列尾</span></span><br><span class="line">    dispatch_unfair_lock_s dq_sidelock; <span class="comment">// 辅助锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch_queue_s 包含的其他字段 ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从 <code>_dispatch_lane_create_with_target</code> 函数实现上来看，如果创建的串行队列还是并发队列，返回的都是 <code>dispatch_lane_s</code> 类型。</p><p>初始化队列 <code>dq</code> 可以分成两部分逻辑来看：</p><ul><li><strong>分配内存</strong></li><li><strong>初始化</strong></li></ul><h5 id="a、分配内存"><a href="#a、分配内存" class="headerlink" title="a、分配内存"></a>a、分配内存</h5><p>分配内存主要是通过 <code>_dispatch_object_alloc</code> 函数实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_lane_s));</span><br></pre></td></tr></table></figure><p>其中，<code>vtable</code> 参数值通过下述逻辑获取的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dqai.dqai_concurrent) &#123;</span><br><span class="line">    <span class="comment">// 宏展开后：vtable = &amp;_dispatch_queue_concurrent_vtable</span></span><br><span class="line">    vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 宏展开后：vtable = &amp;_dispatch_queue_serial_vtable</span></span><br><span class="line">    vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vtable</code> 实际上是一个虚表(虚函数表)，虚表主要用于支持多态性和动态方法调用，允许对象在运行时调用对应的函数实现。一个类中有虚函数（<code>virtual</code> 关键字声明的函数）时，编译器会自动为该类及其派生类自动生成虚表，虚表中的指针会指向派生类的实现。</p><p>可以简单理解为虚表中存储了函数具体实现的指针。对应的类或结构体，通过访问虚表中的函数指针可以调用到对应的函数实现。</p><p>由上述源码可以知道，当创建串行队列时，<code>vtable</code> 为 <code>&amp;_dispatch_queue_serial_vtable</code>，当创建并发队列时，<code>vtabl</code>e 为 <code>&amp;_dispatch_queue_concurrent_vtable</code>。</p><p>接下来以 <code>_dispatch_queue_concurrent_vtable</code> 为例，看下源码实现。从 libdispatch 的源码中，找到了如下宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_SUBCLASS_DECL(queue_concurrent, <span class="built_in">queue</span>, lane);</span><br></pre></td></tr></table></figure><p>根据源码，将宏完全展开后如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@protocol OS_dispatch_queue_concurrent &lt;OS_dispatch_queue&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface <span class="title function_">OS_dispatch_queue_concurrent</span> <span class="params">()</span> &lt;OS_dispatch_queue_concurrent&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dispatch_queue_concurrent_s;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> _<span class="title">OS_dispatch_queue_concurrent_vtable</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> _<span class="title">dispatch_queue_concurrent_vtable</span> __<span class="title">asm__</span>(&quot;__<span class="title">OS_dispatch_queue_concurrent_vtable</span>&quot;);</span></span><br></pre></td></tr></table></figure><p>从上述源码可以看出，<code>_OS_dispatch_queue_concurrent_vtable</code> 是 <code>OS_dispatch_queue_concurrent</code> 类的虚表，之后又通过 <code>__asm__</code> 指令在汇编代码中将 <code>_OS_dispatch_queue_concurrent_vtable</code> 与 <code>_dispatch_queue_concurrent_vtable</code> 进行关联。</p><p>所以 <code>_dispatch_queue_concurrent_vtable</code> 对应的实现类是 <code>OS_dispatch_queue_concurrent</code>，而 <code>_dispatch_queue_concurrent_vtable</code> 中则存储了 <code>OS_dispatch_queue_concurrent</code> 类相关函数的实现的指针。</p><p>这也是为什么将创建的并发队列打印出来之后，显示 <code>OS_dispatch_queue_concurrent</code> 的原因：<br><img src="/images/lix_blog_218.png"></p><p>同样的，根据源码可以知道创建串行队列，对应的实现类是 <code>OS_dispatch_queue_serial</code>。</p><p>从 libdispatch 的源码的下述源码，可以看到 <code>_dispatch_queue_concurrent_vtable</code> 中存储的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_concurrent, lane,</span><br><span class="line">    .do_type        = DISPATCH_QUEUE_CONCURRENT_TYPE,</span><br><span class="line">    .do_dispose     = _dispatch_lane_dispose,</span><br><span class="line">    .do_debug       = _dispatch_queue_debug,</span><br><span class="line">    .do_invoke      = _dispatch_lane_invoke,</span><br><span class="line"></span><br><span class="line">    .dq_activate    = _dispatch_lane_activate,</span><br><span class="line">    .dq_wakeup      = _dispatch_lane_wakeup,</span><br><span class="line">    .dq_push        = _dispatch_lane_concurrent_push,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_VTABLE_SUBCLASS_INSTANCE(name, ctype, ...) \</span></span><br><span class="line"><span class="meta">        OS_OBJECT_VTABLE_SUBCLASS_INSTANCE(dispatch_##name, dispatch_##ctype, \</span></span><br><span class="line"><span class="meta">                _dispatch_xref_dispose, _dispatch_dispose, \</span></span><br><span class="line"><span class="meta">                .do_kind = #name, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_OBJECT_VTABLE_SUBCLASS_INSTANCE(name, ctype, xdispose, dispose, ...) \</span></span><br><span class="line"><span class="meta">        const struct ctype##_vtable_s OS_OBJECT_CLASS_SYMBOL(name) = &#123; \</span></span><br><span class="line"><span class="meta">            ._os_obj_xref_dispose = xdispose, \</span></span><br><span class="line"><span class="meta">            ._os_obj_dispose = dispose, \</span></span><br><span class="line"><span class="meta">            ._os_obj_vtable = &#123; __VA_ARGS__ &#125;, \</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_OBJECT_CLASS_SYMBOL(name) _##name##_vtable</span></span><br></pre></td></tr></table></figure><p>将宏完全展开后如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> _<span class="title">dispatch_queue_concurrent_vtable</span> =</span> &#123;</span><br><span class="line">    ._os_obj_xref_dispose = _dispatch_xref_dispose,</span><br><span class="line">    ._os_obj_dispose = _dispatch_dispose,</span><br><span class="line">    ._os_obj_vtable = &#123;</span><br><span class="line">        .do_kind = <span class="string">&quot;queue_concurrent&quot;</span>,</span><br><span class="line">        .do_type = DISPATCH_QUEUE_CONCURRENT_TYPE,</span><br><span class="line">        .do_dispose = _dispatch_lane_dispose,</span><br><span class="line">        .do_debug = _dispatch_queue_debug,</span><br><span class="line">        .do_invoke = _dispatch_lane_invoke,</span><br><span class="line">        .dq_activate = _dispatch_lane_activate,</span><br><span class="line">        .dq_wakeup = _dispatch_lane_wakeup,</span><br><span class="line">        .dq_push = _dispatch_lane_concurrent_push,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，也可以看到 <code>_dispatch_queue_serial_vtable</code> 内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> _<span class="title">dispatch_queue_serial_vtable</span> =</span> &#123;</span><br><span class="line">    ._os_obj_xref_dispose = _dispatch_xref_dispose,</span><br><span class="line">    ._os_obj_dispose = _dispatch_dispose,</span><br><span class="line">    ._os_obj_vtable = &#123;</span><br><span class="line">        .do_kind = <span class="string">&quot;queue_serial&quot;</span>,</span><br><span class="line">        .do_type        = DISPATCH_QUEUE_SERIAL_TYPE,</span><br><span class="line">        .do_dispose     = _dispatch_lane_dispose,</span><br><span class="line">        .do_debug       = _dispatch_queue_debug,</span><br><span class="line">        .do_invoke      = _dispatch_lane_invoke,</span><br><span class="line"></span><br><span class="line">        .dq_activate    = _dispatch_lane_activate,</span><br><span class="line">        .dq_wakeup      = _dispatch_lane_wakeup,</span><br><span class="line">        .dq_push        = _dispatch_lane_push,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中存储的各个函数实现在 libdispatch 的源码中都可以找到，这里就不一一贴出来了。</p><p>再回头看下分配内存逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_lane_s));</span><br></pre></td></tr></table></figure><p>其中 <code>_dispatch_object_alloc</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">_dispatch_object_alloc(<span class="type">const</span> <span class="type">void</span> *vtable, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _os_object_alloc_realized(vtable, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配并初始化一个 _os_object_t 类型的对象</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">_os_object_t</span></span><br><span class="line">_os_object_alloc_realized(<span class="type">const</span> <span class="type">void</span> *cls, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个 _os_object_t 类型的变量 obj，用于存储分配的对象</span></span><br><span class="line">    <span class="type">_os_object_t</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言检查，确保传入的 size 大于等于 _os_object_s 结构体的大小</span></span><br><span class="line">    <span class="comment">// 这是为了确保分配的内存足够大，能够包含 _os_object_s 结构体的所有字段</span></span><br><span class="line">    dispatch_assert(size &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> _os_object_s));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 while 循环尝试分配内存，直到分配成功为止</span></span><br><span class="line">    <span class="comment">// unlikely 宏用于提示编译器，这个条件（分配失败）不太可能发生，从而优化分支预测</span></span><br><span class="line">    <span class="keyword">while</span> (unlikely(!(obj = <span class="built_in">calloc</span>(<span class="number">1u</span>, size)))) &#123;</span><br><span class="line">        <span class="comment">// 如果内存分配失败，调用 _dispatch_temporary_resource_shortage 函数处理资源短缺</span></span><br><span class="line">        _dispatch_temporary_resource_shortage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置分配的对象的 isa 指针为传入的 cls，表示对象的类型</span></span><br><span class="line">    obj-&gt;os_obj_isa = cls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回分配并初始化好的对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述主要逻辑如下：</p><ul><li>创建 <code>_os_object_t</code> 类型的对象 <code>obj</code>，并分配内存。</li><li>将 <code>vtable</code> 赋值给 <code>obj-&gt;os_obj_isa</code>。<ul><li><code>vtable</code> 是虚表，存储了具体的函数实现的指针。</li><li>串行队列时，<code>vtable</code> 虚表对应实现类是 <code>OS_dispatch_queue_serial</code><ul><li>并发队列时，<code>vtable</code> 虚表对应实现类是 <code>OS_dispatch_queue_concurrent</code></li></ul></li></ul></li></ul><h5 id="b、初始化"><a href="#b、初始化" class="headerlink" title="b、初始化"></a>b、初始化</h5><p>初始化是通过调用 <code>_dispatch_queue_init</code> 函数实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">        DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">        (dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>调用 <code>_dispatch_queue_init</code> 传入了 4 个参数，根据源码可知，创建串行队列时，第 3 个参数（<code>width</code>）传入的十进制值是 1；</p><p>创建并发队列时，第 3 个参数（<code>width</code>）传入的十进制值是 <code>DISPATCH_QUEUE_WIDTH_MAX，DISPATCH_QUEUE_WIDTH_MAX</code> 是个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_WIDTH_FULL           0x1000ull</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_WIDTH_MAX  (DISPATCH_QUEUE_WIDTH_FULL - 2)</span></span><br></pre></td></tr></table></figure><p>经过计算，<code>DISPATCH_QUEUE_WIDTH_MAX</code> 的十进制值是 <code>4094</code>，所以创建串行队列时，第 3 个参数（<code>width</code>）传入的十进制值是 <code>4094</code>；</p><p>结合前面生成 <code>dqai</code> 那部分的源码，可以知道无论串行队列还是并发队列，<code>dqai.dqai_inactive</code> 值都是 0，所以，<code>_dispatch_queue_init</code> 函数第 4 个参数（<code>initial_state_bits</code>）传入的值是 <code>DISPATCH_QUEUE_ROLE_INNER</code>（<code>0x0000000000000000ull</code>）。</p><p><code>_dispatch_queue_init</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_queue_class_t</span></span><br><span class="line">_dispatch_queue_init(<span class="type">dispatch_queue_class_t</span> dqu, <span class="type">dispatch_queue_flags_t</span> dqf,</span><br><span class="line">        <span class="type">uint16_t</span> width, <span class="type">uint64_t</span> initial_state_bits)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化队列状态</span></span><br><span class="line">    <span class="type">uint64_t</span> dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(width);</span><br><span class="line">    <span class="comment">// 获取实际的调度队列对象</span></span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言检查，确保初始状态位只包含队列角色和非活动标志</span></span><br><span class="line">    dispatch_assert((initial_state_bits &amp; ~(DISPATCH_QUEUE_ROLE_MASK |</span><br><span class="line">            DISPATCH_QUEUE_INACTIVE)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列是非活动的，增加引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (initial_state_bits &amp; DISPATCH_QUEUE_INACTIVE) &#123;</span><br><span class="line">        dq-&gt;do_ref_cnt += <span class="number">2</span>; <span class="comment">// 参见 rdar://8181908 的 _dispatch_lane_resume</span></span><br><span class="line">        <span class="comment">// 如果是调度源类型，进一步增加引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (dx_metatype(dq) == _DISPATCH_SOURCE_TYPE) &#123;</span><br><span class="line">            dq-&gt;do_ref_cnt++; <span class="comment">// 当 DSF_DELETED 被设置时释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将初始状态位合并到队列状态中，由于传入的 initial_state_bits 参数为 DISPATCH_QUEUE_ROLE_INNER（0x0000000000000000ull），所以这一步对 dq_state 的值没有任何影响</span></span><br><span class="line">    dq_state |= initial_state_bits;</span><br><span class="line">    <span class="comment">// 将队列的下一个对象指针设置为无列表状态</span></span><br><span class="line">    dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    <span class="comment">// 将宽度标志合并到队列标志中</span></span><br><span class="line">    dqf |= DQF_WIDTH(width);</span><br><span class="line">    <span class="comment">// 原子存储队列的标志，使用 relaxed 内存顺序</span></span><br><span class="line">    os_atomic_store2o(dq, dq_atomic_flags, dqf, relaxed);</span><br><span class="line">    <span class="comment">// 设置队列的状态</span></span><br><span class="line">    dq-&gt;dq_state = dq_state;</span><br><span class="line">    <span class="comment">// 设置队列的序列号，并递增全局的队列序列号计数器</span></span><br><span class="line">    dq-&gt;dq_serialnum =</span><br><span class="line">            os_atomic_inc_orig(&amp;_dispatch_queue_serial_numbers, relaxed);</span><br><span class="line">    <span class="comment">// 返回初始化后的调度队列类对象</span></span><br><span class="line">    <span class="keyword">return</span> dqu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分逻辑，重点需要关注 <code>dq_state</code>、<code>dq_width</code> 的赋值。</p><p><code>dq_state</code> 的赋值比较好理解，其初始值就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(width);</span><br></pre></td></tr></table></figure><p>注意，这里的 <code>dq_state</code> 非最终值，后续还有 <code>dq_state</code> 赋值逻辑，在下面“dq 其他配置”部分会继续分析 <code>dq_state</code>。</p><p><code>dq_width</code> 字段是队列的宽度，存储了队列能够同时处理的任务的数量。关于 <code>dq_width</code> 的赋值，先回头看下 <code>dispatch_queue_t</code> 的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">dispatch_queue_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略 ......</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> <span class="comment">// 下一个队列对象的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> <span class="comment">// 目标队列指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 32位整数，表示队列的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint64_t</span> <span class="keyword">volatile</span> dq_state; <span class="comment">// 队列状态</span></span><br><span class="line">        dispatch_lock dq_state_lock; <span class="comment">// 队列状态锁</span></span><br><span class="line">        <span class="type">uint32_t</span> dq_state_bits; <span class="comment">// 队列状态位</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LP64 全局队列缓存行边界</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dq_serialnum; <span class="comment">// 队列的序列号</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dq_label; <span class="comment">// 队列标签，用于标识队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，用于存储队列的标志和宽度</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> <span class="keyword">volatile</span> dq_atomic_flags; <span class="comment">// 队列的原子标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">const</span> <span class="type">uint16_t</span> dq_width; <span class="comment">// 队列的宽度，即：队列能够同时处理的任务的数量</span></span><br><span class="line">            <span class="type">const</span> <span class="type">uint16_t</span> __dq_opaque2; <span class="comment">// 额外的占位符字段</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略 ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面已经提到，联合体中的 <code>dq_atomic_flags</code> 是 32 位的无符号整数类型，其占用了 32 位的内存区域，联合体内部 <code>dq_width</code> 和 <code>__dq_opaque2</code> 分别占用 <code>dq_atomic_flags</code> 的低 16 位和高 16 位。</p><p><code>_dispatch_queue_init</code> 函数中，注意下面这部分逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dqf |= DQF_WIDTH(width);</span><br><span class="line">os_atomic_store2o(dq, dq_atomic_flags, dqf, relaxed);</span><br></pre></td></tr></table></figure><p>其中 <code>DQF_WIDTH</code> 宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_OPTIONS(dispatch_queue_flags, <span class="type">uint32_t</span>,</span><br><span class="line">    DQF_NONE                = <span class="number">0x00000000</span>, </span><br><span class="line">    DQF_AUTORELEASE_ALWAYS  = <span class="number">0x00010000</span>, </span><br><span class="line">    DQF_AUTORELEASE_NEVER   = <span class="number">0x00020000</span>, </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DQF_AUTORELEASE_MASK 0x00030000 <span class="comment">// 自动释放相关的掩码</span></span></span><br><span class="line"></span><br><span class="line">    DQF_THREAD_BOUND        = <span class="number">0x00040000</span>, <span class="comment">// 队列与线程绑定标志</span></span><br><span class="line">    DQF_BARRIER_BIT         = <span class="number">0x00080000</span>, <span class="comment">// 队列在其目标上是一个屏障</span></span><br><span class="line">    DQF_TARGETED            = <span class="number">0x00100000</span>, <span class="comment">// 队列被其他对象作为目标</span></span><br><span class="line">    DQF_LABEL_NEEDS_FREE    = <span class="number">0x00200000</span>, </span><br><span class="line">    DQF_MUTABLE             = <span class="number">0x00400000</span>, </span><br><span class="line">    DQF_RELEASED            = <span class="number">0x00800000</span>, <span class="comment">// 引用计数为 -1，表示已释放</span></span><br><span class="line"></span><br><span class="line">    DSF_STRICT              = <span class="number">0x04000000</span>, </span><br><span class="line">    DSF_WLH_CHANGED         = <span class="number">0x08000000</span>, </span><br><span class="line">    DSF_CANCELED            = <span class="number">0x10000000</span>, </span><br><span class="line">    DSF_CANCEL_WAITER       = <span class="number">0x20000000</span>, </span><br><span class="line">    DSF_NEEDS_EVENT         = <span class="number">0x40000000</span>, </span><br><span class="line">    DSF_DELETED             = <span class="number">0x80000000</span>, </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DQF_FLAGS_MASK        ((dispatch_queue_flags_t)0xffff0000) <span class="comment">// 标志位掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DQF_WIDTH_MASK        ((dispatch_queue_flags_t)0x0000ffff) <span class="comment">// 宽度掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DQF_WIDTH(n)          ((dispatch_queue_flags_t)(uint16_t)(n)) <span class="comment">// 设置队列宽度</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>DQF_WIDTH</code> 宏将 <code>width</code> 转换为 <code>dispatch_queue_flags_t</code> 类型，并确保它位于低 16 位。具体来说，<code>DQF_WIDTH</code>(<code>width</code>) 通过将 <code>width</code> 强制转换为 <code>uint16_t</code>，然后再转换为 <code>dispatch_queue_flags_t</code>，确保宽度值仅影响低 16 位。</p><p>也就是说，下述逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dqf |= DQF_WIDTH(width);</span><br></pre></td></tr></table></figure><p>将 <code>width</code> 的值设置到 <code>dqf</code> 的低 16 位上。</p><p><code>os_atomic_store2o</code> 宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> os_atomic_store2o(p, f, v, m) \</span></span><br><span class="line"><span class="meta">        os_atomic_store(&amp;(p)-&gt;f, (v), m)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> os_atomic_store(p, v, m) \</span></span><br><span class="line"><span class="meta">        atomic_store_explicit(_os_atomic_c11_atomic(p), v, memory_order_##m)</span></span><br></pre></td></tr></table></figure><p>可以定义知道 <code>os_atomic_store2o</code> 宏的作用是将值 <code>dqf</code> 原子地存储到结构体 <code>dq</code> 的字段 <code>dq_atomic_flags</code> 中。</p><p>所以，最终 <code>width</code> 值将会赋值给 <code>dispatch_queue_s</code> 中的 <code>dq_width</code> 上，<code>dqf</code> 其他内容存储到 <code>__dq_opaque2</code> 中。</p><p>所以最终：</p><ul><li>创建串行队列时，<code>dq_width = 1</code>；</li><li>创建并发队列时，<code>dq_width = 4094</code>；</li></ul><h4 id="（4）dq-其他配置"><a href="#（4）dq-其他配置" class="headerlink" title="（4）dq 其他配置"></a>（4）dq 其他配置</h4><p>这部分逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置队列标签和优先级。</span></span><br><span class="line">dq-&gt;dq_label = label;</span><br><span class="line">dq-&gt;dq_priority = _dispatch_priority_make((<span class="type">dispatch_qos_t</span>)dqai.dqai_qos,</span><br><span class="line">        dqai.dqai_relpri);</span><br><span class="line"><span class="comment">// 如果开启超额提交，设置相应标志。</span></span><br><span class="line"><span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">    dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果队列不是非活动状态，继承目标队列的优先级和工作循环。</span></span><br><span class="line"><span class="keyword">if</span> (!dqai.dqai_inactive) &#123;</span><br><span class="line">    _dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">    _dispatch_lane_inherit_wlh_from_target(dq, tq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保留目标队列引用。</span></span><br><span class="line">_dispatch_retain(tq);</span><br><span class="line"><span class="comment">// 设置目标 targetq 为当前 dispatch_queue_t</span></span><br><span class="line">dq-&gt;do_targetq = tq;</span><br></pre></td></tr></table></figure><p>这里主要是对 <code>dq</code> 其他的一些参数的配置，这里重点看下 <code>_dispatch_lane_inherit_wlh_from_target</code> 函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_lane_inherit_wlh_from_target(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_queue_t</span> tq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> old_state, new_state, role;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查目标队列 tq 是否具有 QUEUE_ROOT 类型标志</span></span><br><span class="line">    <span class="keyword">if</span> (!dx_hastypeflag(tq, QUEUE_ROOT)) &#123;</span><br><span class="line">        <span class="comment">// 如果 tq 不是根队列，将 role 设置为 INNER（内部队列）</span></span><br><span class="line">        role = DISPATCH_QUEUE_ROLE_INNER;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_dispatch_base_lane_is_wlh(dq, tq)) &#123;</span><br><span class="line">        <span class="comment">// 如果 dq 和 tq 共享相同的 WLH，设置 role 为 BASE_WLH</span></span><br><span class="line">        role = DISPATCH_QUEUE_ROLE_BASE_WLH;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，将 role 设置为 BASE_ANON</span></span><br><span class="line">        role = DISPATCH_QUEUE_ROLE_BASE_ANON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子操作更新 dq 的状态，确保线程安全</span></span><br><span class="line">    os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, &#123;</span><br><span class="line">        <span class="comment">// 清除旧的 role 位</span></span><br><span class="line">        new_state = old_state &amp; ~DISPATCH_QUEUE_ROLE_MASK;</span><br><span class="line">        <span class="comment">// 设置新的 role 位</span></span><br><span class="line">        new_state |= role;</span><br><span class="line">        <span class="comment">// 如果状态没有改变，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (old_state == new_state) &#123;</span><br><span class="line">            os_atomic_rmw_loop_give_up(<span class="keyword">break</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果旧状态是 base WLH 且新状态不是</span></span><br><span class="line">    <span class="keyword">if</span> (_dq_state_is_base_wlh(old_state) &amp;&amp; !_dq_state_is_base_wlh(new_state)) &#123;</span><br><span class="line">        <span class="type">dispatch_deferred_items_t</span> ddi = _dispatch_deferred_items_get();</span><br><span class="line">        <span class="keyword">if</span> (ddi &amp;&amp; ddi-&gt;ddi_wlh == (<span class="type">dispatch_wlh_t</span>)dq) &#123;</span><br><span class="line">            _dispatch_event_loop_leave_immediate(new_state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查目标队列 tq 是否具有 QUEUE_ROOT 类型标志</span></span><br><span class="line">    <span class="keyword">if</span> (!dx_hastypeflag(tq, QUEUE_ROOT)) &#123;</span><br><span class="line">        <span class="comment">// 定义需要清除和设置的标志</span></span><br><span class="line">        <span class="type">dispatch_queue_flags_t</span> clear = <span class="number">0</span>, <span class="built_in">set</span> = DQF_TARGETED;</span><br><span class="line">        <span class="comment">// 如果 tq 类型是 WORKLOOP_TYPE</span></span><br><span class="line">        <span class="keyword">if</span> (dx_metatype(tq) == _DISPATCH_WORKLOOP_TYPE) &#123;</span><br><span class="line">            clear |= DQF_MUTABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !DISPATCH_ALLOW_NON_LEAF_RETARGET</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clear |= DQF_MUTABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有需要清除的标志，则进行清除和设置操作</span></span><br><span class="line">        <span class="keyword">if</span> (clear) &#123;</span><br><span class="line">            _dispatch_queue_atomic_flags_set_and_clear(tq, <span class="built_in">set</span>, clear);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _dispatch_queue_atomic_flags_set(tq, <span class="built_in">set</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要关注角色位 <code>role</code> 配置，<code>role</code> 最终会参与 <code>dq_state</code> 的赋值 <code>new_state |= role;</code>。</p><p><code>role</code> 赋值判断逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dx_hastypeflag(tq, QUEUE_ROOT)) &#123;</span><br><span class="line">    role = DISPATCH_QUEUE_ROLE_INNER;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (_dispatch_base_lane_is_wlh(dq, tq)) &#123;</span><br><span class="line">    role = DISPATCH_QUEUE_ROLE_BASE_WLH;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    role = DISPATCH_QUEUE_ROLE_BASE_ANON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dx_hastypeflag</code> 是个宏，根据其源码定义以及 <code>_dispatch_queue_concurrent_vtable</code>、 <code>_dispatch_queue_serial_vtable</code> 可知，无论串行队列还是并发队列，<code>dx_hastypeflag(tq, QUEUE_ROOT)</code> 都是 <code>true</code>，所以不会走第一个 <code>if</code> 分支，故会进入 <code>_dispatch_base_lane_is_wlh</code> 函数的判断逻辑。</p><p><code>_dispatch_base_lane_is_wlh</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查给定的调度通道是否是工作循环（workloop）的一部分</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dispatch_base_lane_is_wlh(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_queue_t</span> tq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果工作队列事件机制未启用，则返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!_dispatch_kevent_workqueue_enabled)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查调度通道的类型是否为网络事件队列类型</span></span><br><span class="line">    <span class="keyword">if</span> (dx_type(dq) == DISPATCH_QUEUE_NETWORK_EVENT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// 如果是网络事件类型，则返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查调度通道的元类型是否为调度源类型</span></span><br><span class="line">    <span class="keyword">if</span> (dx_metatype(dq) == _DISPATCH_SOURCE_TYPE) &#123;</span><br><span class="line">        <span class="comment">// 源类型不支持同步等待者，因此那些不会改变 QoS 的源</span></span><br><span class="line">        <span class="comment">// 无法受益于任何具有开销的工作循环特性，</span></span><br><span class="line">        <span class="comment">// 因此只使用工作队列的 kqueue。</span></span><br><span class="line">        <span class="keyword">if</span> (likely(!upcast(dq)._ds-&gt;ds_refs-&gt;du_can_be_wlh)) &#123;</span><br><span class="line">            <span class="comment">// 如果调度源不可以是工作循环，则返回 false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确保直接引用</span></span><br><span class="line">        dispatch_assert(upcast(dq)._ds-&gt;ds_refs-&gt;du_is_direct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列宽度是否为 1 且目标队列在根队列数组中</span></span><br><span class="line">    <span class="keyword">return</span> dq-&gt;dq_width == <span class="number">1</span> &amp;&amp; _dispatch_is_in_root_queues_array(tq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dispatch_is_in_root_queues_array(<span class="type">dispatch_queue_class_t</span> dqu)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断调度队列的指针范围是否在根队列数组的有效范围内</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * _DISPATCH_ROOT_QUEUE_IDX_COUNT = 18</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 根据前面 &quot;创建 tq&quot; 部分，创建串行队列时，index = 10，创建并发队列时 index = 9，均满足 &gt;= 0 &amp;&amp; &lt; 18</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">return</span> (dqu._dgq &gt;= _dispatch_root_queues) &amp;&amp;</span><br><span class="line">            (dqu._dgq &lt; _dispatch_root_queues + _DISPATCH_ROOT_QUEUE_IDX_COUNT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述逻辑中，无论串行队列还是并发队列，<code>_dispatch_is_in_root_queues_array</code> 函数都是返回 <code>true</code>。所以，最终 <code>_dispatch_base_lane_is_wlh</code> 函数返回值取决于 <code>dq-&gt;dq_width == 1</code> 的判断结果，即：</p><ul><li>创建串行队列时，返回值为 <code>true</code>。<ul><li><code>role = DISPATCH_QUEUE_ROLE_BASE_WLH;</code></li><li><code>dq_state = (dq_state | role) = (DISPATCH_QUEUE_STATE_INIT_VALUE(dq_width) | DISPATCH_QUEUE_ROLE_BASE_WLH);</code></li></ul></li><li>创建并发队列时，返回值为 <code>false</code>。<ul><li><code>role = DISPATCH_QUEUE_ROLE_BASE_ANON;</code></li><li><code>dq_state = (dq_state | role) = (DISPATCH_QUEUE_STATE_INIT_VALUE(dq_width) | DISPATCH_QUEUE_ROLE_BASE_ANON);</code></li></ul></li></ul><h4 id="（5）简单总结"><a href="#（5）简单总结" class="headerlink" title="（5）简单总结"></a>（5）简单总结</h4><p>总结一下：</p><ul><li><p><strong>串行队列</strong></p><ul><li><code>dq_width = 1；</code><ul><li>即串行队列最多能同时处理 <code>1</code> 个任务</li></ul></li><li><code>dq_state = (DISPATCH_QUEUE_STATE_INIT_VALUE(dq_width) | DISPATCH_QUEUE_ROLE_BASE_WLH);</code></li><li>串行队列是 <code>overcommit</code> 的</li></ul></li><li><p><strong>并发队列</strong></p><ul><li><code>dq_width = 4094</code><ul><li>即串行队列最多能同时处理 <code>4094</code> 个任务，但最终有多少个任务能够同时执行，还要看系统资源情况，例如线程池可用线程数量等。</li></ul></li><li><code>dq_state = (DISPATCH_QUEUE_STATE_INIT_VALUE(dq_width) | DISPATCH_QUEUE_ROLE_BASE_ANON);</code></li><li>并发队列是非 <code>overcommit</code> 的</li></ul></li></ul><p>对于 <code>do_targetq</code>，串行队列、并发队列的 <code>do_targetq</code>，都是从根队列数组 <code>_dispatch_root_queues</code> 中取出的对应的根队列（root queue），只不过两者取的 <code>index</code> 不一样。</p><p>同时，根据源码中宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_STATE_INIT_VALUE(width) \</span></span><br><span class="line"><span class="meta">        ((DISPATCH_QUEUE_WIDTH_FULL - (width)) &lt;&lt; DISPATCH_QUEUE_WIDTH_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_WIDTH_FULL           0x1000ull</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_WIDTH_SHIFT          41</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ROLE_BASE_WLH        0x0000002000000000ull</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ROLE_BASE_ANON       0x0000001000000000ull</span></span><br></pre></td></tr></table></figure><p>可以计算出：<br><strong>串行队列：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq_state = (DISPATCH_QUEUE_STATE_INIT_VALUE(dq_width) | DISPATCH_QUEUE_ROLE_BASE_WLH)  = (DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="number">1</span>) | DISPATCH_QUEUE_ROLE_BASE_WLH) = <span class="number">0x001ffe2000000000</span>。</span><br></pre></td></tr></table></figure><p><strong>并发队列：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq_state = (DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="number">4094</span>) | DISPATCH_QUEUE_ROLE_BASE_ANON) = <span class="number">0x0000041000000000</span>。</span><br></pre></td></tr></table></figure><p>关于 <code>dq_width</code>、<code>dq_state</code>，我们可以使用一个 Demo 验证一下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">&quot;com.demo.serialQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">&quot;com.lixkit.concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;serialQueue = %@&quot;</span>, [serialQueue debugDescription]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;concurrentQueue = %@&quot;</span>, [concurrentQueue debugDescription]);</span><br></pre></td></tr></table></figure><p>运行后打印结果：<br><img src="/images/lix_blog_219.png"></p><p>上述打印结果中，<code>width</code> 就是 <code>dq_width</code>：</p><ul><li>串行队列 <code>width = 0x1</code>，转成十进制就是 <code>1</code>。</li><li>并发队列 <code>width = 0xffe</code>，转成十进制就是 <code>4094</code>。</li></ul><p>打印结果的 <code>state</code> 就是 <code>dq_state</code>，可以看到打印出的 <code>dq_width</code>、<code>dq_state</code> 和前面我们根据源码计算出的结果一致。</p><p>这里为什么要重点关注 <code>dq_width</code>、<code>dq_state</code>、<code>do_targetq</code>，因为后续 <code>dispatch_sync</code>、<code>dispatch_async</code> 源码中会用到。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCD 底层原理 1 - dispatch_once</title>
      <link href="/posts/33519/"/>
      <url>/posts/33519/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>单例在 iOS 中应用广泛，常用于管理全局的资源，如应用程序的配置信息、数据库管理、网络请求管理器等。<code>dispatch_once</code> 常被用来实现单例，如下是创建单例的一个最基本的用法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> TestObject *instance;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        instance = [[TestObject alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>通过使用 <code>dispatch_once</code> 和静态变量，可以确保在多线程环境下，TestObject 类的实例只会被创建一次。这种实现方式是线程安全的，并且是 Objective-C 中实现单例模式的标准方法。</p><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><p><code>libdispatch</code> 是 Apple 的 Grand Central Dispatch (GCD) 的实现库，<code>libdispatch</code> 提供了用于在多核硬件上执行并发代码的基础设施。<br>它通过管理线程池和调度任务来优化性能，减少上下文切换，并提高应用程序的响应能力。</p><p><code>dispatch_once</code> 是 <code>libdispatch</code> 提供的一个函数，用于确保某段代码在程序的生命周期内只执行一次。通过使用 <code>dispatch_once</code>，开发者可以轻松实现线程安全的初始化逻辑，而无需担心多线程环境下的竞态条件。</p><p><code>libdispatch</code> 是开源的：<a href="https://github.com/apple-oss-distributions/libdispatch">apple-oss-distributions&#x2F;libdispatch</a>，接下来，通过 <code>libdispatch</code> 源码，看下 <code>dispatch_once</code> 实现原理。</p><h3 id="1、dispatch-once"><a href="#1、dispatch-once" class="headerlink" title="1、dispatch_once"></a>1、dispatch_once</h3><p><code>dispatch_once</code> 实现源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">intptr_t</span> <span class="type">dispatch_once_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(^<span class="type">dispatch_block_t</span>)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dispatch_once</span><span class="params">(<span class="type">dispatch_once_t</span> *val, <span class="type">dispatch_block_t</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">    dispatch_once_f(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_once</code> 主要有两个参数：</p><ul><li><strong>val</strong><ul><li><code>val</code> 是一个指向整数类型的指针。<ul><li><code>dispatch_once_t</code> 是 <code>intptr_t</code> 类型，<code>intptr_t</code> 实际上是个有符号整数类型。</li></ul></li><li>在后续逻辑中，<code>val</code> 会被转成联合体 <code>dispatch_once_gate_t</code>，并借助其中的成员 <code>dgo_once</code> 标识 <code>block</code> 是否已经执行过。<ul><li><code>dgo_once</code> 是一个整数类型。</li></ul></li></ul></li><li><strong>block</strong><ul><li>实际要执行的代码块。</li></ul></li></ul><h3 id="2、dispatch-once-f"><a href="#2、dispatch-once-f" class="headerlink" title="2、dispatch_once_f"></a>2、dispatch_once_f</h3><p><code>dispatch_once</code> 中主要调用了 <code>dispatch_once_f</code> 函数，<code>dispatch_once_f</code> 实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dispatch_once_f</span><span class="params">(<span class="type">dispatch_once_t</span> *val, <span class="type">void</span> *ctxt, <span class="type">dispatch_function_t</span> func)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_once_gate_t</span> l = (<span class="type">dispatch_once_gate_t</span>)val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_once_gate_tryenter(l)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_once_callout(l, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_once_wait(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_once_gate_t</code> 是指向 <code>dispatch_once_gate_s</code> 结构体的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> dispatch_lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_gate_s</span> &#123;</span></span><br><span class="line">    dispatch_lock dgl_lock;</span><br><span class="line">&#125; dispatch_gate_s, *<span class="type">dispatch_gate_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_once_gate_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        dispatch_gate_s dgo_gate;</span><br><span class="line">        <span class="type">uintptr_t</span> dgo_once;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; dispatch_once_gate_s, *<span class="type">dispatch_once_gate_t</span>;</span><br></pre></td></tr></table></figure><p><code>dispatch_once_gate_s</code> 是一个联合体，主要包含两个成员：</p><ul><li><strong>dgo_gate</strong><ul><li><code>dispatch_gate_s</code> 结构体类型，该结构体中只有一个整数类型的成员 <code>dgl_lock</code>。</li><li><code>dgo_gate</code> 用于实现后续的锁机制。</li></ul></li><li><strong>dgo_once</strong><ul><li>无符号整数，用于存储代码块的执行状态。</li></ul></li></ul><h3 id="3、-dispatch-once-gate-tryenter"><a href="#3、-dispatch-once-gate-tryenter" class="headerlink" title="3、_dispatch_once_gate_tryenter"></a>3、_dispatch_once_gate_tryenter</h3><p><code>dispatch_once_f</code> 内部首先调用 <code>_dispatch_once_gate_tryenter</code> 函数进行判断，<code>_dispatch_once_gate_tryenter</code> 实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dispatch_once_gate_tryenter(<span class="type">dispatch_once_gate_t</span> l)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> os_atomic_cmpxchg(&amp;l-&gt;dgo_once, DLOCK_ONCE_UNLOCKED,</span><br><span class="line">            (<span class="type">uintptr_t</span>)_dispatch_lock_value_for_self(), relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>os_atomic_cmpxchg</code> 是一个宏，其相关宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> os_atomic_cmpxchg(p, e, v, m) \</span></span><br><span class="line"><span class="meta">        (&#123; _os_atomic_basetypeof(p) _r = (e); \</span></span><br><span class="line"><span class="meta">        atomic_compare_exchange_strong_explicit(_os_atomic_c11_atomic(p), \</span></span><br><span class="line"><span class="meta">        &amp;_r, v, memory_order_##m, memory_order_relaxed); &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _os_atomic_basetypeof(p) \</span></span><br><span class="line"><span class="meta">        __typeof__(atomic_load_explicit(_os_atomic_c11_atomic(p), memory_order_relaxed))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_load_explicit   __c11_atomic_load</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _os_atomic_c11_atomic(p) \</span></span><br><span class="line"><span class="meta">        ((__typeof__(*(p)) _Atomic *)(p))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_compare_exchange_strong_explicit   __c11_atomic_compare_exchange_strong</span></span><br></pre></td></tr></table></figure><p><code>_dispatch_once_gate_tryenter</code> 源码完全展开后，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dispatch_once_gate_tryenter(<span class="type">dispatch_once_gate_t</span> l)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 预期值，DLOCK_ONCE_UNLOCKED 表示该状态尚未初始化</span></span><br><span class="line">    <span class="type">uintptr_t</span> expected_value = DLOCK_ONCE_UNLOCKED;</span><br><span class="line">    <span class="comment">// 新值，使用当前线程的锁值作为新值</span></span><br><span class="line">    <span class="type">uintptr_t</span> new_value = (<span class="type">uintptr_t</span>)_dispatch_lock_value_for_self(); </span><br><span class="line">    <span class="comment">// 执行原子比较并交换操作</span></span><br><span class="line">    <span class="keyword">return</span> atomic_compare_exchange_strong_explicit(</span><br><span class="line">        <span class="comment">// 将 l-&gt;dgo_once 转换为 C11 原子类型</span></span><br><span class="line">        ((__typeof__(l-&gt;dgo_once) <span class="keyword">_Atomic</span> *)(&amp;l-&gt;dgo_once)),</span><br><span class="line">        <span class="comment">// 预期值的地址，函数会检查 l-&gt;dgo_once 是否等于这个值</span></span><br><span class="line">        &amp;expected_value, </span><br><span class="line">        <span class="comment">// 如果 l-&gt;dgo_once 等于预期值，则将 l-&gt;dgo_once 设置为这个新值</span></span><br><span class="line">        new_value,</span><br><span class="line">        <span class="comment">// 成功时的内存序，memory_order_relaxed 表示此操作是原子的，但不强制其他线程立即看到更新</span></span><br><span class="line">        memory_order_relaxed, </span><br><span class="line">        <span class="comment">// 失败时的内存序</span></span><br><span class="line">        memory_order_relaxed </span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（1）atomic-compare-exchange-strong-explicit"><a href="#（1）atomic-compare-exchange-strong-explicit" class="headerlink" title="（1）atomic_compare_exchange_strong_explicit"></a>（1）atomic_compare_exchange_strong_explicit</h4><p><code>atomic_compare_exchange_strong_explicit</code> 是 C11 标准中定义的一个原子操作函数，用于实现比较并交换（Compare and Swap, CAS）操作。</p><p><strong>该函数的主要作用是比较一个原子变量的当前值与预期值，如果相等，则将其更新为新值。这个操作是原子的，意味着它在执行过程中不会被其他线程打断。</strong></p><p><strong>函数原型如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">atomic_compare_exchange_strong_explicit</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">atomic_type</span> *obj,</span></span><br><span class="line"><span class="params">    <span class="type">atomic_type</span> *expected,</span></span><br><span class="line"><span class="params">    <span class="type">atomic_type</span> desired,</span></span><br><span class="line"><span class="params">    memory_order success,</span></span><br><span class="line"><span class="params">    memory_order failure</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><strong>各参数含义：</strong></p><ul><li><code>atomic_type *obj</code><ul><li>指向要操作的原子变量的指针。该变量的值将被比较并可能被更新。</li></ul></li><li><code>aomic_type *expected</code><ul><li>指向预期值的指针。如果 <code>*obj</code> 的值等于 <code>*expected</code>，则将 <code>*obj</code> 更新为 <code>desired</code>。如果不相等，<code>*expected</code> 将被更新为 <code>*obj</code> 的当前值。</li></ul></li><li><code>atomic_type desired</code><ul><li>新值，如果比较成功（即 <code>*obj</code> 的值等于 <code>*expected</code>），则将 <code>*obj</code> 更新为该值。</li></ul></li><li><code>memory_order success</code><ul><li>表示操作成功时的内存序，决定了其他线程对该操作的可见性。</li></ul></li><li><code>memory_order failure</code><ul><li>表示操作失败时的内存序。与成功时的内存序相似，决定了在操作未成功时的可见性。</li></ul></li></ul><p><code>atomic_compare_exchange_strong_explicit</code> 函数作用如下：</p><ul><li>该函数会检查原子变量 <code>obj</code> 的当前值是否等于给定的预期值 <code>expected</code>。如果相等，函数会将该原子变量的值更新为新的值 <code>desired</code>。<ul><li>这个操作是原子的，意味着在执行过程中不会被其他线程打断，从而避免数据竞争和不一致性。</li></ul></li><li>如果操作成功（即当前值等于预期值），函数返回 <code>true</code>，并且原子变量的值被更新为新值。</li><li>如果操作失败（即当前值不等于预期值），函数返回 <code>false</code>，并且预期值会被更新为当前值。</li></ul><p>下面是参考 <code>_dispatch_once_gate_tryenter</code> 实现的一个 <code>atomic_compare_exchange_strong_explicit</code> 的简单示例，该示例和 <code>_dispatch_once_gate_tryenter</code> 一样，使用 <code>memory_order_relaxed</code> 内存序，多个线程并发修改共享的原子变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享的原子变量</span></span><br><span class="line"><span class="type">atomic_int</span> shared_value;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">0</span>; <span class="comment">// 预期值</span></span><br><span class="line">    <span class="type">int</span> desired = <span class="number">1</span>; <span class="comment">// 新值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试将 shared_value 从 0 改为 1</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_compare_exchange_strong_explicit(&amp;shared_value, &amp;expected, desired,</span><br><span class="line">                                                 memory_order_relaxed,</span><br><span class="line">                                                 memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程 %ld: 成功将值从 0 改为 %d\n&quot;</span>, (<span class="type">long</span>)arg, desired);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程 %ld: 值未改变，当前值为 %d，预期值为 %d\n&quot;</span>, (<span class="type">long</span>)arg, shared_value, expected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化共享原子变量为 0</span></span><br><span class="line">    shared_value = ATOMIC_VAR_INIT(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> threadCount = <span class="number">10</span>;</span><br><span class="line">    <span class="type">pthread_t</span> threads[threadCount];</span><br><span class="line">    <span class="comment">// 创建多个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_func, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行打印如下：<br><img src="/images/lix_blog_67.png" alt="upload successful"><br>可以看到，当 <code>atomic_compare_exchange_strong_explicit</code> 原子操作使用 <code>memory_order_relaxed</code> 内存序时，多个线程可以并发执行这个原子操作，但最终只会有一个线程成功能操作成功。</p><h4 id="（2）内存序"><a href="#（2）内存序" class="headerlink" title="（2）内存序"></a>（2）内存序</h4><p>内存序使用的是 <code>memory_order_relaxed</code>，内存序（Memory Order）是多线程编程中的一个关键概念，它决定了在多线程环境中，如何保证内存操作的可见性和顺序性。在原子操作中，内存序用于指定操作的内存模型，以确保线程间的同步和数据一致性。C11 和 C++11 标准中定义了几种不同的内存序，<code>memory_order_relaxed</code> 是其中之一。</p><p><strong>内存序主要有 6 种类型：</strong></p><ul><li><code>memory_order_relaxed</code><ul><li>特点：不对其他内存操作施加顺序上的约束，即不保证操作的可见性和顺序性。</li><li>用途：适用于不需要同步的情况，只需要保证原子性。<ul><li>例如，计数器的递增操作。</li></ul></li><li>性能：因为没有同步开销，通常具有较高的性能。</li></ul></li><li><code>memory_order_consume</code><ul><li>特点：确保依赖于加载结果的操作在加载之后执行。</li><li>用途：适用于需要依赖关系但不需要严格顺序的情况。</li></ul></li><li><code>memory_order_acquire</code><ul><li>特点：保证在此操作之后的读写不会被重排到此操作之前。</li><li>用途：用于加载操作，确保获取到最新的值。</li></ul></li><li><code>memory_order_release</code><ul><li>特点：保证在此操作之前的读写不会被重排到此操作之后。</li><li>用途：用于存储操作，确保对其他线程可见。</li></ul></li><li><code>memory_order_acq_rel</code><ul><li>特点：结合了 acquire 和 release 的特性。</li><li>用途：用于读-改-写操作，确保读写的顺序。</li></ul></li><li><code>memory_order_seq_cst</code><ul><li>特点：提供最强的顺序保证，所有操作按全局顺序执行。</li><li>用途：适用于需要严格顺序的场合，通常性能较低。</li></ul></li></ul><p>接下来，通过一个示例看下 <code>memory_order_relaxed</code> 的作用。</p><p>下面是一个计数器的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_INCREMENTS 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>; <span class="comment">// 共享计数器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">increment_counter</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_INCREMENTS; ++i) &#123;</span><br><span class="line">        counter++; <span class="comment">// 非原子操作，存在数据竞争</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程来同时增加计数器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, increment_counter, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;counter = %d\n&quot;</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的主要逻辑是 4 个线程同时对一个共享的计数器 <code>counter</code> 进行递增操作。每个线程都会在一个循环中执行 <code>1000000</code> 次的 <code>counter++</code> 操作。</p><p>符合预期的结果，运行结束 <code>counter</code> 应该等于 <code>4000000</code>，但实际上述代码每次运行结束 <code>counter</code> 结果都不相同：<br><img src="/images/lix_blog_133.png" alt="upload successful"></p><p>主要原因是 <code>counter++</code> 不是原子操作，多个线程同时修改 <code>counter</code> 会导致数据竞争，最终结果可能小于预期。</p><p>使用 <code>memory_order_relaxed</code> 可以解决问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_INCREMENTS 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">atomic_int</span> counter = <span class="number">0</span>; <span class="comment">// 原子计数器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">increment_counter</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_INCREMENTS; ++i) &#123;</span><br><span class="line">        atomic_fetch_add_explicit(&amp;counter, <span class="number">1</span>, memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程来同时增加计数器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, increment_counter, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;counter = %d\n&quot;</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述使用 <code>memory_order_relaxed</code> 的示例中，无论运行多少次，都可以确保 <code>counter</code> 的值都是符合预期的。</p><p><code>memory_order_relaxed</code> 保证了原子性，但不提供同步保证（即不强制其他线程立即看到更新），这意味着即使一个线程已经完成了对某个变量的更新，其他线程可能不会立即看到这个更新。由于没有同步开销，所以具有较高的性能，非常适合用于性能敏感的场景。</p><h4 id="（3）-dispatch-lock-value-for-self"><a href="#（3）-dispatch-lock-value-for-self" class="headerlink" title="（3）_dispatch_lock_value_for_self()"></a>（3）_dispatch_lock_value_for_self()</h4><p>其中，新值使用的是 <code>_dispatch_lock_value_for_self()</code>，其实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前线程的唯一标识符</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _dispatch_tid_self()        ((dispatch_tid)_dispatch_thread_port())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _dispatch_thread_port() pthread_mach_thread_np(_dispatch_thread_self())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程的标识符</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _dispatch_thread_self() ((uintptr_t)pthread_self())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mach_port_t 类型为 uint32_t，用于表示 Mach 端口</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">mach_port_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dispatch_tid 类型为 mach_port_t，用于表示线程标识符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">mach_port_t</span> dispatch_tid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dispatch_lock 类型为 uint32_t，用于表示锁</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> dispatch_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于掩码操作的常量，DLOCK_OWNER_MASK 用于提取锁所有者的标识部分</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLOCK_OWNER_MASK            ((dispatch_lock)0xfffffffc)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程的锁值</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> dispatch_lock</span><br><span class="line">_dispatch_lock_value_for_self(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的标识符，并转换为锁值</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_lock_value_from_tid(_dispatch_tid_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将线程标识符转换为锁值</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> dispatch_lock</span><br><span class="line">_dispatch_lock_value_from_tid(dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 与 DLOCK_OWNER_MASK 进行按位与操作，提取出线程标识符中用于锁定的部分</span></span><br><span class="line">    <span class="keyword">return</span> tid &amp; DLOCK_OWNER_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_lock_value_for_self</code> 用于获取当前线程的“锁值”，这个“锁值”用于标识当前线程在锁机制中的身份。</p><p><code>_dispatch_lock_value_for_self</code> 核心逻辑是通过一系列的宏和内联函数获取当前线程的唯一标识符 <code>tid</code>，再将线程标识符 <code>tid</code> 与 <code>DLOCK_OWNER_MASK</code> 进行按位与操作，生成最终的“锁值”。</p><h4 id="（4）总结-dispatch-once-gate-tryenter"><a href="#（4）总结-dispatch-once-gate-tryenter" class="headerlink" title="（4）总结 _dispatch_once_gate_tryenter"></a>（4）总结 _dispatch_once_gate_tryenter</h4><p>根据前面内容对 <code>_dispatch_once_gate_tryenter</code> 总结如下：</p><ul><li>该函数只有一个参数 <code>dispatch_once_gate_t l</code>：它是指向 <code>dispatch_once_gate_s</code> 结构的指针。</li><li>该函数调用 <code>os_atomic_cmpxchg</code> 宏，执行原子比较并交换操作，<code>os_atomic_cmpxchg</code> 宏展开后，实际调用的是前面提到的 <code>atomic_compare_exchange_strong_explicit</code> 函数。</li><li>总结该函数核心逻辑如下：<ul><li>如果 <code>&amp;l-&gt;dgo_once</code> 等于 <code>DLOCK_ONCE_UNLOCKED</code>，则将其更新为当前线程的锁值，并返回 <code>true</code>，表示当前线程可以进入一次性初始化的代码块。<ul><li>获取当前线程的唯一标识符 <code>tid</code>，再将线程标识符 <code>tid</code> 与 <code>DLOCK_OWNER_MASK</code> 进行按位与操作，生成最终的“锁值”。</li><li>返回 <code>true</code> 将调用 <code>_dispatch_once_callout(l, ctxt, func)</code>;</li></ul></li><li>如果 <code>&amp;l-&gt;dgo_once</code> 的值已经被其他线程修改（即不等于 <code>DLOCK_ONCE_UNLOCKED</code>），则返回 <code>false</code>，表示其他线程可能正在执行该代码块。<ul><li>返回 <code>false</code> 将调用 <code>_dispatch_once_wait(l)</code>。</li></ul></li><li>使用的内存序是 <code>memory_order_relaxed</code>，即**多个线程可以并发执行，但最终只会有一个线程执行成功并返回 <code>true</code>**。</li></ul></li></ul><p>从 <code>dispatch_once_f</code> 实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dispatch_once_f</span><span class="params">(<span class="type">dispatch_once_t</span> *val, <span class="type">void</span> *ctxt, <span class="type">dispatch_function_t</span> func)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_once_gate_t</span> l = (<span class="type">dispatch_once_gate_t</span>)val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_once_gate_tryenter(l)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_once_callout(l, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_once_wait(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以知道，<code>_dispatch_once_gate_tryenter</code> 主要逻辑是判断进入一次性代码块，还是等待。</p><p>接下来看下代码块执行逻辑 <code>_dispatch_once_callout</code> 和  <code>_dispatch_once_wait</code> 的源码实现。</p><h3 id="4、-dispatch-once-callout"><a href="#4、-dispatch-once-callout" class="headerlink" title="4、_dispatch_once_callout"></a>4、_dispatch_once_callout</h3><p><code>_dispatch_once_callout</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_once_callout(<span class="type">dispatch_once_gate_t</span> l, <span class="type">void</span> *ctxt,</span><br><span class="line">                <span class="type">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">        _dispatch_client_callout(ctxt, func);</span><br><span class="line">        _dispatch_once_gate_broadcast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数内部，调用了 <code>_dispatch_client_callout</code>、<code>_dispatch_once_gate_broadcast</code> 两个函数。</p><h4 id="（1）-dispatch-client-callout"><a href="#（1）-dispatch-client-callout" class="headerlink" title="（1）_dispatch_client_callout"></a>（1）_dispatch_client_callout</h4><p><code>_dispatch_client_callout</code> 源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On platforms with SjLj exceptions, avoid the SjLj overhead on every callout</span></span><br><span class="line"><span class="comment">// by clearing the unwinder&#x27;s TSD pointer to the handler stack around callouts</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _dispatch_get_tsd_base()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _dispatch_get_unwind_tsd() (NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _dispatch_set_unwind_tsd(u) do &#123;(void)(u);&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _dispatch_free_unwind_tsd()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_client_callout(<span class="type">void</span> *ctxt, <span class="type">dispatch_function_t</span> f)</span><br><span class="line">&#123;</span><br><span class="line">_dispatch_get_tsd_base();</span><br><span class="line"><span class="type">void</span> *u = _dispatch_get_unwind_tsd();</span><br><span class="line"><span class="keyword">if</span> (likely(!u)) <span class="keyword">return</span> f(ctxt);</span><br><span class="line">_dispatch_set_unwind_tsd(<span class="literal">NULL</span>);</span><br><span class="line">f(ctxt);</span><br><span class="line">_dispatch_free_unwind_tsd();</span><br><span class="line">_dispatch_set_unwind_tsd(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>_dispatch_client_callout</code> 中核心逻辑主要是涉及到一系列 <code>tsd</code> 相关宏的调用，以及执行具体 <code>block</code>。</p><p>在该函数执行的宏定义中可以看到，这些宏实际上都是 <code>NOOPs</code>（无操作指令），可以理解为空的逻辑“没有任何作用”。那这些宏还有什么存在意义呢？</p><p>源码上方的注释给出了解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// On platforms with SjLj exceptions, avoid the SjLj overhead on every callout</span><br><span class="line">// by clearing the unwinder&#x27;s TSD pointer to the handler stack around callouts</span><br></pre></td></tr></table></figure><p>即：在具有 <code>SjLj</code> 异常的平台上，通过在调用过程中清除展开器的 <code>TSD</code> 指针到处理程序堆栈，避免每次调用的 <code>SjLj</code> 开销。</p><p><code>SjLj</code> 是一种异常处理机制，主要用于不支持更高级异常处理的架构。它通过 <code>setjmp</code> 和 <code>longjmp</code> 函数实现异常捕获和跳转。<code>setjmp</code> 用于保存当前的堆栈状态，而 <code>longjmp</code> 用于恢复到之前保存的状态，从而实现异常处理。</p><p>每次调用 <code>setjmp</code> 时，都会有一定的开销，因为需要保存当前的堆栈上下文，包括寄存器状态和程序计数器等。在频繁调用的情况下，这种开销可能会显著影响性能。</p><p>对于现代硬件来说，这种对 <code>TSD</code>（线程安全数据）指针的 <code>SjLj</code>（<code>Setjmp</code>&#x2F;<code>Longjmp</code>）优化是不必要的，这些 <code>NOOPs</code>（无操作指令）是故意而为之。</p><p>所以，可以理解为 <code>_dispatch_client_callout</code> 函数实现就是执行具体 <code>block</code>。</p><h4 id="（2）-dispatch-once-gate-broadcast"><a href="#（2）-dispatch-once-gate-broadcast" class="headerlink" title="（2）_dispatch_once_gate_broadcast"></a>（2）_dispatch_once_gate_broadcast</h4><p><code>_dispatch_once_gate_broadcast</code> 函数主要作用是在完成一次性初始化后，通知可能等待在该初始化完成的其他线程，该函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_once_gate_broadcast(<span class="type">dispatch_once_gate_t</span> l)</span><br><span class="line">&#123;</span><br><span class="line">dispatch_lock value_self = _dispatch_lock_value_for_self();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 调用 _dispatch_once_mark_done(l) 将 dispatch_once 状态标记为完成。</span></span><br><span class="line"><span class="comment"> 这个函数内部使用原子操作将 dgo_once 设置为 DLOCK_ONCE_DONE，表示初始化已经完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uintptr_t</span> v = _dispatch_once_mark_done(l);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他线程相关检查</span></span><br><span class="line"><span class="keyword">if</span> (likely((dispatch_lock)v == value_self)) <span class="keyword">return</span>;</span><br><span class="line">_dispatch_gate_broadcast_slow(&amp;l-&gt;dgo_gate, (dispatch_lock)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>_dispatch_once_mark_done</code> 函数实现逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uintptr_t</span></span><br><span class="line">_dispatch_once_mark_done(<span class="type">dispatch_once_gate_t</span> dgo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> os_atomic_xchg(&amp;dgo-&gt;dgo_once, DLOCK_ONCE_DONE, release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_once_gate_broadcast</code> 函数关键逻辑是<strong>在 <code>_dispatch_client_callout</code> 执行完 <code>dispatch_once</code> 具体 <code>block</code> 后，使用原子操作将 <code>dgo_once</code> 设置为 <code>DLOCK_ONCE_DONE</code>（记住这个操作，非常重要）</strong>。</p><h3 id="5、-dispatch-once-wait"><a href="#5、-dispatch-once-wait" class="headerlink" title="5、_dispatch_once_wait"></a>5、_dispatch_once_wait</h3><p>再回头看下 <code>dispatch_once_f</code> 实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dispatch_once_f</span><span class="params">(<span class="type">dispatch_once_t</span> *val, <span class="type">void</span> *ctxt, <span class="type">dispatch_function_t</span> func)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dispatch_once_gate_t</span> l = (<span class="type">dispatch_once_gate_t</span>)val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_once_gate_tryenter(l)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_once_callout(l, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_once_wait(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前述内容可知，<code>_dispatch_once_gate_tryenter</code> 返回 <code>false</code>，则代表当前的这次调用没有获得 <code>dispatch_once</code> 的 <code>block</code> 执行权，则调用 <code>_dispatch_once_wait</code> 函数进入等待逻辑。</p><p><code>_dispatch_once_wait</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_once_wait(<span class="type">dispatch_once_gate_t</span> dgo)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_lock self = _dispatch_lock_value_for_self();</span><br><span class="line">    <span class="type">uintptr_t</span> old_v, new_v;</span><br><span class="line">    <span class="type">uint32_t</span> timeout = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        os_atomic_rmw_loop(&amp;dgo-&gt;dgo_once, old_v, new_v, relaxed, &#123;</span><br><span class="line">            <span class="keyword">if</span> (likely(old_v == DLOCK_ONCE_DONE)) &#123;</span><br><span class="line">                os_atomic_rmw_loop_give_up(<span class="keyword">return</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            new_v = old_v | (<span class="type">uintptr_t</span>)DLOCK_WAITERS_BIT;</span><br><span class="line">            <span class="keyword">if</span> (new_v == old_v) os_atomic_rmw_loop_give_up(<span class="keyword">break</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_lock_is_locked_by((dispatch_lock)old_v, self))) &#123;</span><br><span class="line">            DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">&quot;trying to lock recursively&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _dispatch_thread_switch(new_v, <span class="number">0</span>, timeout++);</span><br><span class="line">        (<span class="type">void</span>)timeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数中包含一系列宏定义，将该函数完全展开后逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_once_wait(<span class="type">dispatch_once_gate_t</span> dgo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的锁值，用于标识当前线程</span></span><br><span class="line">    dispatch_lock self = _dispatch_lock_value_for_self();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义两个变量用于存储旧值和新值</span></span><br><span class="line">    <span class="type">uintptr_t</span> old_v, new_v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化超时计数器，初始值为1</span></span><br><span class="line">    <span class="type">uint32_t</span> timeout = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入一个无限循环，直到条件满足退出</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 原子读-修改-写循环，尝试更新 dgo_once 的状态</span></span><br><span class="line">        <span class="type">bool</span> _result = <span class="literal">false</span>;</span><br><span class="line">        __typeof__(&amp;dgo-&gt;dgo_once) _p = (&amp;dgo-&gt;dgo_once);</span><br><span class="line">        old_v = os_atomic_load(_p, relaxed);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 如果状态已经是 DLOCK_ONCE_DONE，表示初始化已完成，直接返回，函数执行结束</span></span><br><span class="line">            <span class="keyword">if</span> (likely(old_v == DLOCK_ONCE_DONE)) &#123;</span><br><span class="line">                os_atomic_thread_fence(relaxed);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置等待者标志，表示当前线程在等待</span></span><br><span class="line">            new_v = old_v | (<span class="type">uintptr_t</span>)DLOCK_WAITERS_BIT;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果新旧值相同，说明已经被其他线程(或自己)设置成等待状态了，退出当前 do while 循环</span></span><br><span class="line">            <span class="keyword">if</span> (new_v == old_v) &#123;</span><br><span class="line">                os_atomic_thread_fence(relaxed);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试将 old_v 替换为 new_v</span></span><br><span class="line">            _result = atomic_compare_exchange_weak_explicit(</span><br><span class="line">                _os_atomic_c11_atomic(_p), &amp;old_v, new_v, </span><br><span class="line">                memory_order_relaxed, memory_order_relaxed);</span><br><span class="line">        &#125; <span class="keyword">while</span> (unlikely(!_result));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前线程是否已经持有锁，避免递归锁定</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_lock_is_locked_by((dispatch_lock)old_v, self))) &#123;</span><br><span class="line">            DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">&quot;trying to lock recursively&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行线程切换，允许其他线程执行</span></span><br><span class="line">        _dispatch_thread_switch(new_v, <span class="number">0</span>, timeout++);</span><br><span class="line">        (<span class="type">void</span>)timeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>_dispatch_thread_switch</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">kern_return_t</span> <span class="title function_">thread_switch</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">mach_port_name_t</span> thread_name,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> option,</span></span><br><span class="line"><span class="params">    <span class="type">mach_msg_timeout_t</span> option_time)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_dispatch_thread_switch(dispatch_lock value, <span class="type">dispatch_lock_options_t</span> flags,</span><br><span class="line">        <span class="type">uint32_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> option;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DLOCK_LOCK_DATA_CONTENTION) &#123;</span><br><span class="line">        option = SWITCH_OPTION_OSLOCK_DEPRESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        option = SWITCH_OPTION_DEPRESS;</span><br><span class="line">    &#125;</span><br><span class="line">    thread_switch(_dispatch_lock_owner(value), option, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_thread_switch</code> 函数，主要是对 <code>thread_switch</code> 函数的调用，<code>thread_switch</code> 函数是一个系统调用，用于在多线程环境中进行线程调度切换。当一个线程在等待某个资源（如锁）时，直接进行忙等待会浪费 CPU 资源。<code>thread_switch</code> 允许线程主动让出 CPU，使得其他线程可以被调度执行。</p><p>当一个线程调用 <code>thread_switch</code> 时，该线程会被挂起一段时间（由 <code>option_time</code> 参数指定，单位毫秒），在此期间，操作系统可以调度其他线程运行。</p><p><code>_dispatch_once_wait</code> 中对 <code>thread_switch</code> 调用，第一次调用 <code>option_time</code> 传的值是 <code>1</code> 毫秒，即当前线程挂起 <code>1</code> 毫秒让出 CPU 资源给其他线程调用。下次时候 <code>option_time ++</code>，传入的是 <code>2</code> 毫秒，再挂起 <code>2</code> 毫秒，依次递增挂起时长……</p><p>总结  <code>_dispatch_once_wait</code> 函数核心逻辑是：</p><ul><li>无限 <code>for</code> 循环，检测 <code>dgo_once</code> 是否为 <code>DLOCK_ONCE_DONE</code>。<ul><li>如果是，代表 <code>dispatch_once</code> 的 <code>block</code> 执行完毕，无需再等待，终止 <code>for</code> 循环，该函数执行结束。</li><li>如果不是，代表 <code>dispatch_once</code> 的 <code>block</code> 没有执行完毕，将 <code>dgo_once</code> 设置为 <code>dgo_once | DLOCK_WAITERS_BIT</code>，继续 <code>for</code> 循环检测，直到 <code>dgo_once</code> 变成 <code>DLOCK_ONCE_DONE</code>。<ul><li>无限 <code>for</code> 循环期间，通过 <code>thread_switch</code> 系统调用，使当前线程挂起，让出 CPU 资源给其他线程。挂起时长从 1毫秒开始，每次调用 <code>thread_switch</code> 递增 1 毫秒。</li></ul></li></ul></li></ul><h3 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h3><p>根据前述 <code>dispatch_once</code> 源码，可以用下图表示其实现逻辑：<br><img src="/images/lix_blog_217.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热修复之 MangoFix 实现原理</title>
      <link href="/posts/62814/"/>
      <url>/posts/62814/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h2><p>MangoFix 是 iOS 中另一个热修复 SDK，其实现原理与 JSPatch 不同。MangoFix 定义了一套与 OC 相似语法规则，使用该规则编写热修复代码，并使用 Lex、Yacc 实现词法分析器、语法分析器处理热修复代码生成抽象语法树 AST 并解释执行，再利用 Runtime 实现方法的替换、新增等，以达到热修复的目的。</p><p>例如，想使用 MangoFix 热修复修改 <code>ViewController</code> 中的 <code>testMethodWithStr:</code> 实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testMethodWithStr:(<span class="built_in">NSString</span> *)str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testMethodWithStr:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>热修复代码文件（demo.mg）中热修复代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ViewController:<span class="built_in">UIViewController</span> &#123;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testMethodWithStr:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">    <span class="comment">// 变量定义</span></span><br><span class="line">    <span class="built_in">NSString</span> *text = <span class="string">@&quot;Example Text&quot;</span>;</span><br><span class="line">    <span class="keyword">self</span>.resultView.text = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载热修复代码文件：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MFContext *context = [[MFContext alloc] init];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSString</span> *sourcePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;demo&quot;</span> ofType:<span class="string">@&quot;mg&quot;</span>];</span><br><span class="line"><span class="built_in">NSString</span> *script = [<span class="built_in">NSString</span> stringWithContentsOfFile:sourcePath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line">[context evalMangoScriptWithSourceString:script];</span><br></pre></td></tr></table></figure><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><p>无论是 JSPatch 还是 MangoFix，热修复代码本质上都是一段代码字符串，要实现热修复，最关键的一步就是如何让这段代码字符串被 iOS 系统（或 APP）理解并执行。</p><p>JSPatch 利用了 iOS 系统提供的 JavaScriptCore 的 API，通过使用 JS 编写热修复代码，利用 JavaScriptCore 去执行 JS 代码(字符串)，最后利用 Runtime 去实现方法的替换，达到了热修复的目的。</p><p>而 MangoFix 则是自定义了一套语言，这套语言仅可用于 iOS 的热修复，所以可以被称为 DSL（Domain-Specific Language，领域特定语言）。为了使 MangoFix 的这套自定义的语言编写的可以被执行，就需要将 MangoFix 热修复代码字符串构建成一个逻辑能被 iOS 系统（或 APP）识别、执行和遍历的抽象语法树 AST。</p><p>而要构建 AST，就必须实现对应的词法分析器、语法分析器。MangoFix 则利用 Lex、Yacc 分别实现词法分析器、语法分析器，最终使热修复代码字符串得以被执行，最后再利用 Runtime 实现对原方法的替换。</p><p>简而言之，MangoFix 自定义了一套解释型语言用于编写热修复代码，再利用 Lex、Yacc实现解释器并执行热修复代码，最后再利用 Runtime 实现对原方法的替换，达到热修复的目的。</p><p>还以下面这段热修复代码为例看下 MangoFix 实现原理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ViewController:<span class="built_in">UIViewController</span> &#123;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testMethodWithStr:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">    <span class="comment">// 变量定义</span></span><br><span class="line">    <span class="built_in">NSString</span> *text = <span class="string">@&quot;Example Text&quot;</span>;</span><br><span class="line">    <span class="keyword">self</span>.resultView.text = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MangoFix 加载执行热修复代码，主要是通过下述方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)evalMangoScriptWithAES128Data:(<span class="built_in">NSData</span> *)scriptData &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 将加密的脚本(热修复代码字符串)，解密成原始代码字符串</span></span><br><span class="line">        <span class="built_in">NSData</span> *mangoFixData = [scriptData AES128ParmDecryptWithKey:_key iv:_iv];</span><br><span class="line">        <span class="built_in">NSString</span> *mangoFixString = [[<span class="built_in">NSString</span> alloc] initWithData:mangoFixData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="keyword">if</span> (!mangoFixString.length) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;[MangoFix] [ERROR] : AES128(ECBMode) decrypt error!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置解释器</span></span><br><span class="line">        mf_set_current_compile_util(<span class="keyword">self</span>.interpreter);</span><br><span class="line">        <span class="comment">// 添加内置函数到解释器</span></span><br><span class="line">        mf_add_built_in(<span class="keyword">self</span>.interpreter);</span><br><span class="line">        <span class="comment">// 编译(解释)热修复代码：词法解析、语法解析，生成抽象语法树 AST</span></span><br><span class="line">        [<span class="keyword">self</span>.interpreter compileSourceWithString:mangoFixString];</span><br><span class="line">        <span class="comment">// 置空解释器</span></span><br><span class="line">        mf_set_current_compile_util(<span class="literal">nil</span>);</span><br><span class="line">        <span class="comment">// 解释并执行热修复代码：语义分析、解释执行</span></span><br><span class="line">        mf_interpret(<span class="keyword">self</span>.interpreter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要关注 <code>compileSourceWithString:</code> 和 <code>mf_interpret()</code> 两个方法。</p><p><code>compileSourceWithString:</code> 方法实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)compileSourceWithString:(<span class="built_in">NSString</span> *)source &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> mf_set_source_string(<span class="type">char</span> <span class="keyword">const</span> *source);</span><br><span class="line">    mf_set_source_string([source UTF8String]);</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> yyrestart  (FILE * input_file );</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> yyparse(<span class="type">void</span>);</span><br><span class="line">    yyrestart(<span class="literal">NULL</span>); <span class="comment">/* 每次解析前，重置yylex */</span></span><br><span class="line">    <span class="keyword">if</span> (yyparse()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该方法主要逻辑如下：</p><ul><li>设置词法分析源字符串为热修复代码字符串</li><li>重置词法分析器</li><li>执行语法分析函数 <code>yyparse()</code></li></ul><p>其中，<code>yyparse()</code> 函数是语法分析器核心函数，是 Xcode 根据 Yacc 文件（MangoFix&#x2F;Compiler&#x2F;lex_yacc&#x2F;mango.y）自动编译生成的。</p><p>关于 Lex 词法分析器、Yacc 语法分析器相关内容，可以看我的另一篇博客：<a href="https://www.lixkit.com/posts/20895/">《编译原理之 Lex &amp; Yacc》</a></p><p>前面提到的热修复示例代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ViewController:<span class="built_in">UIViewController</span> &#123;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testMethodWithStr:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">    <span class="comment">// 变量定义</span></span><br><span class="line">    <span class="built_in">NSString</span> *text = <span class="string">@&quot;Example Text&quot;</span>;</span><br><span class="line">    <span class="keyword">self</span>.resultView.text = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在词法分析、语法分析时，就需要匹配出代码字符串中的类、父类、方法名、方法实现等内容。</p><p>以类信息匹配为例，Yacc 文件（mango.y）中定义的类匹配文法规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class_definition: annotation_list CLASS IDENTIFIER COLON annotation_list IDENTIFIER LC</span><br><span class="line">            &#123;</span><br><span class="line">                NSArray&lt;MFAnnotation *&gt; *annotationList = (__bridge_transfer NSArray&lt;MFAnnotation *&gt; *)$1;</span><br><span class="line">                NSString *name = (__bridge_transfer NSString *)$3;</span><br><span class="line">                NSArray&lt;MFAnnotation *&gt; *superAnnotationList = (__bridge_transfer NSArray&lt;MFAnnotation *&gt; *)$5;</span><br><span class="line">                NSString *superName = (__bridge_transfer NSString *)$6;</span><br><span class="line">                mf_start_class_definition(annotationList, name, superAnnotationList, superName,nil);</span><br><span class="line">            &#125;</span><br><span class="line">            RC</span><br><span class="line">            &#123;</span><br><span class="line">                MFClassDefinition *classDefinition = mf_end_class_definition(nil);</span><br><span class="line">                $$ = (__bridge_retained void *)classDefinition;</span><br><span class="line">            &#125;</span><br><span class="line">            | annotation_list CLASS IDENTIFIER COLON annotation_list IDENTIFIER LC</span><br><span class="line">            &#123;</span><br><span class="line">                NSArray&lt;MFAnnotation *&gt; *annotationList = (__bridge_transfer NSArray&lt;MFAnnotation *&gt; *)$1;</span><br><span class="line">                NSString *name = (__bridge_transfer NSString *)$3;</span><br><span class="line">                NSArray&lt;MFAnnotation *&gt; *superAnnotationList = (__bridge_transfer NSArray&lt;MFAnnotation *&gt; *)$5;</span><br><span class="line">                NSString *superName = (__bridge_transfer NSString *)$6;</span><br><span class="line">                mf_start_class_definition(annotationList, name, superAnnotationList, superName,nil);</span><br><span class="line">            &#125;</span><br><span class="line">            member_definition_list RC</span><br><span class="line">            &#123;</span><br><span class="line">                NSArray *members = (__bridge_transfer NSArray *)$9;</span><br><span class="line">                MFClassDefinition *classDefinition = mf_end_class_definition(members);</span><br><span class="line">                $$ = (__bridge_retained void *)classDefinition;</span><br><span class="line">            &#125;</span><br><span class="line">            | annotation_list CLASS IDENTIFIER COLON annotation_list IDENTIFIER LT protocol_list GT LC</span><br><span class="line">            &#123;</span><br><span class="line">                NSArray&lt;MFAnnotation *&gt; *annotationList = (__bridge_transfer NSArray&lt;MFAnnotation *&gt; *)$1;</span><br><span class="line">                NSString *name = (__bridge_transfer NSString *)$3;</span><br><span class="line">                NSArray&lt;MFAnnotation *&gt; *superAnnotationList = (__bridge_transfer NSArray&lt;MFAnnotation *&gt; *)$5;</span><br><span class="line">                NSString *superName = (__bridge_transfer NSString *)$6;</span><br><span class="line">                NSArray *protocolNames = (__bridge_transfer NSArray *)$8;</span><br><span class="line">                mf_start_class_definition(annotationList, name, superAnnotationList, superName, protocolNames);</span><br><span class="line">            &#125;</span><br><span class="line">            RC</span><br><span class="line">            &#123;</span><br><span class="line">                MFClassDefinition *classDefinition = mf_end_class_definition(nil);</span><br><span class="line">                $$ = (__bridge_retained void *)classDefinition;</span><br><span class="line">            &#125;</span><br><span class="line">            | annotation_list CLASS IDENTIFIER COLON annotation_list IDENTIFIER LT protocol_list GT LC</span><br><span class="line">            &#123;</span><br><span class="line">                NSArray&lt;MFAnnotation *&gt; *annotationList = (__bridge_transfer NSArray&lt;MFAnnotation *&gt; *)$1;</span><br><span class="line">                NSString *name = (__bridge_transfer NSString *)$3;</span><br><span class="line">                NSArray&lt;MFAnnotation *&gt; *superAnnotationList = (__bridge_transfer NSArray&lt;MFAnnotation *&gt; *)$5;</span><br><span class="line">                NSString *superName = (__bridge_transfer NSString *)$6;</span><br><span class="line">                NSArray *protocolNames = (__bridge_transfer NSArray *)$8;</span><br><span class="line">                mf_start_class_definition(annotationList, name, superAnnotationList, superName, protocolNames);</span><br><span class="line">            &#125;</span><br><span class="line">            member_definition_list RC</span><br><span class="line">            &#123;</span><br><span class="line">                NSArray *members = (__bridge_transfer NSArray *)$12;</span><br><span class="line">                MFClassDefinition *classDefinition = mf_end_class_definition(members);</span><br><span class="line">                $$ = (__bridge_retained void *)classDefinition;</span><br><span class="line">            &#125;</span><br><span class="line">            ;</span><br></pre></td></tr></table></figure><p>上述主要逻辑如下：</p><ul><li>词法分析器输出词法单元 tokens</li><li>语法分析器使用 tokens 按照类文法规则匹配类信息</li><li>匹配成功后，获取类、父类等信息，调用 <code>mf_start_class_definition()</code> 函数</li><li>匹配结束后，调用 <code>mf_end_class_definition()</code> 函数</li></ul><p><code>mf_start_class_definition()</code> 和 <code>mf_end_class_definition()</code> 函数实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> mf_start_class_definition(<span class="built_in">NSArray</span>&lt;MFAnnotation *&gt; *annotationList, <span class="built_in">NSString</span> *name, <span class="built_in">NSArray</span>&lt;MFAnnotation *&gt; *superAnnotationList, <span class="built_in">NSString</span> *superName, <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *protocolNames)&#123;</span><br><span class="line">    MFInterpreter *interpreter = mf_get_current_compile_util();</span><br><span class="line">    MFClassDefinition *classDefinition = [[MFClassDefinition alloc] init];</span><br><span class="line">    classDefinition.lineNumber = interpreter.currentLineNumber; <span class="comment">// mango.l 中赋值</span></span><br><span class="line">    classDefinition.annotationList = annotationList;</span><br><span class="line">    classDefinition.superAnnotationList = superAnnotationList;</span><br><span class="line">    <span class="keyword">if</span> (classDefinition.swiftModuleAnnotation) &#123;</span><br><span class="line">        classDefinition.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%s.%@&quot;</span>, classDefinition.swiftModuleAnnotation.expr.cstringValue, name];</span><br><span class="line">        [[MFSwfitClassNameAlisTable shareInstance] addSwiftClassNmae:classDefinition.name alias:name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *swiftClassName = [[MFSwfitClassNameAlisTable shareInstance] swiftClassNameByAlias:name];</span><br><span class="line">        <span class="keyword">if</span> (swiftClassName) &#123;</span><br><span class="line">            classDefinition.name = swiftClassName;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            classDefinition.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (classDefinition.superSwiftModuleAnnotation) &#123;</span><br><span class="line">        classDefinition.superName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%s.%@&quot;</span>, classDefinition.superSwiftModuleAnnotation.expr.cstringValue, superName];</span><br><span class="line">        [[MFSwfitClassNameAlisTable shareInstance] addSwiftClassNmae:classDefinition.superName alias:superName];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *swiftSuperClassName = [[MFSwfitClassNameAlisTable shareInstance] swiftClassNameByAlias:superName];</span><br><span class="line">        <span class="keyword">if</span> (swiftSuperClassName) &#123;</span><br><span class="line">            classDefinition.superName = swiftSuperClassName;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            classDefinition.superName = superName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    classDefinition.protocolNames = protocolNames;</span><br><span class="line">    interpreter.currentClassDefinition = classDefinition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MFClassDefinition *mf_end_class_definition(<span class="built_in">NSArray</span>&lt;MFMemberDefinition *&gt; *members)&#123;</span><br><span class="line">    MFInterpreter *interpreter = mf_get_current_compile_util();</span><br><span class="line">    MFClassDefinition *classDefinition = interpreter.currentClassDefinition;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;MFPropertyDefinition *&gt; *propertyDefinition = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;MFMethodDefinition *&gt; *classMethods = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;MFMethodDefinition *&gt; *instanceMethods = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (MFMemberDefinition *memberDefinition <span class="keyword">in</span> members) &#123;</span><br><span class="line">        memberDefinition.classDefinition = classDefinition;</span><br><span class="line">        <span class="keyword">if</span> ([memberDefinition isKindOfClass:[MFPropertyDefinition <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            [propertyDefinition addObject:(MFPropertyDefinition *)memberDefinition];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([memberDefinition isKindOfClass:[MFMethodDefinition <span class="keyword">class</span>]])&#123;</span><br><span class="line">            MFMethodDefinition *methodDefinition = (MFMethodDefinition *)memberDefinition;</span><br><span class="line">            <span class="keyword">if</span> (methodDefinition.classMethod) &#123;</span><br><span class="line">                [classMethods addObject:methodDefinition];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                [instanceMethods addObject:methodDefinition];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    classDefinition.properties = propertyDefinition;</span><br><span class="line">    classDefinition.classMethods = classMethods;</span><br><span class="line">    classDefinition.instanceMethods = instanceMethods;</span><br><span class="line">    interpreter.currentClassDefinition = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> classDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mf_start_class_definition()</code> 主要逻辑如下：</p><ul><li>获取当前的解释器实例</li><li>创建一个新的 <code>MFClassDefinition</code> 对象，并初始化其属性</li><li>将解释器当前行号赋值给类定义对象的 <code>lineNumber</code> 属性（用于后续的异常信息中）</li><li>将 <code>MFClassDefinition</code> 对象保存到解释器的 <code>currentClassDefinition</code> 属性中</li></ul><p><code>mf_end_class_definition()</code> 主要逻辑如下：</p><ul><li>获取当前解释器实例</li><li>获取解释器的 <code>currentClassDefinition</code></li><li>将从热修复代码中匹配到的属性、类方法、实例方法分别保存到 <code>currentClassDefinition</code> 的 <code>properties</code>、<code>classMethods</code> 和 <code>instanceMethods</code> 中</li></ul><p>除了上述类信息匹配之外，还有对应的方法信息、方法实现等信息的匹配，匹配完成后，就生成了对应的 AST，而上述的 <code>MFClassDefinition</code> 则是 AST 的一个节点，其中就保存了热修复代码中的类、方法、属性等信息。</p><p>生成的 AST 之后，就开始执行 <code>mf_interpret()</code> 函数，<code>mf_interpret()</code> 函数实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> mf_interpret(MFInterpreter *interpreter)&#123;</span><br><span class="line">    <span class="keyword">for</span> (__kindof <span class="built_in">NSObject</span> *top <span class="keyword">in</span> interpreter.topList) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([top isKindOfClass:[MFStatement <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            execute_statement(interpreter, interpreter.topScope, top);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([top isKindOfClass:[MFStructDeclare <span class="keyword">class</span>]])&#123;</span><br><span class="line">            add_struct_declare(interpreter,top);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([top isKindOfClass:[MFClassDefinition <span class="keyword">class</span>]])&#123;</span><br><span class="line">            define_class(interpreter, top);</span><br><span class="line">            fix_class(interpreter,top);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前述的示例中，创建的 AST 的 top 节点是 MFClassDefinition ，所以此处会调用 <code>define_class()</code> 和 <code>fix_class()</code> 函数。</p><p><code>define_class()</code> 实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> define_class(MFInterpreter *interpreter, MFClassDefinition *classDefinition)&#123;</span><br><span class="line">    <span class="keyword">if</span> (classDefinition.annotationIfExprResult == AnnotationIfExprResultNoComputed) &#123;</span><br><span class="line">        MFExpression *annotationIfConditionExpr = classDefinition.ifAnnotation.expr;</span><br><span class="line">        <span class="keyword">if</span> (annotationIfConditionExpr) &#123;</span><br><span class="line">            MFValue *value = mf_eval_expression(interpreter, interpreter.topScope, annotationIfConditionExpr);</span><br><span class="line">            classDefinition.annotationIfExprResult = value.isSubtantial ? AnnotationIfExprResultTrue : AnnotationIfExprResultFalse;</span><br><span class="line">            <span class="keyword">if</span> (!value.isSubtantial) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            classDefinition.annotationIfExprResult = AnnotationIfExprResultTrue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (classDefinition.annotationIfExprResult != AnnotationIfExprResultTrue) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取类名对应的 Class 对象</span></span><br><span class="line">    Class clazz = <span class="built_in">NSClassFromString</span>(classDefinition.name);</span><br><span class="line">    <span class="keyword">if</span> (!clazz) &#123;</span><br><span class="line">        <span class="comment">// 类不存在，则动态创建类</span></span><br><span class="line">        <span class="comment">// 获取父类</span></span><br><span class="line">        <span class="built_in">NSString</span> *superClassName = classDefinition.superName;</span><br><span class="line">        Class superClass = <span class="built_in">NSClassFromString</span>(superClassName);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果父类不存在且有 Swift 模块注解</span></span><br><span class="line">        <span class="keyword">if</span> (!superClass) &#123;</span><br><span class="line">            <span class="keyword">if</span> (classDefinition.swiftModuleAnnotation &amp;&amp; !classDefinition.superSwiftModuleAnnotation) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *sueprClassFullName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%s.%@&quot;</span>, classDefinition.swiftModuleAnnotation.expr.cstringValue, superClassName];</span><br><span class="line">                superClass = <span class="built_in">NSClassFromString</span>(sueprClassFullName);</span><br><span class="line">                <span class="keyword">if</span> (superClass) &#123;</span><br><span class="line">                    [[MFSwfitClassNameAlisTable shareInstance] addSwiftClassNmae:sueprClassFullName alias:superClassName];</span><br><span class="line">                    classDefinition.superName = sueprClassFullName;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果父类仍然不存在，则递归</span></span><br><span class="line">        <span class="keyword">if</span> (!superClass) &#123;</span><br><span class="line">            define_class(interpreter, interpreter.classDefinitionDic[superClassName]);</span><br><span class="line">            superClass = <span class="built_in">NSClassFromString</span>(superClassName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!superClass &amp;&amp; classDefinition.swiftModuleAnnotation &amp;&amp; !classDefinition.superSwiftModuleAnnotation) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *sueprClassFullName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%s.%@&quot;</span>, classDefinition.swiftModuleAnnotation.expr.cstringValue, superClassName];</span><br><span class="line">            define_class(interpreter, interpreter.classDefinitionDic[sueprClassFullName]);</span><br><span class="line">            superClass = <span class="built_in">NSClassFromString</span>(sueprClassFullName);</span><br><span class="line">            <span class="keyword">if</span> (superClass) &#123;</span><br><span class="line">                [[MFSwfitClassNameAlisTable shareInstance] addSwiftClassNmae:sueprClassFullName alias:superClassName];</span><br><span class="line">                classDefinition.superName = sueprClassFullName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果父类仍然不存在，则抛出错误</span></span><br><span class="line">        <span class="keyword">if</span> (!superClass) &#123;</span><br><span class="line">            mf_throw_error(classDefinition.lineNumber, MFRuntimeErrorNotFoundSuperClass, <span class="string">@&quot;not found super class: %@&quot;</span>,superClassName);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分配并注册新的类</span></span><br><span class="line">        clazz = objc_allocateClassPair(superClass, classDefinition.name.UTF8String, <span class="number">0</span>);</span><br><span class="line">        objc_registerClassPair(clazz);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将生成的类对象存储在类定义中</span></span><br><span class="line">    classDefinition.clazz = clazz;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>define_class()</code> 主要逻辑如下：</p><ul><li>获取类名对应的 <code>Class</code> 对象，判断 <code>Class</code> 对象是否已存在。<ul><li>如果不存在，则动态创建 <code>Class</code>。</li><li>如果已经存在，直接保存到 <code>classDefinition</code> 的 <code>clazz</code>  属性中。</li></ul></li></ul><p><code>fix_class()</code> 实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> fix_class(MFInterpreter *interpreter, MFClassDefinition *classDefinition)&#123;</span><br><span class="line">    Class clazz = classDefinition.clazz;</span><br><span class="line">    <span class="keyword">for</span> (MFPropertyDefinition *prop <span class="keyword">in</span> classDefinition.properties) &#123;</span><br><span class="line">        replace_prop(interpreter,clazz, prop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (MFMethodDefinition *classMethod <span class="keyword">in</span> classDefinition.classMethods) &#123;</span><br><span class="line">        replace_method(interpreter, clazz, classMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (MFMethodDefinition *instanceMethod <span class="keyword">in</span> classDefinition.instanceMethods) &#123;</span><br><span class="line">        replace_method(interpreter, clazz, instanceMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> replace_method(MFInterpreter *interpreter, Class clazz, MFMethodDefinition *method)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 略 ......</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *sig = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:typeEncoding.UTF8String];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> argCount = (<span class="type">unsigned</span> <span class="type">int</span>)[sig numberOfArguments];</span><br><span class="line">    <span class="type">void</span> *imp = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ffi_cif（Call Interface）用于描述函数调用的接口，包括返回类型、参数类型等。</span></span><br><span class="line">    ffi_cif *cif = malloc(<span class="keyword">sizeof</span>(ffi_cif));<span class="comment">//不可以free</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个可以调用的函数闭包</span></span><br><span class="line">    ffi_closure *closure = ffi_closure_alloc(<span class="keyword">sizeof</span>(ffi_closure), (<span class="type">void</span> **)&amp;imp);</span><br><span class="line">    ffi_type *returnType = mf_ffi_type_with_type_encoding(sig.methodReturnType);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据方法签名设置函数的返回类型和参数类型</span></span><br><span class="line">    ffi_type **args = malloc(<span class="keyword">sizeof</span>(ffi_type *) * argCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>  i = <span class="number">0</span> ; i &lt; argCount; i++) &#123;</span><br><span class="line">        args[i] = mf_ffi_type_with_type_encoding([sig getArgumentTypeAtIndex:i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备 ffi_cif 以便用于函数调用，并将闭包与具体的函数实现绑定</span></span><br><span class="line">    <span class="keyword">if</span>(ffi_prep_cif(cif, FFI_DEFAULT_ABI, argCount, returnType, args) == FFI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *userInfo = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (method.classDefinition) &#123;</span><br><span class="line">            userInfo = @&#123;<span class="string">@&quot;class&quot;</span>:c2, <span class="string">@&quot;typeEncoding&quot;</span>:[typeEncoding <span class="keyword">copy</span>], <span class="string">@&quot;classDefinition&quot;</span> : method.classDefinition&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            userInfo = @&#123;<span class="string">@&quot;class&quot;</span>:c2, <span class="string">@&quot;typeEncoding&quot;</span>:[typeEncoding <span class="keyword">copy</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFTypeRef</span> cfuserInfo = (__bridge_retained <span class="built_in">CFTypeRef</span>)userInfo;</span><br><span class="line">        <span class="comment">// 将闭包与具体的函数实现 replaceIMP 绑定，并传递 userInfo 作为上下文</span></span><br><span class="line">        ffi_prep_closure_loc(closure, cif, replaceIMP, (<span class="type">void</span> *)cfuserInfo, imp);</span><br><span class="line">    &#125;</span><br><span class="line">    class_replaceMethod(c2, sel, imp, typeEncoding.UTF8String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> replaceIMP(ffi_cif *cif, <span class="type">void</span> *ret, <span class="type">void</span> **args, <span class="type">void</span> *userdata)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 略 ......</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;MFValue *&gt; *argValues = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="built_in">NSUInteger</span> numberOfArguments = [methodSignature numberOfArguments];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; numberOfArguments; i++) &#123;</span><br><span class="line">        MFValue *argValue;</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span> *type = [methodSignature getArgumentTypeAtIndex:i];</span><br><span class="line">        <span class="keyword">if</span> (strcmp(type, <span class="string">&quot;@?&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">id</span> block =  (__bridge <span class="type">id</span>)(*(<span class="type">void</span> **)args[i]);</span><br><span class="line">            block = [block <span class="keyword">copy</span>];</span><br><span class="line">            argValue = [MFValue valueInstanceWithObject:block];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">void</span> *arg = args[i];</span><br><span class="line">            argValue = [[MFValue alloc] initWithCValuePointer:arg typeEncoding:[methodSignature getArgumentTypeAtIndex:i] bridgeTransfer:<span class="literal">NO</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [argValues addObject:argValue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行热修复中的方法实现</span></span><br><span class="line">    __autoreleasing MFValue *retValue = mf_call_mf_function(inter, classScope, method.functionDefinition, argValues);</span><br><span class="line">    [retValue assignToCValuePointer:ret typeEncoding:[methodSignature methodReturnType]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fix_class()</code> 主要逻辑如下：</p><ul><li>创建 <code>imp</code>，用于关联热修复代码中方法实现</li><li>利用 libffi 将 <code>replaceIMP</code> 函数与 <code>imp</code> 进行关联</li><li>利用 Runtime 使用 <code>imp</code> 替换 OC 原方法实现<ul><li>完成替换后，原方法执行，实际将会执行到 <code>replaceIMP</code>  函数</li><li><code>replaceIMP</code> 函数中，会传递方法参数并执行热修复代码中具体方法逻辑</li></ul></li></ul><p><strong>关于 libffi：</strong><br>libffi（Foreign Function Interface Library）是一个开源库(<a href="https://github.com/libffi/libffi">libffi</a>)，它提供了最底层的接口，在不确定参数个数和类型的情况下，根据相应规则，完成所需数据的准备，生成相应汇编指令的代码来完成函数调用。</p><p>libffi 允许程序在运行时调用未知的函数，主要用于实现跨语言调用和动态代码生成，它在运行时生成调用代码，而不需要在编译时知道函数的签名。libffi 在很多编程语言的实现中都有应用，例如 Python 的 ctypes 模块、Java 的 JNI（Java Native Interface）、和 Ruby 的 Fiddle 模块等。</p><p>总结上述逻辑，MangoFix 实现方法替换的流程可用下图表示：<br><img src="/images/lix_blog_188.png" style="width:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> 热修复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热修复之 JSPatch 实现原理</title>
      <link href="/posts/48084/"/>
      <url>/posts/48084/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h2><p>JSPatch  基于 <code>JavaScriptCore</code>、<code>Runtime</code> 实现，可以使用 JavaScript 代码对原方法进行重写(覆盖)、新增方法等，实现对线上问题代码的修复，例如：<br>假设 <code>JPViewController</code> 中按钮点击事件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@implementation JPViewController</span><br><span class="line"></span><br><span class="line">- (void)handleBtn:(id)sender &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>现在要使用 JSPatch 覆盖该方法，使点击按钮跳转到 <code>JPTableViewController</code>，其对应 JSPatch 热修复代码实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defineClass(&#x27;JPViewController&#x27;, &#123;</span><br><span class="line">  handleBtn: function(sender) &#123;</span><br><span class="line">    var tableViewCtrl = JPTableViewController.alloc().init()</span><br><span class="line">    self.navigationController().pushViewController_animated(tableViewCtrl, YES)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>将上述热修复代码放到 demo.js 文件中，使用 <code>JPEngine</code> 执行 JS 代码即可实现对原方法的覆盖：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[JPEngine startEngine];</span><br><span class="line"><span class="built_in">NSString</span> *sourcePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;demo&quot;</span> ofType:<span class="string">@&quot;js&quot;</span>];</span><br><span class="line"><span class="built_in">NSString</span> *script = [<span class="built_in">NSString</span> stringWithContentsOfFile:sourcePath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line">[JPEngine evaluateScript:script];</span><br></pre></td></tr></table></figure><p>在 JSPatch 的热修复代码中，调用 OC 方法的方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 调用类方法</span><br><span class="line">var redColor = UIColor.redColor();</span><br><span class="line"></span><br><span class="line">// 调用实例方法</span><br><span class="line">var view = UIView.alloc().init();</span><br><span class="line">view.setNeedsLayout();</span><br><span class="line"></span><br><span class="line">// 多参数方法名使用 _ 分隔</span><br><span class="line">self.navigationController().pushViewController_animated(tableViewCtrl, YES)</span><br><span class="line"></span><br><span class="line">// 在方法名前加 ORIG 即可调用未覆盖前的 OC 原方法：</span><br><span class="line">defineClass(&quot;JPTableViewController&quot;, &#123;</span><br><span class="line">  viewDidLoad: function() &#123;</span><br><span class="line">     self.ORIGviewDidLoad();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><h3 id="1、OC-方法的替换"><a href="#1、OC-方法的替换" class="headerlink" title="1、OC 方法的替换"></a>1、OC 方法的替换</h3><p>前面热修复代码实例中，可以看到 defineClass 的调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defineClass(&#x27;JPViewController&#x27;, &#123;</span><br><span class="line">  handleBtn: function(sender) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在执行 <code>defineClass</code> 时，实际上会走进 JSPatch.js 中定义的 <code>defineClass</code> 中，<code>defineClass</code> 实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">global.defineClass = function(declaration, properties, instMethods, clsMethods) &#123;</span><br><span class="line">    var newInstMethods = &#123;&#125;, newClsMethods = &#123;&#125;</span><br><span class="line">    // 如果 properties 不是数组，则调整参数顺序</span><br><span class="line">    if (!(properties instanceof Array)) &#123;</span><br><span class="line">      clsMethods = instMethods</span><br><span class="line">      instMethods = properties</span><br><span class="line">      properties = null</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果有 properties，为每个属性生成 getter 和 setter 方法，并添加到 instMethods 中</span><br><span class="line">    if (properties) &#123;</span><br><span class="line">      // 遍历 properties 数组中的每一个属性名</span><br><span class="line">      properties.forEach(function(name)&#123;</span><br><span class="line">        // 如果 instMethods 中没有该属性名对应的方法，则为其生成 getter 方法</span><br><span class="line">        if (!instMethods[name]) &#123;</span><br><span class="line">          instMethods[name] = _propertiesGetFun(name);</span><br><span class="line">        &#125;</span><br><span class="line">        var nameOfSet = &quot;set&quot;+ name.substr(0,1).toUpperCase() + name.substr(1);</span><br><span class="line">          // 如果 instMethods 中没有该 setter 方法，则为其生成 setter 方法</span><br><span class="line">        if (!instMethods[nameOfSet]) &#123;</span><br><span class="line">          instMethods[nameOfSet] = _propertiesSetFun(name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 提取类名，并去除多余的空格</span><br><span class="line">    var realClsName = declaration.split(&#x27;:&#x27;)[0].trim()</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * instMethods/clsMethods -&gt; newInstMethods/newClsMethods</span><br><span class="line">     * newInstMethods/newClsMethods 都是数组，key 为原始函数的名称；value 为数组，[0] 为参数数量，[1] 函数实现</span><br><span class="line">     */</span><br><span class="line">    _formatDefineMethods(instMethods, newInstMethods, realClsName)</span><br><span class="line">    _formatDefineMethods(clsMethods, newClsMethods, realClsName)</span><br><span class="line">    // _OC_defineClass：新增方法，或者对原方法进行覆盖</span><br><span class="line">    var ret = _OC_defineClass(declaration, newInstMethods, newClsMethods)</span><br><span class="line">    var className = ret[&#x27;cls&#x27;]</span><br><span class="line">    var superCls = ret[&#x27;superCls&#x27;]</span><br><span class="line">    _ocCls[className] = &#123;</span><br><span class="line">      instMethods: &#123;&#125;,</span><br><span class="line">      clsMethods: &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    if (superCls.length &amp;&amp; _ocCls[superCls]) &#123;</span><br><span class="line">      for (var funcName in _ocCls[superCls][&#x27;instMethods&#x27;]) &#123;</span><br><span class="line">        _ocCls[className][&#x27;instMethods&#x27;][funcName] = _ocCls[superCls][&#x27;instMethods&#x27;][funcName]</span><br><span class="line">      &#125;</span><br><span class="line">      for (var funcName in _ocCls[superCls][&#x27;clsMethods&#x27;]) &#123;</span><br><span class="line">        _ocCls[className][&#x27;clsMethods&#x27;][funcName] = _ocCls[superCls][&#x27;clsMethods&#x27;][funcName]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _setupJSMethod(className, instMethods, 1, realClsName)</span><br><span class="line">    _setupJSMethod(className, clsMethods, 0, realClsName)</span><br><span class="line">    return require(className)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由上可知，<code>defineClass</code> 定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defineClass(classDeclaration, [properties,] instanceMethods, classMethods)</span><br></pre></td></tr></table></figure><ul><li><code>classDeclaration</code>：字符串，类名&#x2F;父类名和 Protocol</li><li><code>properties</code>：新增 property，字符串数组，可省略</li><li><code>instanceMethods</code>：要添加或覆盖的实例方法</li><li><code>classMethods</code>：要添加或覆盖的类方法</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">defineClass(&quot;xxxClassName&quot;, [&#x27;property1&#x27;, &#x27;property2&#x27;], &#123;</span><br><span class="line">  instanceMethod1: function() &#123;&#125;,</span><br><span class="line">  instanceMethod2: function() &#123;&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  classMethod1: function() &#123;&#125;,</span><br><span class="line">  classMethod2: function() &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>defineClass</code> 中主要逻辑如下：</p><ul><li>如果有 <code>properties</code>，为每个属性生成 <code>getter</code> 和 <code>setter</code> 方法，并添加到 <code>instMethods</code> 中。</li><li>对 <code>instMethods</code>、<code>classMethods</code> 进行包装处理，<ul><li>包装前：<code>key</code> 为原始函数的名称；<code>value</code> 为函数实现。</li><li>包装后：<code>key</code> 为原始函数的名称；<code>value</code> 为数组，<code>[0]</code> 为参数数量，<code>[1]</code> 函数实现。<ul><li>如果包装的原因是，从 JS 将数据传给 OC，OC 收到的是 <code>JSValue</code> 类型，OC 无法从中读取参数数量，而 OC 后续的逻辑需要使用参数数量。</li></ul></li></ul></li><li>执行 <code>_OC_defineClass</code>，进行方法的新增和替换。</li></ul><p><code>_OC_defineClass</code> 是 OC 中通过 <code>JSContext</code> 注入的函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context[<span class="string">@&quot;_OC_defineClass&quot;</span>] = ^(<span class="built_in">NSString</span> *classDeclaration, JSValue *instanceMethods, JSValue *classMethods) &#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(classDeclaration, instanceMethods, classMethods);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其会走进 OC 实现的 defineClass 方法中：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 替换或新增方法。并返回字典：@&#123;@&quot;cls&quot;: className, @&quot;superCls&quot;: superClassName&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSDictionary</span> *defineClass(<span class="built_in">NSString</span> *classDeclaration, JSValue *instanceMethods, JSValue *classMethods)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 NSScanner 扫描 classDeclaration 字符串，提取类名、父类名和协议名</span></span><br><span class="line">    <span class="comment">// classDeclaration 示例：JPTableViewController : UITableViewController &lt;UIAlertViewDelegate&gt;</span></span><br><span class="line">    <span class="built_in">NSScanner</span> *scanner = [<span class="built_in">NSScanner</span> scannerWithString:classDeclaration];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *className;</span><br><span class="line">    <span class="built_in">NSString</span> *superClassName;</span><br><span class="line">    <span class="built_in">NSString</span> *protocolNames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描到 &quot;:&quot; 之前的内容作为类名</span></span><br><span class="line">    [scanner scanUpToString:<span class="string">@&quot;:&quot;</span> intoString:&amp;className];</span><br><span class="line">    <span class="keyword">if</span> (!scanner.isAtEnd) &#123;</span><br><span class="line">        <span class="comment">// 跳过 &quot;:&quot; 字符</span></span><br><span class="line">        scanner.scanLocation = scanner.scanLocation + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 扫描到 &quot;&lt;&quot; 之前的内容作为父类名</span></span><br><span class="line">        [scanner scanUpToString:<span class="string">@&quot;&lt;&quot;</span> intoString:&amp;superClassName];</span><br><span class="line">        <span class="keyword">if</span> (!scanner.isAtEnd) &#123;</span><br><span class="line">            <span class="comment">// 跳过 &quot;&lt;&quot; 字符</span></span><br><span class="line">            scanner.scanLocation = scanner.scanLocation + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 扫描到 &quot;&gt;&quot; 之前的内容作为协议名</span></span><br><span class="line">            [scanner scanUpToString:<span class="string">@&quot;&gt;&quot;</span> intoString:&amp;protocolNames];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 superClassName 没取到，就赋值为 NSObject</span></span><br><span class="line">    <span class="keyword">if</span> (!superClassName) superClassName = <span class="string">@&quot;NSObject&quot;</span>;</span><br><span class="line">    className = trim(className);</span><br><span class="line">    superClassName = trim(superClassName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 协议可能是多个，拆分成数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *protocols = [protocolNames length] ? [protocolNames componentsSeparatedByString:<span class="string">@&quot;,&quot;</span>] : <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(className);</span><br><span class="line">    <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">        Class superCls = <span class="built_in">NSClassFromString</span>(superClassName);</span><br><span class="line">        <span class="keyword">if</span> (!superCls) &#123;</span><br><span class="line">            _exceptionBlock([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;can&#x27;t find the super class %@&quot;</span>, superClassName]);</span><br><span class="line">            <span class="keyword">return</span> @&#123;<span class="string">@&quot;cls&quot;</span>: className&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 类不存在，但是父类存在。则动态创建一个新的类</span></span><br><span class="line">        cls = objc_allocateClassPair(superCls, className.UTF8String, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将新创建的类注册到运行时系统中</span></span><br><span class="line">        objc_registerClassPair(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (protocols.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span>* protocolName <span class="keyword">in</span> protocols) &#123;</span><br><span class="line">            <span class="comment">// 将协议添加到的类中，使类遵循该协议</span></span><br><span class="line">            Protocol *protocol = objc_getProtocol([trim(protocolName) cStringUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">            class_addProtocol (cls, protocol);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        <span class="comment">// 分别针对 instanceMethods、classMethods 处理</span></span><br><span class="line">        <span class="type">BOOL</span> isInstance = i == <span class="number">0</span>;</span><br><span class="line">        JSValue *jsMethods = isInstance ? instanceMethods: classMethods;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         objc_getMetaClass 获取元类，接收参数是字符串。等价于 object_getClass([xxxObject class])</span></span><br><span class="line"><span class="comment">         元类：类的所属类，普通类存储了实例方法，而元类存储了类方。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class currCls = isInstance ? cls: objc_getMetaClass(className.UTF8String);</span><br><span class="line">        <span class="built_in">NSDictionary</span> *methodDict = [jsMethods toDictionary];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *jsMethodName <span class="keyword">in</span> methodDict.allKeys) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             在 JS 的 _formatDefineMethods 中，methodName 对应的 value 被设置成了数组，[0] 为参数数量，[1] 为包装后的函数实现</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            JSValue *jsMethodArr = [jsMethods valueForProperty:jsMethodName];</span><br><span class="line">            <span class="comment">// 获取方法的参数个数</span></span><br><span class="line">            <span class="type">int</span> numberOfArg = [jsMethodArr[<span class="number">0</span>] toInt32];</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             将 JS 热修复代码的方法名转成正常方法名。例如：</span></span><br><span class="line"><span class="comment">             tableView_cellForRowAtIndexPath -&gt;  tableView:cellForRowAtIndexPath:</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSString</span> *selectorName = convertJPSelectorString(jsMethodName);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ([selectorName componentsSeparatedByString:<span class="string">@&quot;:&quot;</span>].count - <span class="number">1</span> &lt; numberOfArg) &#123;</span><br><span class="line">                selectorName = [selectorName stringByAppendingString:<span class="string">@&quot;:&quot;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            JSValue *jsMethod = jsMethodArr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (class_respondsToSelector(currCls, <span class="built_in">NSSelectorFromString</span>(selectorName))) &#123;</span><br><span class="line">                <span class="comment">// 如果 currCls 中已实现对应方法，说明是想覆盖原方法，HOOK 替换原方法实现</span></span><br><span class="line">                overrideMethod(currCls, selectorName, jsMethod, !isInstance, <span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// currCls 中如果没有实现过，则无法直接获取方法的类型编码（overrideMethod 的最后一个参数），需要获取正确的类型编码传进去</span></span><br><span class="line">                <span class="comment">// 先看协议中使用有这个方法，如果有，则从协议中获取方法类型编码</span></span><br><span class="line">                <span class="type">BOOL</span> overrided = <span class="literal">NO</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">NSString</span> *protocolName <span class="keyword">in</span> protocols) &#123;</span><br><span class="line">                    <span class="type">char</span> *types = methodTypesInProtocol(protocolName, selectorName, isInstance, <span class="literal">YES</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!types) types = methodTypesInProtocol(protocolName, selectorName, isInstance, <span class="literal">NO</span>);</span><br><span class="line">                    <span class="keyword">if</span> (types) &#123;</span><br><span class="line">                        overrideMethod(currCls, selectorName, jsMethod, !isInstance, types);</span><br><span class="line">                        free(types);</span><br><span class="line">                        overrided = <span class="literal">YES</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果协议中没有找到，参数、返回值全按照 id 类型生成 类型编码</span></span><br><span class="line">                <span class="keyword">if</span> (!overrided) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (![[jsMethodName substringToIndex:<span class="number">1</span>] isEqualToString:<span class="string">@&quot;_&quot;</span>]) &#123;</span><br><span class="line">                        <span class="comment">// 第一个 @，代表返回值是 id 类型、第二个 @，代表 id 类型参数 self、第三个 : 代表 SEL 类型参数 _cmd</span></span><br><span class="line">                        <span class="built_in">NSMutableString</span> *typeDescStr = [<span class="string">@&quot;@@:&quot;</span> mutableCopy];</span><br><span class="line">                        <span class="comment">// 其余参数全按照 id 类型处理</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numberOfArg; i ++) &#123;</span><br><span class="line">                            [typeDescStr appendString:<span class="string">@&quot;@&quot;</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        overrideMethod(currCls, selectorName, jsMethod, !isInstance, [typeDescStr cStringUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class_addMethod(cls, <span class="keyword">@selector</span>(getProp:), (IMP)getPropIMP, <span class="string">&quot;@@:@&quot;</span>);</span><br><span class="line">    class_addMethod(cls, <span class="keyword">@selector</span>(setProp:forKey:), (IMP)setPropIMP, <span class="string">&quot;v@:@@&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> @&#123;<span class="string">@&quot;cls&quot;</span>: className, <span class="string">@&quot;superCls&quot;</span>: superClassName&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之，OC 中实现的 <code>defineClass</code> 主要逻辑如下：</p><ul><li>解析出类、方法名、类型编码等信息</li><li>利用 Runtime 进行新增或替换方法</li></ul><p>其中，方法的动态替换是通过其 <code>overrideMethod</code> 方法实现的，其具体实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> overrideMethod(Class cls, <span class="built_in">NSString</span> *selectorName, JSValue *function, <span class="type">BOOL</span> isClassMethod, <span class="keyword">const</span> <span class="type">char</span> *typeDescription)</span><br><span class="line">&#123;</span><br><span class="line">    SEL selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!typeDescription) &#123;</span><br><span class="line">        Method method = class_getInstanceMethod(cls, selector);</span><br><span class="line">        typeDescription = (<span class="type">char</span> *)method_getTypeEncoding(method);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 OC 原方法的实现</span></span><br><span class="line">    IMP originalImp = class_respondsToSelector(cls, selector) ? class_getMethodImplementation(cls, selector) : <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    IMP msgForwardIMP = _objc_msgForward;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> !defined(__arm64__)</span></span><br><span class="line">        <span class="keyword">if</span> (typeDescription[<span class="number">0</span>] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//In some cases that returns struct, we should use the &#x27;_stret&#x27; API:</span></span><br><span class="line">            <span class="comment">//http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html</span></span><br><span class="line">            <span class="comment">//NSMethodSignature knows the detail but has no API to return, we can only get the info from debugDescription.</span></span><br><span class="line">            <span class="built_in">NSMethodSignature</span> *methodSignature = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:typeDescription];</span><br><span class="line">            <span class="keyword">if</span> ([methodSignature.debugDescription rangeOfString:<span class="string">@&quot;is special struct return? YES&quot;</span>].location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">                msgForwardIMP = (IMP)_objc_msgForward_stret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     把  -forwardInvocation: 方法的实现给替换掉了，如果程序里真有用到这个方法对消息进行转发，原来的逻辑怎么办？</span></span><br><span class="line"><span class="comment">     首先在替换 -forwardInvocation: 方法前会新建一个方法 -ORIGforwardInvocation:，保存原来的实现 IMP，在新的 -forwardInvocation: 实现里做了个判断，如果转发的方法是我们想改写的，就走我们的逻辑，若不是，就调 -ORIGforwardInvocation: 走原来的流程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (class_getMethodImplementation(cls, <span class="keyword">@selector</span>(forwardInvocation:)) != (IMP)JPForwardInvocation) &#123;</span><br><span class="line">        <span class="comment">// 替换类 cls 中的 forwardInvocation: 方法的实现为 JPForwardInvocation</span></span><br><span class="line">        IMP originalForwardImp = class_replaceMethod(cls, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)JPForwardInvocation, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (originalForwardImp) &#123;</span><br><span class="line">            class_addMethod(cls, <span class="keyword">@selector</span>(ORIGforwardInvocation:), originalForwardImp, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增一个 ORIGXXX 方法，指向原方法的实现</span></span><br><span class="line">    [cls jp_fixMethodSignature];</span><br><span class="line">    <span class="keyword">if</span> (class_respondsToSelector(cls, selector)) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *originalSelectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;ORIG%@&quot;</span>, selectorName];</span><br><span class="line">        SEL originalSelector = <span class="built_in">NSSelectorFromString</span>(originalSelectorName);</span><br><span class="line">        <span class="keyword">if</span>(!class_respondsToSelector(cls, originalSelector)) &#123;</span><br><span class="line">            class_addMethod(cls, originalSelector, originalImp, typeDescription);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *JPSelectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;_JP%@&quot;</span>, selectorName];</span><br><span class="line">    </span><br><span class="line">    _initJPOverideMethods(cls);</span><br><span class="line">    _JSOverideMethods[cls][JPSelectorName] = function;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     通过 class_replaceMethod() 接口将原方法直接指向 _objc_msgForward，使调用方法的时候，直接走消息转发流程，这样调用这个方法时就会走到 -forwardInvocation:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    class_replaceMethod(cls, selector, msgForwardIMP, typeDescription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>overrideMethod</code> 逻辑总结如下：</p><ul><li><p>先替换 <code>forwardInvocation:</code> 实现，替换成 <code>JPForwardInvocation</code></p><ul><li>同时将原保存到 <code>forwardInvocation:</code> 实现保存到 <code>ORIGforwardInvocation:</code></li><li>执行 <code>JPForwardInvocation</code> 时，如果没有找到对应 JS 方法，则走原始转发流程，执行 <code>ORIGforwardInvocation:</code></li></ul></li><li><p>添加 <code>-ORIGXXXXX</code> 和 <code>-_JPXXXXX</code> 两个方法，前者指向原来的 IMP 实现，后者是 JS 热修复代码中的新实现。</p><ul><li>如果热修复代码需要调用原方法，可以在方法名前拼上 ORIG 去调用，因为这一步保存了方法原实现 <code>-ORIGXXXXX</code></li></ul></li><li><p>将原方法实现指向 <code>_objc_msgForward</code>，使方法直接走消息转发流程。</p></li><li><p>在 <code>JPForwardInvocation</code> 里，获取 <code>Invocation</code>  参数，传给 <code>-_JPXXXXX</code> 方法并执行，实现了 JS 方法替换 OC 方法。</p></li></ul><p>该流程可用下图表示：<br><img src="/images/lix_blog_186.png"></p><h3 id="2、JavaScriptCore-执行-OC-方法"><a href="#2、JavaScriptCore-执行-OC-方法" class="headerlink" title="2、JavaScriptCore 执行 OC 方法"></a>2、JavaScriptCore 执行 OC 方法</h3><p>还以前面的热修复代码为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defineClass(&#x27;JPViewController&#x27;, &#123;</span><br><span class="line">  handleBtn: function(sender) &#123;</span><br><span class="line">    var tableViewCtrl = JPTableViewController.alloc().init()</span><br><span class="line">    self.navigationController().pushViewController_animated(tableViewCtrl, YES)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述 JS 实现的热修复代码中，有类似 <code>alloc</code>、<code>init</code> 等 OC 方法的调用，而在 JS 中，是不存在这些方法的，如果想要 JS 代码执行不报错，就需要保证这些方法在 JS 中正常被调用。</p><p>实际上，在 <code>JPEngine</code> 中执行 JS 代码时，逻辑如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+ (JSValue *)_evaluateScript:(<span class="built_in">NSString</span> *)script withSourceURL:(<span class="built_in">NSURL</span> *)resourceURL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!script || ![JSContext <span class="keyword">class</span>]) &#123;</span><br><span class="line">        _exceptionBlock(<span class="string">@&quot;script is nil&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> startEngine];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!_regex) &#123;</span><br><span class="line">        _regex = [<span class="built_in">NSRegularExpression</span> regularExpressionWithPattern:_regexStr options:<span class="number">0</span> error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     1、正则匹配找到热修复 JS 代码中的所有方法调用，改成调用 __c()</span></span><br><span class="line"><span class="comment">     UIView.alloc().init()  -&gt;  UIView.__c(&#x27;alloc&#x27;)().__c(&#x27;init&#x27;)()</span></span><br><span class="line"><span class="comment">     object.methodName(param1, param2); -&gt;  object.__c(&quot;methodName&quot;)(param1, param2);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     2、将修改后的 JS 放到 try catch 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSString</span> *formatedScript = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;;(function()&#123;try&#123;\n%@\n&#125;catch(e)&#123;_OC_catch(e.message, e.stack)&#125;&#125;)();&quot;</span>, [_regex stringByReplacingMatchesInString:script options:<span class="number">0</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, script.length) withTemplate:_replaceStr]];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="comment">// 3、执行热修复 JS</span></span><br><span class="line">        <span class="keyword">if</span> ([_context respondsToSelector:<span class="keyword">@selector</span>(evaluateScript:withSourceURL:)]) &#123;</span><br><span class="line">            <span class="keyword">return</span> [_context evaluateScript:formatedScript withSourceURL:resourceURL];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [_context evaluateScript:formatedScript];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        _exceptionBlock([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, exception]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行 JS 代码之前，JSPatch 使用正则找到了所有方法的调用，将方法的调用改成 <code>__c</code> 函数的调用，并放到 try catch 中，例如前面热修复代码，经过这一步之后，会变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;(function()&#123;try&#123;</span><br><span class="line">defineClass(&#x27;JPViewController&#x27;, &#123;</span><br><span class="line">  handleBtn: function(sender) &#123;</span><br><span class="line">    var tableViewCtrl = JPTableViewController.__c(&quot;alloc&quot;)().__c(&quot;init&quot;)()</span><br><span class="line">    self.__c(&quot;navigationController&quot;)().__c(&quot;pushViewController_animated&quot;)(tableViewCtrl, YES)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;catch(e)&#123;_OC_catch(e.message, e.stack)&#125;&#125;)();</span><br></pre></td></tr></table></figure><p>JSPatch 通过正则把所有方法调用都改成调用 <code>__c()</code> 函数，再执行这个 JS 脚本，达到类似 OC&#x2F;Lua&#x2F;Ruby 等的消息转发的目的。</p><p><code>__c</code> 函数实现方式：在 JSPatch.js 中，给 JS 对象基类 Object 加上 <code>__c</code> 成员，这样所有对象都可以调用到<code> __c</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(Object.prototype, &#x27;__c&#x27;, &#123;value: function(methodName) &#123;</span><br><span class="line">  if (!this.__obj &amp;&amp; !this.__clsName) return this[methodName].bind(this);</span><br><span class="line">  var self = this</span><br><span class="line">  return function()&#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments)</span><br><span class="line">    return _methodFunc(self.__obj, self.__clsName, methodName, args, self.__isSuper)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;)</span><br></pre></td></tr></table></figure><p>在上述的 <code>_methodFunc()</code> 中，把相关信息传给 OC，OC 再利用 Runtime 去调用相应方法，返回结果值。这样就达到了 JS 调用任意 OC 方法的目的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var _methodFunc = function(instance, clsName, methodName, args, isSuper, isPerformSelector) &#123;</span><br><span class="line">  var selectorName = methodName</span><br><span class="line">  if (!isPerformSelector) &#123;</span><br><span class="line">    methodName = methodName.replace(/__/g, &quot;-&quot;)</span><br><span class="line">    selectorName = methodName.replace(/_/g, &quot;:&quot;).replace(/-/g, &quot;_&quot;)</span><br><span class="line">    var marchArr = selectorName.match(/:/g)</span><br><span class="line">    var numOfArgs = marchArr ? marchArr.length : 0</span><br><span class="line">    if (args.length &gt; numOfArgs) &#123;</span><br><span class="line">      selectorName += &quot;:&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):</span><br><span class="line">                       _OC_callC(clsName, selectorName, args)</span><br><span class="line">  return _formatOCToJS(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>_methodFunc()</code> 中，通过 <code>_OC_callI</code>&#x2F;<code>_OC_callC</code> 调用具体 OC 方法，<code>_OC_callI</code>&#x2F;<code>_OC_callC</code> 会执行 OC 实现的 <code>callSelector</code>，在 <code>callSelector</code> 中利用 Runtime 去调用相应方法，返回结果值给到 JS。这样就达到了 JS 调用任意 OC 方法的目的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context[<span class="string">@&quot;_OC_callI&quot;</span>] = ^<span class="type">id</span>(JSValue *obj, <span class="built_in">NSString</span> *selectorName, JSValue *arguments, <span class="type">BOOL</span> isSuper) &#123;</span><br><span class="line">    <span class="keyword">return</span> callSelector(<span class="literal">nil</span>, selectorName, arguments, obj, isSuper);</span><br><span class="line">&#125;;</span><br><span class="line">context[<span class="string">@&quot;_OC_callC&quot;</span>] = ^<span class="type">id</span>(<span class="built_in">NSString</span> *className, <span class="built_in">NSString</span> *selectorName, JSValue *arguments) &#123;</span><br><span class="line">    <span class="keyword">return</span> callSelector(className, selectorName, arguments, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该过程总结如下：</p><ul><li>通过正则替换方法的调用：在执行 JS 代码之前，JSPatch 使用正则匹配找到所有方法的调用，并将其替换为调用 <code>__c</code> 函数。<ul><li><code>object.methodName(param1, param2);</code> -&gt; <code>object.__c(&quot;methodName&quot;)(param1, param2);</code></li></ul></li><li><code>__c</code> 函数的实现： 在 JSPatch.js 中，给 JS 对象基类 Object 添加 <code>__c</code> 成员函数，这样所有对象都可以调用到 <code>__c</code>，在 <code>__c</code> 中会调用 <code>_methodFunc</code> 函数。</li><li><code>_methodFunc</code> 函数：负责处理具体的方法调用信息，通过 <code>_OC_callI</code> 和 <code>_OC_callC</code> 传递方法调用信息。</li><li><code>_OC_callI</code>&#x2F;<code>_OC_callC</code>：<code>JSEngine</code> 注入的方法，实际调用的是 OC 实现的 c<code>allSelector</code>。</li><li><code>callSelector</code>：利用 <code>Runtime</code> 执行方法，并将返回值返回给 JS。</li></ul><h3 id="3、JS-与-OC-数据传递"><a href="#3、JS-与-OC-数据传递" class="headerlink" title="3、JS 与 OC 数据传递"></a>3、JS 与 OC 数据传递</h3><p>还以前面示例为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;(function()&#123;try&#123;</span><br><span class="line">defineClass(&#x27;JPViewController&#x27;, &#123;</span><br><span class="line">  handleBtn: function(sender) &#123;</span><br><span class="line">    var tableViewCtrl = JPTableViewController.__c(&quot;alloc&quot;)().__c(&quot;init&quot;)()</span><br><span class="line">    self.__c(&quot;navigationController&quot;)().__c(&quot;pushViewController_animated&quot;)(tableViewCtrl, YES)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;catch(e)&#123;_OC_catch(e.message, e.stack)&#125;&#125;)();</span><br></pre></td></tr></table></figure><p>上述实现有两个方向的数据传递：</p><ul><li><p><strong>OC -&gt; JS</strong></p><ul><li>JS 调用 OC ，获取 OC 返回值：<ul><li><code>var tableViewCtrl = JPTableViewController.__c(&quot;alloc&quot;)().__c(&quot;init&quot;)()</code></li><li><code>tableViewCtrl</code> 为 OC 返回给 JS 的数据。</li></ul></li></ul></li><li><p><strong>JS -&gt; OC</strong></p><ul><li>JS 获取到 OC 返回值后，再调用 OC 方法转给 OC：<ul><li><code>self.__c(&quot;navigationController&quot;)().__c(&quot;pushViewController_animated&quot;)(tableViewCtrl, YES)</code></li><li><code>tableViewCtrl</code>、<code>YES</code> 为 JS 传给 OC 的数据。</li></ul></li></ul></li></ul><h4 id="（1）OC-JS-数据传递"><a href="#（1）OC-JS-数据传递" class="headerlink" title="（1）OC -&gt; JS 数据传递"></a>（1）OC -&gt; JS 数据传递</h4><p>前面已经提到，JS 的 <code>__c</code> 函数实际上是调用 <code>_methodFunc()</code>，<code>_methodFunc()</code> 实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var _methodFunc = function(instance, clsName, methodName, args, isSuper, isPerformSelector) &#123;</span><br><span class="line">  var selectorName = methodName</span><br><span class="line">  if (!isPerformSelector) &#123;</span><br><span class="line">    methodName = methodName.replace(/__/g, &quot;-&quot;)</span><br><span class="line">    selectorName = methodName.replace(/_/g, &quot;:&quot;).replace(/-/g, &quot;_&quot;)</span><br><span class="line">    var marchArr = selectorName.match(/:/g)</span><br><span class="line">    var numOfArgs = marchArr ? marchArr.length : 0</span><br><span class="line">    if (args.length &gt; numOfArgs) &#123;</span><br><span class="line">      selectorName += &quot;:&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):</span><br><span class="line">                       _OC_callC(clsName, selectorName, args)</span><br><span class="line">  return _formatOCToJS(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>_methodFunc()</code> 中主要逻辑是获取获取具体方法调用信息以及具体参数，再去调用<code> _OC_callI</code>、<code>_OC_callC</code>，<code>_OC_callI</code>、<code>_OC_callC</code> 最终都会走进 OC 的 <code>callSelector</code> 中：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context[<span class="string">@&quot;_OC_callI&quot;</span>] = ^<span class="type">id</span>(JSValue *obj, <span class="built_in">NSString</span> *selectorName, JSValue *arguments, <span class="type">BOOL</span> isSuper) &#123;</span><br><span class="line">    <span class="keyword">return</span> callSelector(<span class="literal">nil</span>, selectorName, arguments, obj, isSuper);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">context[<span class="string">@&quot;_OC_callC&quot;</span>] = ^<span class="type">id</span>(<span class="built_in">NSString</span> *className, <span class="built_in">NSString</span> *selectorName, JSValue *arguments) &#123;</span><br><span class="line">    <span class="keyword">return</span> callSelector(className, selectorName, arguments, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>callSelector</code> 逻辑伪代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">id</span> callSelector(<span class="built_in">NSString</span> *className, <span class="built_in">NSString</span> *selectorName, JSValue *arguments, JSValue *instance, <span class="type">BOOL</span> isSuper)</span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line">    invocation = ...</span><br><span class="line">    [invocation setTarget:xxxx];</span><br><span class="line">    </span><br><span class="line">    <span class="type">id</span> argumentsObj = formatJSToOC(arguments);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *methodSignature = ......;</span><br><span class="line">    <span class="built_in">NSUInteger</span> numberOfArguments = methodSignature.numberOfArguments;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">2</span>; i &lt; numberOfArguments; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span> *argumentType = [methodSignature getArgumentTypeAtIndex:i];</span><br><span class="line">        <span class="type">id</span> valObj = argumentsObj[i<span class="number">-2</span>];</span><br><span class="line">        <span class="comment">// 根据 argumentType 将 valObj 转成对应的类型</span></span><br><span class="line">        value = covert(valObj);</span><br><span class="line">        [invocation setArgument:&amp;value atIndex:i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> *result;</span><br><span class="line">    [invocation getReturnValue:&amp;result];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> formatOCToJS(returnValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>callSelector</code> 中，执行完 OC 方法，会将 OC 方法返回值，调用 OC 中实现的 <code>formatOCToJS</code> 进行处理后再返回给 JS。</p><p><code>formatOCToJS</code> 的作用就是将传入的 OC 对象包装成一个 <code>NSDictionary</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">id</span> formatOCToJS(<span class="type">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] || [obj isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]] || [obj isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] || [obj isKindOfClass:[<span class="built_in">NSDate</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> _autoConvert ? obj: _wrapObj([JPBoxing boxObj:obj]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> _convertOCNumberToString ? [(<span class="built_in">NSNumber</span>*)obj stringValue] : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;NSBlock&quot;</span>)] || [obj isKindOfClass:[JSValue <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     将  obj 包装成字典</span></span><br><span class="line"><span class="comment">     字典主要有两个 key:</span></span><br><span class="line"><span class="comment">     __obj：当前对象</span></span><br><span class="line"><span class="comment">     __clsName：对象对应的 class 字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> _wrapObj(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>_wrapObj</code> 实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSDictionary</span> *_wrapObj(<span class="type">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj || obj == _nilObj) &#123;</span><br><span class="line">        <span class="keyword">return</span> @&#123;<span class="string">@&quot;__isNil&quot;</span>: @(<span class="literal">YES</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> @&#123;<span class="string">@&quot;__obj&quot;</span>: obj, <span class="string">@&quot;__clsName&quot;</span>: <span class="built_in">NSStringFromClass</span>([obj isKindOfClass:[JPBoxing <span class="keyword">class</span>]] ? [[((JPBoxing *)obj) unbox] <span class="keyword">class</span>]: [obj <span class="keyword">class</span>])&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字典中至少保存了两个信息：</p><ul><li><code>__obj</code><ul><li>对象实例</li></ul></li><li><code>__clsName</code><ul><li>ClassName 字符串</li></ul></li></ul><p>这样 JS 中就可以通过判断对象是否有 <code>__obj</code> 属性得知这个对象是否表示 OC 对象指针。</p><p>该过程总结如下：</p><ul><li><p>如果是 <code>NSString</code>、<code>NSDictionary</code>、<code>NSArray</code> 类型，则先将 <code>obj</code> 包装成 <code>JPBoxing</code>，再调用 <code>_wrapObj</code> 将 <code>JPBoxing</code> 包装成字典。</p><ul><li><code>NSMutableArray</code>&#x2F;<code>NSMutableDictionary</code>&#x2F;<code>NSMutableString</code> 从 OC 传到 JS 时，<code>JavaScriptCore</code> 把它们转成了 JS 的 <code>Array</code>&#x2F;<code>Object</code>&#x2F;<code>String</code>，再回传给 OC 时，OC 收到的不再是 NSMutableXXX，脱离了跟原对象的联系，导致在 JS 中无法调用三者可变对象中的方法去修改对象，解决办法是：<ul><li>如果对象是 NSMutableXXX，就先将对象保存到 <code>JPBoxing</code>，JS 拿到的是 <code>JPBoxing</code>，从 JS 再传回给 OC 时就可以通过 <code>JPBoxing</code> 对象成员取到原始对象。</li><li>为了规则简单，JSPatch 让 <code>NSArray</code>&#x2F;<code>NSDictionary</code>&#x2F;<code>NSString</code> 也同样以封装的方式传递，避免在调用 OC 方法返回对象时还需要关心它返回的是可变还是不可变对象。</li></ul></li></ul></li><li><p>如果是其他普通 OC 对象，直接调用 <code>_wrapObj</code> 包装成字典。</p></li><li><p>JS 中通过判断对象是否有 <code>__obj</code> 属性得知这个对象是否表示 OC 对象指针。</p><ul><li>OC 的字典传到 JS，就变成 JS 的对象 Object 类型。</li></ul></li></ul><h4 id="（2）JS-OC-数据传递"><a href="#（2）JS-OC-数据传递" class="headerlink" title="（2）JS -&gt; OC 数据传递"></a>（2）JS -&gt; OC 数据传递</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var tableViewCtrl = JPTableViewController.__c(&quot;alloc&quot;)().__c(&quot;init&quot;)()</span><br><span class="line">self.__c(&quot;navigationController&quot;)().__c(&quot;pushViewController_animated&quot;)(tableViewCtrl, YES)</span><br></pre></td></tr></table></figure><p>上述 <code>tableViewCtrl</code> 是调用 JS 调用 OC 获取的返回值，即调用 <code>_methodFunc</code> 的返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var _methodFunc = function(instance, clsName, methodName, args, isSuper, isPerformSelector) &#123;</span><br><span class="line"></span><br><span class="line">  // 省略 ......</span><br><span class="line"></span><br><span class="line">  var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):</span><br><span class="line">                       _OC_callC(clsName, selectorName, args)</span><br><span class="line">  return _formatOCToJS(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_methodFunc</code> 中，在获取到 OC 返回值的时候，会调用 JS 函数 <code>_formatOCToJS</code> 对返回值进行处理，JS 中的 <code>_formatOCToJS</code> 实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var _formatOCToJS = function(obj) &#123;</span><br><span class="line">  if (obj === undefined || obj === null) return false</span><br><span class="line"></span><br><span class="line">  if (typeof obj == &quot;object&quot;) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * OC 返回给 JS 的字典（OC 对象保存到字典的 __obj 中），到 JS 里就会自动变成 JS 的 Object</span><br><span class="line">     * 如果有 __obj 标志，就代表是 OC 对象，取出 OC 对象返回</span><br><span class="line">     */</span><br><span class="line">    if (obj.__obj) return obj</span><br><span class="line">    if (obj.__isNil) return false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果 obj 是一个数组，则递归地调用 _formatOCToJS 处理数组中的每一个元素，并返回新的数组。</span><br><span class="line">  if (obj instanceof Array) &#123;</span><br><span class="line">    var ret = []</span><br><span class="line">    obj.forEach(function(o) &#123;</span><br><span class="line">      ret.push(_formatOCToJS(o))</span><br><span class="line">    &#125;)</span><br><span class="line">    return ret</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 省略 ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，参数 <code>tableViewCtrl</code> 在传给 OC 之前，就已经从 OC 传递的字典中解析出原始对象，再将解析出原始对象传给 OC。<br>即：JS 传给 OC 的对象，是 OC 原始对象。</p><p><strong>JS 与 OC 数据流转可用下图表示：</strong><br><img src="/images/lix_blog_187.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> 热修复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理之 Lex &amp; Yacc</title>
      <link href="/posts/20895/"/>
      <url>/posts/20895/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Lex 和 Yacc 是编译器和解释器开发中广泛使用的工具，分别用于词法分析和语法分析。它们通常配合使用，帮助开发者快速构建语言处理工具，处理复杂的语言解析任务。</p><p>Lex（Lexical Analyzer Generator）是词法分析器生成器，Yacc（Yet Another Compiler Compiler）是语法分析器生成器，可以通过编写 Lex 和 Yacc 文件，实现自定义的词法分析器和语法分析器，实现对特定语言的解析和处理。</p><p>Lex 最早由 Mike Lesk 和 Eric Schmidt 在 1975 年为 Unix 操作系统开发。虽然 Lex 的原始版本是闭源的，但后来出现了多个开源实现，如 <font color=#ff0000>Flex</font>（Fast Lexical Analyzer Generator），这是 Lex 的一个开源替代品。</p><p>Yacc 由 Stephen C. Johnson 在 1970 年代开发，旨在为 Unix 操作系统提供一个语法分析器生成工具。Yacc 的原始版本也是闭源的，但后来出现了多个开源实现，如 <font color=#ff0000>Bison</font>，这是 GNU 项目提供的 Yacc 的开源替代品。</p><p>macOS 已经内置了 Flex 和 Bison：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/flex</span><br><span class="line">/usr/bin/bison</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_177.png"></p><p>&#x2F;usr&#x2F;bin 中同时还有 lex、yacc 两个工具，路径如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/lex</span><br><span class="line">/usr/bin/yacc</span><br></pre></td></tr></table></figure><p>其本质也是 Flex 和 Bison：<br><img src="/images/lix_blog_178.png"></p><p>Lex、Yacc 常用命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lex test.l      # 生成  lex.yy.c，该文件中实现了词法分析器函数  yylex()</span><br><span class="line">yacc -d test.y  # 生成 y.tab.h, y.tab.c，该文件中实现了语法分析器函数  yyparse()</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_179.png"></p><p>在 Xcode 中，也内置了 lex 和 yacc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lex</span><br><span class="line">/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/yacc</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_180.png"></p><p>也就是说，Xcode 已经支持了 Lex、Yacc，可以自动将 Lex、Yacc 描述文件编译成分析器代码文件。</p><p>在编译流程中，Lex、Yacc 负责的工作如下：</p><ul><li><strong>Lex</strong><ul><li>负责<strong>“词法分析”</strong>的工作。<br></li></ul></li><li><strong>Yacc</strong> <ul><li>核心功能是<strong>“语法分析”</strong>。</li><li>还可以通过 Yacc 语义动作的扩展，使其承担更多工作：“语义分析”、“中间代码生成”。<ul><li>这种方式在实际编译器实现中比较常见，在一个解析阶段中完成多个编译步骤，以提高编译效率。即：<strong>Yacc 同时负责“语法分析”、“语义分析”、“中间代码生成”的工作。</strong></li></ul></li></ul></li></ul><p>Lex 和 Yacc 在编译器构建过程中的协同工作主要流程如下：<br><img src="/images/lix_blog_181.png"></p><ul><li><p><strong>编写 Lex &amp; Yacc 文件</strong></p><ul><li>Lex 文件<ul><li>定义词法分析规则的文件，包含正则表达式和相应的动作。</li></ul></li><li>Yacc 文件<ul><li>定义语法分析规则的文件，包含语法规则和相应的语义动作。</li></ul></li></ul></li><li><p><strong>生成分析器</strong></p><ul><li>Lex<ul><li>读取 Lex 文件，根据描述文件生成 C 语言实现的词法分析器代码文件 lex.yy.c，该文件中实现了词法分析器函数 <code>yylex()</code>。</li></ul></li><li>Yacc<ul><li>读取 Yacc 文件，根据描述文件生成 C 语言实现的语法分析器代码文件 y.tab.h 和 y.tab.c，该文件中实现了语法分析器函数 <code>yyparse()</code>。</li></ul></li></ul></li><li><p><strong>处理流程</strong></p><ul><li><p>词法分析（lex.yy.c）</p><ul><li>输入源代码文件。</li><li>由 <code>yylex()</code> 处理源代码，识别并生成词法单元（tokens）。</li></ul></li><li><p>语法分析（y.tab.h、y.tab.c）</p><ul><li>接受来自 <code>yylex()</code> 的词法单元。</li><li>由 <code>yyparse()</code> 处理词法单元，构建语法树或执行语义动作，最终生成输出。</li></ul></li></ul></li></ul><h2 id="二、Lex"><a href="#二、Lex" class="headerlink" title="二、Lex"></a>二、Lex</h2><p>Lex 负责将输入的字符流分解成有意义的词法单元（token），Lex 文件通常使用 <code>.l</code> 扩展名，使用正则表达式来定义词法规则。</p><p>Lex 文件(example.l)内容示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">[a-zA-Z]+      &#123; printf(&quot;Word: %s\n&quot;, yytext); &#125;</span><br><span class="line">[0-9]+         &#123; printf(&quot;Number: %s\n&quot;, yytext); &#125;</span><br><span class="line">&quot;+&quot;            &#123; printf(&quot;Plus operator\n&quot;); &#125;</span><br><span class="line">&quot;-&quot;            &#123; printf(&quot;Minus operator\n&quot;); &#125;</span><br><span class="line">[ \t\n]+       &#123; /* 匹配空白字符，忽略 */ &#125;</span><br><span class="line">.              &#123; printf(&quot;Unknown character: %s\n&quot;, yytext); &#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int yywrap() &#123;</span><br><span class="line">    return 1;  /* 指示没有更多的输入 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Enter text:\n&quot;);</span><br><span class="line">    yylex();  /* 调用词法分析器 */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成词法分析器代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lex example.l</span><br></pre></td></tr></table></figure><p>编译生成可执行文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc lex.yy.c -o lexer</span><br></pre></td></tr></table></figure><p>执行完上述两个命令之后，会生成文件名为 lexer 的可执行文件：<br><img src="/images/lix_blog_182.png"><br>执行可执行文件，输入测试字符串，可以看到词法分析器输出内容：<br><img src="/images/lix_blog_183.png"></p><p>生成的词法分析器实现代码在 lex.yy.c 中，lex.yy.c 中自动生成的主要函数如下：</p><ul><li><p><code>yylex()</code></p><ul><li>主词法分析函数，它从输入中读取字符并尝试匹配定义的模式。</li><li>每次调用 <code>yylex()</code> 时，它会扫描输入，找到最匹配的模式并执行相应的动作代码。</li><li>返回一个整数值，通常是匹配的模式的标识符（token）。</li></ul></li><li><p><code>yywrap()</code></p><ul><li>在输入文件结束时调用，决定是否继续读取其他输入，返回 <code>1</code> 表示输入结束，返回 <code>0</code> 表示继续。</li></ul></li><li><p><code>yytext</code></p><ul><li>全局字符数组或指针，存储当前匹配的文本。</li><li>每次 <code>yylex()</code> 匹配到模式时，<code>yytext</code> 包含匹配的字符串。</li><li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Matched text: %s\n&quot;, yytext);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>yyleng</code></p><ul><li>全局整数，表示 <code>yytext</code> 中匹配文本的长度。</li></ul></li><li><p><code>yyin</code></p><ul><li>文件指针，指向词法分析器的输入流。</li><li>默认情况下，<code>yyin</code> 指向 <code>stdin</code>，可以重定向到其他文件。</li><li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yyin = fopen(&quot;input.txt&quot;, &quot;r&quot;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>yyout</code></p><ul><li>文件指针，指向词法分析器的输出流（通常用于调试）。</li><li>默认情况下，<code>yyout</code> 指向 <code>stdout</code>，可以重定向到其他文件。</li><li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yyout = fopen(&quot;output.txt&quot;, &quot;w&quot;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>yyrestart(FILE *input_file)</code></p><ul><li>重置词法分析器的输入流。</li><li>可以在文件切换或重新开始分析时使用。</li><li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yyrestart(yyin);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>yyset_in(FILE * _in_str)</code></p><ul><li>设置词法分析器的输入文件。</li><li>调用这个函数，可以动态地更改词法分析器的输入来源，而无需重新启动词法分析器。</li><li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *file = fopen(&quot;input.txt&quot;, &quot;r&quot;);</span><br><span class="line">yyset_in(file);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>yylex_destroy()</code></p><ul><li>释放词法分析器使用的资源。</li><li>在程序结束时调用，以避免内存泄漏。</li></ul></li><li><p><code>yy_scan_string(const char *str)</code></p><ul><li>从字符串而不是文件中读取输入。</li><li>适用于需要从内存中读取输入的场景。</li><li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yy_scan_string(&quot;example input&quot;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)</code></p><ul><li>切换词法分析器的输入缓冲区。</li><li>适用于需要在多个输入源之间切换的场景。</li><li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YY_BUFFER_STATE buffer = yy_scan_string(&quot;example input&quot;);</span><br><span class="line">yy_switch_to_buffer(buffer);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>这些函数和变量共同构成了 Lex 词法分析器的核心功能，使其能够高效地处理输入、匹配模式并执行相应的动作。</p><p>Lex 文件内容结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;定义&gt;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&lt;规则&gt;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&lt;代码&gt;</span><br></pre></td></tr></table></figure><p>使用 %% 对不同的部分进行分隔，其主要包含三部分内容，分别是：</p><ul><li><strong>定义（可选）</strong><ul><li>C 代码定义</li><li>命名正则表达式定义</li><li>指令定义</li></ul></li><li><strong>规则（必选）</strong><ul><li>模式：用于描述词法规则的正则表达式</li><li>动作：模式匹配时要执行的 C 代码</li></ul></li><li><strong>代码（可选）</strong><ul><li>辅助函数</li><li>也可以包含主程序的 main 函数</li><li>这部分代码会被直接拷贝进 lex.yy.c 中</li></ul></li></ul><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>定义部分主要包含三部分内容：</p><ul><li>C 代码定义 (<code>%&#123;</code> 和 <code>%&#125;</code>)</li><li>命名正则表达式定义</li><li>指令定义（以 <code>%</code> 开头的指令）</li></ul><h4 id="（1）C-代码定义-和"><a href="#（1）C-代码定义-和" class="headerlink" title="（1）C 代码定义 (%{ 和 %})"></a>（1）C 代码定义 (%{ 和 %})</h4><p>在定义部分中，可以包含直接嵌入到生成的 C 代码中的代码片段，这些代码会被直接拷贝到生成的 C 文件的开头部分。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">/* C 代码定义 */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int my_global_variable;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure><p>在 <code>%&#123;</code> 和 <code>%&#125;</code> 之间定义的 C 代码会被 Lex 工具直接拷贝到生成的词法分析器代码中。这通常用于定义变量、包含头文件、声明函数等。</p><h4 id="（2）命名正则表达式定义"><a href="#（2）命名正则表达式定义" class="headerlink" title="（2）命名正则表达式定义"></a>（2）命名正则表达式定义</h4><p>用来给常用的正则表达式定义名字，这样在规则部分可以复用这些命名的表达式。</p><p>基本格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name expression</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">letter   [a-zA-Z]</span><br><span class="line">digit    [0-9]</span><br><span class="line">punct    [,.:;!?]</span><br><span class="line">nonblank [^ \t]</span><br><span class="line">name     &#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*</span><br></pre></td></tr></table></figure><p>命名正则表达式定义了表示某一类符号的正则表达式，这样可以在规则部分使用 <code>&#123;name&#125;</code> 来引用。</p><h4 id="（3）指令定义"><a href="#（3）指令定义" class="headerlink" title="（3）指令定义"></a>（3）指令定义</h4><p>使用以 <code>%</code> 开头的指令来修改内置变量的默认值或设置词法分析器的配置。</p><p>常见指令：</p><ul><li><p><code>%array</code> 和 <code>%pointer</code>：控制 <code>yytext</code> 的类型。</p><ul><li><code>%array</code>：<code>yytext</code> 是一个字符数组（默认）。</li><li><code>%pointer</code>：<code>yytext</code> 是一个字符指针。</li></ul></li><li><p><code>%s STATE</code>：定义一个状态，STATE 可以是任意字符串。</p><ul><li>词法分析器可以有多个状态，使用 <code>%s</code> 来定义新的状态。</li></ul></li><li><p><code>%e size</code>：定义内置的 <code>NFA</code> 表项的数量。默认值是 <code>1000</code>。</p></li><li><p><code>%n size</code>：定义内置的 <code>DFA</code> 表项的数量。默认值是 <code>500</code>。</p></li><li><p><code>%p size</code>：定义内置的 <code>move</code> 表项的数量。默认值是 <code>2500</code>。</p></li></ul><h3 id="2、规则"><a href="#2、规则" class="headerlink" title="2、规则"></a>2、规则</h3><h4 id="（1）规则的基本使用"><a href="#（1）规则的基本使用" class="headerlink" title="（1）规则的基本使用"></a>（1）规则的基本使用</h4><p>规则部分主要包含三部分内容：</p><ul><li><strong>模式</strong>：用于描述词法规则的正则表达式</li><li><strong>动作</strong>：模式匹配时要执行的 C 代码</li></ul><p>规则部分是 Lex 文件的核心部分，也是 Lex 文件 中唯一必选部分，它定义了正则表达式模式及其对应的动作。当输入匹配某个模式时，执行相应的动作代码。</p><p><strong>规则部分的基本结构</strong><br>规则部分由一系列的规则组成，每条规则由一个正则表达式模式和一个动作代码块构成，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern   &#123; action &#125;</span><br></pre></td></tr></table></figure><ul><li><code>pattern</code>：一个正则表达式，用于匹配输入文本。</li><li><code>action</code>：C 代码块，当输入文本与模式匹配时执行的动作。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-Z]+      &#123; printf(&quot;Word: %s\n&quot;, yytext); &#125;</span><br><span class="line">[0-9]+         &#123; printf(&quot;Number: %s\n&quot;, yytext); &#125;</span><br><span class="line">&quot;+&quot;            &#123; printf(&quot;Plus operator\n&quot;); &#125;</span><br><span class="line">&quot;-&quot;            &#123; printf(&quot;Minus operator\n&quot;); &#125;</span><br><span class="line">[ \t\n]+       &#123; /* 忽略空白字符 */ &#125;</span><br><span class="line">.              &#123; printf(&quot;Unknown character: %s\n&quot;, yytext); &#125;</span><br></pre></td></tr></table></figure><p>上述示例中，当正则匹配到对应字符串后，打印出对应的信息。</p><p>正则表达式匹配规则：<br><img src="/images/lix_blog_184.png"></p><h4 id="（2）使用状态的规则"><a href="#（2）使用状态的规则" class="headerlink" title="（2）使用状态的规则"></a>（2）使用状态的规则</h4><p>在 Lex 中，可以使用状态来控制规则的应用范围。状态允许你在不同的上下文中应用不同的规则，使词法分析器能够处理更复杂的输入结构。</p><p><strong>Lex 有三种定义状态的方式：</strong></p><ul><li><code>%s</code> 定义 Exclusive 状态<ul><li>仅在特定状态下匹配特定规则，其他状态下不匹配。</li></ul></li><li><code>%x</code> 定义 Inclusive 状态<ul><li>在特定状态下优先匹配特定规则，但其他状态下的规则也可以匹配。</li></ul></li><li><code>%start</code> 定义初始状态或多个状态<ul><li>声明初始状态或多个状态，可以与 BEGIN 宏结合使用来切换状态。</li></ul></li></ul><p><strong>%s 定义 Exclusive 状态</strong><br><br>在这种状态下，只有特定状态下定义的规则才会被匹配。当处于其他状态时，这些规则将不会被考虑。</p><p>示例：处理 C 风格注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%s COMMENT</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">&quot;/*&quot;        &#123; BEGIN(COMMENT); &#125;  /* 进入 COMMENT 状态 */</span><br><span class="line">&lt;COMMENT&gt;&quot;*/&quot;   &#123; BEGIN(INITIAL); &#125;  /* 退出 COMMENT 状态，回到初始状态 */</span><br><span class="line">&lt;COMMENT&gt;.      &#123; /* 处理 COMMENT 状态下的字符 */ &#125;</span><br><span class="line">&lt;COMMENT&gt;\n     &#123; /* 处理 COMMENT 状态下的新行 */ &#125;</span><br><span class="line">.         &#123; /* 处理其他字符 */ &#125;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>/*</code> 会将词法分析器的状态切换到 <code>COMMENT</code>。</li><li>在 <code>COMMENT</code> 状态下，<code>*/</code> 会将状态切换回初始状态 <code>INITIAL</code>。</li><li>在 <code>COMMENT</code> 状态下的规则仅在该状态下生效，而在其他状态下无效。</li></ul><p><strong>%x 定义 Inclusive 状态</strong><br><br>在这种状态下，特定状态下的规则会优先匹配，但其他状态下的规则也可以被匹配。</p><p>示例：处理字符串字面量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%x STRING</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">\&quot;          &#123; BEGIN(STRING); &#125;  /* 进入 STRING 状态 */</span><br><span class="line">&lt;STRING&gt;\&quot;  &#123; BEGIN(INITIAL); &#125;  /* 退出 STRING 状态，回到初始状态 */</span><br><span class="line">&lt;STRING&gt;.   &#123; /* 处理 STRING 状态下的字符 */ &#125;</span><br><span class="line">&lt;STRING&gt;\n  &#123; /* 处理 STRING 状态下的新行 */ &#125;</span><br><span class="line">.           &#123; /* 处理其他字符 */ &#125;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>\&quot;</code> 会将词法分析器的状态切换到 <code>STRING</code>。</li><li>在 <code>STRING</code> 状态下，<code>\&quot;</code> 会将状态切换回初始状态 <code>INITIAL</code>。</li><li>在 <code>STRING</code> 状态下的规则优先匹配，但其他状态下的规则也可以匹配。</li></ul><p><strong>%start 定义初始状态或多个状态</strong><br><br>用于声明初始状态或多个状态，可以与 <code>BEGIN</code> 宏结合使用来切换状态。</p><p>示例：处理 C 和 C++ 风格注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%start C_COMMENT CC_COMMENT</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">&quot;/*&quot;        &#123; BEGIN(C_COMMENT); &#125;  /* 进入 C_COMMENT 状态 */</span><br><span class="line">&lt;CC_COMMENT&gt;&quot;*/&quot;   &#123; BEGIN(INITIAL); &#125;  /* 退出 C_COMMENT 状态，回到初始状态 */</span><br><span class="line">&lt;CC_COMMENT&gt;.      &#123; /* 处理 C_COMMENT 状态下的字符 */ &#125;</span><br><span class="line">&lt;CC_COMMENT&gt;\n     &#123; /* 处理 C_COMMENT 状态下的新行 */ &#125;</span><br><span class="line"></span><br><span class="line">&quot;//&quot;        &#123; BEGIN(CC_COMMENT); &#125;  /* 进入 CC_COMMENT 状态 */</span><br><span class="line">&lt;CC_COMMENT&gt;\n     &#123; BEGIN(INITIAL); &#125;  /* 退出 CC_COMMENT 状态，回到初始状态 */</span><br><span class="line">&lt;CC_COMMENT&gt;.      &#123; /* 处理 CC_COMMENT 状态下的字符 */ &#125;</span><br><span class="line"></span><br><span class="line">.           &#123; /* 处理其他字符 */ &#125;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>/*</code> 会将词法分析器的状态切换到 <code>C_COMMENT</code>。</li><li>在 <code>C_COMMENT</code> 状态下，<code>*/</code> 会将状态切换回初始状态 <code>INITIAL</code>。</li><li><code>//</code> 会将词法分析器的状态切换到 <code>CC_COMMENT</code>。</li><li>在 <code>CC_COMMENT</code> 状态下，<code>\n</code> 会将状态切换回初始状态 <code>INITIAL</code>。</li></ul><h3 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h3><p>代码部分是 Lex 文件的最后一部分，位于第二个 <code>%%</code> 之后。这部分通常包含主函数 <code>main()</code> 和其他用户自定义的辅助函数。用户代码部分的主要作用是启动词法分析器并处理分析结果。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line">/* 用户代码部分 */</span><br><span class="line">int main() &#123;</span><br><span class="line">    /* 启动词法分析器，单独使用 Lex 时可实现 main 函数并启动词法分析器 */</span><br><span class="line">    yylex();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int yywrap() &#123;</span><br><span class="line">    return 1; /* 返回 1 表示输入结束 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、Yacc"><a href="#三、Yacc" class="headerlink" title="三、Yacc"></a>三、Yacc</h2><p>Yacc 负责根据上下文无关文法解析词法单元，生成语法树或执行相应的操作，Yacc 文件通常使用 .y 扩展名。</p><p>上下文无关文法在 Yacc 中起到了定义语法规则的作用，Yacc 使用上下文无关文法来描述编程语言的语法结构，并生成相应的解析器。</p><p>上下文无关文法（Context-Free Grammar, CFG）由诺姆·乔姆斯基（Noam Chomsky）在 1956 年提出，它是形式语言理论中的一种文法类型，用于定义编程语言的语法结构。</p><p>一个上下文无关文法由以下四个部分组成：</p><ul><li><p><strong>终结符集合（Terminal symbols）</strong></p><ul><li>表示语言中的基本符号，不能再被分解<ul><li>例如：数字（如 123）、标识符（如 x、y）、运算符（如 +、-、*、&#x2F;）、关键字（如 <code>if</code>、<code>else</code>、<code>while</code>）</li></ul></li><li>通常直接对应于词法分析器 Lex 生成的 token</li></ul></li><li><p><strong>非终结符集合（Non-terminal symbols）</strong></p><ul><li>表示语法结构，可以被分解为终结符或其他非终结符<ul><li>例如：表达式（如 <code>expression</code>）、语句（如 <code>statement</code>）、项（如 <code>term</code>）、因子（如 <code>factor</code>）</li></ul></li></ul></li><li><p><strong>生产规则集合（Production rules）</strong></p><ul><li>定义了如何将非终结符替换为终结符或其他非终结符</li></ul></li><li><p><strong>起始符（Start symbol）</strong></p><ul><li>一个特殊的非终结符，文法生成的语言的句子从这个符号开始</li></ul></li></ul><p>在 Yacc 文件中，对这四个部分的使用方式如下：<br><br><strong>（1）终结符集合（Terminal symbols）</strong><br><br>终结符是语言中的基本符号，不能再被分解。在 Yacc 中，终结符通过 <code>%token</code> 声明。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%token INTEGER</span><br><span class="line">%token PLUS MINUS TIMES DIVIDE LPAREN RPAREN</span><br></pre></td></tr></table></figure><p>这些声明表示 INTEGER、PLUS、MINUS、TIMES、DIVIDE、LPAREN 和 RPAREN 是终结符。</p><p><strong>（2）非终结符集合（Non-terminal symbols）</strong><br><br>非终结符表示语法结构，可以被分解为终结符或其他非终结符。在 Yacc 中，非终结符通过规则定义。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%type &lt;ival&gt; E T F</span><br></pre></td></tr></table></figure><p>这里的 E、T 和 F 是非终结符，表示表达式（<code>Expression</code>）、项（<code>Term</code>）和因子（<code>Factor</code>）。</p><p><strong>（3）生产规则集合（Production rules）</strong><br><br>生产规则定义了如何将非终结符替换为终结符或其他非终结符。在 Yacc 文件中，生产规则在 <code>%%</code> 符号之间定义。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line">E:</span><br><span class="line">    E PLUS T &#123; $$ = $1 + $3; &#125;</span><br><span class="line">    | E MINUS T &#123; $$ = $1 - $3; &#125;</span><br><span class="line">    | T</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">T:</span><br><span class="line">    T TIMES F &#123; $$ = $1 * $3; &#125;</span><br><span class="line">    | T DIVIDE F &#123; $$ = $1 / $3; &#125;</span><br><span class="line">    | F</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">F:</span><br><span class="line">    LPAREN E RPAREN &#123; $$ = $2; &#125;</span><br><span class="line">    | INTEGER &#123; $$ = $1; &#125;</span><br><span class="line">    ;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>这些规则描述了如何将非终结符 E、T 和 F 替换为其他非终结符和终结符的组合。</p><p><strong>（4）起始符（Start symbol）</strong><br><br>起始符是一个特殊的非终结符，文法生成的语言的句子从这个符号开始。在 Yacc 文件中，起始符是规则的第一个非终结符。例如，在上述规则中，E 是起始符，因为它是第一个定义的非终结符。</p><p>Yacc 通常与 Lex 配合使用，和 Lex 一样，Yacc 文件(example.y)内容示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token NUMBER PLUS MINUS</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">expr : expr PLUS term &#123; printf(&quot;Addition\n&quot;); &#125;</span><br><span class="line">     | expr MINUS term &#123; printf(&quot;Subtraction\n&quot;); &#125;</span><br><span class="line">     | term</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">term : NUMBER &#123; printf(&quot;Number: %d\n&quot;, $1); &#125;</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    yyparse();  /* 启动语法分析器 */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void yyerror(const char *s) &#123;</span><br><span class="line">    fprintf(stderr, &quot;Error: %s\n&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成语法分析器代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yacc -d example.y</span><br></pre></td></tr></table></figure><p>执行完上述命令之后，就会生成 y.tab.h、y.tab.c 语法分析器代码实现文件，其中自动生成的主要函数如下：</p><ul><li><p><code>yyparse()</code></p><ul><li>主语法分析函数，它从词法分析器获取 token 并尝试匹配定义的文法规则。</li><li>每次调用 <code>yyparse()</code> 时，它会启动语法分析过程，直到输入结束或遇到错误。</li><li>返回一个整数值，通常是 <code>0</code> 表示成功，<code>1</code> 表示有语法错误。</li><li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int result = yyparse();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>yyerror(const char *s)</code></p><ul><li>错误处理函数，当语法分析器遇到错误时调用。</li><li>通常用于打印错误信息或执行其他错误处理逻辑。</li><li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void yyerror(const char *s) &#123;</span><br><span class="line">fprintf(stderr, &quot;Error: %s\n&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>yylval</code></p><ul><li>全局变量，用于存储词法分析器返回的 token 的值。</li><li>在词法分析器中设置 <code>yylval</code>，在语法分析器中使用。</li><li>默认为 <code>int</code> 类型，实际开发中通常会将 <code>yylval</code> 配置成联合体，以支持存储更复杂的数据。<ul><li>可以使用 <code>%union</code>、<code>%token</code>、<code>%type</code> 自定义 <code>yylval</code> 类型：<ul><li><p><code>%union</code> 来定义一个包含多种类型的联合体，该联合体就是 yylval 的实际类型。</p></li><li><p>使用 <code>%token</code> 声明 Lex 解析出的终结符 token 使用联合体哪个成员存储。</p></li><li><p>使用 <code>%type</code> 声明 Lex 解析出的非终结符 token 使用联合体哪个成员存储。</p></li><li><p>示例：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%union &#123;</span><br><span class="line">int ival;</span><br><span class="line">float fval;</span><br><span class="line">char *sval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%token &lt;ival&gt; INTEGER</span><br><span class="line">%token &lt;fval&gt; FLOAT</span><br><span class="line">%token &lt;sval&gt; STRING</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p><code>yychar</code></p><ul><li>全局变量，存储当前解析的 token。</li><li>由 <code>yyparse()</code> 使用，用于控制解析过程。</li><li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   if (yychar == SOME_TOKEN) &#123;</span><br><span class="line">// Do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><br>Yacc 文件内容结构与 Lex 完全一样，Yacc 内容结构如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;定义&gt;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&lt;规则&gt;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&lt;代码&gt;</span><br></pre></td></tr></table></figure><p>Yacc 文件也同样包含定义、规则、代码三部分内容：</p><ul><li><strong>定义（可选）</strong><ul><li>token 定义</li><li>优先级与关联性定义</li><li>C 代码定义</li></ul></li><li><strong>规则（必选）</strong><ul><li>定义了文法规则和对应的动作代码<ul><li>规则名：一个非终结符</li><li>产生式：由终结符和非终结符组成的序列</li><li>动作：C 代码，当产生式匹配时执行</li></ul></li></ul></li><li><strong>代码（可选）</strong><ul><li>辅助函数</li><li>也可以包含主程序的 main 函数</li><li>这部分代码会被直接拷贝进 y.tab.c 中</li></ul></li></ul><h3 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h3><p>定义是 Yacc 的第一部分，主要包含三部分内容：</p><ul><li>token 定义</li><li>优先级与关联性定义</li><li>C 代码定义</li></ul><h4 id="（1）-token-定义"><a href="#（1）-token-定义" class="headerlink" title="（1） token 定义"></a>（1） token 定义</h4><p>Lex 词法分析器将源代码字符串识别成一个个的 token，Yacc 语法分析器则会将 token 进行分类处理，因此两者之间必须统一 token 的类型。</p><p>为了使词法分析器和语法分析器之间的 token 类型一致，通常在 Yacc 文件中定义 token 类型。使用 <code>%token</code> 指令定义 token，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%token name1 name2 name3 ...</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%token NUMBER PLUS MINUS</span><br></pre></td></tr></table></figure><p>Yacc 会将 %token 指令转换为 C 语言的宏定义（<code>#define</code>）。</p><p>例如要解析一个简单的数学表达式，如 3 + 5，并计算其结果：<br>Lex 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &quot;y.tab.h&quot;  // 包含 Yacc 生成的头文件，其中定义了 token</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">[0-9]+          &#123; yylval = atoi(yytext); return INTEGER; &#125;</span><br><span class="line">&quot;+&quot;             &#123; return PLUS; &#125;</span><br><span class="line">[ \t\n]+        &#123; /* 忽略空白字符 */ &#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int yywrap() &#123;</span><br><span class="line">    return 1;  /* 指示没有更多的输入 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Yacc 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void yyerror(const char *s);</span><br><span class="line">int yylex(void);</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token INTEGER PLUS</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">expr: expr PLUS term &#123; printf(&quot;Result: %d\n&quot;, $1 + $3); &#125;</span><br><span class="line">    | term</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">term: INTEGER &#123; $$ = $1; &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Enter an expression:\n&quot;);</span><br><span class="line">    yyparse();  /* 启动语法分析器 */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void yyerror(const char *s) &#123;</span><br><span class="line">    fprintf(stderr, &quot;Error: %s\n&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例中，Yacc 中定义了 INTEGER 和 PLUS 两个 Token，在 Lex 文件中使用了这两个 Token。</p><h4 id="（2）优先级与关联性定义"><a href="#（2）优先级与关联性定义" class="headerlink" title="（2）优先级与关联性定义"></a>（2）优先级与关联性定义</h4><p>在 Yacc 中，优先级和关联性定义用于解决语法分析中的歧义，特别是在处理运算符时。优先级决定了运算符的应用顺序，而关联性决定了相同优先级的运算符在表达式中的结合方向。</p><ul><li><p><strong>优先级</strong></p><ul><li>优先级用于确定运算符的应用顺序。例如，在表达式 3 + 4 * 5 中，乘法运算符 * 的优先级高于加法运算符 +，因此乘法会先于加法执行。</li></ul></li><li><p><strong>关联性</strong></p><ul><li>关联性用于确定相同优先级的运算符的结合方向。例如，在表达式 a - b - c 中，加法和减法都是左关联，即从左到右结合。而赋值运算符 &#x3D; 是右关联，即从右到左结合。</li></ul></li></ul><p>Yacc 提供了以下指令来定义运算符的优先级和关联性：</p><ul><li><code>%left</code><ul><li>左关联。先定义的优先级低于后定义的优先级</li><li>例如：算术运算符(+、-、*、&#x2F; 等)、比较运算符(&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 等)</li></ul></li><li><code>%right</code><ul><li>右关联，先定义的优先级高于后定义的优先级。</li><li>例如：赋值运算符(&#x3D;、+&#x3D;、-&#x3D; 等)、条件运算符(?:)</li></ul></li><li><code>%nonassoc</code><ul><li>无关联，用于定义不允许连续使用的运算符（如比较运算符）</li><li>例如：Python 中的逻辑运算符(and、or)</li></ul></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%right &#x27;=&#x27;</span><br><span class="line">%left &#x27;+&#x27; &#x27;-&#x27;</span><br><span class="line">%left &#x27;*&#x27; &#x27;/&#x27; &#x27;%&#x27;</span><br></pre></td></tr></table></figure><h4 id="（3）C-代码定义"><a href="#（3）C-代码定义" class="headerlink" title="（3）C 代码定义"></a>（3）C 代码定义</h4><p>在 <code>%&#123;</code> 和 <code>%&#125;</code> 之间可以定义 C 语言的变量和函数，这些定义会被直接拷贝到生成的 C 文件的开头部分。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int i, j, k;</span><br><span class="line">static float x = 1.0;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure><h3 id="2、规则-1"><a href="#2、规则-1" class="headerlink" title="2、规则"></a>2、规则</h3><p>规则主要包含三部分内容：</p><ul><li><strong>规则名</strong>：一个非终结符</li><li><strong>产生式</strong>：由终结符和非终结符组成的序列</li><li><strong>动作</strong>：C 代码，当产生式匹配时执行</li></ul><p>规则部分定义了一系列的语法规则。每条规则由一个非终结符和一个或多个产生式组成，每个产生式可以包含可选的语义动作。</p><p><strong>基本格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">identifier : definition &#123; action &#125;</span><br><span class="line">           | definition &#123; action &#125;</span><br><span class="line">           ;</span><br></pre></td></tr></table></figure><ul><li><code>identifier</code> 是非终结符，对应文法产生式的左部。</li><li><code>definition</code> 是产生式，由终结符和非终结符组成，对应文法产生式的右部。</li><li><code>&#123; action &#125;</code> 是语义动作，当产生式匹配时执行的 C 代码。<ul><li>一般多个产生式对应一个 <code>action</code>，在 <code>action</code> 中，可以使用 <code>$</code> 获取产生式的值。<ul><li><code>$n</code> 获取第 <code>n</code> 个产生式的值。</li><li><code>$$</code> 表示当前产生式左侧非终结符的值，即当前产生式的结果。</li></ul></li></ul></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">expression:</span><br><span class="line">    expression &#x27;+&#x27; expression &#123;</span><br><span class="line">        $$ = $1 + $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#x27;-&#x27; expression &#123;</span><br><span class="line">        $$ = $1 - $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#x27;*&#x27; expression &#123;</span><br><span class="line">        $$ = $1 * $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#x27;/&#x27; expression &#123;</span><br><span class="line">        $$ = $1 / $3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    | NUMBER &#123;</span><br><span class="line">        $$ = $1;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>例如在上述示例中：</p><ul><li><code>expression &#39;+&#39; expression</code> 是三个产生式：<code>expression</code>、<code>&#39;+&#39;</code>、<code>expression</code></li><li><code>$1</code>、<code>$3</code> 表示产生式的第一个 <code>expression</code>、第二个 <code>expression</code> 的值</li><li><code>$$</code> 表示产生式结果</li></ul><p>默认情况下，规则部分定义的第一个非终结符为开始符号（Start Symbol）。可以使用 <code>%start</code> 指令自定义开始符号。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%start my_start_symbol</span><br></pre></td></tr></table></figure><h3 id="3、代码-1"><a href="#3、代码-1" class="headerlink" title="3、代码"></a>3、代码</h3><p>代码 Yacc 文件的最后一部分，可以包含辅助函数和主程序的 main 函数。这部分代码会被直接拷贝到生成的 C 文件的末尾。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 定义，略 ...</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">// 规则，略 ...</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    yyparse();  /* 启动语法分析器 */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void yyerror(const char *s) &#123;</span><br><span class="line">    fprintf(stderr, &quot;Error: %s\n&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、Lex、Yacc-完整示例及解读"><a href="#四、Lex、Yacc-完整示例及解读" class="headerlink" title="四、Lex、Yacc 完整示例及解读"></a>四、Lex、Yacc 完整示例及解读</h2><p>使用 Lex、Yacc 实现一个简单的计算器。</p><p>在 Xcode 中新建一个 macOS 的 Command Line Tool 工程。</p><p>calc.l 文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &quot;y.tab.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int yywrap(void) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[0-9]+  &#123;</span><br><span class="line">    yylval = atoi(yytext);</span><br><span class="line">    return NUMBER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[ \t]   &#123; /* ignore whitespace */ &#125;</span><br><span class="line"></span><br><span class="line">\n      &#123; return &#x27;\n&#x27;; &#125;</span><br><span class="line"></span><br><span class="line">.       &#123;</span><br><span class="line">    return yytext[0];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>calc.y 文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void yyerror(const char *s);</span><br><span class="line">int yylex(void);</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token NUMBER</span><br><span class="line">%left &#x27;+&#x27; &#x27;-&#x27;</span><br><span class="line">%left &#x27;*&#x27; &#x27;/&#x27;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">calculation:</span><br><span class="line">    expression &#x27;\n&#x27; &#123;</span><br><span class="line">        printf(&quot;Yacc: Completed calculation with result: %d\n&quot;, $1);</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#123;</span><br><span class="line">        printf(&quot;Yacc: Completed calculation with result: %d\n&quot;, $1);</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expression:</span><br><span class="line">    expression &#x27;+&#x27; expression &#123;</span><br><span class="line">        $$ = $1 + $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#x27;-&#x27; expression &#123;</span><br><span class="line">        $$ = $1 - $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#x27;*&#x27; expression &#123;</span><br><span class="line">        $$ = $1 * $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#x27;/&#x27; expression &#123;</span><br><span class="line">        $$ = $1 / $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | &#x27;(&#x27; expression &#x27;)&#x27; &#123;</span><br><span class="line">        $$ = $2;</span><br><span class="line">    &#125;</span><br><span class="line">    | NUMBER &#123;</span><br><span class="line">        $$ = $1;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">void yyerror(const char *s) &#123;</span><br><span class="line">    fprintf(stderr, &quot;Error: %s\n&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.m 文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.m</span><br><span class="line">//  CompilerTest</span><br><span class="line">//</span><br><span class="line">//  Created by Lix on 2022/4/13.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#include &quot;y.tab.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int yyparse(void);</span><br><span class="line">extern void yyset_in(FILE *file);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        const char *input = &quot;2 + 3 * 4\n&quot;; // 添加换行符以终止输入</span><br><span class="line"></span><br><span class="line">        FILE *inputFile = fmemopen((void *)input, strlen(input), &quot;r&quot;);</span><br><span class="line">        yyset_in(inputFile);</span><br><span class="line">        </span><br><span class="line">        if (yyparse() == 0) &#123;</span><br><span class="line">            NSLog(@&quot;Calculation successful!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSLog(@&quot;Error in calculation.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fclose(inputFile);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行，打印如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yacc: Completed calculation with result: 14</span><br><span class="line">Calculation successful!</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><p>因为 Xcode 内置了 Lex、Yacc 工具，所以可以直接编译运行。不同的是，Xcode 自动生成的词法分析代码文件为 Lex文件名.yy.c，例如上述示例生成的是  calc.yy.c。<br><img src="/images/lix_blog_185.png"></p><p>在上述示例中，调用 Lex 词法分析器的 <code>yyset_in(FILE * _in_str)</code> 函数设置词法分析器的输入文件，然后调用 Yacc 语法分析器的 <code>yyparse()</code> 函数执行语法分析及后续流程。</p><p><code>yyparse()</code> 是由 Yacc（或 Bison）自动生成的语法分析器的核心函数。它的主要任务是根据定义的语法规则解析输入，并执行相应的语义动作。</p><p><code>yyparse()</code> 伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">int yyparse() &#123;</span><br><span class="line">    int yystate = 0; // 初始状态</span><br><span class="line">    int yyn, yychar, yytoken, yym, yyerrstatus = 0;</span><br><span class="line"></span><br><span class="line">    YYSTYPE yylval;    // 存储词法单元的值</span><br><span class="line">    YYSTYPE yyval;     // 存储语法规则的语义值</span><br><span class="line">    YYSTYPE yyvs[YYMAXDEPTH]; // 符号栈</span><br><span class="line">    int yyssp;        // 状态栈指针</span><br><span class="line">    int yyss[YYMAXDEPTH]; // 状态栈</span><br><span class="line"></span><br><span class="line">    yyssp = 0;</span><br><span class="line">    yychar = YYEMPTY; // 表示当前没有读到的词法单元</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        /* 根据当前状态和词法单元yytoken查询语法表，决定下一步动作 */</span><br><span class="line">        yyn = yypact[yystate];</span><br><span class="line">        if (yyn == YYPACT_NINF) &#123;</span><br><span class="line">            // 发生错误, 调用错误处理函数</span><br><span class="line">            yyerror(&quot;syntax error&quot;);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取下一个词法单元</span><br><span class="line">        if (yychar == YYEMPTY) &#123;</span><br><span class="line">            yychar = yylex();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        yychar = yychar &lt; 0 ? 0 : yychar;</span><br><span class="line">        yytoken = YYTRANSLATE(yychar);</span><br><span class="line"></span><br><span class="line">        yyn += yytoken;</span><br><span class="line">        if (yyn &lt; 0 || yyn &gt;= YYLAST || yycheck[yyn] != yytoken) &#123;</span><br><span class="line">            yyn = yydefact[yystate];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            yyn = yytable[yyn];</span><br><span class="line">            if (yyn &lt;= 0) &#123;</span><br><span class="line">                if (yyn == 0 || yyn == YYTABLE_NINF) &#123;</span><br><span class="line">                    yychar = yylex();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                yyn = -yyn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // `移入`</span><br><span class="line">        if (yyn == YYFINAL) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (yyn == YYERROR) &#123;</span><br><span class="line">            yyerror(&quot;syntax error&quot;);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (yyn &gt; 0) &#123;</span><br><span class="line">            // 移入操作</span><br><span class="line">            yyssp++;</span><br><span class="line">            yyss[yyssp] = yystate;</span><br><span class="line">            yystate = yyn;</span><br><span class="line">            yychar = YYEMPTY;</span><br><span class="line"></span><br><span class="line">            yyvs[yyssp] = yylval;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 语法规则</span><br><span class="line">        yyn = -yyn;</span><br><span class="line">        yym = yyr2[yyn];</span><br><span class="line">        yyval = yyvs[yyssp - yym + 1];</span><br><span class="line"></span><br><span class="line">        // 执行语义动作</span><br><span class="line">        switch (yyn) &#123;</span><br><span class="line">            case 2:  // `expression: expression + expression`</span><br><span class="line">                yyval = eval_add(yyvs[yyssp - 2], yyvs[yyssp]);</span><br><span class="line">                break;</span><br><span class="line">            case 3:  // `expression: expression * expression`</span><br><span class="line">                yyval = eval_mul(yyvs[yyssp - 2], yyvs[yyssp]);</span><br><span class="line">                break;</span><br><span class="line">            // 其他规则...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        yyssp -= yym;</span><br><span class="line">        yyssp++;</span><br><span class="line">        yyss[yyssp] = yystate;</span><br><span class="line"></span><br><span class="line">        yystate = yygoto[yyn - YYNTOKENS];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>yyparse() 的主要逻辑如下：</strong></p><ul><li><strong>初始化</strong><ul><li>初始化状态栈和符号栈。</li><li>设置初始状态为起始状态。</li><li>读取第一个词法单元（token）。</li></ul></li><li><strong>主循环</strong><ul><li>在一个循环中，不断读取下一个词法单元，直到到达输入的结尾或检测到语法错误。</li></ul></li><li><strong>状态转移</strong><ul><li>根据当前状态和当前词法单元，从语法表中查找下一步的动作：<ul><li>移入（shift）：将当前词法单元移入符号栈，并转移到新状态。</li><li>规约（reduce）：使用一个产生式规则将栈顶的符号归约为非终结符，并转移到新状态。</li><li>接受（accept）：解析成功，停止解析过程。</li><li>错误（error）：检测到语法错误，调用错误处理函数。</li></ul></li></ul></li><li><strong>执行语义动作</strong><ul><li>在规约过程中，执行相应的语义动作，计算值或构建语法树。</li></ul></li></ul><p>所以，上述示例在解析表达式 2 + 3 * 4 时，<code>yyparse()</code> 按照以下步骤工作：</p><ul><li>初始化<ul><li>初始化状态和符号栈。</li><li>读取第一个词法单元 2。</li></ul></li><li>状态转移和规约：<ul><li>移入 2：<ul><li>读取下一个词法单元 +。</li></ul></li><li>移入 +：<ul><li>读取下一个词法单元 3。</li></ul></li><li>移入 3：<ul><li>读取下一个词法单元 *。</li></ul></li><li>移入 *：<ul><li>读取下一个词法单元 4。</li></ul></li><li>移入 4：<ul><li>读取下一个词法单元 \n。</li></ul></li><li>规约 3 * 4：<ul><li>匹配规则 expression ‘*’ expression。</li><li>执行语义动作 $$ &#x3D; $1 * $3 计算结果 12。</li><li>将结果 12 压入符号栈。</li></ul></li><li>规约 2 + 12：<ul><li>匹配规则 expression ‘+’ expression。</li><li>执行语义动作 $$ &#x3D; $1 + $3 计算结果 14。</li><li>将结果 14 压入符号栈。</li></ul></li><li>终止：读取到 \n 并匹配完成，解析成功，返回结果。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 热修复 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理之 OC 编译</title>
      <link href="/posts/63748/"/>
      <url>/posts/63748/</url>
      
        <content type="html"><![CDATA[<h2 id="一、低级语言与高级语言"><a href="#一、低级语言与高级语言" class="headerlink" title="一、低级语言与高级语言"></a>一、低级语言与高级语言</h2><h3 id="1、低级语言"><a href="#1、低级语言" class="headerlink" title="1、低级语言"></a>1、低级语言</h3><p>低级语言（Low-level Language）是接近计算机硬件的编程语言，是计算机可以直接执行或接近直接执行的语言。</p><p>常见的低级语言包括：</p><ul><li><p><strong>机器语言</strong></p><ul><li>计算机可以直接执行的二进制代码（即：机器码），由 0 和 1 组成。每一个机器指令对应于特定的处理器操作。</li></ul></li><li><p><strong>汇编语言</strong></p><ul><li>汇编语言是机器语言的符号化表示，使用助记符和符号代替机器语言的二进制代码，相较于机器语言更易读（但仍然复杂）。</li><li>汇编语言需要通过汇编器（Assembler）转换成机器语言才能被计算机执行。</li></ul></li></ul><p>由于直接操作硬件，所以低级语言的性能较高，但其通常与特定的硬件平台相关，导致代码移植性差。</p><h3 id="2、高级语言"><a href="#2、高级语言" class="headerlink" title="2、高级语言"></a>2、高级语言</h3><p>高级语言（High-level Language）是指接近人类自然语言的编程语言，使代码更容易编写、阅读和维护。</p><p>高级语言编写的代码不能直接执行，必须先通过编译器或解释器转换成低级语言（机器语言，即机器码）才能被计算机执行。</p><p>高级语言提供了对底层硬件的抽象，使开发者无需关心底层细节，高级语言在经过重新编译或解释后，通常可以在不同平台上运行。</p><p>常见的高级语言包括：</p><ul><li><strong>编译型语言</strong>：C、C++、Java、Go、Rust 等。</li><li><strong>解释型语言</strong>：Python、JavaScript、Ruby、PHP 等。</li></ul><h2 id="二、编译型语言和解释型语言"><a href="#二、编译型语言和解释型语言" class="headerlink" title="二、编译型语言和解释型语言"></a>二、编译型语言和解释型语言</h2><p>高级语言主要有两种：编译型语言、解释型语言。<br><img src="/images/lix_blog_172.png"></p><h3 id="1、编译型语言"><a href="#1、编译型语言" class="headerlink" title="1、编译型语言"></a>1、编译型语言</h3><p>在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，即：先编译再执行。</p><p>常见的编译型语言有：C、C++、Java、Go、Rust 等。</p><p>编译型语言优缺点如下：</p><ul><li>优点<ul><li>高性能：编译后的机器代码直接在硬件上运行，执行速度快，性能高。</li><li>优化能力强：编译器可以进行各种优化（如循环展开、内联展开等），以提高代码效率。</li><li>安全性：编译过程可以进行类型检查和其他静态分析，提前发现潜在的错误。</li><li>独立性：编译后的可执行文件不依赖于源代码和编译器，可以在没有开发环境的机器上运行。</li></ul></li><li>缺点<ul><li>编译时间长：编译过程可能耗时较长，特别是大型项目。</li><li>调试复杂：编译后的机器代码不易调试，调试信息可能不完整。</li><li>跨平台性差：编译后的可执行文件通常与特定平台相关，不同平台需要重新编译。</li></ul></li></ul><h3 id="2、解释型语言"><a href="#2、解释型语言" class="headerlink" title="2、解释型语言"></a>2、解释型语言</h3><p>解释型语言又称直译式语言、脚本语言，解释型语言不需要事先编译，解释器直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。</p><p>常见的解释型语言有：Python、JavaScript、Ruby、PHP 等。</p><p>解释型语言优缺点如下：</p><ul><li>优点<ul><li>即时性：不需要预先编译，源代码可以直接运行，适合快速开发和调试。</li><li>跨平台性强：源代码通过解释器运行，可以在不同平台上执行相同的代码。</li><li>灵活性高：通常具有动态类型和灵活的语法，适合快速迭代和原型开发。</li></ul></li><li>缺点<ul><li>性能较低：解释执行的开销较大，执行速度通常比编译型语言慢。</li><li>依赖解释器：需要解释器才能运行源代码，增加了部署和运行时的依赖。</li><li>安全性较低：由于动态类型和运行时检查，潜在的错误可能在运行时才发现。</li></ul></li></ul><p>解释型语言的执行流程与编译型语言不同，解释型语言通过解释器逐行解释和执行源代码，不需要预先编译成目标机器代码。解释型语言执行流程如下图：<br><img src="/images/lix_blog_173.png"></p><h2 id="三、OC-的编译流程"><a href="#三、OC-的编译流程" class="headerlink" title="三、OC 的编译流程"></a>三、OC 的编译流程</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>iOS 开发常用的语言是 Objective-C 和 Swift，两者都是编译型语言，所以 iOS 代码的执行，都需要经过编译器编译的流程，这里主要看 OC 的编译流程。</p><p>无论是高级语言还是低级语言，最终都是在计算机的中央处理器（CPU）上执行的，OC 代码想要被执行，必须先使用编译器将其编译成能在 CPU 上直接执行的机器码，现代编译器工作的主要流程如下：<br><img src="/images/lix_blog_174.png"></p><ul><li><p><strong>前端，OC 使用 Clang 作为编译器前端</strong></p><ul><li>为 LLVM 提供了预处理，词法分析，语法分析，语义分析、错误处理、生成 LLVM IR 等各种各样的功能。在这个过程中，也会对代码进行检查，如果发现出错的或需要警告的会标注出来。</li></ul></li><li><p><strong>中间端</strong></p><ul><li>使用优化器（Optimizer）对 LLVM IR 进行优化，优化的目标是提高代码的执行效率和减少代码的体积。</li></ul></li><li><p><strong>后端，OC 使用 LLVM 作为编译器后端</strong></p><ul><li>针对不同的架构，生成对应的机器码。</li></ul></li></ul><h3 id="2、LLVM-IR"><a href="#2、LLVM-IR" class="headerlink" title="2、LLVM IR"></a>2、LLVM IR</h3><p><strong>上面提到了 LLVM IR，LLVM IR 是什么呢？</strong><br><br>LLVM IR （Intermediate Representation）直译过来是“中间描述”，它是整个编译过程中生成的区别于源码和机器码的一种中间代码。IR 提供了独立于任何特定机器架构的源语，因此它是 LLVM 优化和进行代码生成的关键，也是 LLVM 有别于其他编译器的最大特点。LLVM 的核心功能都是围绕的 IR 建立的，它是 LLVM 编译过程中前端的输出，后端的输入。</p><p>LLVM IR 的存在意味着 LLVM 可以作为多种语言的后端，这样 LLVM 就能够提供和语言无关的优化，同时还能够方便的针对多种 CPU 代码生成。</p><p>编译器的架构分为前端、优化器和后端。传统编译器（如 BASIC）的前端和后端没有完全分离，耦合在了一起，因而如果要支持一门新的语言或硬件平台，需要做大量的工作。而 LLVM 和传统编译器最大的不同点在于，前端输入的任何语言，在经过编译器前端处理后，生成的中间码都是 IR 格式的。这样做的优点是如果需要支持一种新的编程语言，那么我们只需要实现一种新的前端。如果我们需要支持一种新的硬件设备，那我们只需要实现一个新的后端。</p><p><strong>LLVM IR 的三种格式：</strong></p><ul><li>内存中的编译中间语言</li><li>硬盘上存储的可读中间格式（以 .ll 结尾）</li><li>硬盘上存储的二进制中间语言（以 .bc 结尾）</li></ul><p>这三种中间格式是完全等价的。</p><p><strong>什么是 Bitcode？</strong><br><br>Bitcode 其实就是前面提到的 LLVM IR 三种格式中的第三种，即存储在磁盘上的二进制文件（以 .bc 结尾）。</p><p>之所以要把 Bitcode 拿出来单独说，是因为 Apple 单独对 Bitcode 进行了额外的优化。从 Xcode 7 开始，Apple 支持在提交 App 编译产物的同时提交 App 的 Bitcode (非强制)，并且之后对提交了 Bitcode 的 App 都单独进行了云端编译打包。也就是说，即便在提交时已经将本地编译好的 ipa 提交到 App Store，Apple 最终还是会使用 Bitcode 在云端再次打包，并且最终用户下载到手机上的版本也是由 Apple 在云端编译出来的版本，而非开发人员在本地编译的版本。</p><p>这里有一篇文章<a href="https://juejin.cn/post/6844903572568539143">《Xcode 7 Bitcode的工作流程及安全性评估》</a>，揭示了360团队如何通过一个小 trick 来验证 Apple 审核人员安装的 App 是直接由本地编译出来的版本还是云端通过 Bitcode 编译出来的版本。</p><p>测试方式大致是从网上找个两个完全不同的应用，将其中一个的 Bitcode 嵌入到另一个的 MachO 中，并提交到 AppStore，两个应用 UI 上完全不一样。根据被拒信息中截图发现审核人员审核的是从 Bitcode 编译出来的程序。</p><p><strong>为什么需要 Bitcode？</strong><br><br>Apple 之所以这么做，一是因为 Apple 可以在云端编译过程中做一些额外的针对性优化工作，而这些额外的优化是本地环境所无法实现的。二是 Apple 可以为安装 App 的目标设备进行二进制优化，减少安装包的下载大小。</p><p>比如我们在本地编译生成的 ipa 是同时包含了多个 CPU 架构的（armv7、arm64 ），对于 iPhone X 而言 armv7 的架构文件就是无用文件。而 Apple 可以在云端为不同的设备编译出对应 CPU 架构的 ipa ，这样 iPhone X 下载到的 App 就只包含了所需的 arm64 架构文件。</p><p>而且，由于 Bitcode 是无关设备架构的，它可以被转化为任何被支持的 CPU 架构，包括现在还没被发明的 CPU 架构。以后如果苹果新出了一款新手机并且 CPU 也是全新设计的，在苹果后台服务器一样可以从这个 App 的 Bitcode 开始编译转化为新 CPU 上的可执行程序，可供新手机用户下载运行这个 App ，而无需开发人员重新在本地编译打包上传。</p><p><strong>为什么要废弃 Bitcode？</strong><br><br>从 Xcode 14 开始，App Store 不再接受来自 Xcode 14 的 Bitcode 提交，并且不再支持构建部署目标早于 iOS 11 以下的 APP（前一个版本的 Xcode 最低支持到 iOS 9），也不再支持构建 armv7、armv7s 以及 i386 架构的项目。</p><p>从 2015 年发布 Xcode 7 支持 Bitcode，到 2022 年发布 Xcode 14 正式废弃 Bitcode，大概经过了 7 年。Apple 为什么要废弃 Bitcode 呢？最根本的原因是 Apple 旗下产品实现了 CPU 架构的统一，随着 M 系列 MacBook 发布，旗下主流产品 iPhone、MacBook 都统一成了 ARM 架构，Bitcode 自然就发挥不了太大的作用了。</p><p>并且，如果 Bitcode 对生态要求较高，如果 APP 要支持 Bitcode，就需要保证其所有依赖都支持 Bitcode，否则 Bitcode 无法使用。所以，废弃 Bitcode，还有助于简化开发和发布流程，使得开发者可以更专注于应用本身的开发和优化，而不是处理中间表示和编译的问题。</p><h3 id="3、详细编译流程"><a href="#3、详细编译流程" class="headerlink" title="3、详细编译流程"></a>3、详细编译流程</h3><p>现代编译器工作流程如下：<br><img src="/images/lix_blog_175.png"></p><p>现代编译器通常采用模块化设计，将前端和后端分离，以便于维护和扩展。在 iOS 开发中，Objective-C 语言使用 Clang 作为编译器前端（Swift 采用 Swift 作为编译器前端），使用 LLVM 作为编译器后端。</p><h4 id="（1）编译器前端（Clang）"><a href="#（1）编译器前端（Clang）" class="headerlink" title="（1）编译器前端（Clang）"></a>（1）编译器前端（Clang）</h4><ul><li><p>预处理</p><ul><li>处理宏定义、展开头文件、条件编译、删除注释等。</li><li>生成预处理后的源代码。</li></ul></li><li><p>词法分析</p><ul><li>将预处理后的源代码转换为一系列词法单元（tokens）。<ul><li>词法分析器通过模式匹配（通常使用正则表达式）识别词法单元。</li></ul></li></ul></li><li><p>语法分析</p><ul><li>语法分析器解析 tokens，构建成能被计算机理解的树状结构：抽象语法树 AST（Abstract Syntax Tree）。</li></ul></li><li><p>语义分析</p><ul><li>对抽象语法树进行语义检查，确保源代码的语义正确。</li><li>生成和维护符号表，记录标识符的信息（如类型、作用域、存储位置等）。</li></ul></li><li><p>中间代码生成</p><ul><li>CodeGen（实现代码生成器）遍历抽象语法树 AST，生成 LLVM IR 中间码。</li></ul></li></ul><p>至此前端工作完成，把 LLVM IR 中间码输入到优化器。</p><h4 id="（2）编译器中间端"><a href="#（2）编译器中间端" class="headerlink" title="（2）编译器中间端"></a>（2）编译器中间端</h4><p>中间端主要是借助优化器（Optimizer）对中间表示进行各种优化。</p><p>以下是优化器的几个主要目标和作用：</p><ul><li><p>减少包体</p><ul><li>代码压缩：优化器可以通过删除不必要的代码（如死代码）和简化代码结构来减少代码体积。</li><li>内联展开：内联函数调用有时会增加代码体积，但在某些情况下，优化器可以通过内联展开减少函数调用的开销，从而整体上减少代码体积。</li></ul></li><li><p>提高执行效率</p><ul><li>循环优化：优化器可以通过循环展开、循环分割和循环合并等技术来提高循环的执行效率。</li><li>常量传播：将编译时已知的常量值传播到代码中，减少运行时的计算开销。</li><li>强度削减：将高开销的操作（如乘法、除法）替换为低开销的操作（如加法、移位）。</li></ul></li><li><p>改善内存使用</p><ul><li>寄存器分配：优化器会尽量将变量分配到寄存器中，以减少内存访问的次数，提高程序运行速度。</li><li>内存访问优化：通过优化内存访问模式（如缓存友好的数据布局），减少缓存未命中次数，提高内存访问效率。</li></ul></li><li><p>平衡优化</p><ul><li>空间与时间的权衡：优化器需要在代码体积和执行效率之间找到平衡。例如，内联展开可能会增加代码体积，但可以减少函数调用的开销，提高执行效率。</li><li>不同优化级别：编译器通常提供不同的优化级别（如 -O1、-O2、-O3、-Os），开发者可以根据需求选择适合的优化级别。-Os 专注于减少代码体积，而 -O3 专注于提高执行效率。</li></ul></li><li><p>平台特定优化</p><ul><li>目标架构优化：优化器可以根据目标硬件平台的特性进行特定的优化，例如利用特定 CPU 指令集、优化缓存使用等。</li><li>特定应用场景优化：针对特定应用场景进行优化，例如嵌入式系统中的低功耗优化、实时系统中的实时性优化等。</li></ul></li></ul><p>在 Xcode 中可以设置优化级别：<br><img src="/images/lix_blog_176.png"></p><ul><li>-O0<ul><li>无优化：这是默认的优化级别，编译器不会进行任何优化。主要用于调试，因为它保留了源代码和生成代码之间的一一对应关系，便于调试和错误定位。</li></ul></li><li>-O1<ul><li>基本优化：应用一些基本的优化策略，旨在提高代码的执行效率而不会显著增加编译时间。例如，常量传播、死代码消除和简单的循环优化等。</li></ul></li><li>-O2<ul><li>标准优化：应用更多的优化策略，进一步提高代码的执行效率。除了 -O1 中的优化，还包括更多的循环优化、内联展开、寄存器分配等。</li></ul></li><li>-O3<ul><li>高级优化：应用最激进的优化策略，旨在最大化代码的执行效率。除了 -O2 中的优化，还包括更复杂的优化技术，如自动矢量化、函数内联和更高级的循环优化。这可能会显著增加编译时间和生成代码的体积。</li></ul></li><li>-Os<ul><li>优化代码体积：专注于减少生成代码的体积，同时尽可能保持较高的执行效率。适用于对代码体积有严格要求的应用，如嵌入式系统。</li></ul></li><li>-Oz<ul><li>极限优化代码体积：进一步减少代码体积，甚至可能牺牲一些执行性能。适用于对代码体积有极端要求的场景。</li></ul></li></ul><h4 id="（3）编译器后端（LLVM）"><a href="#（3）编译器后端（LLVM）" class="headerlink" title="（3）编译器后端（LLVM）"></a>（3）编译器后端（LLVM）</h4><ul><li><p>目标代码生成</p><ul><li>LLVM 对 IR 进行优化后，会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出。</li></ul></li><li><p>汇编</p><ul><li>汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出目标文件（object file）。该阶段会创建 .o 格式的目标文件。</li></ul></li><li><p>链接</p><ul><li>链接器将多个 .o 文件和库文件（如 .dylib、.a、.tbd）链接在一起，生成最终的可执行文件（Mach-O 文件）。</li><li>链接过程包括静态链接和动态链接：<ul><li>静态链接：在编译链接期间，将目标文件和静态库一起链接形成可执行文件。</li><li>动态链接：链接过程推迟到运行时进行，将动态库链接到可执行文件中。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP 启动优化 3 - 二进制重排</title>
      <link href="/posts/29690/"/>
      <url>/posts/29690/</url>
      
        <content type="html"><![CDATA[<h2 id="一、二进制重排原理"><a href="#一、二进制重排原理" class="headerlink" title="一、二进制重排原理"></a>一、二进制重排原理</h2><h3 id="1、Page-In-与-二进制重排"><a href="#1、Page-In-与-二进制重排" class="headerlink" title="1、Page In 与 二进制重排"></a>1、Page In 与 二进制重排</h3><p>在前面总结的冷启动流程中已经提到了 Page In，这里再简单补充下，在 iOS 中，内存管理主要由操作系统、CPU 协同完成：</p><ul><li>操作系统负责分配物理内存，并更新存放物理内存、虚拟内存映射关系的页表。</li><li>位于 CPU 上的 MMU（内存管理单元，是个硬件）负责虚拟内存、物理内存间的转换。</li><li>mmap 是一个系统调用，可以将文件映射到虚拟地址空间，操作系统也会同步更新页表，创建对应映射条目。但 mmap 只能将文件映射到虚拟地址空间，不会将文件加载进物理内存，所以操作系统在页表中会将其映射条目标记为未加载的状态。</li></ul><p>我们启动 APP 时，进程加载 Mach-O 实际上是通过 mmap 将 Mach-O 文件映射到 APP 进程的虚拟内存里的，这时候只分配了虚拟内存，并没有分配物理内存，也没有加载进物理内存。</p><p>如果访问一个虚拟内存地址，而 MMU 检测到对应物理内存中不存在的时候，就会触发 MMU 的 Page Fault（缺页错误、缺页异常、缺页中断），此时操作系统会暂停当前线程，停止后续代码逻辑的执行。接着触发一个 Page In：分配物理内存，并把文件中的内容拷贝到物理内存里。需要的数据读取到物理内存后，将会恢复线程，继续代码逻辑的执行。比如，我们在启动时通过虚拟内存调用一个方法，第一次调用这个方法时如果物理内存中还没将该方法加载进来，就会触发 Page In。</p><p>大致流程如下：<br><img src="/images/lix_blog_163.png"></p><p>而 Page In 是相当耗时的，每次 Page In 都需要先查找空闲的物理内存页，然后触发磁盘 IO 将数据加载进物理内存。对于 iOS 13 以下系统，如果加载进物理内存的是 TEXT 段内容，还需要进行解密，最后还要对解密后的页进行签名验证。而一个中大型 APP 在一次启动流程中触发 Page In 次数少则几百，多则上千，所以减少 Page In 次数可以在一定程度上加快启动时间。</p><p>但是在一次 APP 启动过程中，只有少部分函数被调用，这些函数在二进制文件中的分布是零散的，所以 Page In 读入的数据利用率并不高。如果我们可以把启动用到的函数排列到二进制的连续区间，那么就可以减少 Page In 的次数，从而优化启动时间。</p><p>以下图为例，方法 1 和方法 3 是启动的时候用到的，为了执行对应的代码，就需要两次 Page In。假如我们把方法 1 和 3 排列到一起，那么只需要一次 Page In，从而提升启动速度。<br><img src="/images/lix_blog_166.png"></p><h3 id="2、二进制重排配置"><a href="#2、二进制重排配置" class="headerlink" title="2、二进制重排配置"></a>2、二进制重排配置</h3><p>Xcode 早就提供了支持二进制重排，并且苹果也对 objc 的源码就采用了二进制重排方案进行优化，如下图：<br><img src="/images/lix_blog_135.png"></p><p>在源码文件夹中可以找到该文件：<br><img src="/images/lix_blog_136.png"></p><p>内容格式如下：<br><img src="/images/lix_blog_137.png"></p><p>可以看到，该 order 格式的文件内部都是函数符号，在 Xcode 中指定了 order file 的路径后，Xcode 在编译的时候按照文件中函数符号的顺序来排列二进制代码段。而我们要做的就是获取到 APP 启动过程中执行的所有函数符号，写入到 order 格式的文件中，并在 Xcode 的 Build Settings -&gt; Linking -&gt; Order File 选项中指定该文件的路径，这样就达到了把启动用到的函数排列到二进制的连续区间的目的，减少了启动时发生 Page In 的次数。<br><img src="/images/lix_blog_138.png"></p><h3 id="3、查看-Page-In-次数"><a href="#3、查看-Page-In-次数" class="headerlink" title="3、查看 Page In 次数"></a>3、查看 Page In 次数</h3><p>这块前面文章也有提到，可以借助 Instrument 中的 System Trace 工具，System Trace 调试结束会获取到启动过程中的分析数据，在结果页面选中主线程，结果中的 File Backed Page In 次数就是 Page In 次数（也称为 Page Fault 次数）：<br><img src="/images/lix_blog_139.png"></p><h2 id="二、二进制重排实现方案"><a href="#二、二进制重排实现方案" class="headerlink" title="二、二进制重排实现方案"></a>二、二进制重排实现方案</h2><p>根据前面内容可以知道实现二进制重排的关键点是如何获取到启动过程中执行的所有函数符号。</p><p>获取启动过程中执行的函数符号目前主要有两种主流实现方式：</p><ul><li>静态扫描 + 运行时 Trace（使用 fishhook 进行 hook 获取被调用的函数）</li><li>Clang 插桩</li></ul><h3 id="1、静态扫描-运行时-Trace"><a href="#1、静态扫描-运行时-Trace" class="headerlink" title="1、静态扫描 + 运行时 Trace"></a>1、静态扫描 + 运行时 Trace</h3><p>大致原理是通过扫描 linkmap 文件获得所有函数符号，然后借助 <a href="https://github.com/facebook/fishhook">fishhook</a> hook objc_msgSend 函数，由于 objc_msgSend 是变长参数，hook 相关代码是使用汇编来实现的。具体可查看<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485101&idx=1&sn=abbbb6da1aba37a04047fc210363bcc9&scene=21&token=2051547505&lang=zh_CN#wechat_redirect">《抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15%》</a></p><h3 id="2、Clang-插桩"><a href="#2、Clang-插桩" class="headerlink" title="2、Clang 插桩"></a>2、Clang 插桩</h3><p>基于 Clang 插桩获取符号有两种实现方式：</p><ul><li><p>一种是自己编写一个 Clang 插件，在 Clang 插件中我们去分析抽象语法树不同的节点，在相应的节点中插入自定义的代码用于符号收集，这种自定义 Clang 插件的方式优点是可根据自己需求进行灵活处理，缺点是通用性较差；</p></li><li><p>一种是利用 SanitizerCoverage 工具进行符号收集。</p></li></ul><p>这里主要介绍使用 SanitizerCoverage 进行插桩的方式，Clang SanitizerCoverage 是 LLVM 提供的代码覆盖工具，在编译时，它能够根据我们的编译配置，将一系列以 <code>__sanitizer_cov_trace_pc_</code> 为前缀的函数插入到我们自定义的函数内。</p><p>当我们在 Clang 的自定义配置 Other C Flags 中新增:<br><code>-fsanitize-coverage=trace-pc-guard</code><br>标志时，编译器将会为每个自定义的函数中插入 <code>__sanitizer_cov_trace_pc_guard</code><br>回调函数。</p><p>所以我们在 APP 中实现该回调函数，就可以在该回调函数内部收集原函数符号，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插桩的初始化方法</span></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) &#123;</span><br><span class="line">  <span class="keyword">static</span> uint64_t N; </span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>; </span><br><span class="line">  <span class="keyword">for</span> (uint32_t *x = start; x &lt; stop; x++)</span><br><span class="line">    *x = ++N; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取函数符号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>__sanitizer_cov_trace_pc_guard</code> 是在编译期由 Clang 插入到原函数内部的，因此<code>__sanitizer_cov_trace_pc_guard</code> 函数算是原函数内部的一个嵌套子函数，而操作系统在执行 bl 跳转指令的时候，会先保存下一条指令地址到 lr 寄存器中，当<code>__sanitizer_cov_trace_pc_guard</code> 函数执行完即执行 ret 指令后，需要继续回到原函数中继续执行，操作系统会去读取 LR 寄存器中的值拿到原函数的下一条待执行指令地址，这个地址可以通过下面代码来获取：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>也就是说，在 <code>__sanitizer_cov_trace_pc_guard</code> 函数中我们可以通过 <code>__builtin_return_address(0)</code> 拿到原函数某条指令的地址，那我们只要再通过 <code>dladdr()</code> 函数就可以获取到原函数的信息，从而拿到该函数符号：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    Dl_info info;</span><br><span class="line">    dladdr(PC, &amp;info);</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;%s\n&quot;</span>,info.dli_sname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_140.png"><br>在实际的使用过程中，需要解决以下几个主要问题：<br>(1) 多线程问题，由于 <code>__sanitizer_cov_trace_pc_guard</code> 函数是各个方法内插入的回调函数，而原函数可能处于不同的线程中，从而造成 <code>__sanitizer_cov_trace_pc_guard</code> 函数调用的多线程问题，解决这个问题可以使用原子队列 OSAtomicEnqueue 来处理，使用原子队列之后需要在 Other C Flags 配置中修改原来的配置为如下形式：<br><code>-fsanitize-coverage=func,trace-pc-guard</code></p><p>(2) 如果要支持 Swift 符号收集，由于 Swift 的编译前端与 OC 不同，需要在编译配置的Other Swift Flags下，新增下面配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-sanitize-coverage=func</span><br><span class="line">-sanitize=undefined</span><br></pre></td></tr></table></figure><p>(3) 使用 Cocoapods 管理的项目，存在多 target 的情况下，需要在每个 target 下都要进行上面的 Other C Flags 配置。</p><p>收集到启动过程中的函数符号之后，将这些符号写入到 order 文件中，并将该 order 文件的地址在 Xcode 的 Order File参数下进行配置即可。另外，《App 二进制文件重排已经被玩坏了》文章中详细介绍了此方式，并且作者基于 Clang SanitizerCoverage 写了个工具 AppOrderFiles，可一行调用生成 Order File，已经开源：<a href="https://github.com/yulingtianxia/AppOrderFiles">AppOrderFiles</a>。</p><p>使用该工具也一样需要先配置 Other C Flags 和 Other Swift Flags 参数：</p><ul><li>在 build settings 里的 “Other C Flags” 中添加 -fsanitize-coverage&#x3D;func,trace-pc-guard。</li><li>如果含有 Swift 代码的话，还需要在 “Other Swift Flags” 中加入 -sanitize-coverage&#x3D;func 和 -sanitize&#x3D;undefined。</li><li>所有链接到 App 中的二进制都需要开启 SanitizerCoverage，这样才能完全覆盖到所有调用。</li></ul><p>使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AppOrderFiles(^(<span class="built_in">NSString</span> *orderFilePath) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;OrderFilePath:%@&quot;</span>, orderFilePath);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不过，这两种方式也都有一个缺点，如果项目依赖了静态库，由于静态库是编译后的二进制文件，所以这两种方式无法获取到其中的函数符号。为了解决该问题，手淘采用了汇编插桩的实现方式，具体可查看相关<a href="https://www.jiqizhixin.com/articles/2020-01-07-4">文章</a>。</p><p><strong>参考：</strong><br><a href="https://mp.weixin.qq.com/s/wkK2UBvuUZW3Pf0Yd_3XTA">58 同城 App 性能治理实践-iOS 启动时间优化</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485101&idx=1&sn=abbbb6da1aba37a04047fc210363bcc9&scene=21&token=2051547505&lang=zh_CN#wechat_redirect">抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15%</a><br><a href="https://www.jiqizhixin.com/articles/2020-01-07-4">iOS基于静态库插桩的⼆进制重排启动优化</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP 启动优化 2 - 优化方案</title>
      <link href="/posts/29857/"/>
      <url>/posts/29857/</url>
      
        <content type="html"><![CDATA[<h2 id="一、启动时长监控"><a href="#一、启动时长监控" class="headerlink" title="一、启动时长监控"></a>一、启动时长监控</h2><h3 id="1、阶段划分"><a href="#1、阶段划分" class="headerlink" title="1、阶段划分"></a>1、阶段划分</h3><p>一般而言，对于冷启动时长，一般是统计从用户点击图标到首屏展示出来这段时间的时长。这个过程可以粗粒度分为下面两个阶段进行统计：<br><img src="/images/lix_blog_122.png"><br>这里一般是使用 root viewController 的 viewDidAppear 时间作为首屏渲染完成时间，也就是 APP 首屏加载完成用户可以交互的时间。</p><p>Pre Main 阶段，进程创建到执行 main() 的时间：</p><ul><li>加载动态库：加载系统动态库及三方动态库</li><li><code>Rebase</code> &amp; <code>Bind</code>：修复 Mach-O 内外指针偏移</li><li>Objc setup：初始化 objc runtime、注册 sel、加载 category 等</li><li>Initializers：调用 <code>+load</code> 方法，调用 static initializer 相关方法等</li></ul><p>After Main 阶段，执行 <code>main()</code> 到首屏渲染完成的时间：</p><ul><li>SDK 注册</li><li>业务初始化</li><li>首屏数据加载 &amp; UI 绘制</li><li>…</li></ul><p>当然这只是较粗粒度的划分，基本大部分 APP 都是划分成类似阶段。部分 APP 的 After Main 阶段定义为“执行 <code>main()</code>”到 “<code>didFinishLuanching</code> 执行结束”，这不是非常好的划分方式，因为对于用户来说，用户真正等待的时间是点击图标到 APP 首页展示完成能够交互的这段时间，而“<code>didFinishLuanching</code> 执行结束”时首页未必渲染完成。</p><p>对于 After Main 阶段，由于可能会有大量 SDK 注册、业务初始化等任务。为了能准确定位各任务耗时情况，一般需要对这些任务进行集中管理，监控任务执行耗时。</p><p>部分 APP 为了能够更加细致地分析各阶段耗时情况，可能会把 APP 冷启动划分为更加细粒度的几个阶段，例如抖音将冷启动划分成了下面这些阶段：<br><img src="/images/lix_blog_123.png"></p><h3 id="2、线上耗时监控"><a href="#2、线上耗时监控" class="headerlink" title="2、线上耗时监控"></a>2、线上耗时监控</h3><h4 id="1-节点时间上报"><a href="#1-节点时间上报" class="headerlink" title="(1) 节点时间上报"></a>(1) 节点时间上报</h4><p>只要启动阶段划分完成了，对于监控耗时情况就比较容易了，只需要获取各阶段节点发生的时间进行计算和上报即可。根据前面我们对 Pre Main 和 After Main 两个阶段的划分，对于“执行 <code>mian()</code>”和“首屏渲染完成”这两个节点，我们只需要在对应时刻插入统计逻辑即可。对于“进程创建时间”，可以通过 <code>sysctl</code> 系统调用拿到进程创建的时间戳：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要先导入头文件</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimeInterval</span>)processStartTime &#123;   </span><br><span class="line">    <span class="comment">// 单位是毫秒</span></span><br><span class="line">    <span class="keyword">struct</span> kinfo_proc kProcInfo;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> processInfoForPID:[[<span class="built_in">NSProcessInfo</span> processInfo] processIdentifier] procInfo:&amp;kProcInfo]) &#123;</span><br><span class="line">        <span class="keyword">return</span> kProcInfo.kp_proc.p_un.__p_starttime.tv_sec * <span class="number">1000.0</span> + kProcInfo.kp_proc.p_un.__p_starttime.tv_usec / <span class="number">1000.0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@&quot;无法取得进程的信息&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)processInfoForPID:(<span class="type">int</span>)pid procInfo:(<span class="keyword">struct</span> kinfo_proc*)procInfo &#123;</span><br><span class="line">    <span class="type">int</span> cmd[<span class="number">4</span>] = &#123;<span class="built_in">CTL_KERN</span>, KERN_PROC, KERN_PROC_PID, pid&#125;;</span><br><span class="line">    size_t size = <span class="keyword">sizeof</span>(*procInfo);</span><br><span class="line">    <span class="keyword">return</span> sysctl(cmd, <span class="keyword">sizeof</span>(cmd)/<span class="keyword">sizeof</span>(*cmd), procInfo, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iOS 9 之前 <code>sysctl</code> 还能获取到其他进程的信息，后来 Apple 为了隐私安全禁止了 <code>sysctl</code> 获取其他进程的信息，但是仍然允许获取当前进程的信息。</p><h4 id="2-无侵入监控方案"><a href="#2-无侵入监控方案" class="headerlink" title="(2) 无侵入监控方案"></a>(2) 无侵入监控方案</h4><p>无侵入监控的好处是降低使用者的学习成本，无需更改 APP 的现有逻辑。无侵入埋点对冷启动的定义仍然可以是“进程创建”到“首屏渲染完成”这段时间，这里可以参考字节的 APM 团队提供的一种无侵入的启动监控方案，方案将启动流程拆分成几个粒度比较粗的与业务无关的阶段：进程创建，最早的 <code>+load</code>，<code>didFinishLuanching</code> 开始和首屏首次绘制完成。<br><img src="/images/lix_blog_124.png"><br>前三个时间点无侵入获取较为简单</p><ul><li>进程创建：通过 sysctl 系统调用拿到进程创建的时间戳（实现方式前面提到了）。</li><li>最早的 <code>+load</code>：<code>+load</code>、initializer 的调用顺序和链接顺序有关，链接顺序默认按照 CocoaPod 的 Pod 命名升序排列，所以将组件命名为 AAA 开头既可以让某个 <code>+load</code>、initializer 第一个被执行。</li><li><code>didFinishLaunching</code>：监控 SDK 初始化一般在启动的很早期，用监控 SDK 的初始化时间作为 <code>didFinishLaunching</code> 的时间。</li></ul><p>那么问题来了：<br><strong>如何无侵入获取“首屏渲染完成”时间？</strong></p><p>iOS 13 开始，Apple 提供了 MetricKit 用于统计 APP 的性能数据，包括 APP 启动时间、电池使用、磁盘 IO 等性能数据，iOS 系统会自动收集收集这些性能数据进行上报，在 Xcode 11 版本我们可以在 Window - Organizer 中看到 APP 的这些数据：<br><img src="/images/lix_blog_125.png"><br>MetricKit 官方的统计的冷启动结束时间（首屏渲染完成时间）是完成第一个 CA::Transaction::commit 的时间，这点我们可以与之对齐。而我们如何准确获取到这个时间呢？</p><p>CATransaction 的 setCompletionBlock: 方法会在 CATransaction commit 结束被调用，所以我们可以利用这个 API 获取完成第一个 CA::Transaction::commit 的时间：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">CATransaction</span> setCompletionBlock:^&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 首屏渲染完成</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>经过测试可以发现，该 Block 回调时间在首个 ViewController（例如 TabBarViewController） 的 viewWillAppear 和 viewDidAppear 之间，相对来说还是比较准确的。</p><p>关于 MetricKit 工具，除了系统自动收集上报前面提到的那些数据外，MetricKit  还会统计上报 OSSignpost 事件持续的时间，所以我们可以借助 OSSignpost 完成一些自定义指标的收集。MetricKit  还会在一天结束后，将过去 24 小时搜集的性能数据归集在一起，然后在下一次启动 App 后，在 delegate 的回调中提供给我们（开发阶段可以手动触发：Xcode &gt; Debug &gt; Simulate MetricKit Payloads），这些数据已经做了聚合计算，划分为 50 分位数、90 分位数和 95 分位数的统计数据，拿到这些数据后我们可以直接用柱状图展示。所以我们也可以借助 MetricKit 相关 API 完成关键数据的收集，关于 MetricKit  用法网上有较多资料，这里不再补充。</p><h3 id="3、调试工具"><a href="#3、调试工具" class="headerlink" title="3、调试工具"></a>3、调试工具</h3><h4 id="1-Xcode-打印-pre-main-时间"><a href="#1-Xcode-打印-pre-main-时间" class="headerlink" title="(1) Xcode 打印 pre-main 时间"></a>(1) Xcode 打印 pre-main 时间</h4><p>Xcode 提供了一个很便捷的方式打印 pre-main 阶段耗时情况，开启方式为：在 Edit scheme -&gt; Run -&gt; Arguments -&gt; Environment Variables 中将环境变量 DYLD_PRINT_STATISTICS 设为 1，就可以看到 main 之前各个阶段的时间消耗。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Total pre-main time:  80.58 milliseconds (100.0%)</span><br><span class="line">         dylib loading time: 145.27 milliseconds (180.2%)</span><br><span class="line">        rebase/binding time: 126687488.6 seconds (128083892.1%)</span><br><span class="line">            ObjC setup time: 136.30 milliseconds (169.1%)</span><br><span class="line">           initializer time:  91.84 milliseconds (113.9%)</span><br><span class="line">           slowest intializers :</span><br><span class="line">             libSystem.B.dylib :   6.23 milliseconds (7.7%)</span><br><span class="line">   libBacktraceRecording.dylib :   6.51 milliseconds (8.0%)</span><br><span class="line">               libobjc.A.dylib :  11.04 milliseconds (13.7%)</span><br><span class="line">                CoreFoundation :   5.64 milliseconds (7.0%)</span><br><span class="line">                    Foundation :   4.91 milliseconds (6.1%)</span><br><span class="line">    libMainThreadChecker.dylib :  28.61 milliseconds (35.5%)</span><br><span class="line">        libLLVMContainer.dylib :  24.80 milliseconds (30.7%)</span><br></pre></td></tr></table></figure><p>如果将将环境变量 DYLD_PRINT_STATISTICS_DETAILS 设为 1，可以看到更加详细的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">total time: 2.9 seconds (100.0%)</span><br><span class="line">total images loaded:  341 (334 from dyld shared cache)</span><br><span class="line">total segments mapped: 21, into 383 pages</span><br><span class="line">total images loading time: 2.7 seconds (94.8%)</span><br><span class="line">total load time in ObjC:   8.29 milliseconds (0.2%)</span><br><span class="line">total debugger pause time: 2.5 seconds (88.5%)</span><br><span class="line">total dtrace DOF registration time:   0.00 milliseconds (0.0%)</span><br><span class="line">total rebase fixups:  16,242</span><br><span class="line">total rebase fixups time:   1.69 milliseconds (0.0%)</span><br><span class="line">total binding fixups: 496,287</span><br><span class="line">total binding fixups time:  92.61 milliseconds (3.1%)</span><br><span class="line">total weak binding fixups time:   0.01 milliseconds (0.0%)</span><br><span class="line">total redo shared cached bindings time: 159.41 milliseconds (5.4%)</span><br><span class="line">total bindings lazily fixed up: 0 of 0</span><br><span class="line">total time in initializers and ObjC +load:  48.24 milliseconds (1.6%)</span><br><span class="line">                     libSystem.B.dylib :   5.00 milliseconds (0.1%)</span><br><span class="line">           libBacktraceRecording.dylib :   6.48 milliseconds (0.2%)</span><br><span class="line">            libMainThreadChecker.dylib :  30.63 milliseconds (1.0%)</span><br><span class="line">total symbol trie searches:    1168220</span><br><span class="line">total symbol table binary searches:    0</span><br><span class="line">total images defining weak symbols:  35</span><br><span class="line">total images using weak symbols:  89</span><br></pre></td></tr></table></figure><h4 id="2-App-Launch"><a href="#2-App-Launch" class="headerlink" title="(2) App Launch"></a>(2) App Launch</h4><p>App Launch 是 Xcode 11 后新出的模板，同时包含了 Time Profile 以及 System Trace 的功能，可以用于查看 App 的启动过程，从而可以针对性的对启动速度进行优化，使用方式如下：</p><ul><li>首先在 Xcode 的 build settings 中 Debug Information Format 设置为 DWARF with dsYM File (用于符号化地址)</li><li>Xcode 编译运行项目</li><li>通过 Xcode –&gt; Open Developer Tool –&gt; Instruments –&gt; APP Launch 启动应用，App Launch 会启动应用 5 秒后自动关闭应用。</li></ul><p>之后就可以查看主线程被阻塞的情况，再借助 Time Profile 查看调用堆栈定位耗时任务进行优化即可。</p><h4 id="3-OSSignpost"><a href="#3-OSSignpost" class="headerlink" title="(3) OSSignpost"></a>(3) OSSignpost</h4><p>OSSignpost 是 iOS 12 推出的可以用于在 instruments 里标记时间段的 API，性能非常高，可以认为对启动无影响：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;os/signpost.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 log 对象</span></span><br><span class="line">os_log_t log = os_log_create(<span class="string">&quot;com.demo.signpost&quot;</span>, <span class="string">&quot;mySignpost&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 os_signpost 的 ID</span></span><br><span class="line">os_signpost_id_t spid = os_signpost_id_generate(log);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记开始，或者使用 MXSignpostIntervalBegin(log, event_id, name, ...)</span></span><br><span class="line">os_signpost_interval_begin(log, spid, <span class="string">&quot;task&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要监控的逻辑放到 begin 和 end 之间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记开始，或者使用 MXSignpostIntervalEnd(log, event_id, name, ...)</span></span><br><span class="line">os_signpost_interval_end(log, spid, <span class="string">&quot;task&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中 os_log_create 函数有两个参数：</p><ul><li>第一个参数 subsystem：标识，反向 DNS 格式，例如 com.demo.signpost</li><li>第二个参数 category：分类</li></ul><p>os_signpost_interval_begin 和 os_signpost_interval_end 用于标记开始和结束，第三个参数是给时间段的事件名。并且还可以增加第四、五个参数用于携带元数据，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os_signpost_interval_begin(log, spid, <span class="string">&quot;task&quot;</span>, <span class="string">&quot;Start&quot;</span>);</span><br><span class="line">os_signpost_interval_end(log, spid, <span class="string">&quot;task&quot;</span>, <span class="string">&quot;Finished with size %d&quot;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>除此之外，还可以利用 os_signpost_event_emit 函数添加兴趣点，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os_signpost_event_emit(log, spid, <span class="string">&quot;task&quot;</span>, <span class="string">&quot;testEmit&quot;</span>);</span><br></pre></td></tr></table></figure><p>除了 MetricKit  会统计使用 OSSignpost  的自定义事件时长数据外，我们还可以借助 Instruments 工具来查看这些数据，先看下 demo 内容：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">os_log_t log = os_log_create(<span class="string">&quot;com.demo.signpost&quot;</span>, <span class="string">&quot;mySignpost&quot;</span>);</span><br><span class="line">os_signpost_id_t spid = os_signpost_id_generate(log);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">&quot;com.demo.queue1&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">&quot;com.demo.queue2&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> randomSleep];</span><br><span class="line">        os_signpost_interval_begin(log, spid, <span class="string">&quot;task&quot;</span>);</span><br><span class="line">        [<span class="keyword">self</span> randomSleep];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 兴趣点</span></span><br><span class="line">            os_signpost_event_emit(log, spid, <span class="string">&quot;task&quot;</span>, <span class="string">&quot;testEmit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        os_signpost_interval_end(log, spid, <span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> randomSleep];</span><br><span class="line">        <span class="comment">// 可以携带元数据</span></span><br><span class="line">        os_signpost_interval_begin(log, spid, <span class="string">&quot;task2&quot;</span>, <span class="string">&quot;xxxxxx&quot;</span>);</span><br><span class="line">        [<span class="keyword">self</span> randomSleep];</span><br><span class="line">        os_signpost_interval_end(log, spid, <span class="string">&quot;task2&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 demo，然后打开 Instruments 选择 Blank：<br><img src="/images/lix_blog_126.png"></p><p>点击右上角加号，选择 os_signpost 双击或拖动到左边：<br><img src="/images/lix_blog_127.png"></p><p>开始调试就可以看到相关数据了：<br><img src="/images/lix_blog_128.png"></p><p>所以，可以借助这种方式调试启动过程中代码逻辑耗时情况。</p><h4 id="4-火焰图"><a href="#4-火焰图" class="headerlink" title="(4) 火焰图"></a>(4) 火焰图</h4><p>火焰图用来分析时间相关的性能瓶颈非常有用，可以直接把业务代码的耗时绘制出来。本质上是使用 hook <code>objc_msgSend</code> 或者编译期插桩在方法的开始和末尾打两个点，以计算这个方法的耗时，然后转换成 Chrome 的标准的 json 格式就可以分析了，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFTimeInterval</span> begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="built_in">CFTimeInterval</span> end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;cost = %@&quot;</span>,(end - begin));</span><br></pre></td></tr></table></figure><p>可以看到上面是使用 <code>CACurrentMediaTime()</code> 获取的时间，那么这种方式与 <code>NSDate</code>、<code>CFAbsoluteTimeGetCurrent()</code> 有何区别呢？</p><p>区别：</p><ul><li><p><code>NSDate</code> 属于 Foundation 框架、<code>CFAbsoluteTimeGetCurrent()</code> 属于 CoreFoundation框架、<code>CACurrentMediaTime()</code> 属于 QuartzCore 框架</p><ul><li>QuartzCore 框架提供了图形处理和视频图像处理的能力，Core Animation 就属于 QuartzCore 框架</li></ul></li><li><p><code>NSDate</code> 或 <code>CFAbsoluteTimeGetCurrent()</code> 返回网络时间同步的时钟时间。</p></li><li><p><code>CACurrentMediaTime()</code> 和 <code>mach_absolute_time()</code> 是系统时间，是基于内建时钟的，能够更精确更原子化地测量，并且不会因为外部时间变化而变化（例如时区变化、夏时制、秒突变等），但它和系统的 uptime 有关，系统重启后 <code>CACurrentMediaTime()</code> 会被重置。</p></li></ul><p>应用场景：</p><ul><li><code>NSDate</code>、<code>CFAbsoluteTimeGetCurrent()</code> 常用于日常时间、时间戳的表示，与服务器之间的数据交互，其中 <code>CFAbsoluteTimeGetCurrent()</code> 相当于<code>[[NSDate data] timeIntervalSinceReferenceDate]</code>；</li><li><code>CACurrentMediaTime()</code> 常用于测试代码的效率；</li></ul><p>知道了如何计算代码的执行时间，那如何以可视化方式展示数据呢？有两种方式，一种是借助 Chrome 内置的 chrome:&#x2F;&#x2F;tracing 工具，我们将统计的数据格式转成该工具所需的 格式即可导入展示。</p><p>另一种方式是借助开源工具 <a href="https://github.com/everettjf/AppleTrace">AppleTrace</a>，该工具会生成可直观展示数据的 html，实现原理和使用方式可以查看该 github 中贴出的文章<a href="https://everettjf.github.io/2017/09/21/appletrace">《AppleTrace 性能分析工具》</a>。该工具最终生成的火焰图效果如下：<br><img src="/images/lix_blog_129.png"></p><h2 id="二、优化实践"><a href="#二、优化实践" class="headerlink" title="二、优化实践"></a>二、优化实践</h2><h3 id="1、Pre-Main-阶段优化"><a href="#1、Pre-Main-阶段优化" class="headerlink" title="1、Pre Main 阶段优化"></a>1、Pre Main 阶段优化</h3><p>前面已经提到 Pre Main 阶段的任务：</p><ul><li>加载动态库</li><li>Rebase &amp; Bind</li><li>Objc setup</li><li>Initializers</li></ul><p>我们可以针对这些任务进行针对性优化：</p><h4 id="1-减少动态库数量"><a href="#1-减少动态库数量" class="headerlink" title="(1) 减少动态库数量"></a>(1) 减少动态库数量</h4><p>减少动态库数量可以加减少 dyld 3 启动闭包创建和加载动态库阶段的耗时，官方建议动态库数量小于 6 个。减少动态库可以合并动态库或者将动态库转为静态库，相较而言，转为静态库在操作上更容易些，是首选方案。</p><p>cocoapods 默认使用的就是静态库，但是如果 Podfile 中加入 use_frameworks! 选项将会使用动态库。</p><h4 id="2-动态库懒加载"><a href="#2-动态库懒加载" class="headerlink" title="(2) 动态库懒加载"></a>(2) 动态库懒加载</h4><p>实现动态库懒加载主要分为两步：</p><ul><li>第一步：在 Build Phases 的 Link Binary With Libraries 中去掉需要懒加载的动态库；</li><li>第二步：运行时使用 <code>dlopen</code> 对动态库按需加载。</li></ul><p>苹果系统 API <code>&lt;dlfcn.h&gt;</code> 中提供了几个操作动态库的方法，包括 <code>dlopen</code>、<code>dlerror</code>、<code>dlsym</code> 和 <code>dlclose</code> 等，我们可以使用 <code>dlopen</code> 对启动阶段不需要的动态库在运行时手动加载。</p><p>需要注意的是，使用 <code>dlopen</code> 懒加载动态库时，<code>dlopen</code> 会调用 <code>dlopen_preflight</code> 先校验动态库签名，如果动态库没有打包进 APP（和 APP 使用相同签名），真机会加载失败并报签名错误。所以动态库懒加载核心思想是使动态库只参与签名不参与链接，在需要动态库的时候我们手动加载动态库。</p><p>非系统的动态库路径是固定的，均位于 “xxx.app&#x2F;Frameworks&#x2F;“ 目录下，可以通过 <code>[NSBundle mainBundle].bundlePath</code> 获取 “xxx.app” 所在的目录，然后在必要时候手动加载动态库：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">char</span> *)dlopenFramework:(<span class="built_in">NSString</span> *)frameworkName &#123;</span><br><span class="line">    <span class="comment">// 根据动态库名称获取动态库所在路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@/Frameworks/%@.framework/%@&quot;</span>,</span><br><span class="line">                      [<span class="built_in">NSBundle</span> mainBundle].bundlePath,</span><br><span class="line">                      frameworkName,</span><br><span class="line">                      frameworkName];</span><br><span class="line">    <span class="comment">// 调用 dlopen 加载动态库</span></span><br><span class="line">    <span class="type">void</span>* fp = dlopen(path.UTF8String, RTLD_LAZY);</span><br><span class="line">    <span class="comment">// 获取 dlopen 产生的错误信息</span></span><br><span class="line">    <span class="type">char</span>* err = dlerror();</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态库懒加载也可以使用 <code>[NSBundle loadAndReturnError:]</code> 或 <code>[NSBundle load]</code> 这两个 API，他们本质上调用的是底层的 <code>dlopen</code>，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)loadFramework:(<span class="built_in">NSString</span> *)frameworkName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@/%@&quot;</span>, [<span class="built_in">NSBundle</span> mainBundle].privateFrameworksPath, frameworkName];</span><br><span class="line">    <span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleWithPath:path];</span><br><span class="line">    <span class="keyword">if</span> (!bundle) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ not found&quot;</span>, frameworkName);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="keyword">if</span> (![bundle loadAndReturnError:&amp;error]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Load %@ failed: %@&quot;</span>, frameworkName, error);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Load %@ success&quot;</span>, frameworkName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将动态库配置成懒加载，就无法直接调用其中的类和方法，因为其符号并不包含在运行内存中。面对这样的情况，我们可以把动态库中提供给外部调用的逻辑收口，使用特定的协议或接口，通过组件化框架在调用接口时尝试加载动态库，再进行实际逻辑的调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (Class&lt;FeatureBridge&gt;)getBridgeWithProtocol:(Protocol *)protocol &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *bridgeName = [<span class="keyword">self</span> getClassNameWithProtocol:protocol];</span><br><span class="line">    Class bridgeClass = <span class="built_in">NSClassFromString</span>(bridgeName);</span><br><span class="line">    <span class="keyword">if</span> (bridgeClass) &#123;</span><br><span class="line">        <span class="comment">// 已加载：直接返回</span></span><br><span class="line">        <span class="keyword">return</span> bridgeClass;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未加载：加载动态库后再返回</span></span><br><span class="line">        <span class="built_in">NSString</span> *frameworkName = [<span class="keyword">self</span> getFrameworkNameWithProtocol:protocol];</span><br><span class="line">        [<span class="keyword">self</span> dlopenFramework:frameworkName];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NSClassFromString</span>(bridgeName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经验证，手动调用 <code>dlopen</code> 的耗时大于系统 <code>dyld</code> 加载耗时，所以需要避免在主线程直接调用 <code>dlopen</code> 操作。一个有效的解决手段是在启动阶段或者启动完成后，异步预加载所有懒加载的动态库。</p><p>对于使用 Cocoapods 管理的项目也可以配置动态库懒加载：在 pod install 之后，会生成 Pods-xxx-frameworks.sh 和 Pods-xxx.release.xcconfig 这两个文件，其中 Pods-xxx-frameworks.sh 文件脚本负责架构剔除和重签名等功能，而 Pods-xxx.xcconfig 文件则负责静态库和动态库的链接配置，我们自定义的动态库想要进行懒加载，只需要修改 xxx.xcconfig 配置文件，将需要懒加载的动态库从配置文件中移除，这样保证懒加载的动态库参与签名和拷贝，但是不参与链接。<br><img src="/images/lix_blog_130.png"><br>需要注意的是使用动态库懒加载是有一定风险的，而且 Apple 官方也不建议懒加载动态库。懒加载动态库的前提是不做频繁升级和变更，但是一旦升级则可能引起灾难性的后果，因为 API 发生变更，编译能正常通过，因为编译是依赖协议进行的，API 发生了变更很可能负责升级的同学并没有对协议进行升级，可以在 debug 环境下利用 Runtime 对相关 API 进行检测。</p><h4 id="3-移除无用代码"><a href="#3-移除无用代码" class="headerlink" title="(3) 移除无用代码"></a>(3) 移除无用代码</h4><p>移除无用代码可以减少 Rebase &amp; Bind &amp; Runtime 初始化的耗时，可通过静态扫描方式查找无用代码，最容易的静态扫描是使用 AppCode，但是项目大了之后 AppCode 的索引速度非常慢，另外的一种静态扫描是基于 Mach-O 的：</p><ul><li><code>_objc_selrefs</code> 和 <code>_objc_classrefs</code> 存储了引用到的 <code>sel</code> 和 <code>class</code></li><li><code>__objc_classlist</code> 存储了所有的 <code>sel</code> 和 <code>class</code><br><img src="/images/lix_blog_131.png"></li></ul><p>二者做个差集就知道那些 class&#x2F;sel 用不到，实现方式可以参考：<a href="https://github.com/nst/objc_cover">objc_cover</a>，由于 OC 支持运行时调用，删除之前还要再二次确认。</p><h4 id="4-load-优化"><a href="#4-load-优化" class="headerlink" title="(4) +load 优化"></a>(4) +load 优化</h4><p>过多的 <code>+load</code> 方法会拖慢启动速度，一种优化方式是将 <code>+load</code> 方法中的任务迁移到 <code>+initialize</code> 方法中：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于有些任务确实需要在启动的早期（<code>+load</code>）里注册的，例如各个组件经常在 <code>+load</code> 方法中注册自己提供的 <code>Service</code>，即 <code>protocol</code> 和 class 对应关系，可以使用 clang attribute 代替。Clang 提供了很多的编译器函数，它们可以完成不同的功能。其中一种就是 <code>section()</code> 函数，<code>section()</code> 函数提供了二进制段的读写能力，它可以将一些编译期就可以确定的常量写入数据段，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((used, section (&quot;xxx段,xxx节&quot;)))</span><br></pre></td></tr></table></figure><p>通过使用 <code>__attribute__((section(&quot;xxx段,xxx节&quot;)))</code> 来指明将数据存储到哪个段哪个节。<code>__attribute__((used))</code> 告诉编译器该静态变量即使没有被使用也要保留，防止链接器在优化时将其删除。</p><p>借助 clang attribute 取代 <code>+load</code> 进行 <code>Service</code> 注册的 demo 如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach-o/getsect.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ServiceInfo &#123;</span><br><span class="line">    <span class="type">char</span> *<span class="keyword">class</span>;</span><br><span class="line">    <span class="type">char</span> *protocol;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ServiceRegister(_class_,_protocol_)\</span></span><br><span class="line"><span class="meta">__attribute__((used, section (<span class="string">&quot;__DATA,__services__&quot;</span>))) static struct ServiceInfo ServiceInfo##_class_ =\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">    .class = #_class_,\</span></span><br><span class="line"><span class="meta">    .protocol = #_protocol_,\</span></span><br><span class="line"><span class="meta">&#125;;</span></span><br></pre></td></tr></table></figure><p>使用时：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServiceRegister(AAAclass, AAAprotocol);</span><br><span class="line">ServiceRegister(BBBclass, BBBprotocol);</span><br></pre></td></tr></table></figure><p>取数据：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.根据符号找到所在的 mach-o 文件信息</span></span><br><span class="line">Dl_info info;</span><br><span class="line">dladdr((__bridge <span class="type">void</span> *)[<span class="keyword">self</span> <span class="keyword">class</span>], &amp;info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取 __DATA 中自定义的 __services__ 数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mhp = (<span class="keyword">struct</span> mach_header*)info.dli_fbase;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> serviceSize = <span class="number">0</span>;</span><br><span class="line">    uint32_t *serviceMemory = (uint32_t*)getsectiondata(mhp, <span class="string">&quot;__DATA&quot;</span>, <span class="string">&quot;__services__&quot;</span>, &amp;serviceSize);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> mach_header_64 *mhp = (<span class="keyword">struct</span> mach_header_64*)info.dli_fbase;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> serviceSize = <span class="number">0</span>;</span><br><span class="line">    uint64_t *serviceMemory = (uint64_t*)getsectiondata(mhp, <span class="string">&quot;__DATA&quot;</span>, <span class="string">&quot;__services__&quot;</span>, &amp;serviceSize);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.遍历 __services__ 中的数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> serviceCount = serviceSize/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ServiceInfo);</span><br><span class="line"><span class="keyword">struct</span> ServiceInfo *items = (<span class="keyword">struct</span> ServiceInfo*)serviceMemory;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> idx = <span class="number">0</span>; idx &lt; serviceCount; ++idx) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *<span class="keyword">class</span> = [<span class="built_in">NSString</span> stringWithUTF8String:items[idx].class];</span><br><span class="line">    <span class="built_in">NSString</span> *protocol = [<span class="built_in">NSString</span> stringWithUTF8String:items[idx].protocol];;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;class:%@，protocol:%@&quot;</span>, <span class="keyword">class</span>, protocol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class:AAAclass，protocol:AAAprotocol</span><br><span class="line">class:BBBclass，protocol:BBBprotocol</span><br></pre></td></tr></table></figure><p>我们使用 MachOView 工具查看 Mach-O 可以看到我们存储的数据：<br><img src="/images/lix_blog_132.png"></p><h4 id="5-减少静态初始化方法的使用"><a href="#5-减少静态初始化方法的使用" class="headerlink" title="(5) 减少静态初始化方法的使用"></a>(5) 减少静态初始化方法的使用</h4><p>例如减少 <code>__attribute__(constructor)</code> 的使用，这里没有太多需要总结的。<br>（使用 <code>__attribute__((constructor))</code> 修饰的函数可以在 main 函数之前调用）。</p><h3 id="2、After-Main-阶段优化"><a href="#2、After-Main-阶段优化" class="headerlink" title="2、After Main 阶段优化"></a>2、After Main 阶段优化</h3><p>After Main 阶段主要耗时的地方在于 <code>didFinishLuanching</code> 中的大量启动项，比如 SDK 注册、业务初始化等。所以这一阶段最佳优化方式是对启动项集中管理，并且根据启动项的重要和紧急程度，提供三种启动时机：</p><ul><li>同步启动</li><li>异步启动</li><li>首屏渲染完成后启动</li></ul><p>当然也可以根据自己 APP 需求提供其他启动时机，对于那些不是立刻能用到的 SDK 或者某些任务，比如微信分享 SDK，放到首屏渲染完成后启动，这样能有效减少启动项带来的耗时。</p><p>对于启动项注册主要有两种方式：</p><ul><li>.plist 中集中注册启动项；</li><li>启动项自注册，即由需要设置启动项的组件自行注册启动项；</li></ul><p>对于 .plist 中集中注册启动项的方式，启动项、组件之间产生了耦合，当这个组件被另个 APP 依赖的时候，又需要重新注册启动项，启动项注册逻辑无法复用。而启动项自注册的方式，恰好解决了这个问题。那组件如何自行注册启动项呢？一般是在 +load 方法中进行注册，但是 +load 方法会增加 Pre Main 阶段耗时，所以应当使用前面提到的 clang attribute 相关函数进行注册。</p><p>为了准确知道各启动项耗时情况，还应当对每个启动项进行监控，记录耗时时长并进行上报，在开发阶段和上线后跟踪启动项的耗时，及时进行优化。对于获取启动项耗时可以使用前面提到的在任务开始、结束分别使用 <code>CACurrentMediaTime()</code> 获取时间计算差值即可。</p><p>而对于首页渲染耗时，则需要根据业务逻辑进行优化，例如缓存必要数据、子线程预加载动画文件等。</p><p><strong>参考：</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247487757&idx=1&sn=a52c11f6a6f217bd0d3283de9b00c8bc&chksm=e9d0daefdea753f954cfcb15d5d0f90302a9f45ba06968377644ffe9e5757a69c5b0132d2c8b&scene=178&cur_album_id=1590407423234719749#rd">抖音品质建设 - iOS启动优化</a><br><a href="https://www.jianshu.com/p/3063053a6114">从探索到实践，58动态库懒加载实录</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP 启动优化 1 - 冷启动流程</title>
      <link href="/posts/40965/"/>
      <url>/posts/40965/</url>
      
        <content type="html"><![CDATA[<p>iOS 的冷启动流程可用下图表示：<br><img src="/images/lix_blog_108.png"><br>接下来，详细介绍 APP 启动流程中的各个阶段：</p><h2 id="一、exec"><a href="#一、exec" class="headerlink" title="一、exec()"></a>一、exec()</h2><p>iOS 操作环境的操作系统部分是 Darwin，Darwin 是一种类 Unix 操作系统，其内核是 XNU，XNU 是一个宏内核 BSD 与微内核 Mach 混合内核。</p><p>在 iOS 中，用户环境始于 <code>launchd</code> 进程，它是第一个被内核启动的用户态进程，<code>launchd</code> 由操作系统内核启动，Mac OS 中 <code>launchd</code> 不止一个，第一个为 <code>PID 1</code>，由内核启动，如果有用户登录进系统，则会创建另一个 <code>launchd</code>，这是由第一个 <code>launchd</code> fork 出来的，并且所有权属于登录用户。由于 iOS 不需要登录，所以只有一个系统范围的 <code>launchd</code>，并且它是系统运行期间唯一不能终止的进程，当系统关闭时，它作为最后一个进程退出。<br><img src="/images/lix_blog_109.png"><br><code>launchd</code> 主要负责直接或间接的启动系统中的其他进程。它是用户模式里所有进程的父进程，同时也将负责两种后台作业：守护程序和代理程序。</p><ul><li>守护程序（daemon）：守护程序由系统自动启动，不考虑是否有用户登录进系统，是后台服务，通常和用户没有交互。比如 push 通知、外接设备插入的处理和 XPC 等。</li><li>代理程序（agent）：是一类特殊的守护程序，只有在用户登录的时候才启动，可以和用户交互，有的程序还会有 GUI，比如 MacOS 的 Finder 或 iOS 的 SpringBoard。</li></ul><p>当启动一个 APP 时，<code>launchd</code> 进程（<code>launchd</code> 是用户态进程）会通过 <code>fork()</code> 函数进行系统调用，进入内核态克隆出另一个 <code>launchd</code> 进程，再通过 <code>exec()</code> 函数进行系统调用，传入目标 APP 对应主 Mach-O 文件的路径，作为该进程的内容。</p><p>也就是说，我们在 Mac OS 和 iOS 里启动的 APP，父进程 parent process 都是 <code>launchd</code>，例如我们通过活动监视器双击任意一个进程可以看到这点：<br><img src="/images/lix_blog_110.png"></p><p>在 iOS 的 crash log 里我们也能看到 APP 的 parent process 是 <code>launchd</code>：<br><img src="/images/lix_blog_111.png"></p><p>那 <code>launchd</code> 进程的 parent process 是谁呢？<br><img src="/images/lix_blog_112.png"><br><code>launchd</code> 的 parent process 是 <code>kernel_task</code>。<code>kernel_task</code> 进程就是内核进程本程了，在内核启动时自行创建。</p><p><strong>这里提到内核态和用户态，那内核态和用户态是什么呢？</strong></p><p>内核控制着操作系统最核心的部分，为了防止应用程序崩溃而导致的内核崩溃，内核与应用程序之间需要进行严格的分离。基于软件的分离会产生巨大的开销，因此现代的操作系统都是依靠硬件来分离。分离的结果就是用户态与内核态。</p><p>用户态和内核态之间有两种切换方式：</p><ul><li>自愿转换：比如系统调用；</li><li>非自愿转换：当发生异常、中断或处理器陷阱的时候，代码的执行会被挂起，并且保留发生错误时候的完整状态。控制权被转交给预定义的内核态错误处理程序或中断服务程序。</li></ul><p>在 XNU 中，系统调用有四种类别：</p><ul><li>BSD 系统调用</li><li>Mach 陷阱</li><li>机器相关调用</li><li>诊断调用</li></ul><p><code>exec()</code> 函数的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容。</p><p>UNIX 提供了 6 种不同的 <code>exec()</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int execl(const char *pathname, const char *arg0, ...  /* (char *)0 */ );</span><br><span class="line">int execv(const char *pathname, char *const argv[]);</span><br><span class="line">int execle(const char *pathname, const char *arg0, ...  /* (char *)0, char *const envp[] */ );</span><br><span class="line">int execve(const char *pathname, char *const argv[], char *const envp[]);</span><br><span class="line">int execlp(const char *filename, const char *arg0, ...  /* (char *)0 */ );</span><br><span class="line">int execvp(cosnt char *filename, char *const argv[]);</span><br></pre></td></tr></table></figure><p>其中只有 <code>execve</code> 是真正意义上的系统调用，其它都是在此基础上经过包装的库函数，包括 <code>exec()</code> 函数。</p><p>也就是说，执行完 <code>exec()</code> 函数，APP 对应的 Mach-O 会被加载进新创建的进程里了。</p><h2 id="二、加载-Mach-O"><a href="#二、加载-Mach-O" class="headerlink" title="二、加载 Mach-O"></a>二、加载 Mach-O</h2><h3 id="1、Mach-O-的结构"><a href="#1、Mach-O-的结构" class="headerlink" title="1、Mach-O 的结构"></a>1、Mach-O 的结构</h3><p>Mach-O（Mach Object 的简写）是 Mac 和 iOS 可执行文件的格式。<br>常见的 Mach-O 格式文件有：</p><ul><li>目标文件 .o</li><li>库文件<ul><li>.a</li><li>.dylib</li><li>.framework</li></ul></li><li>可执行文件</li><li>dyld ( 动态链接器 )</li><li>.dsym ( 符号表 )</li></ul><p>我们可以使用 MachOView 查看一个 Mach-O 文件内容：<br><img src="/images/lix_blog_113.png"><br>我们可以生成只包含一种架构的 Mach-O 文件，比如 armv7。当然也可以编译生成多架构的的 Mach-O 文件，这种包含多种架构的我们称之为通用 Mach-O，也可以称为 Fat Mach-O。运行通用 Mach-O 的时候，加载器会选择合适的架构的代码去执行。我们 APP 的主二进制文件就是 Fat Mach-O：<br><img src="/images/lix_blog_114.png"><br>Mach-O 可以分为三部分：</p><ul><li>Header</li><li>Load Commands</li><li>Data<img src="/images/lix_blog_115.png" style="width:50%;"></li></ul><p><code>Header</code> 存储该二进制文件的一般信息，例如：架构类型、加载命令的数量等。Header 的最开始是 Magic Number，表示这是一个 Mach-O 文件，除此之外还包含一些 flags，这些 flags 会影响 Mach-O 的解析。</p><p><code>Load Commands</code> 即加载命令，又称指令。这些命令在被调用时清晰地指导了如何设置并加载二进制数据。有一些命令是由内核加载器直接使用的，其他命令是由动态链接器（<code>dyld</code>）处理的。其中 <code>LC_LOAD_DYLINKER</code> 命令中存储了动态链接器（<code>dyld</code>）的路径信息。</p><p><img src="/images/lix_blog_116.png"><br><code>Data</code> 部分包含了实际的代码和数据，<code>Data</code> 被分割成很多个 <code>Segment</code>，每个 <code>Segment</code> 又被划分成很多个 <code>Section</code>，分别存放不同类型的数据。<br>标准的三个 <code>Segment</code> 是 <code>TEXT</code>、<code>DATA</code>、<code>LINKEDIT</code>，也支持自定义：</p><ul><li><code>TEXT</code>，代码段，只读可执行，存储函数的二进制代码(<code>__TEXT</code>)，常量字符串(<code>__cstring</code>)，Objective C 的类&#x2F;方法名等信息</li><li><code>DATA</code>，数据段，读写，存储 Objective C 的字符串(<code>__cfstring</code>)，以及运行时的元数据：<code>class</code>&#x2F;<code>protocol</code>&#x2F;<code>method</code>…</li><li><code>LINKEDIT</code>，启动 App 需要的信息，如 <code>bind</code> &amp; <code>rebase</code> 的地址，代码签名信息，符号表…</li></ul><h3 id="2、虚拟内存"><a href="#2、虚拟内存" class="headerlink" title="2、虚拟内存"></a>2、虚拟内存</h3><p>用户态的一个优点在于虚拟内存隔离，每个进程都独享一个私有的地址空间。何谓虚拟内存呢？</p><p>内存可以分为虚拟内存和物理内存，其中物理内存是实际占用的内存，虚拟内存是在物理内存之上建立的一层逻辑地址，保证内存访问安全的同时为应用提供了连续的地址空间。</p><p>系统将虚拟内存和物理内存分割成统一大小的单元，叫做页(page)。在早期的 iOS 里，页大小均为 4K；之后基于 A7 和 A8 的 iOS 里，采用虚拟内存每页 16K，物理内存每页 4K；基于 A9 或更新 CPU 的 iOS 里，页大小均为 16K。</p><p>CPU 有个内存管理单元（MMU）, 它维护了一张页表（page table），内部记录了虚拟地址和物理地址映射关系。用户访问虚拟地址时，会自动被 MMU 转换成物理地址。当 CPU 访问的虚拟地址并未映射到物理地址时，会发生 <code>Page Fault</code>：暂停当前执行的程序代码，然后分配一块干净的物理内存，从磁盘中加载所需的一页数据到该物理内存，同时更新页表，然后继续执行程序代码。</p><p>iOS 是通过 mmap（全称 memory map，一种内存映射技术）做物理内存和虚拟内存映射的。进程向系统申请内存时，系统也并不会直接返回物理内存的地址，而是返回一个虚拟内存地址。只有在 CPU 需要访问该虚拟内存地址时，系统才会分配并映射到物理内存。</p><p>如何查看 APP 启动时候发生 <code>Page Fault</code> 的次数呢？可以借助 Instrument 中的 System Trace 工具，System Trace 调试结束会获取到启动过程中的分析数据，在结果页面选中主线程，结果中的 File Backed Page In 次数就是 <code>Page Fault</code> 次数：<br><img src="/images/lix_blog_117.png"><br>所以，Page Fault 次数又被称为 Page In 次数。</p><p>同样的，加载 Mach-O 实际上也是通过 mmap 将 Mach-O 文件映射到 APP 进程的虚拟内存里的，这时候只分配了虚拟内存，并没有分配物理内存。如果访问一个虚拟内存地址，而物理内存中不存在的时候，触发一个 <code>Page In</code>，分配物理内存，并把文件中的内容拷贝到物理内存里。如果在操作系统的物理内存里有缓存，则会触发一个 Page Cache Hit，后者是比较快的，这也是热启动比冷启动快的原因之一。</p><p>启动的路径上会触发很多次 <code>Page In</code>，其实也比较容易理解，因为启动的会读写二进制中的很多内容。<code>Page In</code> 会占去启动耗时的很大一部分，我们来看看单个 <code>Page In</code> 的过程：<br><img src="/images/lix_blog_191.png" style="width:50%;"></p><ul><li>MMU 找到空闲的物理内存页面</li><li>触发磁盘 IO，把数据读入物理内存</li><li>如果是 <code>TEXT</code> 段的页，要进行解密</li><li>对解密后的页，进行签名验证</li></ul><p>其中解密是大头，IO 其次。为什么要解密呢？</p><p>因为 iTunes Connect 会对上传 Mach-O 的 <code>TEXT</code> 段进行加密，防止 IPA 下载下来就直接可以看到代码。这也就是为什么逆向里会有个概念叫做“砸壳”，砸的就是这一层 TEXT 段加密。iOS 13 对这个过程进行了优化，<code>Page In</code> 的时候不需要解密了（iOS 13 启用了 dyld3，提前生成了启动闭包文件）。</p><p>在 APP 启动过程，<code>Page In</code> 是一个比较耗时的过程，针对这一块，可以通过二进制重排进行优化（后续内容讲解）。</p><h3 id="3、ASLR"><a href="#3、ASLR" class="headerlink" title="3、ASLR"></a>3、ASLR</h3><p>根据前面内容我们可以知道进程在自己私有的虚拟地址空间中执行。按照传统的方式，APP 在某个架构上进程初始虚拟内存镜像都是基本一致的，使得内存中地址分布具有非常强烈的可预测性，给黑客提供了很大的施展空间，是很不安全的。</p><p>大部分操作系统，包括 iOS，都采用了 <code>ASLR</code>（address space layout randomization，地址空间布局随机化） 技术有效避免攻击，通过增加攻击者预测目的地址难度，防止攻击者直接定位攻击代码位置，达到阻止攻击的目的的一种技术。<code>ASLR</code> 使进程每一次启动时，地址空间都会被简单地随机化——只是偏移，而不是搅乱，内存整体布局保持不变。实现方法在通过 mmap 将 Mach-O 文件映射到 APP 进程的虚拟内存时，通过内核将 Mach-O 的 Segment “平移”某个随机系数。所以在使用了 <code>ASLR</code> 之后：<br><code>实际地址（偏移后地址）= 偏移前地址 + ASLR</code></p><h2 id="三、加载-dyld-加载动态库"><a href="#三、加载-dyld-加载动态库" class="headerlink" title="三、加载 dyld &amp; 加载动态库"></a>三、加载 dyld &amp; 加载动态库</h2><h3 id="1、动态库与静态库"><a href="#1、动态库与静态库" class="headerlink" title="1、动态库与静态库"></a>1、动态库与静态库</h3><p>在了解 dyld 之前，先来看下动态库和静态库：</p><ul><li>静态库在程序编译时会被链接到目标代码中一起打包生成可执行文件，以 .a 和 .framework 为文件后缀名。</li><li>而动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入，以 .dylib 和 .framework 为文件后缀名（系统直接提供给我们的 framework 都是动态库！）。</li></ul><p>我们在 MyApp.app 内通过 otool 命令查看主二进制文件依赖的动态链接库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L MyApp</span><br><span class="line">MyApp:</span><br><span class="line">    /System/Library/Frameworks/CoreGraphics.framework/CoreGraphics</span><br><span class="line">    /System/Library/Frameworks/UIKit.framework/UIKit</span><br><span class="line">    /System/Library/Frameworks/Foundation.framework/Foundation</span><br><span class="line">    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation</span><br><span class="line">    /usr/lib/libobjc.A.dylib</span><br><span class="line">    /usr/lib/libSystem.dylib</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>静态库优缺点</p><ul><li>优点<ul><li>静态库被打包到可执行文件中，编译成功后可执行文件可以独立运行，不需要依赖外部环境。</li></ul></li><li>缺点<ul><li>编译生成的可执行文件会变大，如果静态库更新必须重新编译。</li><li>多个 APP 使用同一个静态库，每个 APP 都会拷贝一份，浪费内存。</li></ul></li></ul><p>动态库优缺点</p><ul><li>优点<ul><li>减小编译生成的可执行文件(也可简单理解为 APP)的体积。</li><li>共享内容，节省资源。</li><li>通过更新动态库，达到更新程序的目的。</li></ul></li><li>缺点<ul><li>可执行文件不可以单独运行，必须依赖外部环境。</li></ul></li></ul><p>其中动态库分动态链接库和动态加载库两种：</p><ul><li>动态链接库(Dynamic Link Library，简写 dylib)：在编译阶段需要指定 app 需要依赖哪些动态库。当运行可执行文件时，如果系统还没有加载过这些库时，就会随着运行可执行文件的加载一起加载这些动态库。如果有多个可执行文件依赖同一个动态库，不会重复加载。iOS 中用到的所有系统 .framework 都是动态链接库。</li><li>动态加载库：编译阶段不需要指定 app 需要依赖哪些动态库。当运行过程中需要加载某个动态库时，就会用 <code>dlopen</code> 函数动态的把库加载到内存中使用。</li></ul><p>需要特别注意的是，上面提到的动态库多个 APP 共用，节省内存，这是针对系统动态库而言的。对于我们自己的动态库，会被打包进 IPA 文件中。所以，对于使用非系统的动态库并不能有效减少包体积。</p><p>既然我们自己的动态库无法实现多 APP 共用，不能减少包体积，而且还会影响启动速度，那动态库还有什么用呢？iOS 8 之后，开放了 App Extension 功能，可以为一个应用创建插件，APP Extension 和主 APP 是两个独立的进程，两者之间共享代码逻辑就必须使用动态库了。</p><p>上面提到，动态链接库在程序运行时才被载入，那么这些动链接态库是如何被载入的呢？这就是 dyld 的工作了。</p><p>把主二进制 mmap 进来后，读取 <code>load command</code> 中的 <code>LC_LOAD_DYLINKER</code> 命令，找到 <code>dyld</code> 的的路径。然后 mmap <code>dyld</code> 到虚拟内存，找到<code> dyld</code> 的入口函数 <code>_dyld_start</code>，把 PC 寄存器设置成 <code>_dyld_start</code>，接下来启动流程交给了 <code>dyld</code>。</p><p>注意这个过程都是在内核态完成的，这些流程完成后，将会进入用户态由 <code>dyld</code> 完成后续的工作，这里提到了 PC 寄存器，PC 寄存器存储了下一条指令的地址，程序的执行就是不断修改和读取 PC 寄存器来完成的。</p><h3 id="2、dyld-2-和-dyld-3"><a href="#2、dyld-2-和-dyld-3" class="headerlink" title="2、dyld 2 和 dyld 3"></a>2、dyld 2 和 dyld 3</h3><p><code>dyld</code> 全名 The dynamic link editor，即动态链接器，是 iOS &amp; Mac OS 系统的重要组成部分。在内核将 APP 的主 Mach-O 文件和 <code>dyld</code> 加载完成后，后续的流程将交由 <code>dyld</code> 来完成。<code>dyld</code> 是 in-process 的，也就是在我们 APP 的进程里工作的。<code>dyld</code> 负责解析 Mach-O 的 Header, 得到所依赖的 <code>dylib</code>（动态链接库），通过递归的方式把全部需要的 <code>dylib</code> 都加载进来。</p><p>不过，需要注意的是，<code>dyld</code> 工作不仅仅如此，APP 启动流程中的 <code>Rebase</code>、<code>Bind</code> 等一直到执行 <code>main</code> 函数，都是由 <code>dyld</code> 来完成的。<code>dyld</code> 主要有两个版本：<code>dyld 2</code> 和 <code>dyld 3</code>，iOS 3.1～iOS 12 系统使用 <code>dyld 2</code>，iOS 13 开始采用 <code>dyld 3</code>。</p><p><code>dyld 2</code> 主要工作过程如下：</p><ol><li>解析 Mach-O 的 <code>Header</code></li><li>查找依赖库</li><li>映射 Mach-O 文件到进程内存地址空间中</li><li>执行符号查找</li><li>进行 <code>rebase</code> 和 <code>bind</code></li><li>运行所有初始化器</li><li>执行 <code>main</code> 函数<img src="/images/lix_blog_119.png" style="width:50%;"></li></ol><p>iOS 13 开始 Apple 对三方 App 启用了 <code>dyld 3</code>，<code>dyld 3</code> 将上面 <code>dyld 2</code> 工作过程的第 （1）、（2）、（3） 这三步在另外一个进程上提前（APP 安装或升级时）处理好了，并且将处理结果保存到启动闭包中，并将闭包存储到磁盘（存储在沙盒的 tmp&#x2F;com.apple.dyld 目录）中。<br><img src="/images/lix_blog_120.png" style="width:70%;"></p><p><code>dyld 3</code> 被分为了三个组件：</p><ul><li><p>进程外的 MachO 解析器</p><ul><li><p>预先处理了所有可能影响启动速度的 search path、@rpaths 和环境变量</p></li><li><p>然后分析 Mach-O 的 Header 和依赖，并完成了所有符号查找的工作</p></li><li><p>最后将这些结果创建成了一个启动闭包</p></li><li><p>这是一个普通的 daemon 进程（守护进程），可以使用通常的测试架构</p></li></ul></li><li><p>进程内的引擎，用来运行启动闭包</p><ul><li><p>这部分在进程中处理</p></li><li><p>验证启动闭包的安全性，然后映射到 dylib 之中，再跳转到 main 函数</p></li><li><p>不需要解析 Mach-O 的 Header 和依赖，也不需要符号查找。</p></li></ul></li><li><p>启动闭包缓存服务</p><ul><li><p>系统 App 的启动闭包被构建在一个 Shared Cache 中， 我们甚至不需要打开一个单独的文件</p></li><li><p>对于第三方的 App，闭包创建时机如下：</p><ul><li>App 安装&#x2F;升级后首次启动时</li><li>重启手机后首次启动 App 时<ul><li>因为闭包存储在沙盒 temp 目录中，重启 App 会被清除。</li></ul></li></ul></li></ul></li></ul><p>最终闭包中内容如下：</p><ul><li><code>dependends</code>：依赖动态库列表</li><li><code>fixup</code>：<code>rebase</code> &amp; <code>bind</code> 的地址</li><li><code>initializer-order</code>：初始化器调用顺序</li><li><code>optimizeObjc</code>：Objective C 的元数据</li><li>其他：main entry, uuid…</li></ul><p>相较于 <code>dyld 2</code>，<code>dyld 3</code> 把很多耗时的查找、计算和 I&#x2F;O 的事前都预先处理好了，这使得启动速度有了很大的提升。因为这些信息是每次启动都需要的，把信息存储到一个缓存文件就能避免每次都解析，尤其是 Objective C 的运行时数据（Class&#x2F;Method…）解析非常慢。</p><h2 id="四、Rebase-Bind"><a href="#四、Rebase-Bind" class="headerlink" title="四、Rebase &amp; Bind"></a>四、Rebase &amp; Bind</h2><p>这里需要先了解下什么是 <code>PIC</code>。</p><p><code>PIC</code>，全拼 Position Independ Code，中文名称：位置独立代码、地址无关代码，又称地址无关可执行文件（英文: position-independent executable，缩写为 <code>PIE</code>）。是指可在主存储器中任意位置正确地运行，而不受其绝对地址影响的一种机器码。<code>PIC</code> 广泛使用于共享库，使得同一个库中的代码能够被加载到不同进程的地址空间中。</p><p>iOS 系统有许多动态链接库（<code>dylib</code>），只有在使用的时候，这些动态链接库才会被系统加载到内存中。这些系统的动态链接库有一个公用的共享缓存区（也叫共享缓存库），由于动态链接库在系统中只保留一份内存，所以当某个 APP 使用到这个动态链接库的时候，就会去访问这个共享缓存区。</p><p>因为动态链接库可以被多个进程共享，所以在编译的时候，是不知道动态链接库中的对象或方法在一个进程中的虚拟内存地址的，只有在 APP 运行时才知道对应虚拟内存地址。当 APP 要访问一个 Mach-O 外部（例如动态链接库中的）的对象或方法时，<code>PIC</code> 会在 Mach-O 文件的 <code>__DATA</code> 段中创建一个指针，指向动态链接库中的对应的方法，在调用方法时，实际上是通过这个指针进行间接调用的。将这个指针指向动态链接库中对象或方法的过程就叫做 <code>Bind</code>（绑定）。FishHook 也正是利用修改这个指针的指向实现的 Hook 目的。</p><p>由于 <code>ASLR</code> 的存在，Mach-O 文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，发生偏移。所以就需要进行 <code>Rebase</code> 操作修正 <code>__DATA</code> 段中这个指针的指向，即将地址加上内存偏移量得到真实地址。</p><ul><li><p>Rebase</p><ul><li>修复指针偏移。这是因为 Mach-O 在 mmap 到虚拟内存的时候，起始地址会有一个 ASLR 的随机的偏移量 slide，需要把内部的指针指向加上这个 slide。</li></ul></li><li><p>Bind</p><ul><li>绑定指针与动态链接库中的函数的地址。因为对于动态链接库中的函数，只有运行时才知道它的地址是什么，Bind 就是把指针指向这个地址。</li></ul></li></ul><p><strong>这里为什么一定要通过 <code>Rebase</code> 修复内部指针而不是在 mmap 时直接修改 Mach-O 中对应内存地址呢？</strong></p><p>这是因为在 Mach-O 编译时 Xcode 会进行代码签名（Code Sign），Code Sign 签名时，会对每个 page（这里是指 Segment Data）进行签名生成一个单独的加密散列值，并存储到 <code>__LINKEDIT</code> 中去，系统在加载时会校验每页内容确保没有被篡改，所以如果直接修改对应内存地址会导致签名验证不通过，所以不能直接修改 Image。<code>Rebase</code> 的时候只需要增加对应的偏移量即可，待 <code>Rebase</code> 的数据都存放在 <code>__LINKEDIT</code> 中。</p><h2 id="五、Objc-setup-Initializers"><a href="#五、Objc-setup-Initializers" class="headerlink" title="五、Objc setup &amp; Initializers"></a>五、Objc setup &amp; Initializers</h2><p><code>dyld</code> 在 <code>Bind</code> &amp; <code>Rebase</code> 流程结束之后，首先会执行 libSystem 的 Initializer，做一些最基本的初始化：</p><ul><li>初始化 libdispatch（libdispatch 的别称是 GCD）</li><li>初始化 objc runtime、注册 sel、加载 category</li></ul><p>接下来会进行 main 函数之前的一些初始化，主要包括 +load 和 static initializer，两者调用顺序根据 Apple 官方文档对 +load 方法的描述可以知道：</p><blockquote><p>he order of initialization is as follows:<br>All initializers in any framework you link to.<br>All +load methods in your image.<br>All C++ static initializers and C&#x2F;C++ <strong>attribute</strong>(constructor) functions in your image.<br>All initializers in frameworks that link to you.<br>In addition:<br>A class’s +load method is called after all of its superclasses’ +load methods.<br>A category +load method is called after the class’s own +load method.</p></blockquote><p>即：<strong>先调用 <code>+load</code> 方法，再调用 static initializer 相关方法。父类 <code>+load</code> 方法先于子类被调用，类的 <code>+load</code> 方法先于分类被调用。</strong></p><p><strong>static initializer 静态初始化产生的条件</strong><br>包括但不限于以下几种逻辑会导致静态初始化：</p><h4 id="1-attribute-constructor-修饰的函数"><a href="#1-attribute-constructor-修饰的函数" class="headerlink" title="(1) attribute((constructor)) 修饰的函数"></a>(1) <strong>attribute</strong>((constructor)) 修饰的函数</h4><p>例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor)) <span class="type">void</span> myentry()&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;constructor&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-通过执行代码初始化全局变量"><a href="#2-通过执行代码初始化全局变量" class="headerlink" title="(2) 通过执行代码初始化全局变量"></a>(2) 通过执行代码初始化全局变量</h4><p>例如需要执行 C&#x2F;C++ 函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> initBar()&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    ++i;</span><br><span class="line">    <span class="keyword">return</span> i == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">bool</span> globalBar = initBar();</span><br><span class="line"><span class="type">bool</span> globalBar2 = initBar();</span><br></pre></td></tr></table></figure><h2 id="六、main"><a href="#六、main" class="headerlink" title="六、main"></a>六、main</h2><p><code>+load</code> 和 static initializer 执行完毕之后，<code>dyld</code> 会把启动流程交给 App，开始执行 main 函数。main 函数里要做的最重要的事情就是初始化 UIKit。UIKit 主要会做两个大的初始化：</p><ul><li>初始化 UIApplication</li><li>启动主线程的 Runloop</li></ul><p>由于主线程的 <code>dispatch_async</code> 是基于 runloop 的，所以在 +load 里如果调用了 <code>dispatch_async</code>，<code>dispatch_async</code> 相关任务会在这个阶段执行。</p><p>之后，就进入到我们熟悉的 UIApplicationDelegate 流程了。</p><p><strong>参考：</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485101&idx=1&sn=abbbb6da1aba37a04047fc210363bcc9&scene=21&token=2051547505&lang=zh_CN#wechat_redirect">抖音APP启动速度提升实践</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片加载原理及优化</title>
      <link href="/posts/16217/"/>
      <url>/posts/16217/</url>
      
        <content type="html"><![CDATA[<h2 id="一、图片加载（解压缩）原理"><a href="#一、图片加载（解压缩）原理" class="headerlink" title="一、图片加载（解压缩）原理"></a>一、图片加载（解压缩）原理</h2><h3 id="1、图片加载的工作流"><a href="#1、图片加载的工作流" class="headerlink" title="1、图片加载的工作流"></a>1、图片加载的工作流</h3><p>概括来说，从磁盘中加载一张图片，并将它显示到屏幕上，中间的主要工作流如下：</p><ul><li>(1) 将 UIImage 赋值给屏幕上 UIImageView；</li><li>(2) Core Animation 渲染流水线被触发；</li><li>(3) Core Animation 渲染流水线第一阶段的 Commit Transaction 部分有四个小阶段：布局、显示、准备、提交，在其中的“准备”阶段，会对图片进行解码，这里可能还会涉及到图片文件 I&#x2F;O 操作。<ul><li>解码即：将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作；</li></ul></li><li>(4) 在图片解码完成后，后续被提交到 Render Server 进程，Render Server 处理完成后提交给 GPU 渲染。</li><li>(5) GPU 渲染完成后，将渲染后的位图放到帧缓冲区，后续将被视频控制器读取显示到屏幕上。</li></ul><p>在上面的步骤中，图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。</p><h3 id="2、图片解压缩原理"><a href="#2、图片解压缩原理" class="headerlink" title="2、图片解压缩原理"></a>2、图片解压缩原理</h3><p>图片显示到屏幕上，必须要经过图片的解压缩这一步。不管是 JPEG 还是 PNG 图片，都是一种压缩的位图图形格式，位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。只不过 PNG 图片是无损压缩，并且支持 alpha 通道，而 JPEG 图片则是有损压缩，可以指定 0-100% 的压缩比。值得一提的是，在苹果的 SDK 中专门提供了两个函数用来生成 PNG 和 JPEG 图片：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSData</span> * __<span class="keyword">nullable</span> <span class="built_in">UIImagePNGRepresentation</span>(<span class="built_in">UIImage</span> * __<span class="keyword">nonnull</span> image);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)                           </span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSData</span> * __<span class="keyword">nullable</span> <span class="built_in">UIImageJPEGRepresentation</span>(<span class="built_in">UIImage</span> * __<span class="keyword">nonnull</span> image, <span class="built_in">CGFloat</span> compressionQuality);</span><br></pre></td></tr></table></figure><p>解压缩后的图片大小与原始文件大小之间没有任何关系，而只与图片的像素有关，每个像素由 RGBA 四个字节表示颜色。例如，对于一个大小为 600 B， 像素 30 x 30 的图片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解压缩后的图片大小 = 图片的像素宽 30 * 图片的像素高 30 * 每个像素所占的字节数 4</span><br></pre></td></tr></table></figure><p>所以其解压缩后的图片大小，即图片原始像素数据，大小为 3600 B。</p><p>当未解压缩的图片将要渲染到屏幕时，系统会在主线程对图片进行解压缩，而如果图片已经解压缩了，系统就不会再对图片进行解压缩。因此，对于主线程解压缩影响性能的问题，也就有了业内的解决方案，在子线程提前对图片进行强制解压缩。</p><p>而强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是 <code>CGBitmapContextCreate</code> ：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a bitmap context. The context draws into a bitmap which is `width&#x27;</span></span><br><span class="line"><span class="comment">   pixels wide and `height&#x27; pixels high. The number of components for each</span></span><br><span class="line"><span class="comment">   pixel is specified by `space&#x27;, which may also specify a destination color</span></span><br><span class="line"><span class="comment">   profile. The number of bits for each component of a pixel is specified by</span></span><br><span class="line"><span class="comment">   `bitsPerComponent&#x27;. The number of bytes per pixel is equal to</span></span><br><span class="line"><span class="comment">   `(bitsPerComponent * number of components + 7)/8&#x27;. Each row of the bitmap</span></span><br><span class="line"><span class="comment">   consists of `bytesPerRow&#x27; bytes, which must be at least `width * bytes</span></span><br><span class="line"><span class="comment">   per pixel&#x27; bytes; in addition, `bytesPerRow&#x27; must be an integer multiple</span></span><br><span class="line"><span class="comment">   of the number of bytes per pixel. `data&#x27;, if non-NULL, points to a block</span></span><br><span class="line"><span class="comment">   of memory at least `bytesPerRow * height&#x27; bytes. If `data&#x27; is NULL, the</span></span><br><span class="line"><span class="comment">   data for context is allocated automatically and freed when the context is</span></span><br><span class="line"><span class="comment">   deallocated. `bitmapInfo&#x27; specifies whether the bitmap should contain an</span></span><br><span class="line"><span class="comment">   alpha channel and how it&#x27;s to be generated, along with whether the</span></span><br><span class="line"><span class="comment">   components are floating-point or integer. */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CG_EXTERN</span> <span class="built_in">CGContextRef</span> __<span class="keyword">nullable</span> <span class="built_in">CGBitmapContextCreate</span>(<span class="type">void</span> * __<span class="keyword">nullable</span> data,</span><br><span class="line">    size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> cg_nullable space, uint32_t bitmapInfo)</span><br><span class="line">    <span class="built_in">CG_AVAILABLE_STARTING</span>(__MAC_10_0, __IPHONE_2_0);</span><br></pre></td></tr></table></figure><p>这个函数用于创建一个位图上下文，用来绘制一张宽 <code>width</code> 像素，高 <code>height</code> 像素的位图。</p><p><code>CGBitmapContextCreate</code> 函数中每个参数所代表的具体含义：</p><ul><li><code>data</code> ：如果不为 NULL，那么它应该指向一块大小至少为 <code>bytesPerRow</code> * <code>height</code> 字节的内存；如果 为 NULL，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 NULL 即可；</li><li><code>width</code> 和 <code>height</code> ：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；</li><li><code>bitsPerComponent</code> ：表示每一个颜色分量由多少位组成，<code>Component</code> 就是指颜色分量，例如 RGB 中，指定 R&#x2F;G&#x2F;B 这些颜色分量由多少位来表示，在 RGB 颜色空间下指定 8 即可；</li><li><code>bytesPerRow</code> ：位图的每一行使用的字节数，大小至少为 <code>width</code> * bytes per pixel 字节。有意思的是，当我们指定 0 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化。</li><li><code>space</code> ：颜色空间，一般使用 RGB 即可；</li><li><code>bitmapInfo</code> ：位图的布局信息。</li></ul><p>注释中提到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个像素占用的字节数 = (bitsPerComponent * number of components + 7)/8</span><br></pre></td></tr></table></figure><p>对于 RGBA（R、G、B、A 共 4 个分量） 图片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个像素占用的字节数 = (8* 4 + 7)/8 = 4B</span><br></pre></td></tr></table></figure><p><code>CGBitmapInfo</code> 由两部分取或运算组成：<code>CGImageAlphaInfo</code>、<code>CGImageByteOrderInfo</code>，例如：<code>kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host</code></p><h4 id="1-CGImageAlphaInfo-是-Alpha-的信息由枚举值"><a href="#1-CGImageAlphaInfo-是-Alpha-的信息由枚举值" class="headerlink" title="(1) CGImageAlphaInfo 是 Alpha 的信息由枚举值"></a>(1) CGImageAlphaInfo 是 Alpha 的信息由枚举值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_ENUM</span>(uint32_t, <span class="built_in">CGImageAlphaInfo</span>) &#123;</span><br><span class="line">    kCGImageAlphaNone,               <span class="comment">/* For example, RGB. */</span></span><br><span class="line">    kCGImageAlphaPremultipliedLast,  <span class="comment">/* For example, premultiplied RGBA */</span></span><br><span class="line">    kCGImageAlphaPremultipliedFirst, <span class="comment">/* For example, premultiplied ARGB */</span></span><br><span class="line">    kCGImageAlphaLast,               <span class="comment">/* For example, non-premultiplied RGBA */</span></span><br><span class="line">    kCGImageAlphaFirst,              <span class="comment">/* For example, non-premultiplied ARGB */</span></span><br><span class="line">    kCGImageAlphaNoneSkipLast,       <span class="comment">/* For example, RBGX. */</span></span><br><span class="line">    kCGImageAlphaNoneSkipFirst,      <span class="comment">/* For example, XRGB. */</span></span><br><span class="line">    kCGImageAlphaOnly                <span class="comment">/* No color data, alpha data only */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它提供了三个方面的 <code>alpha</code> 信息：</p><ul><li>是否包含 <code>alpha</code>；</li><li>如果包含 <code>alpha</code>，那么 <code>alpha</code> 信息所处的位置，在像素的最低有效位，比如 RGBA ，还是最高有效位，比如 ARGB；</li><li>如果包含 <code>alpha</code>，那么每个颜色分量是否已经乘以 <code>alpha</code> 的值，这种做法可以加速图片的渲染时间，因为它避免了渲染时的额外乘法运算。比如，对于 RGB 颜色空间，用已经乘以 <code>alpha</code> 的数据来渲染图片，每个像素都可以避免 3 次乘法运算，红色乘以 <code>alpha</code>，绿色乘以 <code>alpha</code> 和蓝色乘以 <code>alpha</code> 。</li></ul><p>那么我们在解压缩图片的时候应该使用哪个值呢？根据 Which CGImageAlphaInfo should we use 和官方文档中对 <code>UIGraphicsBeginImageContextWithOptions</code> 函数的讨论：</p><blockquote><p>You use this function to configure the drawing environment for rendering into a bitmap. The format for the bitmap is a ARGB 32-bit integer pixel format using host-byte order. If the opaque parameter is YES, the alpha channel is ignored and the bitmap is treated as fully opaque (kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host). Otherwise, each pixel uses a premultipled ARGB format (kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host).</p></blockquote><p>我们可以知道，当图片不包含 <code>alpha</code> 的时候使用 <code>kCGImageAlphaNoneSkipFirst</code> ，否则使用 <code>kCGImageAlphaPremultipliedFirst</code> 。此外，上面提到了字节顺序应该使用 32 位的主机字节顺序 <code>kCGBitmapByteOrder32Host</code>。</p><h4 id="2-CGImageByteOrderInfo-是像素格式的字节顺序"><a href="#2-CGImageByteOrderInfo-是像素格式的字节顺序" class="headerlink" title="(2) CGImageByteOrderInfo 是像素格式的字节顺序"></a>(2) CGImageByteOrderInfo 是像素格式的字节顺序</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_ENUM</span>(uint32_t, <span class="built_in">CGImageByteOrderInfo</span>) &#123;</span><br><span class="line">    kCGImageByteOrderMask     = <span class="number">0x7000</span>,</span><br><span class="line">    kCGImageByteOrder16Little = (<span class="number">1</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    kCGImageByteOrder32Little = (<span class="number">2</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    kCGImageByteOrder16Big    = (<span class="number">3</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    kCGImageByteOrder32Big    = (<span class="number">4</span> &lt;&lt; <span class="number">12</span>)</span><br><span class="line">&#125; <span class="built_in">CG_AVAILABLE_STARTING</span>(__MAC_10_12, __IPHONE_10_0);</span><br></pre></td></tr></table></figure><p>它主要提供了两个方面的字节顺序信息：</p><ul><li>小端模式还是大端模式；</li><li>数据以 16 位还是 32 位为单位。</li></ul><p>iOS 设备的处理器是基于 ARM 架构的，默认是采用小端模式读取数据的，而网络和蓝牙传输数据通常是用的大端模式。例如：想传输 ABCD，按大端模式给到 iOS 客户端是 DCBA，那么 iOS 默认读取出来的也是 DCBA，而非 ABCD。所以就需要进行大小端的转换，要不然没办法得到想要的数据。苹果为我们提供了丰富的 API，而不需要让我们对逐个字节进行转换，详见<a href="https://developer.apple.com/documentation/corefoundation/byte-order_utilities?preferredLanguage=occ">官方文档</a>。</p><p>通常 iOS 比较常用的就是 <code>CFSwapInt16BigToHost</code>、<code>CFSwapInt32BigToHost</code>，把大端转换为本机支持的模式，如果本机是大端了则不做任何改变。</p><p>由于 iPhone 采用的是小端模式，但是为了保证应用的向后兼容性，我们可以使用系统提供的宏来做大小端转换，来避免 Hardcoding ：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __BIG_ENDIAN__</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> kCGBitmapByteOrder16Host kCGBitmapByteOrder16Big</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> kCGBitmapByteOrder32Host kCGBitmapByteOrder32Big</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* Little endian. */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> kCGBitmapByteOrder16Host kCGBitmapByteOrder16Little</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> kCGBitmapByteOrder32Host kCGBitmapByteOrder32Little</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>根据前面的讨论，我们知道字节顺序的值应该使用的是 32 位的主机字节顺序 <code>kCGBitmapByteOrder32Host</code>，这样的话不管当前设备采用的是小端模式还是大端模式，字节顺序始终与其保持一致。</p><p>下面，我们来看一张图，它非常形象地展示了在使用 16 或 32 位像素格式的 CMYK 和 RGB 颜色空间下，一个像素是如何被表示的：<br><img src="/images/lix_blog_106.png"><br>我们从图中可以看出，在 32 位像素格式下，每个颜色分量使用 8 位；而在 16 位像素格式下，每个颜色分量则使用 5 位。</p><p>图片解压缩的实现逻辑：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 CGBitmapContextCreate() 方法，生成图片绘制上下文</span></span><br><span class="line"><span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(.....);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 调用 CGContextDrawImage() 方法，将未解码的 imageRef 指针内容，写入到我们创建的上下文中，这个步骤，完成了隐式的解码工作</span></span><br><span class="line"><span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 context 上下文中创建一个新的 imageRef，这是解码后的图片了</span></span><br><span class="line"><span class="built_in">CGImageRef</span> newImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 imageRef 生成供 UI 层使用的 UIImage 对象，同时指定图片的 scale 和 orientation 两个参数。</span></span><br><span class="line"><span class="built_in">UIImage</span> *newImage = [<span class="built_in">UIImage</span> imageWithCGImage:newImageRef</span><br><span class="line">                                        scale:image.scale</span><br><span class="line">                                  orientation:image.imageOrientation];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGContextRelease</span>(context);</span><br><span class="line"><span class="built_in">CGImageRelease</span>(newImageRef);</span><br></pre></td></tr></table></figure><p>它接受一个原始的位图参数 <code>imageRef</code>，最终返回一个新的解压缩后的位图 <code>newImage</code> ，中间主要经过了以下三个步骤：</p><ul><li>使用 <code>CGBitmapContextCreate</code> 函数创建一个位图上下文；</li><li>使用 <code>CGContextDrawImage</code> 函数将原始位图绘制到上下文中；</li><li>使用 <code>CGBitmapContextCreateImage</code> 函数创建一张新的解压缩后的位图。</li></ul><p>上面是图片强制解压缩的简单实现逻辑，提前在子线程对图片进行解压缩，后续在 Core Animation 渲染流水线的流程中就不会再次解压缩了，可以避免因为图片解压缩耗时过长引起的卡顿问题，目前 SDWebImage、YYImage 都是这样的实现逻辑。</p><h3 id="3、第三方开源库解压缩图片的实现"><a href="#3、第三方开源库解压缩图片的实现" class="headerlink" title="3、第三方开源库解压缩图片的实现"></a>3、第三方开源库解压缩图片的实现</h3><p>我们来看看 YYKit 中的相关代码，用于解压缩图片的函数 <code>YYCGImageCreateDecodedCopy</code> 存在于 <code>YYImageCoder</code> 类中，核心代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGImageRef</span> YYCGImageCreateDecodedCopy(<span class="built_in">CGImageRef</span> imageRef, <span class="type">BOOL</span> decodeForDisplay) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decodeForDisplay) &#123; <span class="comment">// decode with redraw (may lose some precision)</span></span><br><span class="line">        <span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef) &amp; kCGBitmapAlphaInfoMask;</span><br><span class="line"></span><br><span class="line">        <span class="type">BOOL</span> hasAlpha = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">if</span> (alphaInfo == kCGImageAlphaPremultipliedLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">            alphaInfo == kCGImageAlphaLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaFirst) &#123;</span><br><span class="line">            hasAlpha = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BGRA8888 (premultiplied) or BGRX8888</span></span><br><span class="line">        <span class="comment">// same as UIGraphicsBeginImageContext() and -[UIView drawRect:]</span></span><br><span class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);</span><br><span class="line">        <span class="keyword">if</span> (!context) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef); <span class="comment">// decode</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> newImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">CFRelease</span>(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newImage;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，SDWebImage 和 FLAnimatedImage 中对图片的解压缩过程与上述完全一致，只是传递给 <code>CGBitmapContextCreate</code> 函数的部分参数存在细微的差别：<br><img src="/images/lix_blog_107.png"></p><p>在上表中，用浅绿色背景标记的参数即为我们在前面的分析中所推荐的参数，用这些参数解压缩后的图片渲染的速度会更快。因此，从理论上说 YYKit 中的解压缩算法是三者之中最优的。</p><h2 id="二、存在问题"><a href="#二、存在问题" class="headerlink" title="二、存在问题"></a>二、存在问题</h2><p>我们调用 <code>UIImage的-imageNamed:</code> 方法或者<code> -imageWithContentsOfFile:</code> 方法显示一张图片时，显示在屏幕上的图片最终都会被转化为 OpenGL 纹理，同时 OpenGL 有一个最大的纹理尺寸（通常是 20482048，或 40964096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为 Core Animation 强制用 CPU 处理图片而不是更快的 GPU。</p><p>在一个简单的图片加载 demo 中测试，使用 <code>[UIImage imageNamed:@&quot;xxx&quot;]</code> 和 第三方开源库加载一个原图约 8 MB 大小、7000 × 10000 像素的图片时，表现如下：</p><ul><li><code>[UIImage imageNamed:@&quot;xxx&quot;]</code> 方式加载该图片时，内存变化约为：42 MB —&gt; 298.5MB。</li><li>SDWebImage 或者 YYWebImage 方式载该图片时，两者差别不是非常大，有几 MB 的差别，内存变化约为 42 MB -&gt; 235 MB -&gt; 44 Mb。</li></ul><p>由此可见，对于大图加载，以上方式都存在卡顿问题，甚至有因内存爆增而导致的 Crash 的风险！</p><h2 id="三、图片加载优化"><a href="#三、图片加载优化" class="headerlink" title="三、图片加载优化"></a>三、图片加载优化</h2><p><strong>1、对不常用的大图片，使用 <code>imageWithContentsOfFile:</code> 代替 <code>imageNamed:</code> 方法</strong><br>两个方法区别如下：</p><ul><li><p>imgeNamed:<br>用这个方法加载图片分为两种情况：</p><ul><li>系统缓存有这个图片，直接从缓存中取得</li><li>系统缓存没有这个图片，则会加载图片并缓存到内存</li></ul></li><li><p>imageWithContentsOfFile:<br>用这个方法只有一种情况，那就是仅仅加载图片， 图像数据不会被缓存。因此在加载较大图片的时候，以及图片使用情况很少的时候可以使用这个方法，降低内存消耗。</p></li></ul><p><strong>2、降低采样</strong><br>在视图比较小，图片比较大的场景下，直接展示原图片会造成不必要的内存和 CPU 消耗，这里就可以使用 ImageIO 的接口，DownSampling，也就是生成缩略图。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DownSampling（降低采样）</span></span><br><span class="line">func downsample(imageAt imageURL: URL, to pointSize: <span class="built_in">CGSize</span>, scale: <span class="built_in">CGFloat</span>) -&gt; <span class="built_in">UIImage</span></span><br><span class="line">&#123;</span><br><span class="line">    let sourceOpt = [kCGImageSourceShouldCache : <span class="literal">false</span>] as <span class="built_in">CFDictionary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他场景可以用 createwithdata (data并未decode,所占内存没那么大),</span></span><br><span class="line">    let source = <span class="built_in">CGImageSourceCreateWithURL</span>(imageURL as <span class="built_in">CFURL</span>, sourceOpt)!</span><br><span class="line">    </span><br><span class="line">    let maxDimension = max(pointSize.width, pointSize.height) * scale</span><br><span class="line">    let downsampleOpt = [kCGImageSourceCreateThumbnailFromImageAlways : <span class="literal">true</span>,</span><br><span class="line">                         kCGImageSourceShouldCacheImmediately : <span class="literal">true</span> ,</span><br><span class="line">                         kCGImageSourceCreateThumbnailWithTransform : <span class="literal">true</span>,</span><br><span class="line">                         kCGImageSourceThumbnailMaxPixelSize : maxDimension] as <span class="built_in">CFDictionary</span></span><br><span class="line">    let downsampleImage = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(source, <span class="number">0</span>, downsampleOpt)!</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: downsampleImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li><p>设置 <code>kCGImageSourceShouldCache</code> 为 <code>false</code>，避免缓存解码后的数据，64 位设置上默认是开启缓存的（很好理解，因为下次使用该图片的时候，可能场景不同，需要生成的缩略图大小是不同的，显然不能做缓存处理）</p></li><li><p>设置 <code>kCGImageSourceShouldCacheImmediately</code> 为 <code>true</code>，避免在需要渲染的时候才做解码，默认选项是 <code>false</code></p></li><li><p>上面 <code>CGImageSourceCreateWithURL</code> 入参数是 URL，也可以传本地图片 URL</p><ul><li>例如：<code>let url = Bundle.main.url(forResource:&quot;test&quot;, withExtension: &quot;jpg&quot;)</code></li></ul></li></ul><p>对于确实需要加载高分辨率图片的场景，也可以图片加载前获取图片的尺寸，如果尺寸达到预设的阀值（例如设置最大尺寸 2000 x 2000），则根据阀值按比例降低采样（生成缩略图）。</p><p><strong>如何获取图片的尺寸呢？</strong>下面这种方式是有问题的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithContentsOfFile:...];</span><br><span class="line"><span class="built_in">CGSize</span> imageSize = image.size;</span><br></pre></td></tr></table></figure><p>这样获取图片尺寸会先把图片加载到内存里，对于超大图，这样已经出现内存爆增的问题了。</p><p>最佳获取图片尺寸的方式仍然是使用 ImageIO：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *imageFileURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;xxxxxxxxxxxxxxx&quot;</span>];</span><br><span class="line"><span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithURL</span>((<span class="built_in">CFURLRef</span>)imageFileURL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *options = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">                         [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">NO</span>], (<span class="built_in">NSString</span> *)kCGImageSourceShouldCache,</span><br><span class="line">                         <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">CFDictionaryRef</span> imageProperties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(imageSource, <span class="number">0</span>, (<span class="built_in">CFDictionaryRef</span>)options);</span><br><span class="line"><span class="keyword">if</span> (imageProperties) &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *width = (<span class="built_in">NSNumber</span> *)<span class="built_in">CFDictionaryGetValue</span>(imageProperties, kCGImagePropertyPixelWidth);</span><br><span class="line">    <span class="built_in">NSNumber</span> *height = (<span class="built_in">NSNumber</span> *)<span class="built_in">CFDictionaryGetValue</span>(imageProperties, kCGImagePropertyPixelHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取图片的 size</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Image dimensions: %@ x %@ px&quot;</span>, width, height);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFRelease</span>(imageProperties);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CFRelease</span>(imageSource);</span><br></pre></td></tr></table></figure><p>这种方式获取 <code>size</code> 不需要提前将图片加载进内存，避免了内存爆增的情况。<code>CGImageSourceCopyPropertiesAtIndex()</code> 返回的字典包含许多信息，除了图片的 size 还包含拍摄的日期、相机的模式和 GPS 信息等。</p><p><strong>3、分片加载</strong><br>本方案图片显示载体为 <code>CATiledLayer</code>，<code>CATiledLayer</code> 作为 <code>UIScrollView</code> 的子 <code>View</code> 实现图片大小缩放，<code>CATiledLayer</code> 设置一个缩放区域的集合和重绘阈值，让 <code>UIScrollView</code> 在缩放时，绘制层根据这些区域和缩放阈值去重新绘制当前显示的区域。</p><p>Apple 官方大图加载完整 <a href="https://developer.apple.com/library/archive/samplecode/LargeImageDownsizing/Introduction/Intro.html">demo 地址</a></p><p><strong>4、第三方库用参数设置</strong><br>对于 SDWebImage，<code>decodeImageWithImage</code> 这个方法用于对图片进行解压缩并且缓存起来，以保证 <code>tableviews</code>&#x2F;<code>collectionviews</code> 交互更加流畅，但是如果是加载高分辨率图片的话，会适得其反，有可能造成上G的内存消耗。对于高分辨率的图片，应该在图片解压缩后，禁止缓存解压缩后的数据，相关的代码处理为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[SDImageCache sharedImageCache] setShouldDecompressImages:<span class="literal">NO</span>];</span><br><span class="line">[[SDWebImageDownloader sharedDownloader] setShouldDecompressImages:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure><p>除此之外，也可以设置 SDWebImage 的其他参数，比如是否缓存到内存以及内存缓存最高限制等，来保证内存安全：</p><ul><li><code>shouldCacheImagesInMemory</code>：是否缓存到内存</li><li><code>maxMemoryCost</code>：内存缓存最高限制</li></ul><p>但是该方式只能避免加载大量不是特别大的高清图时因缓存图片数量过多导致内存爆增引起的 crash，无法解决单个超大图引起的 crash。由于是全局设置，需要在 <code>dealloc</code> 方法中设置回去。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI 渲染原理与优化</title>
      <link href="/posts/42986/"/>
      <url>/posts/42986/</url>
      
        <content type="html"><![CDATA[<h2 id="一、图像渲染原理"><a href="#一、图像渲染原理" class="headerlink" title="一、图像渲染原理"></a>一、图像渲染原理</h2><h3 id="1、iOS-双缓冲机制"><a href="#1、iOS-双缓冲机制" class="headerlink" title="1、iOS 双缓冲机制"></a>1、iOS 双缓冲机制</h3><p>图像的渲染离不开 CPU 和 GPU 的协作：<br><strong>CPU（Central Processing Unit，中央处理器）</strong></p><ul><li>对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics）</li></ul><p><strong>GPU（Graphics Processing Unit，图形处理器）</strong></p><ul><li>纹理的渲染（CPU 计算好的数据不能直接展示到屏幕，需要经过 GPU 的渲染）</li></ul><p>CPU 计算之后数据不能直接用于显示，CPU 将计算之后的图像信息（即：图元 primitives）传给 GPU ，由 GPU 负责后续的渲染，GPU 会将渲染结束之后像素信息（即：位图 bitmap），存在帧缓冲器（Framebuffer）中，视频控制器（Video Controller）会读取帧缓冲器中的信息，经过数模转换传递给显示器（Monitor），进行显示，流程如下：<br><img src="/images/lix_blog_195.png"><br>显示器的电子束会从屏幕的左上角开始逐行扫描，当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号 <code>HSync</code>，而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号 <code>VSync</code>。扫描时，屏幕上的每个点的图像信息都从帧缓冲器中的位图进行读取，在屏幕上对应地显示。扫描的流程如下图所示：<br><img src="/images/lix_blog_89.png"><br>每次整个屏幕被扫描完一次后，就相当于呈现了一帧完整的图像。屏幕不断地刷新，不停呈现新的帧，就能呈现出连续的影像。</p><p>屏幕刷新的频率，就是帧率（Frame per Second，FPS）。由于人眼的视觉暂留效应，当屏幕刷新频率足够高时（FPS 通常是 50 到 60 左右），就能让画面看起来是连续而流畅的。对于 iOS 而言，APP 应该尽量保证 60 FPS 才是最好的体验。</p><p><strong>单缓冲器与屏幕撕裂</strong><br>在单缓冲器的情况下，很容易产生屏幕撕裂，CPU+GPU 的渲染流程是一个非常耗时的过程。如果在电子束开始扫描新的一帧时，位图还没有渲染好，那么这时候帧缓冲器中还是上一帧的内容，显示器的电子束会再次将上一帧内容扫描到屏幕上。扫描一半时，新一帧才被正常渲染完成并放入帧缓冲器中。 那么已扫描的部分就是上一帧的画面，而未扫描的部分则会显示新的一帧图像，于是造成了屏幕撕裂：<br><img src="/images/lix_blog_90.png"></p><p><strong>垂直同步 Vsync + 双缓冲机制 Double Buffering</strong><br>解决屏幕撕裂、提高显示效率的一个策略就是使用垂直同步信号 Vsync 与双缓冲机制 Double Buffering。根据苹果的官方文档描述，iOS 设备会始终使用 <code>Vsync</code> + Double Buffering 的策略。</p><p>垂直同步信号（vertical synchronisation，Vsync）相当于给帧缓冲器加锁：当电子束完成一帧的扫描，将要从头开始扫描时，就会发出一个垂直同步信号。只有当视频控制器接收到 <code>Vsync</code> 之后，才会将帧缓冲器中的位图更新为下一帧，这样就能保证每次显示的都是同一帧的画面，因而避免了屏幕撕裂。</p><p>但是这种情况下，视频控制器在接受到 <code>Vsync</code> 之后，就要将下一帧的位图传入，这意味着整个 CPU+GPU 的渲染流程都要在一瞬间完成，这是明显不现实的。所以双缓冲机制会增加一个新的备用缓冲器（back buffer）。在电子束在扫描帧缓冲器中的内容时，CPU 和 GPU 同时渲染下一帧的内容，渲染结果会预先保存在 back buffer 中，当一帧扫描结束接收到 <code>Vsync</code> 信号的时候，视频控制器会将 back buffer 中的内容置换到 frame buffer 中，此时就能保证置换操作几乎在一瞬间完成（实际上是交换了内存地址），这样就通过充分利用 CPU 和 GPU 资源解决了屏幕撕裂的问题。<br><img src="/images/lix_blog_91.png"></p><h3 id="2、Core-Animation"><a href="#2、Core-Animation" class="headerlink" title="2、Core Animation"></a>2、Core Animation</h3><p>Core Animation 职责并非像其名字一样只负责动画，而是同时兼顾 UI 渲染、构建和实现动画等重要职责，就像 Apple 文档所说：</p><blockquote><p>If you are writing iOS apps, you are using Core Animation whether you know it or not。</p></blockquote><p>也就是说无论我们开发过程中是否直接使用了 Core Animation，它都在底层深度参与了 APP 的构建。</p><p>Core Animation 是 iOS 和 OSX 上的图形渲染和动画基础结构，用于为应用的视图和其他视觉元素设置动画。它把大量的绘图工作交给 GPU 去加速渲染，所以可以实现高帧率高流畅度的动画效果，而不会增加 CPU 负担和减慢应用程序的速度。</p><p>Core Animation 并不是一个绘图系统，而是使用硬件去合成和处理视图内容的基础框架，而这个基础框架的核心就是 CALayer 对象，Core Animation 的职责就是尽可能快地组合屏幕上不同的 CALayer，并且被存储为树状层级结构。这个树也形成了 UIKit 以及在 iOS 应用程序当中你所能在屏幕上看见的一切的基础。<br><img src="/images/lix_blog_92.png"></p><p>上面是来自 Apple 官方文档的一个架构图，上图还涉及到 Metal 和 Core Graphics：</p><ul><li><p>Metal<br>类似于 OpenGL ES 的图形处理框架，Apple 早在 2014 年就推出了 Metal，从 iOS 12 开始 OpenGL ES 被弃用，正式被 Metal 取代，其绘制工作主要使用 GPU。</p></li><li><p>Core Graphics<br>Core Graphics 是一个强大的二维图像绘制引擎，是 iOS 的核心图形库，常用的比如 CGRect 就定义在这个框架下，其绘制工作主要使用 CPU。</p></li></ul><p><strong>Core Animation 渲染流水线</strong><br><img src="/images/lix_blog_93.png"></p><p>上图即为 Core Animation 的渲染流水线，APP 进程本身是不负责渲染的，CATransaction 把一组 UI 上的修改，合并成一个事务，通过 commit 提交给 <code>RenderServer</code>，<code>RenderServer</code> 在一个单独的进程里进行渲染，调用渲染框架(Metal&#x2F;OpenGL ES)来生成 bitmap，放到帧缓冲区里，硬件根据时钟信号读取帧缓冲区内容，完成屏幕刷新。</p><p>根据上图可以看到，一次完整渲染流程需要跨越 3 帧才能完成，我们 iOS 设备的刷帧率是 60 FPS（Frame per Second 帧&#x2F;秒），也就是 1 秒钟可以刷新 60 帧（次）。完成一帧刷新的用时是 16.67ms。因此垂直同步信号 VSync 就是每 16.67ms 发出一次。Core Animation 渲染流水线不停地进行，使每一帧都能展示对应的画面，我们就看到了流畅的画面。换句话说，这些阶段里任何一阶段因耗时太长无法正常在一帧内完成，都会引起卡顿的产生。</p><p><strong>Core Animation 一次完整的渲染流水线中主要有 4 个阶段：</strong></p><p><strong>第一阶段：准备图层和动画属性</strong><br>此阶段发生在应用内，也是开发者最直接接触的阶段，该阶段工作在 CPU 上，分为 <strong>Handle Events</strong>、<strong>Commit Transaction</strong> 两大部分：</p><ul><li><p>Handle Events<br>APP 先响应和处理点击、手势等用户交互事件，这一阶段如果涉及视图&#x2F;图层的改变，就会触发渲染流水线开始。</p></li><li><p>Commit Transaction<br><img src="/images/lix_blog_94.png"><br>Commit Transaction 包含<strong>布局</strong>、<strong>显示</strong>、<strong>准备</strong>、<strong>提交</strong>四个阶段，发生在应用程序进程内，并且是在 CPU 上工作。</p><ul><li><p><strong>Layout：布局</strong><br>  这个阶段主要处理视图的构建和布局，具体步骤包括：</p><ul><li>调用重载的 <code>layoutSubviews</code> 方法</li><li>创建视图，并通过 <code>addSubview</code> 方法添加子视图</li><li>计算视图布局，即所有的 Layout Constraint</li></ul><p>  由于这个阶段是在 CPU 中进行，通常是 CPU 限制或者 IO 限制，所以我们应该尽量高效轻量地操作，减少这部分的时间，比如减少非必要的视图创建、简化布局计算、减少视图层级等。</p></li><li><p><strong>Display：显示</strong><br>  这个阶段主要是交给 Core Graphics 进行视图的绘制，注意不是真正的显示，而是得到前文所说的图元 primitives 数据：</p><ul><li>根据上一阶段 Layout 的结果创建得到图元信息。</li><li>如果重写了 <code>drawRect:</code> 方法，那么会调用重载的 <code>drawRect:</code> 方法，在 <code>drawRect:</code> 方法中手动绘制得到 bitmap 数据，从而自定义视图的绘制。</li></ul><p>  注意正常情况下 Display 阶段只会得到图元 primitives 信息，而位图 bitmap 是在 GPU 中根据图元信息绘制得到的。但是如果重写了 <code>drawRect:</code> 方法，这个方法会直接调用 Core Graphics 绘制方法得到 bitmap 数据，同时系统会额外申请一块内存，用于暂存绘制好的 bitmap，后续 bitmap 到了 GPU 那里经过一定处理之后会跟 GPU 渲染出的 bitmap 一块组合展示。<br>  由于重写了 <code>drawRect:</code> 方法，导致绘制过程从 GPU 转移到了 CPU，这就导致了一定的效率损失。与此同时，这个过程会额外使用 CPU 和内存，因此需要高效绘制，否则容易造成 CPU 卡顿或者内存爆炸。</p></li><li><p><strong>Prepare：准备</strong><br>  这是 Core Animation 准备发送动画数据到 Render Server 的阶段。这同时也是 Core Animation 将要执行一些额外事务的时间点，主要包括：</p><ul><li>图片解码；</li><li>图片转换；</li></ul></li><li><p><strong>Commit：提交</strong><br>  这一步主要是：在 Runloop 即将休眠（BeforeWaiting）或退出（Exit）时，将图层打包并发送到 Render Server。<br>  Render Server 是在单独的进程上工作的，APP 进程和 Render Server 进程之间通过 IPC 进行通信。<br>  注意 commit 操作是依赖图层树递归执行的，所以如果图层树过于复杂，commit 的开销就会很大。这也是我们希望减少视图层级，从而降低图层树复杂度的原因。</p></li></ul></li></ul><p><strong>第二阶段：解码及绘制调用</strong><br>此阶段发生在 Render Server 内，工作在 CPU 上，分为两个阶段：</p><ul><li>Decode<br>使用 Core Animation 解码收到的图层树。</li><li>Draw Calls<br>Core Animation 解码完成后，CPU 通过调用绘制命令（称为一次 Draw Call）来告诉 GPU 开始进行一个渲染过程的，Draw Call 命令会告诉 GPU 需要渲染的信息，包含图元信息。</li></ul><p><strong>第三阶段：渲染</strong><br>此阶段工作在 GPU 上，GPU 接收到 Draw Call 命令之后就会开始进行一次渲染流程。调用着色器，进行像素渲染，最终得到位图 bitmap，并存储到帧缓冲区中。</p><p><strong>第四阶段：展示</strong><br>在 <code>VSync</code> 到达时，视频控制器读取帧缓冲区的数据，交给显示器显示。</p><p>根据 Core Animation 渲染流水线可以知道，为了保证渲染流畅进行，我们在开发阶段需要注意：</p><ul><li>尽量减少非必要的视图创建、简化布局计算、减少视图层级。</li><li>如非必要，不要重写 <code>drawRect:</code> 方法。如果重写了 <code>drawRect:</code> 方法，需要保证高效绘制，以减少 CPU 消耗。</li></ul><h3 id="3、UIView-CALayer"><a href="#3、UIView-CALayer" class="headerlink" title="3、UIView &amp; CALayer"></a>3、UIView &amp; CALayer</h3><h4 id="1-UIView-和-CALayer-的关系"><a href="#1-UIView-和-CALayer-的关系" class="headerlink" title="(1) UIView 和 CALayer 的关系"></a>(1) UIView 和 CALayer 的关系</h4><p>前面提到 Core Animation 的核心就是 <code>CALayer</code> 对象，是显示的基础。那么 <code>UIView</code> 和 <code>CALayer</code> 之间有什么关系呢？</p><p><code>UIView</code> 和 <code>CALayer</code> 概念上很相似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容，管理子图层的位置。两者不同的是：<code>UIView</code> 可以处理触摸事件；<code>CALayer</code> 不处理用户的交互，不参与响应事件传递。</p><p>对于 <code>UIView</code> 视图来说真正的负责内容展示的其实是它内部的 <code>CALayer</code>，<code>UIView</code> 只是将自身的展示任务交给了内部的 <code>CALayer</code> 完成，而它还肩负着一些其它的任务，比如说用户的交互响应，提供一些 Core Animation 底层方法的高级接口等，这也是使用了职责分离的设计思想。</p><p><code>UIView</code> 定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> : <span class="title">UIResponder</span> &lt;<span class="title">NSCoding</span>, <span class="title">UIAppearance</span>, <span class="title">UIAppearanceContainer</span>, <span class="title">UIDynamicItem</span>, <span class="title">UITraitEnvironment</span>, <span class="title">UICoordinateSpace</span>, <span class="title">UIFocusItem</span>, <span class="title">UIFocusItemContainer</span>, <span class="title">CALayerDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">strong</span>) <span class="built_in">CALayer</span>  *layer; <span class="comment">// returns view&#x27;s layer. Will always return a non-nil value. view is layer&#x27;s delegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>CALayer</code> 定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CALayer</span> : <span class="title">NSObject</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">CAMediaTiming</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// …</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* An object providing the contents of the layer, typically a CGImageRef,</span></span><br><span class="line"><span class="comment"> * but may be something else. (For example, NSImage objects are</span></span><br><span class="line"><span class="comment"> * supported on Mac OS X 10.6 and later.) Default value is nil.</span></span><br><span class="line"><span class="comment"> * Animatable. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="type">id</span> contents;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>可以看出：<code>CALayer</code> 是继承于 <code>NSObject</code>；<code>UIView</code> 是继承于 <code>UIResponder</code>，每个 <code>UIView</code> 都拥有一个非空的 <code>CALayer</code>。<code>CALayer</code> 有一个可选的 <code>delegate</code> 属性，实现了 <code>CALayerDelegate</code> 协议。<code>UIView</code> 作为 <code>CALayer</code> 的代理实现了 <code>CALayerDelegae</code> 协议。<br><img src="/images/lix_blog_196.png"><br><code>CALayer</code> 之所以可以呈现可视化内容，是因为 <code>CALayer</code> 保存了 Metal&#x2F;OpenGL 渲染需要的顶点数据和纹理数据。其中顶点数据是必须要有的，而纹理数据不是必需的，图形渲染流水线支持从顶点开始进行绘制（GPU 会处理顶点数据并生成纹理），也支持直接使用纹理进行渲染。</p><ul><li><p>顶点数据<br>通过我们给 <code>CALayer</code> 设置各种属性比如 <code>frame</code>、<code>backgroundColor</code> 来获取。即 Metal&#x2F;OpenGL 获取到位置和大小信息，当然还包括一个颜色来进行一个图形的渲染。</p></li><li><p>纹理数据<br><code>CALayer</code> 有个属性 <code>contents</code>，<code>contents</code> 指向一块缓存区，称为 backing store，可以存放位图(Bitmap)，iOS 中将该缓存区保存的 Bitmap 称为寄宿图。这个也就是 Metal&#x2F;OpenGL 渲染可以使用的纹理数据了。</p></li></ul><p><strong>设置寄宿图有两种方式：使用图片（contents image）和手动绘制（custom drawing）。</strong></p><p><strong>使用图片（contents image）</strong><br>Contents Image 是指通过 <code>CALayer</code> 的 <code>contents</code> 属性来配置图片。关于 contents 属性，根据代码注释也可以知道 <code>contents</code> 默认是 <code>nil</code>，可以用来存储 <code>CALayer</code> 要显示的内容，在 iOS 中可以存储 <code>CGImageRef</code>，即 <code>CGImage</code>，在 macOS 下可以存储 <code>CGImage</code> 或 <code>NSImage</code>。</p><p>Apple 对 <code>CGImageRef</code> 的定义是：</p><blockquote><p>A bitmap image or image mask.</p></blockquote><p>也就是说 <code>CALayer.contents</code> 就可以存储 bitmap，这就和前面 Core Animation 渲染流水线关联起来了。</p><p>例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *myImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;myImage&quot;</span>];</span><br><span class="line">myView.layer.contents = (__bridge <span class="type">id</span>)myImage.CGImage;</span><br></pre></td></tr></table></figure><p><strong>手动绘制（custom drawing）</strong><br>Custom Drawing 是指使用 Core Graphics 直接绘制寄宿图。实际开发中，一般通过继承 <code>UIView</code> 并实现 <code>drawRect:</code> 方法来自定义绘制。</p><p>例如，绘制一个圆形：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    <span class="comment">// 获取画布（获取上下文 context）</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">// 画笔颜色</span></span><br><span class="line">    <span class="built_in">CGContextSetStrokeColorWithColor</span>(context, [<span class="built_in">UIColor</span> redColor].CGColor);</span><br><span class="line">    <span class="comment">// 画笔宽度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> lineWidth = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">CGContextSetLineWidth</span>(context, lineWidth);</span><br><span class="line">    <span class="comment">// 圆点坐标</span></span><br><span class="line">    <span class="built_in">CGFloat</span> centerX = <span class="built_in">CGRectGetWidth</span>(rect)/<span class="number">2.0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> centerY = <span class="built_in">CGRectGetHeight</span>(rect)/<span class="number">2.0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> cusRadius  = <span class="keyword">self</span>.frame.size.width/<span class="number">2.0</span> - lineWidth/<span class="number">2.0</span>;</span><br><span class="line">    <span class="type">double</span>  PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制路径：初始角度、结束角度</span></span><br><span class="line">    <span class="built_in">CGContextAddArc</span>(context, centerX, centerY, cusRadius, <span class="number">1.5</span>*PI, <span class="number">1.5</span>*PI + <span class="number">2</span>*PI, <span class="literal">NO</span>);</span><br><span class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathStroke);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然 <code>drawRect:</code> 是一个 <code>UIView</code> 的方法，但实际上都是底层的 <code>CALayer</code> 完成了重绘工作并保存了产生的图片，在 <code>drawRect:</code> 方法中加断点打印的调用栈如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">frame #<span class="number">0</span>: <span class="number">0x000000010e463f50</span> LayerDemo`-[TestView drawRect:](<span class="keyword">self</span>=<span class="number">0x00007fad307042c0</span>, _cmd=<span class="string">&quot;drawRect:&quot;</span>, rect=(origin = (x = <span class="number">0</span>, y = <span class="number">0</span>), size = (width = <span class="number">200</span>, height = <span class="number">200</span>))) at TestView.m:<span class="number">31</span>:<span class="number">5</span></span><br><span class="line">frame #<span class="number">1</span>: <span class="number">0x00007fff24bf756d</span> <span class="built_in">UIKitCore</span>`-[<span class="built_in">UIView</span>(<span class="built_in">CALayerDelegate</span>) drawLayer:inContext:] + <span class="number">625</span></span><br><span class="line">frame #<span class="number">2</span>: <span class="number">0x00007fff27b1afa9</span> QuartzCore`-[<span class="built_in">CALayer</span> drawInContext:] + <span class="number">288</span></span><br><span class="line">frame #<span class="number">3</span>: <span class="number">0x00007fff279d6001</span> QuartzCore`<span class="built_in">CABackingStoreUpdate_</span> + <span class="number">190</span></span><br><span class="line">frame #<span class="number">4</span>: <span class="number">0x00007fff27b24715</span> QuartzCore`invocation function <span class="keyword">for</span> block <span class="keyword">in</span> CA::Layer::display_() + <span class="number">53</span></span><br><span class="line">frame #<span class="number">5</span>: <span class="number">0x00007fff27b1a7e6</span> QuartzCore`-[<span class="built_in">CALayer</span> _display] + <span class="number">2111</span></span><br><span class="line">frame #<span class="number">6</span>: <span class="number">0x00007fff27b2e0cd</span> QuartzCore`CA::Layer::layout_and_display_if_needed(CA::Transaction*) + <span class="number">463</span></span><br><span class="line">frame #<span class="number">7</span>: <span class="number">0x00007fff27a6d44c</span> QuartzCore`CA::Context::commit_transaction(CA::Transaction*, <span class="type">double</span>, <span class="type">double</span>*) + <span class="number">496</span></span><br><span class="line">frame #<span class="number">8</span>: <span class="number">0x00007fff27aa4233</span> QuartzCore`CA::Transaction::commit() + <span class="number">783</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><strong>主要逻辑如下：</strong></p><ul><li><p><code>UIView</code> 作为 <code>CALayer</code> 的代理实现了 <code>CALayerDelegae</code> 协议，<code>CALayerDelegae</code> 中声明了 <code>displayLayer:</code>、<code>drawLayer:inContext:</code> 等方法。</p></li><li><p>当我们重写了 <code>drawRect:</code> 方法时，<code>CALayer</code> 会调用 <code>display</code> 方法请求其代理（即 <code>UIView</code>）给予一个寄宿图来显示。</p></li><li><p><code>CALayer</code> 首先会尝试调用 <code>displayLayer:</code> 方法，此时代理可以直接设置 <code>contents</code> 属性。<br><code>- (void)displayLayer:(CALayer *)layer;</code></p></li><li><p>如果 <code>CALayer</code> 的代理没有实现 <code>displayLayer:</code> 方法，<code>CALayer</code> 则会尝试调用 <code>drawLayer:inContext:</code> 方法。在调用该方法前，<code>CALayer</code> 会创建一个空的寄宿图和一个 Core Graphics 的绘制上下文 <code>CGContextRef</code>，为绘制寄宿图做准备，作为 <code>ctx</code> 参数传入。<br><code>- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</code></p></li><li><p><code>drawLayer:inContext:</code> 内部会再去调用我们重写的 <code>drawRect:</code> 方法进行绘制。</p></li><li><p>最后，由 Core Graphics 绘制生成的寄宿图会通过 context（<code>CGContextRef</code>） 存入 backing store，后续会提交给 GPU 进行对应的渲染显示流程。</p></li></ul><p>根据上述逻辑可知，<font color=#ff0000>一旦我们重写了 <code>drawRect:</code> 方法，即使方法内部没有任何绘制逻辑，系统也会默认生成一张空的寄宿图，会对 CPU 和内存产生消耗。这也就是前面 Core Animation 渲染流水线内容里提到“如非必要，不要重写 <code>drawRect:</code> 方法”的原因。</font></p><p>这里有个细节需要注意，<code>drawRect:</code> 方法中获取并使用了上下文 <code>context</code>（<code>CGContextRef</code>），实际上也只有在 <code>drawRect:</code> 方法中才能使用这个上下文 <code>context</code>。</p><p>因为 <code>drawRect:</code> 方法在 <code>drawLayer:inContext:</code> 里被调用, 并且被调用前有个 <code>UIGraphicsPushContext(context)</code> 方法将视图图层对应上下文压入栈顶，然后 <code>drawRect:</code> 执行完后，将视图图层对应上下文执行出栈操作。系统会维护一个 <code>CGContextRef</code> 的栈，而 <code>UIGraphicsGetCurrentContext()</code> 会取栈顶的 <code>CGContextRef</code>, 当前视图图层的上下文的入栈和出栈操作恰好将 <code>drawRect:</code> 的执行包裹在其中，所以说只在 <code>drawRect:</code> 方法里才能获取当前图层的上下文。</p><p>相关逻辑伪代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)drawLayer:(<span class="built_in">CALayer</span>*)layer inContext:(<span class="built_in">CGContextRef</span>)context &#123;</span><br><span class="line">    <span class="built_in">UIGraphicsPushContext</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGRect</span> bounds;</span><br><span class="line">    bounds = <span class="built_in">CGContextGetClipBoundingBox</span>(context);</span><br><span class="line">    [<span class="keyword">self</span> drawRect:bounds];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIGraphicsPopContext</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-UI-更新与-RunLoop"><a href="#2-UI-更新与-RunLoop" class="headerlink" title="(2) UI 更新与 RunLoop"></a>(2) UI 更新与 RunLoop</h4><p>操作 UI 时，比如改变了 <code>Frame</code>、更新了 <code>UIView/CALayer</code> 的层次时，或者手动调用了 <code>UIView/CALayer</code> 的 <code>setNeedsLayout/setNeedsDisplay</code> 方法后，这个 <code>UIView/CALayer</code> 就被标记为待处理，并被提交到一个全局的容器去，这个容器就保存了这些 <code>CATransaction</code> 事务。</p><p><code>CATransaction</code> 的作用就是捕获 <code>CALayer</code> 的变化，然后提交，就像下面这样：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">CATransaction</span> begin];</span><br><span class="line">_testLayer.backgroundColor = [<span class="built_in">UIColor</span> blueColor].CGColor;</span><br><span class="line">[<span class="built_in">CATransaction</span> commit];</span><br></pre></td></tr></table></figure><p>苹果注册了一个 RunLoop Observer 监听 <code>BeforeWaiting</code>(即将进入休眠) 和 Exit (退出) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code><br>这个函数里会遍历所有待处理的 <code>UIView/CAlayer</code> 以执行实际的绘制和调整，并更新 UI 界面。</p><p>我们看到下面的代码中就是获取到这个全局的 <code>Transaction</code> 容器，然后执行 Transaction commit，判断 <code>layout_if_needed()</code> 和 <code>display_if_needed()</code>，然后执行视图的创建、布局计算、图片解码、文本绘制等。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> layoutSublayers];</span><br><span class="line">                            [<span class="built_in">UIView</span> layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> display];</span><br><span class="line">                            [<span class="built_in">UIView</span> drawRect];</span><br></pre></td></tr></table></figure><p>如果想要立刻根据刷新标记刷新视图，可以调用 <code>layoutIfNeeded</code> 方法，该方法会触发立刻刷新。如果 <code>view</code> 被标记了需要刷新，那么调用 <code>layoutIfNeeded</code> 方法之后，<code>subView</code> 的 <code>layoutSubviews</code> 方法会被调用。</p><h4 id="3-异步绘制"><a href="#3-异步绘制" class="headerlink" title="(3) 异步绘制"></a>(3) 异步绘制</h4><p>当我们调用了 <code>setNeedsDisplay</code> 方法后，RunLoop 即将进入休眠和结束的时候会调用 <code>[CALayer display]</code>，如果 <code>CALayer</code> 的代理（即 <code>UIView</code>）实现了 <code>dispalyLayer:</code> 方法，那么 <code>dispalyLayer:</code> 会被调用。</p><p>CoreGraphic 的绘制方法是线程安全的，我们可以在子线程中去做异步绘制的工作，我们虽然不能在非主线程将内容绘制到 <code>layer</code> 的 <code>context</code> 上，但是我们可以将需要绘制的内容绘制在一个自己创建的 <code>context</code> 上，绘制完成后切换到到主线程, 为 <code>layer.contents</code> 赋值。例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)display &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这个是重写的 <code>CALayer</code> 的 <code>display</code> 方法实现的。我们也可以重写 <code>UIView</code> 的 <code>dispalyLayer:</code> 方法，在 <code>dispalyLayer:</code> 方法中按照相同方式进行异步绘制。</p><h2 id="二、离屏渲染"><a href="#二、离屏渲染" class="headerlink" title="二、离屏渲染"></a>二、离屏渲染</h2><p>根据前文，简化来看，通常的渲染流程是这样的：<br><img src="/images/lix_blog_197.png"><br>App 通过 CPU 和 GPU 的合作，不停地将内容渲染完成放入 Framebuffer 帧缓冲器中，而显示屏幕不断地从 Framebuffer 中获取内容，显示实时的内容。</p><p>而离屏渲染的流程是这样的：<br><img src="/images/lix_blog_198.png"><br>与普通情况下 GPU 直接将渲染好的内容放入 Framebuffer 中不同，需要先额外创建离屏渲染缓冲区 Offscreen Buffer，将提前渲染好的内容放入其中，等到合适的时机再将 Offscreen Buffer 中的内容进一步叠加、渲染，完成后将结果切换到 Framebuffer 中。</p><p><strong>为什么会有离屏渲染呢？</strong><br>使用离屏渲染主要是因为下面这两种原因：</p><ul><li>(1) 一些特殊效果需要使用额外的 Offscreen Buffer 来保存渲染的中间状态，所以不得不使用离屏渲染。</li><li>(2) 处于效率目的，可以将内容提前渲染保存在 Offscreen Buffer 中，达到复用的目的。</li></ul><p>对于第一种情况，也就是不得不使用离屏渲染的情况，一般都是系统自动触发的，比如阴影、圆角等等。</p><p><strong>为什么需要使用额外的 Offscreen Buffer 来保存渲染的中间状态？</strong>通过前面的 Core Animation 渲染流水线可以知道，主要渲染操作是由 Render Server 模块通过调用显卡驱动所提供的 Metal&#x2F;OpenGL 接口来执行的，通常对于每一层 layer，Render Server 会遵循“画家算法”，按次序输出到 frame buffer，后一层覆盖前一层，就能得到最终的显示结果：<br><img src="/images/lix_blog_98.png"><br>作为“画家”的 GPU 虽然可以一层一层往画布上进行输出，但是无法在某一层渲染完成之后，再回过头来擦除&#x2F;改变其中的某个部分，因为目前存在的 <code>layer</code> 已经是若干层 <code>layer</code> 覆盖合并后的 <code>layer</code> 了。所以，对于这种复杂的场景，就不得不另开一块内存，也就是创建一个缓冲区（Offscreen Buffer），将已渲染好的 <code>layer</code> 先临时保存到这个缓冲区中，以便于可以多次取出做出一些特定处理。</p><p>例如，使用了 <code>mask</code> 蒙版：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *mImageView = [<span class="built_in">UIImageView</span> new];</span><br><span class="line"><span class="built_in">CALayer</span> *maskLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ........</span></span><br><span class="line"></span><br><span class="line">mImageView.layer.mask = maskLayer;</span><br></pre></td></tr></table></figure><p>由于最终的内容是由两层渲染结果叠加，所以必须要利用额外的内存空间对中间的渲染结果进行保存，因此系统会默认触发离屏渲染。<br><img src="/images/lix_blog_99.png"></p><p>再例如，使用了 iOS 8+ 提供的模糊效果 <code>UIBlurEffectView</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *mImageView = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line"><span class="built_in">UIBlurEffect</span> *blur = [<span class="built_in">UIBlurEffect</span> effectWithStyle:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">UIVisualEffectView</span> *blurView = [[<span class="built_in">UIVisualEffectView</span> alloc] initWithEffect:blur];</span><br><span class="line"></span><br><span class="line"><span class="comment">// mImageView.image = ...</span></span><br><span class="line"><span class="comment">// blurView.frame = ...;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">[mImageView addSubview:blurView];</span><br></pre></td></tr></table></figure><p>整个模糊过程分为多步：<strong>Pass 1</strong> 先渲染需要模糊的内容本身，<strong>Pass 2</strong> 对内容进行缩放，<strong>Pass 3 4</strong> 分别对上一步内容进行横纵方向的模糊操作，最后一步用模糊后的结果叠加合成，最终实现完整的模糊特效。<br><img src="/images/lix_blog_100.png"></p><p>而第二种情况，为了复用提高效率而使用离屏渲染一般是主动的行为，是通过 <code>CALayer</code> 的 <code>shouldRasterize</code> 光栅化操作实现的。</p><p>开启光栅化后，会触发离屏渲染，Render Server 会强制将 CALayer 的渲染位图结果 bitmap 保存下来，这样下次再需要渲染时就可以直接复用，从而提高效率。</p><p>而保存的 bitmap 包含 <code>layer</code> 的 <code>subLayer</code>、圆角、阴影、组透明度 group opacity 等，所以如果 <code>layer</code> 的构成包含上述几种元素，结构复杂且需要反复利用，那么就可以考虑打开光栅化，以改善性能。</p><p>圆角、阴影、组透明度等会由系统自动触发离屏渲染，那么打开光栅化可以节约第二次及以后的渲染时间。而多层 <code>subLayer</code> 的情况由于不会自动触发离屏渲染，所以相比之下会多花费第一次离屏渲染的时间，但是可以节约后续的重复渲染的开销。</p><p>例如，<code>UITableView</code> 的 <code>cell</code> 中，如果使用了阴影效果，那么会触发离屏渲染：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">cell.textLabel.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">cell.textLabel.layer.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">cell.textLabel.layer.shadowOpacity = <span class="number">0.5</span>;”</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>shouldRasterize</code> 来缓存图层内容。这将会让图层离屏渲染一次之后把结果保存起来，大大减少了 GPU 的负担：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    cell.layer.shouldRasterize = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过使用光栅化的时候需要注意以下几点：</p><ul><li>如果 <code>layer</code> 不能被复用，则没有必要打开光栅化</li><li>如果 <code>layer</code> 不是静态，需要被频繁修改，比如处于动画之中，那么开启离屏渲染反而影响效率</li><li>离屏渲染缓存内容有时间限制，缓存内容 100ms 内如果没有被使用，那么就会被丢弃，无法进行复用</li><li>离屏渲染缓存空间有限，超过 2.5 倍屏幕像素大小的话也会失效，无法复用。</li></ul><p><strong>离屏渲染的代价是很高的，主要体现在两个方面：</strong></p><ul><li><p><strong>创建新缓冲区(Offscreen Buffer)</strong><br>要想进行离屏渲染，首先要创建一个新的缓冲区，缓冲区需求占有一定的内存空间，大量的离屏渲染可能造成内存的过大压力。与此同时，Offscreen Buffer 的总大小也有限，不能超过屏幕总像素的 2.5 倍。</p></li><li><p><strong>上下文切换</strong><br>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen），等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</p></li></ul><p><strong>离屏渲染的开销非常大，一旦需要离屏渲染的内容过多，很容易造成掉帧的问题。所以大部分情况下，我们都应该尽量避免离屏渲染。</strong></p><p>除了前面提到的几个触发离屏渲染的案例，还有很多情况也会触发离屏渲染。<br>总结一下，<strong>会触发离屏渲染的情况如下：</strong></p><ul><li>使用了 <code>mask</code> 的 <code>layer</code> (<code>layer.mask</code>)</li><li><code>layer</code> 切圆角 (<code>layer.masksToBounds</code> &#x2F; <code>layer.masksToBounds</code>)，单纯的 <code>cornerRadius</code> + <code>masksToBounds</code> 不会触发离屏渲染，以下情况时才会触发离屏渲染：<ul><li><code>layer</code> 设置了圆角裁剪，且有子 <code>layer</code>，或者有 <code>content</code>，会触发离屏渲染。</li><li><code>UIImageView</code> 设置了圆角裁剪，同时设置了 <code>backgroundColor</code> 和 <code>image</code>（属于两个图层），会触发离屏渲染。</li><li><code>UIButton</code> 设置了圆角裁剪，且设置了 <code>backgroundImage</code> 或者 <code>image+backgroundColor</code>，会触发离屏渲染。</li></ul></li><li>有子 <code>layer</code> 或者背景图的 <code>layer</code> 设置了组透明度为 YES（默认就是 YES），并且设置了透明度不为 1 (<code>layer.allowsGroupOpacity</code>&#x2F;<code>layer.opacity</code>)</li><li>添加了投影的 <code>layer</code> (<code>layer.shadow*</code>)</li><li>采用了光栅化的 <code>layer</code> (<code>layer.shouldRasterize</code>)</li><li>绘制了文字的 <code>layer</code> (<code>UILabel</code>, <code>CATextLayer</code>, <code>Core Text</code> 等)</li></ul><p><strong>特殊的“离屏渲染”：CPU渲染</strong><br>在前面渲染流程中提到如果我们重写了 drawRect: 方法，就涉及到了 CPU 渲染。整个渲染过程由 CPU 在 App 内同步地完成，渲染得到的 bitmap(位图)最后再交由 GPU 用于显示。</p><p>Designing for iOS: Graphics &amp; Performance 这篇文章也提到了使用 Core Graphics API 会触发离屏渲染。 苹果 iOS 4.1-8 时期的 UIKit 组成员 Andy Matuschak 也曾对这个说法进行解释：「Core Graphics 的绘制 API 的确会触发离屏渲染，但不是那种 GPU 的离屏渲染。使用 Core Graphics 绘制 API 是在 CPU 上执行，触发的是 CPU 版本的离屏渲染。」</p><p><strong>优化建议：</strong><br>（1）对于圆角，可使用贝塞尔曲线 <code>UIBezierPath</code> 和 <code>CoreGraphics</code> 的替代方式画圆角避免离屏渲染。例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)]; </span><br><span class="line">imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;myImg&quot;</span>]; </span><br><span class="line"><span class="comment">// 开始对 imageView 进行画图 </span></span><br><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(imageView.bounds.size, <span class="literal">NO</span>, <span class="number">1.0</span>); </span><br><span class="line"><span class="comment">// 使用贝塞尔曲线画出一个圆形图 </span></span><br><span class="line">[[<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:imageView.bounds cornerRadius:imageView.frame.size.width] addClip];</span><br><span class="line">[imageView drawRect:imageView.bounds];</span><br><span class="line">imageView.image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>(); </span><br><span class="line"><span class="comment">// 结束画图 </span></span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:imageView];</span><br></pre></td></tr></table></figure><p>（2）对于 <code>layer</code> 透明度不为 1 的情况，可以设置 <code>allowsGroupOpacity</code> 为 NO 避免离屏渲染。iOS 7+ 系统 <code>allowsGroupOpacity</code> 默认为 YES，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.layer.allowsGroupOpacity = <span class="literal">NO</span></span><br><span class="line">view.layer.opacity = <span class="number">0.9</span></span><br></pre></td></tr></table></figure><p>备注：<code>allowsGroupOpacity</code>  作用<br>红色的是父 View，蓝色是子 View，效果如下：<br><img src="/images/lix_blog_101.png" style="width:50%;"><br>子 View 不设置透明度，对父 View 设置半透明：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentView.layer.opacity = <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure><p>allowsGroupOpacity 为 YES（默认） 效果：<br><img src="/images/lix_blog_102.png" style="width:50%;"></p><p>allowsGroupOpacity 为 NO 效果：<br><img src="/images/lix_blog_103.png" style="width:50%;"></p><p>可以看到，如果 <code>allowsGroupOpacity</code> 为 YES，这是对图层整体设置透明度，相当于先合并图层，再设置透明度。如果 <code>allowsGroupOpacity</code> 为 NO，则是分别对图层设置透明度，于是就出现了子 <code>View</code> 半透明后能看到后面的父 View 的效果。</p><p>（3）对于 <code>layer</code> 设置阴影情况，可以通过设置 <code>shadowPath</code> 的替代方式设置阴影避免离屏渲染。例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 设置 shadow ，会产生离屏渲染。</span></span><br><span class="line"><span class="keyword">self</span>.layer.shadowColor = <span class="built_in">UIColor</span>.black.cgColor</span><br><span class="line"><span class="keyword">self</span>.layer.shadowOpacity = <span class="number">0.3</span></span><br><span class="line"><span class="keyword">self</span>.layer.shadowRadius = <span class="number">3</span></span><br><span class="line"><span class="keyword">self</span>.layer.shadowOffset = <span class="built_in">CGSize</span>.zero</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.设置 shadowPath ，告诉 Core Animation 投影路径，则不会出现离屏渲染。</span></span><br><span class="line"><span class="keyword">self</span>.layer.shadowPath = <span class="built_in">UIBezierPath</span>(roundedRect: <span class="keyword">self</span>.bounds, byRoundingCorners: .allCorners</span><br><span class="line">, cornerRadii: <span class="built_in">CGSize</span>(width: <span class="number">30</span>, height: <span class="number">30</span>)).cgPath</span><br></pre></td></tr></table></figure><p><strong>检测离屏渲染</strong><br>启动模拟器并打开如下选项，页面黄色区域部门表示发生了离屏渲染：<br><img src="/images/lix_blog_104.png"></p><h2 id="三、卡顿"><a href="#三、卡顿" class="headerlink" title="三、卡顿"></a>三、卡顿</h2><h3 id="1、卡顿原因"><a href="#1、卡顿原因" class="headerlink" title="1、卡顿原因"></a>1、卡顿原因</h3><p>前面图像渲染原理部分提到 iOS 使用“垂直同步 <code>Vsync</code> + 双缓冲机制 Double Buffering”机制避免了屏幕撕裂问题。但是，这种方式也引起了另个问题：掉帧</p><p>在 <code>VSync</code> 信号到来后，系统图形服务会通过 <code>CADisplayLink</code> 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 <code>VSync</code> 信号到来时显示到屏幕上。如果在接收到 Vsync 之时 CPU 和 GPU 还没有渲染好新的位图，视频控制器就不会去替换 frame buffer 中的位图。这时屏幕就会重新扫描呈现出上一帧一模一样的画面。相当于两个周期显示了同样的画面，引起了掉帧的现象，这就是界面卡顿的原因。<br><img src="/images/lix_blog_199.png"><br>从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p><h3 id="2、解决卡顿"><a href="#2、解决卡顿" class="headerlink" title="2、解决卡顿"></a>2、解决卡顿</h3><p>针对 CPU 资源消耗方面的优化：</p><ul><li>（1）对象的创建和销毁是比较消耗 CPU 资源的，所以应当减少 UIView 的创建，尽量复用 UIView</li><li>（2）尽量使用轻量级对象，例如使用 CALayer 能满足需求的话，尽量使用 CALayer</li><li>（3）如果任务不涉及到 UI 操作，尽量放到后台线程处理</li><li>（4）尽量避免调整视图层次、添加和移除视图</li><li>（5）避免频繁调整 frame&#x2F;bounds&#x2F;center 等属性</li><li>（6）如果使用了 CoreGraphic 相关 API 进行绘制，尽量异步绘制（前面有提到异步绘制实现方式）</li></ul><p><strong>针对 GUP 资源消耗方面的优化：</strong></p><ul><li>（1）当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源，所以应当尽量减少视图数量和层次</li><li>（2）GPU 能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸</li><li>（3）减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES，避免无用的 Alpha 通道合成。</li><li>（4）避免离屏渲染</li></ul><h3 id="3、监听卡顿"><a href="#3、监听卡顿" class="headerlink" title="3、监听卡顿"></a>3、监听卡顿</h3><h4 id="1-利用-Runloop-监控卡顿"><a href="#1-利用-Runloop-监控卡顿" class="headerlink" title="(1) 利用 Runloop 监控卡顿"></a>(1) 利用 Runloop 监控卡顿</h4><p>根据 Runloop 的执行流程可以发现，Runloop 对我们业务逻辑的处理时间在两个阶段：</p><ul><li><code>kCFRunLoopBeforeSources</code> 和 <code>kCFRunLoopBeforeWaiting</code> 之间</li><li><code>kCFRunLoopAfterWaiting</code> 之后</li></ul><p>所以，如果主线程 Runloop 处在 <code>kCFRunLoopBeforeSources</code> 时间过长，也就是迟迟无法将任务处理完成，顺利到达 <code>kCFRunLoopBeforeWaiting</code> 阶段，说明发生了卡顿。</p><p>同样的，如果 Runloop 处在 <code>kCFRunLoopAfterWaitin</code>g 时间过长，也是发生了卡顿。</p><p>所以，如果我们要利用 Runloop 来监控卡顿的话，就要关注 <code>kCFRunLoopBeforeSources</code> 和 <code>kCFRunLoopAfterWaiting</code> 两个阶段，一般卡顿时间超过 250ms 会被明显感知，所以，可以以连续 5 次卡顿时长超过 50ms 可以认为发生卡顿，或者根据需要调整统计阀值。以下是通过 Runloop 监听卡顿的一个例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LagMonitor</span>() </span>&#123;</span><br><span class="line">    <span class="type">int</span> timeoutCount;</span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> runLoopObserver;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    dispatch_semaphore_t dispatchSemaphore;</span><br><span class="line">    <span class="built_in">CFRunLoopActivity</span> runLoopActivity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LagMonitor</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Interface</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">id</span> instance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> dispatchOnce;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;dispatchOnce, ^&#123;</span><br><span class="line">        instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始监控</span></span><br><span class="line">- (<span class="type">void</span>)beginMonitor &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;开始监控&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (runLoopObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建信号量，注意这里信号量为 0</span></span><br><span class="line">    dispatchSemaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建 Observer</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>,(__bridge <span class="type">void</span>*)<span class="keyword">self</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    runLoopObserver = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</span><br><span class="line">                                              kCFRunLoopAllActivities,</span><br><span class="line">                                              <span class="literal">YES</span>,</span><br><span class="line">                                              <span class="number">0</span>,</span><br><span class="line">                                              &amp;runLoopObserverCallBack,</span><br><span class="line">                                              &amp;context);</span><br><span class="line">    <span class="comment">// 将 Observer 添加到主线程的 RunLoop</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), runLoopObserver, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在子线程持续监控</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             信号量 P 操作，成功的话信号量会 - 1，这里超时时间为 50ms，即等待 50ms 后还没成功就返回失败</span></span><br><span class="line"><span class="comment">             操作成功，信号量 - 1，返回值为 0；操作失败，返回值非 0</span></span><br><span class="line"><span class="comment">             由于初始信号量为 0，这里会阻塞，直到 runLoopObserverCallBack 函数中对信号量做了 V 操作，即 RunLoop 状态发生改变的时候。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">long</span> semaphoreWait = dispatch_semaphore_wait(<span class="keyword">self</span>-&gt;dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="number">50</span> * <span class="built_in">NSEC_PER_MSEC</span>));</span><br><span class="line">            <span class="keyword">if</span> (semaphoreWait != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 发生超时，说明 RunLoop 保持在一个状态的时间超过了 50ms</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">self</span>-&gt;runLoopObserver) &#123;</span><br><span class="line">                    <span class="keyword">self</span>-&gt;timeoutCount = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">self</span>-&gt;dispatchSemaphore = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">self</span>-&gt;runLoopActivity = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果是在 BeforeSources 或 AfterWaiting 这两个状态持续时间达到超时时间，就代表发生了卡顿</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;runLoopActivity == kCFRunLoopBeforeSources || <span class="keyword">self</span>-&gt;runLoopActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    <span class="comment">// 出现三次出结果</span></span><br><span class="line">                    <span class="keyword">if</span> (++<span class="keyword">self</span>-&gt;timeoutCount &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 发生了卡顿，可以使用 PLCrashReporter 等收集堆栈并上报</span></span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;发生了卡顿，&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>-&gt;timeoutCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束监控</span></span><br><span class="line">- (<span class="type">void</span>)endMonitor &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;结束监控&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!runLoopObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), runLoopObserver, kCFRunLoopCommonModes);</span><br><span class="line">    <span class="comment">// 释放 Observer</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(runLoopObserver);</span><br><span class="line">    runLoopObserver = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Private</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> runLoopObserverCallBack(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="type">void</span> *info) &#123;</span><br><span class="line">    LagMonitor *lagMonitor = (__bridge LagMonitor*)info;</span><br><span class="line">    lagMonitor-&gt;runLoopActivity = activity;</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_t semaphore = lagMonitor-&gt;dispatchSemaphore;</span><br><span class="line">    <span class="comment">// 对信号量进行 V 操作，信号量 + 1</span></span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="2-子线程-ping-监控卡顿"><a href="#2-子线程-ping-监控卡顿" class="headerlink" title="(2) 子线程 ping 监控卡顿"></a>(2) 子线程 ping 监控卡顿</h4><p>子线程定时给主线程发送 ping 消息，主线程收到消息后回复 pong 消息，如果隔了太久才回复消息，可以说明主线程发生了卡顿。<br>其中一种实现方式是在子线程进行加锁，让主线程去解锁，如果主线程没有卡顿就能很快解锁。但是如果主线程在一定时间阀值内（例如 150 ms）还没有解锁，也就是加锁到解锁这段时间间隔大于阀值，就代表产生了卡顿，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的子线程 PingThread</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PingThread</span> : <span class="title">NSThread</span></span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PingThread</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)main &#123;</span><br><span class="line">    [<span class="keyword">self</span> pingMainThread];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)pingMainThread &#123;</span><br><span class="line">    <span class="comment">// 如果没有取消就循环执行</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">self</span>.cancelled) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="comment">// 如果主线程没有卡顿，这里可以很快解锁</span></span><br><span class="line">                [_lock unlock];</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CFAbsoluteTime</span> pingTime = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">            <span class="comment">// 加锁，让主线程去解锁。如果之前已经加锁，但主线程没有解锁，就会阻塞无法继续执行</span></span><br><span class="line">            [_lock lock];</span><br><span class="line">            <span class="comment">// 只有主线程完成解锁之后，才会执行到这里</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">CFAbsoluteTimeGetCurrent</span>() - pingTime &gt;= _threshold) &#123;</span><br><span class="line">                <span class="comment">// 如果加锁到解锁阶段花费的时间超过阀值，就是发生了卡顿，这里获取主线程堆栈进行上报</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每隔 _interval 秒进行一次卡顿检测</span></span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval: _interval];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>当然这只是其中一种实现方式，除此之外还可以利用信号量、发通知等各种实现方式，但是思想是一样的。</p><h4 id="3-使用-CADisplayLink-监测-FPS"><a href="#3-使用-CADisplayLink-监测-FPS" class="headerlink" title="(3) 使用 CADisplayLink 监测 FPS"></a>(3) 使用 CADisplayLink 监测 FPS</h4><p>通常情况下，屏幕会保持 60hz&#x2F;s 的刷新率，每次刷新时会发出一个屏幕刷新信，通过 <code>CADisplayLink</code> 可以注册一个与刷新信号同步的回调处理。可以通过屏幕刷新机制来展示 FPS 值，如果没有达到 60hz&#x2F;s 可以认为发生了卡顿。例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@implemention ViewController &#123;</span><br><span class="line">    <span class="built_in">UILable</span> *_fpsLabel;</span><br><span class="line">    <span class="built_in">CADisplayLink</span> *_link;</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> _lastTime;</span><br><span class="line">    <span class="type">float</span> _fps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)startMonitoring &#123;</span><br><span class="line">    <span class="keyword">if</span> (_link) &#123;</span><br><span class="line">        [_link removeFromRunloop:[<span class="built_in">NSRunloop</span> mainRunloop] forMode:<span class="built_in">NSRunloopCommonModes</span>];</span><br><span class="line">        [_link invalidate];</span><br><span class="line">        _link = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _link = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(fpsDisplayLinkAction:)];</span><br><span class="line">    [_link addToRunloop:[<span class="built_in">NSRunloop</span> mainRunloop] forMode:<span class="built_in">NSRunloopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)fpsDisplayLinkAction:(<span class="built_in">CADisplaylink</span> *)link &#123;</span><br><span class="line">    <span class="keyword">if</span> (_lastTime == <span class="number">0</span>) &#123;</span><br><span class="line">        _lastTime = link.timestamp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.count++;</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> delta = link.timestamp - _lastTime;</span><br><span class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    _lastTime = link.timestamp;</span><br><span class="line">    _fps = _count / delta;</span><br><span class="line">    <span class="keyword">self</span>.count = <span class="number">0</span>;</span><br><span class="line">    _fpsLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;FPS: %.0f&quot;</span>, _fps];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码逻辑只是通过一个 <code>UILable</code> 去显示当前帧率，如果有需要，可以在帧率小于 60 fps 时上报主线程堆栈。</p><p><strong>参考：</strong><br><a href="https://docs.huihoo.com/apple/wwdc/2014/419_advanced_graphics_and_animation_performance.pdf">Advanced Graphics and Animations for iOS Apps</a><br><a href="https://github.com/RickeyBoy/Rickey-iOS-Notes/blob/master/%E7%AC%94%E8%AE%B0/iOS%20Rendering.md">iOS Rendering 渲染全解析</a><br><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a><br><a href="https://www.hanleylee.com/principle-of-graphic-rendering-in-ios.html">iOS 的图形绘制原理</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WKWebView 与 JavaScriptCore</title>
      <link href="/posts/56329/"/>
      <url>/posts/56329/</url>
      
        <content type="html"><![CDATA[<h2 id="一、WKWebView"><a href="#一、WKWebView" class="headerlink" title="一、WKWebView"></a>一、WKWebView</h2><h3 id="1、WebKit"><a href="#1、WebKit" class="headerlink" title="1、WebKit"></a>1、WebKit</h3><p><code>WebKit</code> 是 Safari 浏览器的内核，<code>WebKit</code> 由多个重要模块组成：<br><img src="/images/lix_blog_78.png"></p><ul><li><p>WebKit Embedding API（WebKit 嵌入 API）<br>WebKit 提供给浏览器 UI 调用的接口，例如 iOS 中 <code>WebKit</code> 框架提供的 <code>WKWebView</code>。</p></li><li><p>WebCore<br>HTML 排版引擎，包括 HTML 解析器、CSS 解析器等。</p></li><li><p>JavaScriptCore<br><code>JavaScriptCore</code> 是 <code>WebKit</code> 默认内嵌的 <code>JavaScript</code> 脚本引擎，是 <code>JavaScript</code> 的虚拟机，为 <code>JavaScript</code> 的执行提供底层资源。</p></li></ul><p>2008 年，<code>WebKit</code> 项目宣布对 <code>JavaScriptCore</code> 重写，项目演变成 SquirrelFish Extreme（简称为 SFX，市场称之为 Nitro），JavaScript 的运行效率有了很大的提升。Safari 和 WKWebView 都使用了 Nitro JavaScript 引擎。</p><ul><li>WebKit Ports<br>WebKit 中的非共享部分，WebKit Ports 提供了调用 Native Library 的接口，由于各平台差异、第三方库和需求不同等原因，往往需要按照自己的方式来设计与实现，例如网络方面 Safari 使用 CFNetwork，而 Chromium 中使用 Chromium stack 等等。</li></ul><p><strong>WebKit 的历史</strong><br><code>WebKit</code> 项目是 Apple 于 2001 年启动的项目，2005 年将 <code>WebKit</code> 开源（之前仅有 <code>WebCore</code> 及 <code>JavaScriptCore</code> 开源）。其中 WebCore 基于 KDE（一个国际性的自由软件社区） 发布的 Konqueror 浏览器项目中的 HTML 排版引擎 <code>KHTML</code>，<code>JavaScriptCore</code> 基于 Konqueror 中的 <code>JavaScript</code> 引擎 <code>KJS</code>。</p><p>Apple 将 <code>KHTML</code> 发扬光大，起初的时候 Apple 和 KDE 关系很和谐，但是随着时间的推进，<code>WebKit</code> 和 <code>KHTML</code> 之间交换代码变得越来越困难，Apple 经常间隔很长时间后提交一大批代码修改，并且没有足够的代码注释及文档，而且存在未开发完整的功能，对于 KDE 而言合并代码非常困难。此外，Apple 要求 KDE 开发者阅览苹果代码之前必须签署保密条款，KDE 也很难接受这一点。在 2005 年，KDE 开发者开始公开攻击 Apple 的做法，并称两方的合作关系已经彻底瓦解了。</p><p>事情被媒体报道之后，苹果做出了一系列的让步。在 2005 年，苹果宣布将 <code>WebKit</code> 完全开源。KDE 和 Apple 的关系也得到了一些改善，有一些 KDE 的开发者们开始为 <code>WebKit</code> 提交更改。</p><p>之后，Google 参与 <code>WebKit</code> 的开发，并与 2008 年推出 Chrome 浏览器，Chrome 浏览器是不开源的，其开源项目是 Chromium，Chromium 为 Chrome 提供了绝大多数的源代码。虽然 Chrome 浏览器是基于 <code>WebKit</code> 开发的，但是 Chrome 主要使用了 <code>WebKit</code> 中的 WebCore，Google 自研了 <code>JavaScript</code> 引擎 V8。</p><p>后由于 Google 与 Apple 之间竞争关系，两者互相指责对方在源码共享上不够开放，2013 年 Google 宣布它创建了 <code>WebKit</code> 中 <code>WebCore</code> 组件的分支——Blink。<br><img src="/images/lix_blog_79.png"></p><h3 id="2、WKWebView"><a href="#2、WKWebView" class="headerlink" title="2、WKWebView"></a>2、WKWebView</h3><h4 id="1-WKWebView-多进程结构"><a href="#1-WKWebView-多进程结构" class="headerlink" title="(1) WKWebView 多进程结构"></a>(1) WKWebView 多进程结构</h4><p>在 iOS 系统中，通常一个应用对应一个进程，但是在 <code>WebKit</code> 的发展过程中，基于稳定性与安全性考虑，引入了多进程的概念，避免单一页面的异常影响整体 app 运行，进程之间通过 <code>CoreIPC</code> 进行通信，一个 WKWebView 往往对应如下三个进程：<br><img src="/images/lix_blog_200.png"></p><ul><li><p><code>UIProcess</code> 进程为 app 所在进程，<code>WKWebView</code> 在该进程中提供了大量 API 供开发者与内核交互，也是开发者最熟悉的一部分。</p></li><li><p><code>WebContent</code> 进程对应的是每一个新开的网页，该进程视内存情况可进行复用，某一 <code>WebContent</code> 进程的异常并不会影响到主 app 进程及其他 WebContent 进程，<code>WebContent</code> 进程被杀死的现象为白屏。</p></li><li><p><code>NetWorking</code> 进程，无论多 <code>WKWebView</code> 还是单 <code>WKWebView</code> 场景，都只有唯一的 <code>NetWorking</code> 进程，这种设计主要便于网络请求管理以及保证网络缓存、<code>cookie</code> 等管理的一致性。</p></li></ul><p><strong>苹果官方文档中描述：配置同一 <code>WKProcessPool</code> 的多个 <code>WKWebView</code> 共享同一 <code>WebContent</code> 进程，即可以配置 <code>WebContent</code> 进程唯一（<a href="https://developer.apple.com/documentation/webkit/wkprocesspool">原文</a>）。<br>但源码头文件中的注释与官方文档不一致，源码头文件描述配置同一 <code>WKProcessPool</code> 的多个 <code>WKWebView</code> 共享的是同一 <code>WebContent</code> 进程池，该配置未限制 <code>WebContent</code> 进程数量，而是共享进程池。<br>从 Demo 实际测试看，官方文档描述并不准确，我们以源码注释为准。<br>（摘自 <a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247484382&idx=1&sn=0ee23e4ca6dc8deff3cf42303dc8c6db&chksm=f94c52cece3bdbd8293832384e2c51282c0ab2435d1f6183fa3ca18b1455776ccd1f444ab631&scene=21#wechat_redirect">WebKit 源码调试与分析</a>）</strong></p><p>也就是说，即使多个 <code>WKWebView</code> 配置了同一个 <code>WKProcessPool</code>，打开多个 <code>WKWebView</code> 仍然会创建多个 <code>WebContent</code> 进程。</p><h4 id="2-WKWebView-的-cookie-问题"><a href="#2-WKWebView-的-cookie-问题" class="headerlink" title="(2) WKWebView 的 cookie 问题"></a>(2) WKWebView 的 cookie 问题</h4><p><code>WKWebView</code>  <code>cookie</code> 的存储<br>先看下 <code>WKWebView</code> 的三个进程与 <code>cookie</code> 的关联<br><strong>UIProcess：</strong><br><code>UIProcess</code> 进程为 app 进程（APP 进程中其实有 <code>NSHTTPCookieStorage</code> 仓储进行 <code>cookie</code> 管理，但这不是本文的重点，因此不展开来讲），苹果系统为开发者提供了 <code>WKHTTPCookieStorage</code> API 进行 <code>WebKit</code> 内核的 <code>cookie</code> 管理，<code>WKHTTPCookieStorage</code> 其实并不提供实际的存储能力，而是封装了一系列基于进程间通信的方法，将 <code>UIProcess</code> 进程中发生的 <code>cookie</code> 操作，发送到 <code>NetWorking</code> 进程中进行处理，并将执行结果通过回调函数返回。</p><p><strong>WebContent：</strong><br><code>WebContent</code> 进程是前端操作 <code>cookie</code> 的进程，原则上，每一个网页页面都只能操作当前页面域名下的 <code>cookie</code>。因此基于性能考虑，每一个 <code>WebContent</code> 进程中会有一个 <code>cookieCache</code> 实例，它是 <code>NetWorking</code> 进程中存储的 <code>cookie</code> 的子集，仅存储当前页面域名下的 <code>cookie</code>，因此 <code>cookieCache</code> 采取了内存缓存的方式，其特征是存储量小，查找速度快。</p><p><strong>NetWorking：</strong><br><code>NSHTTPCookieStorage</code> setCookie 流程图：<br><img src="/images/lix_blog_201.png"><br><code>NetWorking</code> 进程是 <code>cookie</code> 存储的最核心进程，它管理来自网络中服务端 <code>response</code> 中配置的 <code>cookie</code>，同时也接受来自前端和客户端的 <code>cookie</code> 操作，是最全的 <code>cookie</code> 存储中心。通过源码分析，我们发现其内部还是通过 <code>NSHTTPCookieStorage</code> 进行管理的， <code>NSHTTPCookieStorage</code> 有如下存储规则：</p><ul><li><p>allCookies<br>所有 <code>cookie</code> 都会存入字典 <code>allCookies</code> 中，方便快速查询。当我们杀死 app 后，位于内存中的 <code>allCookies</code> 字典也会一同清理掉。</p></li><li><p>sessionOnly false cookie<br>对于某个 <code>cookie</code>，如果其属性中 <code>sessionOnly</code> 为 <code>false</code>，且设置的过期时间未到达，那我们判断该 <code>cookie</code> 是否具备持久性。</p></li><li><p>持久性 cookie<br>具备持久性的 <code>cookie</code> 需要存储到磁盘文件中。</p></li></ul><p><strong>三种不同场景的 <code>cookie</code> 操作是如何协同工作的？</strong><br>如 <code>cookie</code> 管理协同图所示，不同场景下的 <code>cookie</code> 协同操作其本质就是三大进程间的通信：</p><ul><li><p><code>UIProcess</code> 进程并没有直接管理 <code>cookie</code>，而是通过进程间通信的方式，在 <code>NetWorking</code> 进程中管理 <code>cookie</code>。</p></li><li><p>冷启动时，<code>NetWorking</code> 进程会初始化内部 <code>NSHTTPCookieStorage</code> ，并会将磁盘中的 <code>cookie</code> 读取出来，设置到内存字典 <code>allCookies</code> 中，同时将 <code>allCookies</code> 中的 <code>cookie</code> 变更通过广播的方式告知 <code>WebContent</code> 进程，发生了 <code>cookie</code> 变更，需要进行 <code>cookie</code> 同步。</p><ul><li>来自客户端的 <code>cookie</code> 操作或者来自服务端的 <code>cookie</code> 设置，导致了 <code>NetWorking</code> 进程中的 <code>cookie</code> 变更，都会通过广播的方式告知所有 <code>WebContent</code> 进程同时进行变更操作。</li></ul></li><li><p>所有 <code>WebContent</code> 进程都会注册监听 <code>NetWorking</code> 进程中的 <code>cookie</code> 变更，及时进行相关变更的同步。</p><ul><li><p>前端 <code>setCookie</code> 操作会将 <code>cookie</code> 字符串解析为 <code>NSHTTPCookie</code> 实例，然后将该 <code>cookie</code> 存入 <code>cookieCache</code> 中，并同步到 <code>NetWorking</code> 进程中进行存储。</p></li><li><p>前端执行 <code>getCookie</code> 操作会读取当前页面域名下的所有 <code>cookie</code>，若判断 <code>cookieCache</code> 中没有当前页面域名下的 <code>cookie</code>，考虑到异常情况，会兜底向 <code>NetWorking</code> 进程发送请求进行 <code>cookie</code> 查找。</p></li></ul></li></ul><p><strong>WKWebView 的 cookie 问题</strong><br><code>UIWebView</code> 对 <code>cookie</code> 是通过 <code>NSHTTPCookieStorage</code> 来统一处理的，服务端响应时写入，<code>UIWebView</code> 发起请求会自动带上 <code>NSHTTPCookieStorage</code> 中的 <code>cookie</code>，<code>WKWebView</code> <code>Cookie</code> 问题在于 <code>WKWebView</code> 发起的请求不会自动带上存储于 <code>NSHTTPCookieStorage</code> 容器中的 cookie。因为 <code>WKWebView</code> 请求已不在 APP 进程中发起和响应处理，而是在单独进程中处理，所以 <code>WKWebView</code> 发起的请求无法直接从 <code>NSHTTPCookieStorage</code> 取到 <code>cookie</code>。</p><p>但是 <code>WKWebView</code> 其实会将 <code>Cookie</code> 存储于 <code>NSHTTPCookieStorage</code> 中的，但存储时机有延迟，在 iOS 8 上，当页面跳转的时候，当前页面的 <code>cookie</code> 会写入 <code>NSHTTPCookieStorage</code> 中，而在 iOS 10 上，JS 执行 <code>document.cookie</code> 或服务器 <code>set-cookie</code> 注入的 <code>cookie</code> 会很快同步到 <code>NSHTTPCookieStorage</code> 中。</p><p>所以当我们使用 Native 去做登录，登录完成后将 <code>cookie</code> 写入 <code>NSHTTPCookieStorage</code>，在 <code>UIWebView</code> 上不会有问题，在 <code>WKWebView</code> 上就不行了，原因就在于 <code>WKWebView</code> 不会从 <code>NSHTTPCookieStorage</code> 中获取 <code>cookie</code>，这就是常说的 <code>WKWebView</code> 的 <code>cookie</code> 问题。</p><p>iOS 11+ 可以利用 <code>WKHTTPCookieStore</code> 解决这个问题，因为只要是存在 <code>WKHTTPCookieStore</code> 里的 cookie，<code>WKWebView</code> 每次请求都会携带。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WKHTTPCookieStore</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/*! @abstract 获取所有 cookie @param completionHandler 获取所有 cookie 后回调 */</span></span><br><span class="line">- (<span class="type">void</span>)getAllCookies:(<span class="type">void</span> (^)(<span class="built_in">NSArray</span> *))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @abstract 设置一个 cookie  @param cookie 需要设置的 cookie  @param completionHandler cookie 设置成功的回调  */</span> </span><br><span class="line">- (<span class="type">void</span>)setCookie:(<span class="built_in">NSHTTPCookie</span> *)cookie completionHandler:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="type">void</span>))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @abstract 删除指定的 cookie  @param completionHandler cookie 成功删除的回调  */</span> </span><br><span class="line">- (<span class="type">void</span>)deleteCookie:(<span class="built_in">NSHTTPCookie</span> *)cookie completionHandler:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="type">void</span>))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>iOS 11 以下系统，可以在 <code>WKWebView</code> <code>loadRequest</code> 前，在 request header 中设置 <code>Cookie</code> 以解决该问题：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span> * webView = [<span class="built_in">WKWebView</span> new]; </span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> * request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;http://h5.qzone.qq.com/mqzone/index&quot;</span>]]; </span><br><span class="line"></span><br><span class="line">[request addValue:<span class="string">@&quot;skey=skeyValue&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Cookie&quot;</span>]; </span><br><span class="line">[webView loadRequest:request];</span><br></pre></td></tr></table></figure><p>对于(同域)Ajax、iframe 请求不携带 <code>cookie</code> 问题，可以使用如下方式解决：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKUserContentController</span>* userContentController = [<span class="built_in">WKUserContentController</span> new]; </span><br><span class="line"><span class="built_in">WKUserScript</span> * cookieScript = [[<span class="built_in">WKUserScript</span> alloc] initWithSource: <span class="string">@&quot;document.cookie = &#x27;skey=skeyValue&#x27;;&quot;</span> injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentStart</span> forMainFrameOnly:<span class="literal">NO</span>]; </span><br><span class="line"></span><br><span class="line">[userContentController addUserScript:cookieScript];</span><br></pre></td></tr></table></figure><p>这种方案无法解决 302 请求的 <code>Cookie</code> 问题，比如，第一个请求是 <code>www.a.com</code>， 我们通过在 <code>request header</code> 里带上 <code>Cookie</code> 解决该请求的 <code>Cookie</code> 问题，接着页面 302 跳转到 <code>www.b.com</code>， 这个时候 <code>www.b.com</code> 这个请求就可能因为没有携带 <code>cookie</code> 而无法访问。当然，由于每一次页面跳转前都会调用回调函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="type">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler;</span><br></pre></td></tr></table></figure><p>可以在该回调函数里拦截 302 请求，copy request，在 <code>request header</code> 中带上 <code>cookie</code> 并重新 <code>loadRequest</code>。不过这种方法依然解决不了页面 iframe 跨域请求的 <code>Cookie</code> 问题，毕竟-<code>[WKWebView loadRequest:]</code> 只适合加载 mainFrame 请求。</p><h4 id="3-WKWebView-NSURLProtocol-拦截问题"><a href="#3-WKWebView-NSURLProtocol-拦截问题" class="headerlink" title="(3) WKWebView NSURLProtocol 拦截问题"></a>(3) WKWebView NSURLProtocol 拦截问题</h4><p><code>WKWebView</code> 在独立于 APP 进程之外的进程中执行网络请求，请求数据不经过主进程，因此，在 <code>WKWebView</code> 上直接使用 <code>NSURLProtocol</code> 无法拦截请求。苹果开源的 webKit2 源码暴露了私有 API：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ [<span class="built_in">WKBrowsingContextController</span> registerSchemeForCustomProtocol:]</span><br></pre></td></tr></table></figure><p>通过注册 <code>http(s) scheme</code> 后 <code>WKWebView</code> 将可以使用 <code>NSURLProtocol</code> 拦截 <code>http(s)</code> 请求：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;WKBrowsingContextController”); </span></span><br><span class="line"><span class="string">SEL sel = NSSelectorFromString(@&quot;</span>registerSchemeForCustomProtocol:<span class="string">&quot;); </span></span><br><span class="line"><span class="string">if ([(id)cls respondsToSelector:sel]) &#123; </span></span><br><span class="line"><span class="string">           // 注册http(s) scheme, 把 http和https请求交给 NSURLProtocol处理 </span></span><br><span class="line"><span class="string">           [(id)cls performSelector:sel withObject:@&quot;</span>http<span class="string">&quot;]; </span></span><br><span class="line"><span class="string">           [(id)cls performSelector:sel withObject:@&quot;</span>https<span class="string">&quot;]; </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>iOS 11 上, <code>WebKit</code> 团队开放了 <code>WKWebView</code> 加载自定义资源的 API <code>WKURLSchemeHandler</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;    </span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];    </span><br><span class="line">    <span class="built_in">WKWebViewConfiguration</span> *configuration = [<span class="built_in">WKWebViewConfiguration</span> new];</span><br><span class="line">    <span class="comment">//设置URLSchemeHandler来处理特定URLScheme的请求，URLSchemeHandler需要实现WKURLSchemeHandler协议</span></span><br><span class="line">    <span class="comment">//本例中WKWebView将把URLScheme为customScheme的请求交由CustomURLSchemeHandler类的实例处理    </span></span><br><span class="line">    [configuration setURLSchemeHandler:[CustomURLSchemeHandler new] forURLScheme: <span class="string">@&quot;customScheme&quot;</span>];    </span><br><span class="line">    <span class="built_in">WKWebView</span> *webView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="keyword">self</span>.view.bounds configuration:configuration];    </span><br><span class="line">    <span class="keyword">self</span>.view = webView;    </span><br><span class="line">    [webView loadRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;customScheme://www.test.com&quot;</span>]]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>setURLSchemeHandler</code> 注册时机只能在 <code>WKWebView</code> 创建<code>WKWebViewConfiguration</code> 时注册。</li><li><code>WKWebView</code> 只允许开发者拦截自定义 <code>Scheme</code> 的请求，不允许拦截 “http”、“https”、“ftp”、“file” 等的请求，否则会 crash。</li><li>【补充】<code>WKWebView</code> 加载网页前，要在 <code>user-agent</code> 添加个标志，H5 遇到这个标识就使用 <code>customScheme</code>,否则就是用原来的 <code>http</code> 或 <code>https</code></li></ul><p>一般可以通过这种方式实现 H5 加载秒开，基本流程是提前预加载 html、js、css、图片类型文件，注册自定义 <code>WKURLSchemeHandler</code> 拦截资源请求，收到拦截请求后，先获取本地资源包对应的资源，转换成 data 回传给 webView 进行渲染处理；若本地没有，则 customScheme 替换成 https 的 url 重发请求通知 webview。注意由于只能拦截自定义的 Scheme 请求，所以必须和相关 H5 研发统一 Scheme。</p><p>但是这种方案目前存在两个严重缺陷：</p><ul><li>a、post 请求 body 数据被清空<br>由于 <code>WKWebView</code> 在独立进程里执行网络请求。一旦注册 http(s) scheme 后，网络请求将从 Network Process 发送到 App Process，这样 <code>NSURLProtocol</code> 才能拦截网络请求。在 webkit2 的设计里使用 <code>MessageQueue</code> 进行进程之间的通信，Network Process 会将请求 encode 成一个 Message，然后通过 IPC 发送给 App Process。出于性能的原因，encode 的时候 <code>HTTPBody</code> 和 <code>HTTPBodyStream</code> 这两个字段被丢弃掉了。</li></ul><p>因此，如果通过 <code>registerSchemeForCustomProtocol</code> 注册了 <code>http(s)</code> scheme, 那么由 <code>WKWebView</code> 发起的所有 <code>http(s)</code> 请求都会通过 IPC 传给主进程 <code>NSURLProtocol</code> 处理，导致 <code>post</code> 请求 body 被清空；</p><ul><li>b、对 ATS 支持不足<br>测试发现一旦打开 ATS 开关：Allow Arbitrary Loads 选项设置为 NO，同时通过 <code>registerSchemeForCustomProtocol</code> 注册了 <code>http(s)</code> scheme，<code>WKWebView</code> 发起的所有 <code>http</code> 网络请求将被阻塞（即便将Allow Arbitrary Loads in Web Content 选项设置为YES）；</li></ul><p><code>WKWebView</code> 可以注册 <code>customScheme</code>, 比如 <code>dynamic://</code> ，因此希望使用离线功能又不使用 <code>post</code> 方式的请求可以通过 <code>customScheme</code> 发起请求，比如 <code>dynamic://www.dynamicalbumlocalimage.com/</code>，然后在 app 进程 <code>NSURLProtocol</code> 拦截这个请求并加载离线数据。不足：使用 post 方式的请求该方案依然不适用，同时需要 H5 侧修改请求 scheme 以及 CSP 规则；</p><h3 id="3、WKWebView-Native-与-JS-互相调用"><a href="#3、WKWebView-Native-与-JS-互相调用" class="headerlink" title="3、WKWebView Native 与 JS 互相调用"></a>3、WKWebView Native 与 JS 互相调用</h3><p>在 <code>UIWebView</code> 时代没有提供系统级的函数进行 Web 与 Native 的交互，绝大部分 APP 都是通过 <code>WebViewJavascriptBridge</code>（下节介绍）来进行的通信。但是由于 <code>JavascriptCore</code> 的存在，对于 <code>UIWebView</code> 来说只要有效的获取到内部的 <code>JSContext</code>，也可以达到目的。目前已知有效的几个私有方法获取 <code>Context</code> 的方法如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过系统废弃函数获取 context</span></span><br><span class="line">- (<span class="type">void</span>)webView:(WebView *)webView didCreateJavaScriptContext:(JSContext *)context forFrame:(WebFrame *)frame;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 valueForKeyPath 获取 context</span></span><br><span class="line"><span class="keyword">self</span>.jsContext = [_webView valueForKeyPath:<span class="string">@&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];</span><br></pre></td></tr></table></figure><p>在 <code>WKWebView</code> 中提供了系统级的 Web 和 Native 通讯机制，通过 Message Handler 的封装使开发效率有了很大的提升。同时系统封装了 <code>JavaScript</code> 对象和 Objective-C 对象的转换逻辑，也进降低了使用的门槛。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js 端发送消息，postMessage 有且只有一个参数，可传 json(字典)、字符串、数组。如不传参数写 postMessage(null)。&#123;NAME&#125; 为 Message Handler 的 name</span></span><br><span class="line">window.webkit.messageHandlers.&#123;NAME&#125;.postMessage(<span class="string">&quot;xxxx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 Message Handler 的 name</span></span><br><span class="line">[<span class="keyword">self</span>.webView.configuration.userContentController addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@&quot;&#123;NAME&#125;&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Native 在回调中接收</span></span><br><span class="line">- (<span class="type">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message;  </span><br><span class="line"></span><br><span class="line">Objective-C 执行 js 代码也很简单：</span><br><span class="line">[webView evaluateJavaScript:<span class="string">@&quot;js 代码&quot;</span> completionHandler:^(<span class="type">id</span> _Nullable result, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>拦截自定义 Scheme 请求 - <code>WebViewJavascriptBridge</code><br>由于私有方法的稳定性与审核风险，开发者不愿意使用上文提到的 <code>UIWebView</code> 获取 <code>JSContext</code> 的方式进行通信，所以通常都采用基于 iframe 和自定义 Scheme 的 <code>JavascriptBridge</code> 进行通信。虽然在之后的 <code>WKWebView</code> 提供了系统函数，但是大部分 APP 都需要兼容 <code>UIWebView</code> 与 <code>WKWebView</code>，所以目前的使用范围仍然十分广泛。</p><p>在 Github 中类似的开源框架有很多，但是无外乎都是 Web 侧根据固定的格式创建包含通信信息的 Request，之后创建隐式 iFrame 节点请求；Native 侧在相应的 WebView 回调中解析 Request 的 Scheme，之后按照格式解析数据并处理。</p><p>而对于数据传递和回调处理的问题，在兼容两种 WebView、持续的更新的 <code>WebViewJavascriptBridge</code> 中，iFrame request 没有直接传递数据，而是 Web 和 Native 侧维护共同的参数或回调 Queue，Native 通过 Request 中 Scheme 的解析触发对 Queue 里数据的读取。<br><img src="/images/lix_blog_82.png"></p><p>备注：<br><code>WKWebView</code> 的缓存模式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSURLRequestCachePolicy</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> = <span class="number">0</span>,<span class="comment">//默认遵守http缓存策略</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span> = <span class="number">1</span>, <span class="comment">//忽略本地缓存</span></span><br><span class="line">    <span class="built_in">NSURLRequestReloadIgnoringLocalAndRemoteCacheData</span> = <span class="number">4</span>, <span class="comment">// Unimplemented //忽略本地和远程缓存</span></span><br><span class="line">    <span class="built_in">NSURLRequestReloadIgnoringCacheData</span> = <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>,</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span> = <span class="number">2</span>,<span class="comment">//只有当本地缓存不存在的时候才会请求，否则加载本地缓存</span></span><br><span class="line">    <span class="built_in">NSURLRequestReturnCacheDataDontLoad</span> = <span class="number">3</span>,<span class="comment">//只加载本地缓存，没有缓存也不会请求</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURLRequestReloadRevalidatingCacheData</span> = <span class="number">5</span>, <span class="comment">// Unimplemented //判断缓存是否过期</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、JavaScriptCore"><a href="#二、JavaScriptCore" class="headerlink" title="二、JavaScriptCore"></a>二、JavaScriptCore</h2><p>想用使用 <code>JavaScriptCore</code> 需要先导入头文件 <code>#import &lt;JavaScriptCore/JavaScriptCore.h&gt;</code>。我们先看下 JavaScriptCore.h 中的内容：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JavaScriptCore_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JavaScriptCore_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;JavaScriptCore/JavaScript.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;JavaScriptCore/JSStringRefCF.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__OBJC__) &amp;&amp; JSC_OBJC_API_ENABLED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;JavaScriptCore/JSContext.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;JavaScriptCore/JSValue.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;JavaScriptCore/JSManagedValue.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;JavaScriptCore/JSVirtualMachine.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;JavaScriptCore/JSExport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* JavaScriptCore_h */</span></span></span><br><span class="line"></span><br><span class="line">接下来分别介绍一下这几个文件：</span><br></pre></td></tr></table></figure><h3 id="1、JSVirtualMachine"><a href="#1、JSVirtualMachine" class="headerlink" title="1、JSVirtualMachine"></a>1、JSVirtualMachine</h3><p>一个 <code>JSVirtualMachine</code>（以下简称 JSVM）实例代表了一个自包含的 JS 运行环境，或者是一系列 JS 运行所需的资源。该类有两个主要的使用用途：一是支持并发的 JS 调用，二是管理 JS 和 Native 之间桥对象的内存。</p><p>既然 <code>JavaScriptCore</code> 被认为是一个虚拟机，那 JSVM 又是什么？实际上，JSVM 就是一个抽象的 JS 虚拟机，让开发者可以直接操作。在 APP 中，我们可以运行多个 JSVM 来执行不同的任务。而且每一个 <code>JSContext</code>（下节介绍）都从属于一个 JSVM，一个 JSVM 中可以有多个 <code>JSContext</code>。每个 JSVM 都有自己独立的堆空间，GC 也只能处理 JSVM 内部的对象。所以说，不同的 JSVM 之间是无法传递值（JSValue）的。<br><img src="/images/lix_blog_83.png"><br>在一个 JSVM 中，只有一条线程可以跑 JS 代码，所以我们无法使用 JSVM 进行多线程处理 JS 任务。如果我们需要多线程处理 JS 任务的场景，就需要同时生成多个 JSVM，从而达到多线程处理的目的。</p><p><strong>JS 的 GC 机制</strong><br>JS 同样也不需要我们去手动管理内存。JS 的内存管理使用的是 GC 机制（Tracing Garbage Collection）。不同于 OC 的引用计数，Tracing Garbage Collection 是由 <code>GCRoot</code>（<code>Context</code>）开始维护的一条引用链，一旦引用链无法触达某对象节点，这个对象就会被回收掉。如下图所示：<br><img src="/images/lix_blog_84.png"><br><code>JavaScriptCore</code> API 都是线程安全的。你可以在任意线程创建 <code>JSValue</code> 或者执行 JS 代码。如果一个线程正在使用 JSVM，所有其他想要使用该 JSVM 的线程都要等待。</p><h3 id="2、JSContext"><a href="#2、JSContext" class="headerlink" title="2、JSContext"></a>2、JSContext</h3><p>一个 <code>JSContext</code> 表示了一次 JS 的执行环境。我们可以通过创建一个 <code>JSContext</code> 去调用 JS 脚本，访问一些 JS 定义的值和函数，同时也提供了让 JS 访问 Native 对象，方法的接口。</p><p>例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSContext *context = [[JSContext alloc] init];</span><br><span class="line">[context evaluateScript:<span class="string">@&quot;var a = 1;var b = 2;&quot;</span>];</span><br><span class="line"><span class="comment">// evaluateScript: 返回值是 JavaScript 代码中最后一个生成的值</span></span><br><span class="line"><span class="built_in">NSInteger</span> sum = [[context evaluateScript:<span class="string">@&quot;a + b&quot;</span>] toInt32];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;sum = %ld&quot;</span>,(<span class="type">long</span>)sum);</span><br></pre></td></tr></table></figure><p>打印结果 <code>sum = 3</code></p><p><code>JSContext</code> 中有一个 <code>globalObject</code>，它返回当前执行 <code>JSContext</code> 的全局对象，在 <code>WebKit</code> 中的 <code>JSContext</code> 实例获取 <code>globalObject</code> 将返回对应<br><code>WindowProxy</code> 对象，实际上 JS 代码都是在这个 <code>globalObject</code> 上执行的，<code>JSContext</code> 只是 <code>globalObject</code> 的一层壳，为了理解方便，一般可以直接将 <code>JSContext</code> 等价地理解为 <code>globalObject</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JSContext</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">@property</span></span><br><span class="line"><span class="comment">@abstract Get the global object of the context.</span></span><br><span class="line"><span class="comment">@discussion This method retrieves the global object of the JavaScript execution context.</span></span><br><span class="line"><span class="comment"> Instances of JSContext originating from WebKit will return a reference to the</span></span><br><span class="line"><span class="comment"> WindowProxy object.</span></span><br><span class="line"><span class="comment">@result The global object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">strong</span>) JSValue *globalObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 JS 中，对象就是一个引用类型的实例。与我们熟悉的 OC、Java 不一样，对象并不是一个类的实例，因为在 JS 中并不存在类的概念。ECMA 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。从这个定义我们可以发现，JS 中的对象就是无序的键值对，这和 OC 中的 <code>NSDictionary</code> 何其相似。所以，我们可以把 <code>globalObject</code> 转成 <code>NSDictionary</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSContext *context = [[JSContext alloc] init];</span><br><span class="line">[context evaluateScript:<span class="string">@&quot;var a = 1;var b = 2;&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[context.globalObject toDictionary]);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    a = 1;</span><br><span class="line">    b = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个 <code>globalObject</code> 保存了所有的变量（函数也会保存在 <code>globalObject</code> 里）。</p><p>另外，我们可以通过 <code>exceptionHandler</code> 回调来监听来自 JS 的异常：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, exception);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h3 id="3、JSValue"><a href="#3、JSValue" class="headerlink" title="3、JSValue"></a>3、JSValue</h3><p><code>JSValue</code> 实例是一个指向 JS 值的引用指针。我们可以使用 JSValue 类，在 OC 和 JS 的基础数据类型之间相互转换。同时我们也可以使用这个类，去创建包装了 Native 自定义类的 JS 对象，或者是那些由 Native 方法或者<code> Block</code> 提供实现 JS 方法的 JS 对象。</p><p>每个 <code>JSValue</code> 实例都来源于一个代表 <code>JavaScript</code> 执行环境的 <code>JSContext</code> 对象，这个执行环境就包含了这个 <code>JSValue</code> 对应的值。每个 <code>JSValue</code> 对象都持有其 <code>JSContext</code> 对象的强引用，只要有任何一个与特定 <code>JSContext</code> 关联的 <code>JSValue</code> 被持有（<code>retain</code>），这个 <code>JSContext</code> 就会一直存活。通过调用 <code>JSValue</code> 的实例方法返回的其他的 <code>JSValue</code> 对象都属于与最始的 <code>JSValue</code> 相同的 <code>JSContext</code>。</p><p>每个 <code>JSValue</code> 都通过其 <code>JSContext</code> 间接关联了一个特定的代表执行资源基础的 <code>JSVirtualMachine</code> 对象。只能将一个 <code>JSValue</code> 对象传给由相同虚拟机管理的 <code>JSValue</code> 或者 <code>JSContext</code> 的实例方法。如果尝试把一个虚拟机的 <code>JSValue</code> 传给另一个虚拟机，将会触发一个 Objective-C 异常。<br><img src="/images/lix_blog_85.png"></p><h3 id="4、JSManagedValue"><a href="#4、JSManagedValue" class="headerlink" title="4、JSManagedValue"></a>4、JSManagedValue</h3><p>Objective-C 用的是 ARC，不能自动解决循环引用问题，需要开发者手动处理，而 <code>JavaScript</code> 用的是 GC，所有的引用都是强引用，但是垃圾回收器会解决循环引用问题，<code>JavaScriptCore</code> 也一样，一般来说，大多数时候不需要我们去手动管理内存，但是有些情况需要注意：<br>不要在在一个导出到 <code>JavaScript</code> 的 native 对象中持有 <code>JSValue</code> 对象。因为每个 <code>JSValue</code> 对象都包含了一个 <code>JSContext</code> 对象，这种关系将会导致循环引用，因而可能造成内存泄漏。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JSValue *value = [JSValue valueWithObject:<span class="string">@&quot;test&quot;</span> inContext:context];</span><br><span class="line">context[<span class="string">@&quot;block&quot;</span>] = ^()&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通常我们使用 <code>weak</code> 来修饰 <code>block</code> 内需要使用的外部引用以避免循环引用，由于 <code>JSValue</code> 对应的 JS 对象内存由虚拟机进行管理并负责回收，这种方法不能准确地控制 <code>block</code> 内的引用 <code>JSValue</code> 的生命周期，可能在 <code>block</code> 内需要使用 <code>JSValue</code> 的时候，其已经被虚拟机回收。<br><img src="/images/lix_blog_202.png"><br>因为 <code>JSValue</code> 的引用计数为 0，所以早早就被释放了，不能达到我们的预期。</p><p>Apple 引入了有条件的强引用：conditional retain，而对应的类就叫 <code>JSManagedValue</code>。<br>一个 <code>JSManagedValue</code> 对象包含了一个 <code>JSValue</code> 对象，“有条件地持有（conditional retain）”的特性使其可以自动管理内存。</p><p>最基本的用法就是用来在导入到 <code>JavaScript</code> 的 native 对象中存储 <code>JSValue</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSValue *value = [JSValue valueWithObject:<span class="string">@&quot;test&quot;</span> inContext:context];</span><br><span class="line">JSManagedValue *managedValue = [JSManagedValue managedValueWithValue:value     andOwner:<span class="keyword">self</span>];</span><br><span class="line">context[<span class="string">@&quot;block&quot;</span>] = ^()&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [managedValue value]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所谓“有条件地持有（conditional retain）”，是指在以下两种情况任何一个满足的情况下保证其管理的 <code>JSValue</code> 被持有：</p><ul><li>可以通过 <code>JavaScript</code> 的对象图找到该 <code>JSValue</code>。</li><li>可以通过 native 对象图找到该 <code>JSManagedValue</code>。</li></ul><p>使用 <code>addManagedReference:withOwner:</code> 方法可向虚拟机记录该关系。反之如果以上条件都不满足，<code>JSManagedValue</code> 对象就会将其 <code>value</code> 置为 <code>nil</code> 并释放该 <code>JSValue</code>。<br><img src="/images/lix_blog_203.png" alt="upload successful"></p><h3 id="5、JSExport"><a href="#5、JSExport" class="headerlink" title="5、JSExport"></a>5、JSExport</h3><p>实现 <code>JSExport</code> 协议可以开放 OC 类和它们的实例方法、类方法，以及属性给 JS 调用。<br>而通常情况下，我们如果想在 JS 环境中使用 OC 中的类和对象，需要它们实现 <code>JSExport</code> 协议，来确定暴露给 JS 环境中的属性和方法。比如我们需要向 JS 环境中暴露一个 <code>Person</code> 的类与获取名字的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">PersonProtocol</span> &lt;<span class="title">JSExport</span>&gt;</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)fullName; <span class="comment">// fullName 用来拼接 firstName 和 lastName，并返回全名</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JSExportPerson</span> : <span class="title">NSObject</span> &lt;<span class="title">PersonProtocol</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">- (<span class="built_in">NSString</span> *)sayFullName ;<span class="comment">// sayFullName 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *lastName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后，我们可以把一个 <code>JSExportPerson</code> 的一个实例传入 <code>JSContext</code>，并且可以直接执行 <code>fullName</code> 方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> JSExportPerson *person = [[JSExportPerson alloc] init];</span><br><span class="line">context[<span class="string">@&quot;person&quot;</span>] = person;</span><br><span class="line">person.firstName = <span class="string">@&quot;li&quot;</span>;</span><br><span class="line">person.lastName =<span class="string">@&quot;fengfeng&quot;</span>;</span><br><span class="line">[context evaluateScript:<span class="string">@&quot;log(person.fullName())&quot;</span>]; <span class="comment">//调 Native方 法，打印出 person 实例的全名</span></span><br><span class="line">[context evaluateScript:<span class="string">@&quot;person.sayFullName())&quot;</span>]; <span class="comment">// 提示 TypeError，&#x27;person.sayFullName&#x27; is undefined</span></span><br></pre></td></tr></table></figure><p>这就是一个很简单的使用 <code>JSExport</code> 的例子，但请注意，我们只能调用在该对象在 <code>JSExport</code> 中开放出去的方法，如果并未开放出去，如上例中的 <code>sayFullName</code> 方法，直接调用则会报 <code>TypeError</code> 错误，因为该方法在 JS 环境中并未被定义。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSNotification 实现原理</title>
      <link href="/posts/61952/"/>
      <url>/posts/61952/</url>
      
        <content type="html"><![CDATA[<h2 id="一、NSNotification-的基本使用"><a href="#一、NSNotification-的基本使用" class="headerlink" title="一、NSNotification 的基本使用"></a>一、NSNotification 的基本使用</h2><h3 id="1、NSNotification"><a href="#1、NSNotification" class="headerlink" title="1、NSNotification"></a>1、NSNotification</h3><p><code>NSNotification</code> 的定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNotification</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知名称，通知的唯一标识</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSNotificationName</span> name;</span><br><span class="line"><span class="comment">// 任意对象，通常是通知发送者。如果设置了值，注册的通知监听器的 object 需要与通知的 object 匹配，否则接收不到通知</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="type">id</span> object;</span><br><span class="line"><span class="comment">// 通知的附加信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *userInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSNotification 指定初始化方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSNotificationName</span>)name object:(<span class="keyword">nullable</span> <span class="type">id</span>)object userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)userInfo API_AVAILABLE(macos(<span class="number">10.6</span>), ios(<span class="number">4.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)) <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)coder <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>NSNotification</code> 中有一个初始化方法，除了使用该方法进行初始化，还可以使用 <code>NSNotification(NSNotificationCreation)</code> 分类中定义的初始化方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNotification</span> (<span class="title">NSNotificationCreation</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)notificationWithName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)notificationWithName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init <span class="comment">/*API_UNAVAILABLE(macos, ios, watchos, tvos)*/</span>;    <span class="comment">/* do not invoke; not a valid initializer for this class */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 <code>NSNotification(NSNotificationCreation</code>) 分类中对 <code>init</code> 方法注释提示不要用来初始化。如果使用 <code>init</code> 方法初始化 <code>NSNotification</code> 会发生如下 Crash：<br><img src="/images/lix_blog_76.png"><br>不过，开发时一般不会手动创建 <code>NSNotification</code>，而是使用 <code>NSNotificationCenter</code> 创建并发送通知。</p><h3 id="2、NSNotificationCenter"><a href="#2、NSNotificationCenter" class="headerlink" title="2、NSNotificationCenter"></a>2、NSNotificationCenter</h3><p><code>NSNotificationCenter</code> 提供了一个 <code>defaultCenter</code> 属性，用于获取 <code>NSNotificationCenter</code> 单例，并且提供了添加观察者、发送通知、移除通知的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSNotificationCenter</span> *defaultCenter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加通知观察者</span></span><br><span class="line">- (<span class="type">void</span>)addObserver:(<span class="type">id</span>)observer selector:(SEL)aSelector name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject;</span><br><span class="line">- (<span class="type">id</span> &lt;<span class="built_in">NSObject</span>&gt;)addObserverForName:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)name object:(<span class="keyword">nullable</span> <span class="type">id</span>)obj queue:(<span class="keyword">nullable</span> <span class="built_in">NSOperationQueue</span> *)queue usingBlock:(<span class="type">void</span> (^)(<span class="built_in">NSNotification</span> *note))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发出通知</span></span><br><span class="line">- (<span class="type">void</span>)postNotification:(<span class="built_in">NSNotification</span> *)notification;</span><br><span class="line">- (<span class="type">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject;</span><br><span class="line">- (<span class="type">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除通知观察者</span></span><br><span class="line">- (<span class="type">void</span>)removeObserver:(<span class="type">id</span>)observer;</span><br><span class="line">- (<span class="type">void</span>)removeObserver:(<span class="type">id</span>)observer name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="type">id</span>)anObject;</span><br></pre></td></tr></table></figure><p>发送通知的时候，可以指定 <code>notificationName</code> 和 <code>object</code>：</p><ul><li>若 <code>notificationName</code> 为 <code>nil</code>，通知中心会通知所有与该通知中 <code>object</code> 相匹配的监听对象；</li><li>若 <code>anObject</code> 为 <code>nil</code>，通知中心会通知所有与该通知中 <code>notificationName</code> 相匹配的监听对象。</li><li>如果 <code>notificationName</code> 与 <code>anObject</code> 均为 <code>nil</code>，监听者将会收到所有发出的通知。</li></ul><p><strong>可以看到，添加通知观察者除了我们常用的 <code>addObserver:selector:name:object:</code> 外，还有个 <code>addObserverForName:object:queue:usingBlock:</code>，这两种方式有什么区别呢？</strong></p><p><code>NSNotification</code> 的发送和通知接收回调是在同一线程的，这点可以通过一个例子验证下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)btnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;发送通知：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kNotificationName object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)notificationAction:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;收到通知：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">收到通知：&lt;NSThread: 0x6000036a2900&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">发送通知：&lt;NSThread: 0x6000036a2900&gt;&#123;number = 7, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>但是，我们有时候是在子线程发出通知，想要在收到通知的时候在主线程更新 UI，除了在收到通知后主动切换到主线程外，还可以使用 <code>addObserverForName:object:queue:usingBlock:</code> 方法实现，该方法可以指定一个收到通知的 <code>block</code> 在哪个队列执行，我们可以指定主队列：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:kNotificationName object:<span class="literal">nil</span> queue:[<span class="built_in">NSOperationQueue</span> mainQueue] usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;收到通知：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)btnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;发送通知：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kNotificationName object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发送通知：&lt;NSThread: 0x600001420f00&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">收到通知：&lt;NSThread: 0x600001464880&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在子线程发出通知，但是收到通知的 <code>block</code> 是在主线程的。</p><p>这两个方法添加监听者还有一个很重要的区别，就是在 iOS 9 之后，<code>addObserver:selector:name:object:</code> 添加的监听者，在监听者对象释放之前不再需要手动移除监听（iOS 9 之前是需要的）。这是因为在 iOS 9 以后，通知中心持有的观察者由 <code>unsafe_unretained</code> 引用变为 <code>weak</code> 引用，<code>unsafe_unretained</code> 就是 iOS 5 版本以下的 <code>assign</code>，<code>assign</code> 与 <code>unsafe_unretained</code> 修饰对象会产生野指针的问题，修饰的对象释放后，指针不会自动置成 <code>nil</code>，此时再向对象发消息程序会崩溃。而 weak 会在对象释放后置为 <code>nil</code>，所以 iOS 9 之后，不移除监听者也不会引起访问野指针的 Crash 了。</p><p>Apple 文档涉及到这块的描述：</p><blockquote><p>If your app targets iOS 9.0 and later or macOS 10.11 and later, you don’t need to unregister an observer in its dealloc method. Otherwise, you should call removeObserver:name:object: before observer or any object passed to this method is deallocated.</p></blockquote><p>而 <code>addObserverForName:object:queue:usingBlock:</code> 方法添加的监听在 iOS 9 之后仍然需要手动移除监听，因为 <code>NSNotificationCenter</code> 对该方法注册的监听者是强引用，如不移除虽然不会引起 Crash，但是会导致内存泄露。</p><p>Apple 文档涉及到这块的描述：</p><blockquote><p>To unregister observations, you pass the object returned by this method to removeObserver:. You must invoke removeObserver: or removeObserver:name:object:before any object specified by addObserverForName:object:queue:usingBlock:is deallocated.</p></blockquote><p>文档中也已经指出，<code>addObserverForName:object:queue:usingBlock:</code> 会有一个返回值，将该返回值传给 <code>removeObserver:</code> 方法即可移除监听。</p><h3 id="3、NSNotificationQueue"><a href="#3、NSNotificationQueue" class="headerlink" title="3、NSNotificationQueue"></a>3、NSNotificationQueue</h3><p><code>NSNotificationQueue</code> 用于通知消息的管理，如消息发送时机、消息合并策略，并且为 FIFO（先入先出）方式管理消息，但实际消息的发送仍然是在指定时机自动使用 <code>NSNotificationCenter</code> 发送的。每个线程都有一个默认的通知队列，即 <code>NSNotificationQueue</code>，它与 APP 默认的 <code>NSNofitifcationCenter</code> 关联。</p><p><code>NSNotificationQueue</code> 中定义的属性与方法如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取线程默认的 NSNotificationQueue</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSNotificationQueue</span> *defaultQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的 NSNotificationQueue 并指定 NSNotificationCenter</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNotificationCenter:(<span class="built_in">NSNotificationCenter</span> *)notificationCenter <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队列中添加通知</span></span><br><span class="line">- (<span class="type">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle;</span><br><span class="line">- (<span class="type">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle coalesceMask:(<span class="built_in">NSNotificationCoalescing</span>)coalesceMask forModes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队列中移除通知</span></span><br><span class="line">- (<span class="type">void</span>)dequeueNotificationsMatching:(<span class="built_in">NSNotification</span> *)notification coalesceMask:(<span class="built_in">NSUInteger</span>)coalesceMask;</span><br></pre></td></tr></table></figure><p>向队列中添加通知时的参数含义如下：<br><code>postingStyle：</code>用于配置通知什么时候发送</p><ul><li><code>NSPostASAP</code>：Posting As Soon As Possible，在当前通知调用或者计时器结束发送通知。发送时机早于 <code>NSPostWhenIdle</code>，<code>kCFRunLoopBeforeTimers</code> 与 <code>kCFRunLoopBeforeSources</code> 之间发送通知。</li><li><code>NSPostWhenIdle</code>：当 runloop 处于空闲时发出通知。在 <code>kCFRunLoopBeforeWaiting</code> 与 <code>kCFRunLoopAfterWaiting</code> 之间发生通知。</li><li><code>NSPostNow</code>：在合并通知完成之后立即发出通知。</li></ul><p>需要注意的是，如果 <code>postingStyle</code> 参数不是 <code>NSPostNow</code>，并且是在子线程，需要保证子线程 runloop 已经开启；如果是 <code>NSPostNow</code>，则和直接使用 <code>NSNotificationCenter</code> 发送通知效果一样无需开启 runloop。</p><p><code>coalesceMask</code>（注意这是一个 <code>NS_OPTIONS</code> 参数）：用于配置如何合并通知，即移除重复的通知</p><ul><li><code>NSNotificationNoCoalescing</code>：不合并通知（无论 <code>name</code> 和 object 是否相同都不移除通知）</li><li><code>NSNotificationCoalescingOnName</code>：按照通知名字合并通知</li><li><code>NSNotificationCoalescingOnSender</code>：按照传入的 <code>object</code> 合并通知</li></ul><p><code>modes</code>：runloop 的 mode，指定 mode 后，只有当前线程的 runloop 在指定的 mode 下才能将通知自动发送到通知中心。</p><p>例如，将通知添加到队列，并指定 runloop 空闲时发送通知：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kNotificationName = <span class="string">@&quot;kNotificationName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加监听</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter]addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(notificationAction:) name:kNotificationName object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)notificationAction:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;收到通知：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮点击事件</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)btnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(postNotification) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)postNotification &#123;    </span><br><span class="line">    <span class="built_in">NSNotification</span> *notification = [<span class="built_in">NSNotification</span> notificationWithName:kNotificationName object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// 将通知添加到队列，并指定 runloop 空闲时发送通知，不合并通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationQueue</span> defaultQueue] enqueueNotification:notification postingStyle:<span class="built_in">NSPostWhenIdle</span> coalesceMask:<span class="built_in">NSNotificationNoCoalescing</span> forModes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSThread</span> *)thread &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_thread) &#123;</span><br><span class="line">        _thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加 runloop 状态监听</span></span><br><span class="line">            <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">                    <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopEntry&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeTimers&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeSources&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeWaiting&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopAfterWaiting&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopExit&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line">            <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 线程保活</span></span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">        &#125;];</span><br><span class="line">        [_thread start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>按钮点击打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kCFRunLoopEntry</span><br><span class="line">kCFRunLoopBeforeTimers</span><br><span class="line">kCFRunLoopBeforeSources</span><br><span class="line">kCFRunLoopExit</span><br><span class="line">kCFRunLoopEntry</span><br><span class="line">kCFRunLoopBeforeTimers</span><br><span class="line">kCFRunLoopBeforeSources</span><br><span class="line">kCFRunLoopBeforeWaiting</span><br><span class="line">收到通知：&lt;NSThread: 0x600000f13c80&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">kCFRunLoopAfterWaiting</span><br><span class="line">kCFRunLoopBeforeTimers</span><br><span class="line">kCFRunLoopBeforeSources</span><br><span class="line">kCFRunLoopBeforeWaiting</span><br></pre></td></tr></table></figure><p>可以看到，如果我们指定了在 runloop 空闲时发送通知，则会在 runloop 即将进入休眠时发送通知。</p><h2 id="二、NSNotification-实现原理"><a href="#二、NSNotification-实现原理" class="headerlink" title="二、NSNotification 实现原理"></a>二、NSNotification 实现原理</h2><p>由于苹果对 <code>NSNotification</code> 是不开源的，GNUstep 将 Cocoa 的 OC 库重新开源实现了一遍，虽然 GNUstep（<a href="https://github.com/gnustep/libs-base%EF%BC%89">https://github.com/gnustep/libs-base）</a> 不是苹果官方源码，但还是具有一定的参考价值。</p><p>根据 GNUstep 相关源码可知，<code>NSNotificationCenter</code> 中持有了一个 <code>_table</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNotificationCenter</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">  <span class="type">void</span>  *_table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 NSNotificationCenter.m 中：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSNotificationCenter</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>) init &#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) != <span class="literal">nil</span>) &#123;</span><br><span class="line">      _table = newNCTable();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> NCTable *newNCTable(<span class="type">void</span>) &#123;</span><br><span class="line">  NCTable   *t;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>可以知道，<code>NSNotificationCenter</code> 持有了一个 <code>NCTable</code> 类型的 <code>_table</code>，<code>NCTable</code> 是一个结构体，简化后的结构如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> NCTbl &#123;</span><br><span class="line">  Observation       *wildcard;  <span class="comment">// 链表结构，保存既没有 name 也没有 object 的通知</span></span><br><span class="line">  GSIMapTable       nameless;   <span class="comment">// 存储无 name 、有 object 的通知</span></span><br><span class="line">  GSIMapTable       named;      <span class="comment">// 存储有 name 的通知（不管有没有 object）</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; NCTable;</span><br></pre></td></tr></table></figure><p>其中 <code>Observation</code> 结构如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Obs &#123;</span><br><span class="line">    <span class="type">id</span>        observer;       <span class="comment">// 保存接受消息的对象</span></span><br><span class="line">    SEL       selector;       <span class="comment">// 保存注册通知时传入的 SEL</span></span><br><span class="line">    <span class="keyword">struct</span> Obs    *next;      <span class="comment">// 保存注册了同一个通知的下一个观察者</span></span><br><span class="line">    <span class="keyword">struct</span> NCTbl  *link;      <span class="comment">// 保存该 Observation 的 NCTable</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; Observation;</span><br></pre></td></tr></table></figure><p>关于其中 <code>GSIMapTable</code> 等详细结构，接下来从源码实现上来看。</p><h3 id="1、addObserver-selector-name-object-方法的实现"><a href="#1、addObserver-selector-name-object-方法的实现" class="headerlink" title="1、addObserver:selector:name:object: 方法的实现"></a>1、addObserver:selector:name:object: 方法的实现</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>) addObserver: (<span class="type">id</span>)observer</span><br><span class="line">            selector: (SEL)selector</span><br><span class="line">                name: (<span class="built_in">NSString</span>*)name </span><br><span class="line">                object: (<span class="type">id</span>)object &#123;</span><br><span class="line">  Observation   *list;</span><br><span class="line">  Observation   *o;</span><br><span class="line">  GSIMapTable   m;</span><br><span class="line">  GSIMapNode    n;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个 observation 对象，持有监听者和 SEL，下面进行的所有逻辑就是为了存储它</span></span><br><span class="line">  o = obsNew(TABLE, selector, observer);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// case 1： 有 name，存储到 named 表</span></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    <span class="comment">// NAMED 是个宏：(NCTable*)_table-&gt;named</span></span><br><span class="line">    <span class="comment">// 以 name 为 key，从 named 表中获取对应的 GSIMapNode 类型的 value</span></span><br><span class="line">      n = GSIMapNodeForKey(NAMED, (GSIMapKey)(<span class="type">id</span>)name);</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; </span><br><span class="line">          <span class="comment">// 不存在，则创建 </span></span><br><span class="line">          m = mapNew(TABLE);</span><br><span class="line">          GSIMapAddPair(NAMED, (GSIMapKey)(<span class="type">id</span>)name, (GSIMapVal)(<span class="type">void</span>*)m);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123; </span><br><span class="line">          <span class="comment">// 存在则把值取出来 赋值给 m</span></span><br><span class="line">          m = (GSIMapTable)n-&gt;value.ptr;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 以 object 为 key，从字典 m 中取出对应的 GSIMapNode 类型的 value</span></span><br><span class="line">      n = GSIMapNodeForSimpleKey(m, (GSIMapKey)object);</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 不存在，则创建 </span></span><br><span class="line">          o-&gt;next = ENDOBS;</span><br><span class="line">          GSIMapAddPair(m, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          list = (Observation*)n-&gt;value.ptr;</span><br><span class="line">          o-&gt;next = list-&gt;next;</span><br><span class="line">          list-&gt;next = o;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// case2：无 name 、有 object，存储到 nameless 表 </span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (object) &#123;</span><br><span class="line">      <span class="comment">// NAMELESS 也是个宏：(NCTable*)_table-&gt;nameless</span></span><br><span class="line">      <span class="comment">// 以 object 为 key，从 nameless 表中取出对应的 value（Observation 类型）</span></span><br><span class="line">      n = GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object);</span><br><span class="line">      <span class="comment">// 不存在则新建链表，并存到 map 中</span></span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; </span><br><span class="line">          o-&gt;next = ENDOBS;</span><br><span class="line">          GSIMapAddPair(NAMELESS, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">// 存在 则把值接到链表的节点上</span></span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// case3：无 name &amp; 无 object，则存储到 wildcard 链表</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// WILDCARD 也是个宏：(NCTable*)_table-&gt;wildcard</span></span><br><span class="line">      o-&gt;next = WILDCARD;</span><br><span class="line">      WILDCARD = o;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该流程总结：</strong><br><img src="/images/lix_blog_77.png"><br>根据以上各字段数据结构可知，无论是否存在 <code>name</code> 和 <code>object</code>，最终监听者等信息都是存储在 <code>Observation</code> 链表当中的，只不过获取该 <code>Observation</code> 链表的路径不一样。</p><ul><li><p>创建 <code>Observation</code>，添加监听者实际上就是存储 <code>Observation</code> 的过程。</p><ul><li><code>Observation</code> 是一个链表，其中存储了 <code>observer</code>、<code>selector</code> 信息，以及指向下一个 <code>Observation</code> 的 <code>next</code> 指针。</li></ul></li><li><p><code>NSNotificationCenter</code> 持有了一个 <code>NCTable</code> 类型的 <code>_table</code>，根据添加监听时 <code>name</code>、<code>object</code> 参数的情况，决定 <code>Observation</code> 存储在 <code>NCTable</code> 中的哪一个字段中。</p></li><li><p>如果 <code>name</code> 存在：</p><ul><li>则向 <code>named</code> 表中插入元素，<code>key</code> 为 <code>name</code>，<code>value</code> 为 <code>GSIMaptable</code>。</li><li><code>GSIMaptable</code> 中 <code>key</code> 为 <code>object</code>，<code>value</code> 为 <code>Observation</code>。</li></ul></li><li><p>如果 <code>name</code> 不存在：</p><ul><li>则向 <code>nameless</code> 表中插入元素，<code>key</code> 为 <code>object</code>，<code>value</code> 为 <code>Observation</code>。</li></ul></li><li><p>如果 <code>name</code> 和 <code>object</code> 都不存在：</p><ul><li>则把这个 <code>Observation</code> 添加 <code>WILDCARD</code> 链表中。</li></ul></li></ul><p>这里需要注意的是，如果监听者重复注册了多次监听，通知发送时将会收到多次通知。</p><h3 id="2、addObserverForName-object-queue-usingBlock-方法的实现"><a href="#2、addObserverForName-object-queue-usingBlock-方法的实现" class="headerlink" title="2、addObserverForName:object:queue:usingBlock: 方法的实现"></a>2、addObserverForName:object:queue:usingBlock: 方法的实现</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>) addObserverForName: (<span class="built_in">NSString</span> *)name </span><br><span class="line">                   object: (<span class="type">id</span>)object </span><br><span class="line">                    queue: (<span class="built_in">NSOperationQueue</span> *)queue </span><br><span class="line">               usingBlock: (GSNotificationBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个临时监听者</span></span><br><span class="line">    GSNotificationObserver *observer = </span><br><span class="line">        [[GSNotificationObserver alloc] initWithQueue: queue block: block];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用了 addObserver:selector:name:object: 注册监听者</span></span><br><span class="line">    [<span class="keyword">self</span> addObserver: observer </span><br><span class="line">             selector: <span class="keyword">@selector</span>(didReceiveNotification:) </span><br><span class="line">                 name: name </span><br><span class="line">               object: object];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回监听者</span></span><br><span class="line">    <span class="keyword">return</span> observer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>) didReceiveNotification: (<span class="built_in">NSNotification</span> *)notif</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_queue != <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果 queue 不为空，在该队列中执行 block；</span></span><br><span class="line">        GSNotificationBlockOperation *op = [[GSNotificationBlockOperation alloc] </span><br><span class="line">            initWithNotification: notif block: _block];</span><br><span class="line"></span><br><span class="line">        [_queue addOperation: op];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果 queue 为空，直接在当前线程执行 block；</span></span><br><span class="line">        <span class="built_in">CALL_BLOCK</span>(_block, notif);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据该方法源码可以看到该方法的实现就比较简单了：</p><ul><li>创建一个临时监听者，并调用 <code>addObserver:selector:name:object:</code> 方法注册监听者</li><li>监听者收到通知时，在指定的队列 <code>queue</code> 中执行 <code>block</code>。如果 <code>queue</code> 为空，直接在当前线程执行 <code>block</code>。</li></ul><h3 id="3、postNotificationName-object-userInfo-方法的实现"><a href="#3、postNotificationName-object-userInfo-方法的实现" class="headerlink" title="3、postNotificationName:object:userInfo: 方法的实现"></a>3、postNotificationName:object:userInfo: 方法的实现</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>) postNotificationName: (<span class="built_in">NSString</span>*)name</span><br><span class="line">               object: (<span class="type">id</span>)object</span><br><span class="line">             userInfo: (<span class="built_in">NSDictionary</span>*)info</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 构造 GSNotification 对象（NSNotification 子类），并赋值 name、object、info</span></span><br><span class="line">  GSNotification    *notification;</span><br><span class="line">  notification = (<span class="type">id</span>)<span class="built_in">NSAllocateObject</span>(concrete, <span class="number">0</span>, <span class="built_in">NSDefaultMallocZone</span>());</span><br><span class="line">  notification-&gt;_name = [name copyWithZone: [<span class="keyword">self</span> zone]];</span><br><span class="line">  notification-&gt;_object = [object <span class="keyword">retain</span>];</span><br><span class="line">  notification-&gt;_info = [info <span class="keyword">retain</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送通知</span></span><br><span class="line">  [<span class="keyword">self</span> _postAndRelease: notification];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送通知，主要做了三件事：查找、发送、释放</span></span><br><span class="line">- (<span class="type">void</span>) _postAndRelease: (<span class="built_in">NSNotification</span>*)notification &#123;</span><br><span class="line">    <span class="comment">// step1: 从 named、nameless、wildcard 表中查找对应的通知</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// step2：执行发送，即调用 performSelector 执行响应方法，从这里可以看出是同步的</span></span><br><span class="line">    count = GSIArrayCount(a);</span><br><span class="line">    <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        o = GSIArrayItemAtIndex(a, count).ext;</span><br><span class="line">          <span class="keyword">if</span> (o-&gt;next != <span class="number">0</span>)&#123;</span><br><span class="line">                [o-&gt;observer performSelector: o-&gt;selector</span><br><span class="line">                withObject: notification];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// step3: 释放资源</span></span><br><span class="line">    RELEASE(notification);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上逻辑也比较简单：</p><ul><li>创建 <code>notification</code> 对象</li><li>根据 <code>name</code> &amp; <code>object</code> 查找所有符合的 <code>Observation</code>，并保存到数组中。</li><li>遍历数组，使用 <code>performSelector:</code> 逐一同步调用 <code>sel</code></li><li>释放 <code>notification</code> 对象</li></ul><h2 id="三、NSNotification-与多线程"><a href="#三、NSNotification-与多线程" class="headerlink" title="三、NSNotification 与多线程"></a>三、NSNotification 与多线程</h2><h3 id="1、NSNotification-的发送和通知接收回调是在同一线程的"><a href="#1、NSNotification-的发送和通知接收回调是在同一线程的" class="headerlink" title="1、NSNotification 的发送和通知接收回调是在同一线程的"></a>1、NSNotification 的发送和通知接收回调是在同一线程的</h3><p>这点前面已经使用一个例子验证了，我们有时候是在子线程发出通知，想要在收到通知的时候在主线程更新 UI，除了在收到通知后主动切换到主线程外，还可以使用 <code>addObserverForName:object:queue:usingBlock:</code> 方法指定在主队列执行 <code>block</code> 的方式去实现。</p><p>其实 Apple 官方文档里还介绍了一种实现方案：使用 Mach Port 将通知转发到指定线程。假设在子线程发送通知，想在主线程处理通知，使用该方案的实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kNotificationName = <span class="string">@&quot;kNotificationName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSMachPortDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>    *notifications;</span><br><span class="line"><span class="comment">// 期望线程</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSThread</span>          *notificationThread;</span><br><span class="line"><span class="comment">// 用于对通知队列加锁的锁对象，避免线程冲突</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSLock</span>            *notificationLock;</span><br><span class="line"><span class="comment">// 向期望线程发送信号的通信端口（Mach Port）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMachPort</span>        *notificationPort;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">    </span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">self</span>.notifications = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.notificationLock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 期望线程为主线程</span></span><br><span class="line">    <span class="keyword">self</span>.notificationThread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">    <span class="keyword">self</span>.notificationPort = [[<span class="built_in">NSMachPort</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加端口代理，收到 Mach Message 后会执行 handleMachMessage: 方法</span></span><br><span class="line">    <span class="keyword">self</span>.notificationPort.delegate = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 往当前线程（主线程）的 runloop 添加端口源</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:<span class="keyword">self</span>.notificationPort</span><br><span class="line">                                forMode:(__bridge <span class="built_in">NSString</span> *)kCFRunLoopCommonModes];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加监听者</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(processNotification:) name:kNotificationName object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">// 在子线程发送通知</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;子发送通知：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kNotificationName object:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 从端口收到 Mach Message</span></span><br><span class="line">- (<span class="type">void</span>)handleMachMessage:(<span class="type">void</span> *)msg &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 notifications 数组中全部通知并发送</span></span><br><span class="line">    <span class="keyword">while</span> ([<span class="keyword">self</span>.notifications count]) &#123;</span><br><span class="line">        <span class="built_in">NSNotification</span> *notification = [<span class="keyword">self</span>.notifications objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notifications removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        <span class="comment">// 将 notification 转发到期望线程（主线程）</span></span><br><span class="line">        <span class="comment">// 因为收到 Mach Message 的回调一定是在期望线程的 runloop 上（即期望线程上），所以这里直接调用原 notification 处理方法即可</span></span><br><span class="line">        [<span class="keyword">self</span> processNotification:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到通知</span></span><br><span class="line">- (<span class="type">void</span>)processNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread] != _notificationThread) &#123;</span><br><span class="line">        <span class="comment">// 如果收到通知的线程不是期望线程</span></span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">        <span class="comment">// 将通知添加到 notifications 数组</span></span><br><span class="line">        [<span class="keyword">self</span>.notifications addObject:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;需要转发，因为在非期望线程收到通知：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从指定 Mach Port 发送一条 Message，只需设置发送时间参数即可</span></span><br><span class="line">        [<span class="keyword">self</span>.notificationPort sendBeforeDate:[<span class="built_in">NSDate</span> date]</span><br><span class="line">                                   components:<span class="literal">nil</span></span><br><span class="line">                                         from:<span class="literal">nil</span></span><br><span class="line">                                     reserved:<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 收到通知的线程是期望线程，继续后续处理逻辑</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在期望线程收到通知：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子发送通知：&lt;NSThread: 0x600002fb8a40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">需要转发，因为在非期望线程收到通知：&lt;NSThread: 0x600002fb8a40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">在期望线程收到通知：&lt;NSThread: 0x600002ff4900&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><p><strong>实现逻辑总结如下：</strong></p><ul><li><p>首先定义一个 <code>notifications</code> 数组，用于保存需要转发的 <code>notification</code></p></li><li><p>在期望线程的 runloop 上添加一个 Mach Port 端口源</p></li><li><p>收到通知时判断是否是在期望线程收到的</p><ul><li>如果是则直接处理；</li><li>如果不是，则将该 <code>notification</code> 保存到 <code>notifications</code> 数组中，并通过 Mach Port 端口发送一条 <code>Message</code></li></ul></li><li><p>由于 Mach Port 端口源是添加到期望线程 runloop 上的，所以收到 Mach Message 的 <code>delegate</code> 方法 <code>handleMachMessage:</code> 一定是在期望线程上被执行的</p></li><li><p>在 <code>handleMachMessage:</code> 中遍历 <code>notifications</code> 数组中所有 <code>notification</code>，以 <code>notification</code> 为参数重新执行收到通知的处理方法即可</p></li></ul><h3 id="2、NSNotification-的发送和处理是同步的"><a href="#2、NSNotification-的发送和处理是同步的" class="headerlink" title="2、NSNotification 的发送和处理是同步的"></a>2、NSNotification 的发送和处理是同步的</h3><p><code>NSNotification</code> 的发送和处理是同步的，即 <code>NSNotification</code> 的所有监听者注册 <code>sel</code> 执行完毕后，才会执行发送 <code>NSNotification</code> 后面的后续逻辑，例如：<br>定义一个 <code>TestObject</code>，用于用于监听与处理通知，并且在收到通知的 <code>sel</code> 中休眠 2 秒：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;TestObject.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)notificationAction:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;收到通知&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;休眠 2 秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后创建三个 <code>TestObject</code> 的实例监听与处理通知：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    _obj1 = [[TestObject alloc] init];</span><br><span class="line">    _obj2 = [[TestObject alloc] init];</span><br><span class="line">    _obj3 = [[TestObject alloc] init];</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:_obj1 selector:<span class="keyword">@selector</span>(notificationAction:) name:kNotificationName object:<span class="literal">nil</span>];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:_obj2 selector:<span class="keyword">@selector</span>(notificationAction:) name:kNotificationName object:<span class="literal">nil</span>];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:_obj3 selector:<span class="keyword">@selector</span>(notificationAction:) name:kNotificationName object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)btnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;点击了按钮，发送通知&quot;</span>);</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kNotificationName object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;按钮点击的最后一个打印&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">点击了按钮，发送通知</span><br><span class="line">收到通知</span><br><span class="line">休眠 2 秒</span><br><span class="line">收到通知</span><br><span class="line">休眠 2 秒</span><br><span class="line">收到通知</span><br><span class="line">休眠 2 秒</span><br><span class="line">按钮点击的最后一个打印</span><br></pre></td></tr></table></figure><p>根据打印结果可以看到，发送 <code>Notification</code> 会阻塞线程，直到所有监听者注册的 <code>sel</code> 执行完毕才会继续往下执行，即 <code>Notification</code> 的发送和处理是同步的。</p><h3 id="3、异步发送通知"><a href="#3、异步发送通知" class="headerlink" title="3、异步发送通知"></a>3、异步发送通知</h3><p>根据上面的例子可以知道，<code>NSNotification</code> 的发送和处理是同步的，那是否有办法异步发送通知呢？即发送 <code>Notification</code> 如何不阻塞线程？</p><p>可以借助前面提到的 <code>NSNotificationQueue</code> 来实现异步发送通知，实际上从线程的角度看并不是真正的异步发送，因为不涉及开启新线程，更应当称之为延时发送。</p><p>例如，在主线程发送通知，仍然在主线程收到通知，但是使发送通知不阻塞主线程。可以使用 <code>NSNotificationQueue</code> 将通知延迟到 runloop 空闲时发送，在上面例子基础上修改下通知发送方式即可：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    _obj1 = [[TestObject alloc] init];</span><br><span class="line">    _obj2 = [[TestObject alloc] init];</span><br><span class="line">    _obj3 = [[TestObject alloc] init];</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:_obj1 selector:<span class="keyword">@selector</span>(notificationAction:) name:kNotificationName object:<span class="literal">nil</span>];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:_obj2 selector:<span class="keyword">@selector</span>(notificationAction:) name:kNotificationName object:<span class="literal">nil</span>];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:_obj3 selector:<span class="keyword">@selector</span>(notificationAction:) name:kNotificationName object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)btnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;点击了按钮，发送通知&quot;</span>);</span><br><span class="line">    <span class="built_in">NSNotification</span> *notification = [<span class="built_in">NSNotification</span> notificationWithName:kNotificationName object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// 将通知添加到队列（这里获取到的就是主队列），并指定 runloop 空闲时发送通知，不合并通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationQueue</span> defaultQueue] enqueueNotification:notification postingStyle:<span class="built_in">NSPostWhenIdle</span> coalesceMask:<span class="built_in">NSNotificationNoCoalescing</span> forModes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;按钮点击的最后一个打印&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">点击了按钮，发送通知</span><br><span class="line">按钮点击的最后一个打印</span><br><span class="line">收到通知</span><br><span class="line">休眠 2 秒</span><br><span class="line">收到通知</span><br><span class="line">休眠 2 秒</span><br><span class="line">收到通知</span><br><span class="line">休眠 2 秒</span><br></pre></td></tr></table></figure><p>根据打印结果可以看到，该方式发送通知并没有阻塞线程，不需要等待所有监听者处理完通知即可执行后续逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> runloop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Autorelease 实现原理</title>
      <link href="/posts/60692/"/>
      <url>/posts/60692/</url>
      
        <content type="html"><![CDATA[<h2 id="1、-autoreleasepool"><a href="#1、-autoreleasepool" class="headerlink" title="1、@autoreleasepool{}"></a>1、@autoreleasepool{}</h2><p>在新建 iOS 项目的时候，会自动生成 main.m 文件：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goes here.</span></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如下命令：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m  -o main.cpp</span><br></pre></td></tr></table></figure><p>将其转成 C&#x2F;C++ 代码，main 函数实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>(((Class (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *)objc_msgSend)((<span class="type">id</span>)objc_getClass(<span class="string">&quot;AppDelegate&quot;</span>), sel_registerName(<span class="string">&quot;class&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, __null, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了看起来方便，先去掉无关逻辑：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, __null, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里将 <code>@autoreleasepool &#123;&#125;</code> 转换成：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续在 main.cpp 中查找 <code>__AtAutoreleasePool</code> 的定义，可以找到：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="type">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以确定 <code>__AtAutoreleasePool</code> 是一个结构体，这个结构体会在初始化时调用 <code>objc_autoreleasePoolPush()</code> 方法，在析构时调用 <code>objc_autoreleasePoolPop</code> 方法。</p><p>也就是说，main 函数实际实现可以理解为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @autoreleasepool&#123;&#125; 的 &#123;&#125; 中的代码，会自动将创建的对象加入自动释放池</span></span><br><span class="line"></span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 OC 开源的源码中可以找到 <code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 实现如下（为了阅读方便，后续源码会有部分删简）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *objc_autoreleasePoolPush(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> objc_autoreleasePoolPop(<span class="type">void</span> *ctxt) &#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法是 <code>AutoreleasePoolPage</code> 对应静态方法 <code>push</code> 和 <code>pop</code> 的封装，其具体作用后文分析。</p><h2 id="2、AutoreleasePoolPage"><a href="#2、AutoreleasePoolPage" class="headerlink" title="2、AutoreleasePoolPage"></a>2、AutoreleasePoolPage</h2><p><code>AutoreleasePool</code> 并没有单独的结构，每一个 <code>AutoreleasePool</code> 都是由若干个 <code>AutoreleasePoolPage</code> 以双向链表的形式组成，并且每一个 <code>AutoreleasePoolPage</code> 的大小都是 4096 字节，<code>AutoreleasePoolPage</code> 定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AutoreleasePoolPage : private AutoreleasePoolPageData</span><br><span class="line">&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> AutoreleasePoolPageData</span><br><span class="line">&#123;</span><br><span class="line">    magic_t <span class="keyword">const</span> magic;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="type">id</span> *next; </span><br><span class="line">    pthread_t <span class="keyword">const</span> thread;</span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    uint32_t <span class="keyword">const</span> depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>magic<br>检查校验完整性的变量</p></li><li><p>next<br>指向栈顶最新 <code>add</code> 进来的 <code>autorelease</code> 对象的下一个位置</p></li><li><p>thread<br><code>page</code> 当前所在的线程，<code>AutoreleasePool</code> 是按线程一一对应的（结构中的 <code>thread</code> 指针指向当前线程）</p></li><li><p>parent<br>父节点，指向前一个 <code>page</code></p></li><li><p>child<br>子节点，指向下一个 <code>page</code></p></li><li><p>depth<br>链表的深度，节点个数</p></li><li><p>hiwat<br>high water mark 数据容纳的一个上限</p></li></ul><p><code>AutoreleasePoolPage</code> 内存结构如下图：<br><img src="/images/lix_blog_69.png" style="width:50%;"></p><p>每一个 <code>AutoreleasePoolPage</code> 的大小都是 4096 bit，其中有 56 bit 用于存储 <code>AutoreleasePoolPage</code> 的成员变量，剩下的用来存储加入到自动释放池中的对象。</p><p><code>begin()</code> 和 <code>end()</code> 这两个类的实例方法用于快速获取 4096 bit - 56 bit &#x3D; 4040 bit 这一内存范围的边界地址。</p><p><code>next</code> 指向了下一个为空的内存地址，如果 <code>next</code> 指向的地址加入一个对象，它就会如下图所示移动到下一个为空的内存地址中：<br><img src="/images/lix_blog_70.png" style="width:50%;"></p><p>其中 <code>POOL_BOUNDARY</code> 是一个边界对象 <code>nil</code>（老版本变量名是 <code>POOL_SENTINEL</code> 哨兵对象）用来区别每个 <code>AutoreleasePoolPage</code> 边界，起到一个标识作用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_BOUNDARY nil</span></span><br></pre></td></tr></table></figure><p>在每个自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 的时候，都会把一个 <code>POOL_BOUNDARY</code> <code>push</code> 到自动释放池的栈顶，并且返回这个 <code>POOL_BOUNDARY</code> 哨兵对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里的 atautoreleasepoolobj 实际上就是 POOL_BOUNDARY</span></span><br><span class="line">        <span class="type">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @autoreleasepool&#123;&#125; 的 &#123;&#125; 中的代码</span></span><br><span class="line"></span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而调用 <code>objc_autoreleasePoolPop</code> 时，就会向自动释放池中的对象发送 <code>release</code> 消息，并在 <code>AutoreleasePoolPage</code> 中移除对应位置对象，直到第一个 <code>POOL_BOUNDARY</code>。</p><h2 id="3、push-pop"><a href="#3、push-pop" class="headerlink" title="3、push &amp; pop"></a>3、push &amp; pop</h2><p>根据前面对 main.cpp 分析可知，<code>@autoreleasepool&#123;&#125;</code> 实际上就是在 <code>&#123;&#125;</code> 中的代码前后分别调用 <code>objc_autoreleasePoolPush()</code> 和 <code>objc_autoreleasePoolPop(atautoreleasepoolobj);</code></p><p><code>objc_autoreleasePoolPush()</code> 实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *objc_autoreleasePoolPush(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部调用的 <code>AutoreleasePoolPage</code> 中的 <code>push</code> 函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="type">void</span> *push() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> *dest;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(DebugPoolAllocation)) &#123;</span><br><span class="line">        <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会调用 <code>autoreleaseFast</code> 函数，并传入边界对象 <code>POOL_BOUNDARY</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="type">id</span> *autoreleaseFast(<span class="type">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        <span class="comment">// a、有 hotPage 并且当前 page 不满</span></span><br><span class="line">        <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="comment">// b、有 hotPage 并且当前 page 已满</span></span><br><span class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// c、无 hotPage</span></span><br><span class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="a、将对象添加到自动释放池页中"><a href="#a、将对象添加到自动释放池页中" class="headerlink" title="a、将对象添加到自动释放池页中:"></a>a、将对象添加到自动释放池页中:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> *add(<span class="type">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></span><br><span class="line">    *next++ = obj;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add</code> 函数其实就是一个压栈的操作，将对象加入 <code>AutoreleasePoolPage</code> 然后移动栈顶的指针。</p><h4 id="b、有-hotPage-并且当前-page-已满时："><a href="#b、有-hotPage-并且当前-page-已满时：" class="headerlink" title="b、有 hotPage 并且当前 page 已满时："></a>b、有 hotPage 并且当前 page 已满时：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">id</span> *autoreleaseFullPage(<span class="type">id</span> obj, AutoreleasePoolPage *page)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数会从传入的 <code>page</code> 开始遍历整个双向链表<br>如果找到未满的 <code>AutoreleasePoolPage</code>，则调用 <code>add</code> 函数添加对象。<br>如果没有找到未满的 <code>AutoreleasePoolPage</code>，则创建新的 <code>AutoreleasePoolPage</code>，并调用 <code>add</code> 函数添加对象。</p><p>最后将找到的或者新建的 <code>AutoreleasePoolPage</code> 标记为 <code>hotPage</code>.</p><h4 id="c、无-hotPage："><a href="#c、无-hotPage：" class="headerlink" title="c、无 hotPage："></a>c、无 hotPage：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> *autoreleaseNoPage(<span class="type">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(<span class="literal">nil</span>);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">        page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个 <code>AutoreleasePoolPage</code> ，然后再加入 <code>obj</code> ，创建 <code>Autorelease Pool</code> 的时候，<code>obj</code> 的值是 <code>POOL_BOUNDARY</code>。</p><p>我们用一张图来表示 <code>Autorelease Pool</code> 刚创建时候的结构：<br><img src="/images/lix_blog_71.png" style="width:50%;"><br>总结上面 <code>push</code> 过程：<br>首先获取 <code>hotPage</code>，即当前正在使用的 <code>AutoreleasePoolPage</code>，然后针对 <code>hotPage</code> 的情况做不同处理：</p><ul><li>存在 <code>hotPage</code> &amp; <code>page</code> 不满<ul><li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li></ul></li><li>存在 <code>hotPage</code> &amp; <code>page</code> 已满<ul><li>调用 <code>autoreleaseFullPage</code> 函数，从传入的 <code>page</code> 开始往后遍历双向链表。</li><li>如果找到未满的 <code>AutoreleasePoolPage</code>，则将该 <code>page</code> 标记为 <code>hotPage</code>。</li><li>如果没有找到未满的 <code>AutoreleasePoolPage</code>，则创建新的 <code>AutoreleasePoolPage</code>，并将该 <code>page</code> 标记为 <code>hotPage</code>。</li><li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li></ul></li><li>无 <code>hotPage</code><ul><li>调用 <code>autoreleaseNoPage</code> 函数创建一个 <code>hotPage</code></li><li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li></ul></li></ul><p>前边提到，销毁 <code>Autorelease Pool</code> 会调用 <code>objc_autoreleasePoolPop</code> 方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> objc_autoreleasePoolPop(<span class="type">void</span> *ctxt) </span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pop</code> 函数实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="type">void</span> pop(<span class="type">void</span> *token)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    <span class="type">id</span> *stop;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);</span><br><span class="line">    stop = (<span class="type">id</span> *)token;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(<span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面的了解可知，这里 <code>token</code> 即创建 <code>Autorelease Pool</code> 时返回的 <code>POOL_BOUNDARY</code>，这个会作为 <code>pageForPointer</code> 的输入参数。 <code>pageForPointer</code> 函数的实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AutoreleasePoolPage *pageForPointer(<span class="keyword">const</span> <span class="type">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pageForPointer((uintptr_t)p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> AutoreleasePoolPage *pageForPointer(uintptr_t p)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *result;</span><br><span class="line">    uintptr_t offset = p % SIZE;</span><br><span class="line"></span><br><span class="line">    assert(offset &gt;= <span class="keyword">sizeof</span>(AutoreleasePoolPage));</span><br><span class="line"></span><br><span class="line">    result = (AutoreleasePoolPage *)(p - offset);</span><br><span class="line">    result-&gt;fastcheck();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是为了计算出创建 <code>Autorelease Pool</code> 时 <code>AutoreleasePoolPage</code> 的内存起始地址。所以，<code>pageForPointer</code> 函数返回的是当前 <code>Autorelease Pool</code> 创建时候的 <code>AutoreleasePoolPage</code>，获取到 <code>AutoreleasePoolPage</code> 之后，调用 <code>releaseUntil</code> 函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> releaseUntil(<span class="type">id</span> *stop)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Not recursive: we don&#x27;t want to blow out the stack </span></span><br><span class="line">    <span class="comment">// if a thread accumulates a stupendous amount of garbage</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>-&gt;next != stop) &#123;</span><br><span class="line">        <span class="comment">// Restart from hotPage() every time, in case -release </span></span><br><span class="line">        <span class="comment">// autoreleased more objects</span></span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixme I think this `while` can be `if`, but I can&#x27;t prove it</span></span><br><span class="line">        <span class="keyword">while</span> (page-&gt;empty()) &#123;</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        <span class="type">id</span> obj = *--page-&gt;next;</span><br><span class="line">        memset((<span class="type">void</span>*)page-&gt;next, SCRIBBLE, <span class="keyword">sizeof</span>(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setHotPage(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是从当前的 <code>hotPage</code> 开始，依次对 <code>AutoreleasePoolPage</code> 里的对象执行 <code>objc_release</code> 操作，直到遇到 <code>POOL_BOUNDARY</code> 对象。</p><p>总结上面 <code>pop</code> 流程：<br>首先，找到传入的 <code>POOL_BOUNDARY</code> 所在的 <code>page</code>，从 <code>hotPage</code> 开始(从自动释放池的中的最后一个入栈的 <code>autorelease</code> 对象开始)，一直往前释放加入自动释放池的 <code>autorelease</code> 对象，可以向前跨越若干个 <code>page</code>，直到遇到这个 <code>POOL_BOUNDARY</code>，理的方式是向这些对象发送一次 <code>release</code> 消息，使其引用计数减一；</p><p>另外，清空 <code>page</code> 对象还会遵循一些原则：</p><ul><li>如果清理后当前的 <code>page</code> 中存放的对象少于一半，则子 <code>page</code> 全部删除；</li><li>如果清理后当前的 <code>page</code> 存放的多于一半（意味着马上将要满），则保留一个子 <code>page</code>，节省创建新 <code>page</code> 的开销；</li></ul><p>接下来用图对 <code>push</code> 和 <code>pop</code> 过程进行一个演示：<br>首先，假设一个 <code>AutoreleasePoolPage</code> 中只能存储 4 个 <code>Autorelease</code> 对象，第一次创建 <code>Autorelease Pool</code> 时，有 5 个 <code>Autorelease</code> 对象需要放到缓存池中，这时候，第 5 个 <code>Autorelease</code> 对象只能存到一个新的 <code>autoreleasePoolPage</code> 中：<br><img src="/images/lix_blog_72.png" style="width:70%;"></p><p>在上个 <code>Autorelase Pool</code> 还未销毁时，这时又新建了一个 <code>Autorelase Pool</code>，需要存储 2 个 <code>Autorelease</code> 对象，则往 <code>AutorelasePoolPage</code> 的 <code>next</code> 位置加入 <code>POOL_BOUNDARY</code>。并添加 <code>obj6</code> 和 <code>obj7</code>：<br><img src="/images/lix_blog_73.png" style="width:70%;"></p><p>释放时，根据 <code>POOL_BOUNDARY</code> 找到所在 <code>page</code>，在对应 <code>page</code> 中，将晚于 <code>POOL_BOUNDARY</code> 插入的所有 <code>autorelease</code> 对象都发送一次 <code>release</code> 消息，并向回移动 <code>next</code> 指针到正确位置：<br><img src="/images/lix_blog_74.png" style="width:70%;"></p><h2 id="4、RunLoop-与-autoreleasepool："><a href="#4、RunLoop-与-autoreleasepool：" class="headerlink" title="4、RunLoop 与 @autoreleasepool："></a>4、RunLoop 与 @autoreleasepool：</h2><p>默认情况下，<code>Autorelease</code> 对象的释放时机是由 RunLoop 控制的，会在当前 RunLoop 每次循环期间时释放。<br>iOS 在主线程的 RunLoop 中注册了两个 Observer。</p><ul><li><p>第 1 个 Observer<br>监听了 kCFRunLoopEntry 事件，会调用 <code>objc_autoreleasePoolPush()</code>；</p></li><li><p>第 2 个 Observer<br>监听了 <code>kCFRunLoopBeforeWaiting</code> 事件，会调用 <code>objc_autoreleasePoolPop()</code>、<code>objc_autoreleasePoolPush()</code>；<br>监听了 <code>kCFRunLoopBeforeExit</code> 事件，会调用 <code>objc_autoreleasePoolPop()</code>。</p></li></ul><p>所以，释放时机在 RunLoop 的如下三个事件中：</p><ul><li><p>kCFRunLoopEntry<br>在即将进入 RunLoop 时，会自动创建一个 <code>__AtAutoreleasePool</code> 结构体对象，并调用 <code>objc_autoreleasePoolPush()</code> 函数。</p></li><li><p>kCFRunLoopBeforeWaiting<br>在 RunLoop 即将休眠时，会自动销毁一个 <code>__AtAutoreleasePool</code> 对象，调用 <code>objc_autoreleasePoolPop()</code>。然后创建一个新的 <code>__AtAutoreleasePool</code> 对象，并调用 <code>objc_autoreleasePoolPush()</code>。</p></li><li><p>kCFRunLoopBeforeExit<br>在即将退出 RunLoop 时，会自动销毁最后一个创建的 <code>__AtAutoreleasePool</code> 对象，并调用 <code>objc_autoreleasePoolPop()</code>。<br><img src="/images/lix_blog_75.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> runloop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用计数实现原理</title>
      <link href="/posts/15665/"/>
      <url>/posts/15665/</url>
      
        <content type="html"><![CDATA[<h2 id="一、iOS-引用计数概述"><a href="#一、iOS-引用计数概述" class="headerlink" title="一、iOS 引用计数概述"></a>一、iOS 引用计数概述</h2><p>对象的引用方式分为<code>强引用</code>和<code>弱引用</code>，对象的强引用和弱引用信息保存在 <code>SideTables</code> 中，<code>SideTables</code> 是全局的哈希数组，里面存储了有限数量的 SideTable，多个对象会共用一个 <code>SideTable</code>，也就是说每个 <code>SideTable</code> 中存储了多个对象的引用计数信息。<br><img src="/images/lix_blog_68.png"><br>底层通过 <code>indexForPointer</code> 函数计算某个对象使用的是 <code>SideTables</code> 数组中的哪个 <code>index</code> 位置的 <code>SideTable</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">unsigned</span> <span class="type">int</span> indexForPointer(<span class="keyword">const</span> <span class="type">void</span> *p) &#123;</span><br><span class="line">    uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算结果即为对象对应的 <code>SideTable</code> 在 <code>SideTables</code> 中的 <code>index</code>。</p><p>根据以上逻辑，可以看到是对对象地址 <code>addr</code> 经过一定计算后，将结果与 <code>StripeCount</code> 进行模运算。所以，最终计算得到的 <code>index</code> 小于 <code>StripeCount</code>，即 <code>SideTables</code> 中共存储 <code>StripeCount</code> 个 <code>SideTable</code>，根据 <code>StripeCount</code> 定义可知，<font color=#ff0000>在 <code>iPhone</code> 和模拟器上，<code>SideTables</code> 存储 8 个 <code>SideTable</code>，Mac 上存储 64 个 <code>SideTable</code>。</font></p><p>既然 <code>SideTable</code> 中存储了多个对象的引用计数信息，Apple 为什么要使用多个 <code>SideTable</code>，而不是直接在一个 <code>SideTable</code> 中存储全部对象的引用计数信息？</p><p>因为 <code>SideTable</code> 里有一个锁，如果把所有的类的引用信息都放在同一个 <code>SideTable</code>，有任何一个类有改动都会对整个 <code>SideTable</code> 做操作，并且在操作一个类的同时，操作别的类会被锁住等待，这样会导致操作效率和查询效率都很低。而有多个 <code>SideTable</code> 的话，操作的都是单个 <code>SideTable</code>，并不会影响其他的 <code>SideTable</code>，这样就避免了资源竞争，提高了效率。这里引入了分离锁的概念，简而言之就是将一张表分拆成多张表，对他们分别加锁，可以实现并发操作，提升执行效率。</p><p><code>SideTable</code> 的数据结构：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SideTable &#123;</span><br><span class="line">    <span class="comment">// 锁</span></span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    <span class="comment">// 强引用 hash 表</span></span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="comment">// weak 引用 hash 表</span></span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，源码中对锁的定义使用的是 <code>spinlock_t</code> 类型的变量，看起来是自旋锁，实际上，Apple 已经弃用 <code>OSSpinLock</code> 了，最新源码是用 <code>os_unfair_lock</code> 来实现的，其底层执行 <code>lock</code> 和 <code>unlock</code> 的其实是 <code>mutex_t</code>，也就是互斥锁：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using spinlock_t = mutex_tt&lt;LOCKDEBUG&gt;;</span><br><span class="line"><span class="keyword">class</span> mutex_tt : nocopy_t &#123;</span><br><span class="line">    os_unfair_lock mLock;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、强引用计数的存储"><a href="#二、强引用计数的存储" class="headerlink" title="二、强引用计数的存储"></a>二、强引用计数的存储</h2><p>我们都知道，在非 ARC 情况下，需要开发者手动调用 <code>retain</code>、<code>release</code> 进行内存管理，并且可以调用 <code>retainCount</code> 去获取对象的引用计数。</p><p>开始之前先看下 <code>isa</code> 的结构：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      uintptr_t nonpointer        : <span class="number">1</span>;</span><br><span class="line">      uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">      uintptr_t has_cxx_dtor      : <span class="number">1</span>;  </span><br><span class="line">      uintptr_t shiftcls          : <span class="number">33</span>;</span><br><span class="line">      uintptr_t magic             : <span class="number">6</span>;   </span><br><span class="line">      uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">      uintptr_t deallocating      : <span class="number">1</span>; </span><br><span class="line">      uintptr_t has_sidetable_rc  : <span class="number">1</span>; </span><br><span class="line">      uintptr_t extra_rc          : <span class="number">19</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，引用计数器是存储在 <code>extra_rc</code> 中的（存储的是引用计数减 1），但是可以看到，<code>extra_rc</code> 只有 19 位，可以存储的最大引用计数：<code>2^19-1+1=524288</code>，可能会出现不够存储的情况，即存储计数溢出。</p><p>如果出现 <code>extra_rc</code> 不够存储引用计数的情况，<code>has_sidetable_rc</code> 将会被赋值为 1，并且引用计数会存在 <code>SideTable</code> 的 <code>refcnts</code> 中。</p><p><code>refcnts</code> 是一个存放着对象引用计数的散列表，<code>key</code> 为 <code>objc_object</code>，即 OC 对象，<code>value</code> 为引用计数，当 <code>value</code> 为 0 的时候，会将该记录从表中移除。所以，在 64bit 中，引用计数可以直接存储在优化过的 <code>isa</code> 指针中，也可能存储在 <code>SideTable</code> 中。</p><p>接下来看下 <code>retainCount</code> 这方法的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>)<span class="keyword">self</span>)-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其内部是调用 <code>rootRetainCount()</code> 方法。</p><p>在 ARC 环境下，可以调用 Core Foundation 的 <code>CFGetRetainCount()</code> 方法，或调用 Runtime 的 <code>_objc_rootRetainCount(id obj)</code> 方法来获取引用计数，它们实内部实际上也是调用 <code>rootRetainCount()</code> 方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Tagged Pointer，直接返回 isa 本身</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (uintptr_t)<span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    isa_t bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;</span><br><span class="line">        <span class="comment">// 开启了 isa 指针优化</span></span><br><span class="line">        uintptr_t rc = <span class="number">1</span> + bits.extra_rc;</span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有开启 isa 指针优化</span></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>rootRetainCount</code> 主要逻辑：</p><ul><li>如果是 <code>Tagged Pointer</code>，直接返回 <code>isa</code> 本身</li><li>如果开启了 <code>isa</code> 指针优化<ul><li>先去 <code>isa</code> 中取出 <code>extra_rc</code> 存储的引用计数，并 + 1</li><li>再去判断 <code>isa</code> 中 <code>has_sidetable_rc</code> 是否为 1，如果为 1，就去对应 <code>SideTable</code> 中取出引用计数，再与上一步取到的引用计数相加返回</li></ul></li><li>如果没有开启 <code>isa</code> 指针优化，直接去对应 <code>SideTable</code> 中取出引用计数返回</li></ul><p>上面 <code>sidetable_getExtraRC_nolock</code> 和 <code>sidetable_retainCount</code> 都是去 <code>SideTable</code> 中取引用计数，两个函数主要逻辑基本类似，下面是 <code>sidetable_getExtraRC_nolock</code> 函数实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size_t </span><br><span class="line">objc_object::sidetable_getExtraRC_nolock()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="variable language_">this</span>];</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.end()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，强引用计数是存储在对应 <code>SideTable</code> 中的 <code>refcnts</code> 中的。</p><p>根据 <code>retainCount</code> 的实现也能大致反推出 <code>retain</code>、<code>release</code> 是如何修改引用计数的，这里不再补充。</p><h2 id="三、weak-的实现原理"><a href="#三、weak-的实现原理" class="headerlink" title="三、weak 的实现原理"></a>三、weak 的实现原理</h2><h3 id="1、weak-引用计数的存储"><a href="#1、weak-引用计数的存储" class="headerlink" title="1、weak 引用计数的存储"></a>1、weak 引用计数的存储</h3><h4 id="1-weak-table-t"><a href="#1-weak-table-t" class="headerlink" title="(1) weak_table_t"></a>(1) weak_table_t</h4><p>前面提到多个对象会共用一个 <code>SideTable</code>，所以又会以 <code>weak_table</code> 作为 hash 表分散各个对象的弱应用信息，<code>weak_table</code> 是一个结构体：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> weak_table_t &#123; </span><br><span class="line">    <span class="comment">// 保存了全部 weak_entry_t 的 hash 数组</span></span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    <span class="comment">// hash 数组中保存的 weak_entry_t 元素的个数</span></span><br><span class="line">    size_t    num_entries;</span><br><span class="line">    <span class="comment">// hash 数组的长度</span></span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    <span class="comment">// hash 冲突的最大次数</span></span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>weak_entries</code> 是一个动态数组，其余三个元素用于 hash 表的相关操作，其中 <code>mask = hash 数组长度 - 1</code>，通过对象获取对应 <code>weak_entry_t</code> 的逻辑如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> weak_entry_t *</span><br><span class="line">weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)</span><br><span class="line">&#123;</span><br><span class="line">    assert(referent);</span><br><span class="line"></span><br><span class="line">    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!weak_entries) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    size_t begin = hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_table-&gt;weak_entries);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上源码主要是计算对象对应的 <code>weak_entry_t</code> 在 <code>weak_entries</code> 数组中的 <code>index</code>，并根据 <code>index</code> 取出 <code>weak_entry_t</code>。<code>hash_pointer</code> 就是对对象 <code>referent</code> 的地址做个 hash，然后和 <code>mask</code> 做与运算，返回的结果小于 <code>weak_table-&gt;mask</code> ，保证了 <code>index</code> 不会越界，当计算结果做数组的索引。</p><p>这里 hash 冲突的解决方案是计算出 hash 位置 <code>index</code>，判断 <code>index</code> 对应的 <code>weak_entry_t</code> 中存储的 <code>referent</code>（即弱引用该“对象的指针”的指针） 是否与目标 <code>referent</code> 相等，不相等的话后移一位继续判断，并将 <code>hash_displacement ++</code>，记录移动次数。当 <code>hash_displacement</code> 的值大于 <code>max_hash_displacement</code> 时，直接返回 <code>nil</code>。当 <code>index == begin</code> 时，即遍历一圈也没找到目标对象，直接调用 <code>bad_weak_table</code> 报错。</p><h4 id="2-weak-entry-t"><a href="#2-weak-entry-t" class="headerlink" title="(2) weak_entry_t"></a>(2) weak_entry_t</h4><p>每个 <code>weak_entry_t</code> 存储着一个对象的弱引用信息。<code>weak_entry_t</code> 的结构与 <code>weak_table_t</code> 类似，也是一个 hash 表。其中存储的元素是 <code>weak_referrer_t</code> ，实质是弱引用对象指针的指针。通过操作指针的指针，可以实现 <code>weak</code> 引用的指针在对象析构后，指向 <code>nil</code>。</p><p><code>weak_entry_t</code> 的数据结构如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> weak_entry_t &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent; <span class="comment">// 被弱引用的对象</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 引用该对象的对象列表，联合体</span></span><br><span class="line">weak_referrer_t *referrers</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            weak_referrer_t *referrers;                      <span class="comment">// 动态数组，引用计数大于 4 时使用</span></span><br><span class="line">            uintptr_t        out_of_line_ness : <span class="number">2</span>;           <span class="comment">// 是否使用动态 hash 数组标记位</span></span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_2;         <span class="comment">// hash 数组中的元素个数</span></span><br><span class="line">            uintptr_t        mask;                           <span class="comment">// hash 数组长度 -1（hash 数组的长度，而不是元素实际个数）</span></span><br><span class="line">            uintptr_t        max_hash_displacement;          <span class="comment">// 可能会发生的 hash 冲突的最大次数        </span></span><br><span class="line">      &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT]; <span class="comment">// 定长数组，引用计数小于 4 时使用</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前的 weak_entry_t 是使用的定长数组还是动态数组</span></span><br><span class="line">    <span class="type">bool</span> out_of_line() &#123;</span><br><span class="line">        <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 赋值</span></span><br><span class="line">    weak_entry_t&amp; operator=(<span class="keyword">const</span> weak_entry_t&amp; other) &#123;</span><br><span class="line">        memcpy(<span class="variable language_">this</span>, &amp;other, <span class="keyword">sizeof</span>(other));</span><br><span class="line">        <span class="keyword">return</span> *<span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造方法</span></span><br><span class="line">    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : referent(newReferent)     &#123;</span><br><span class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>WEAK_INLINE_COUNT</code> 定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WEAK_INLINE_COUNT 4</span></span><br></pre></td></tr></table></figure><p>其中 <code>DisguisedPtr&lt;objc_object&gt; referent</code> 为弱引用对象指针摘要，可以简单理解为被弱引用的对象，只不过这里使用了摘要的形式存储（所谓摘要，其实是把地址取负）。</p><h3 id="2、weak-实现流程"><a href="#2、weak-实现流程" class="headerlink" title="2、weak 实现流程"></a>2、weak 实现流程</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="(1) 初始化"></a>(1) 初始化</h4><p>当我们初始化一个 <code>weak</code> 对象时，runtime 会调用 <code>objc_initWeak</code> 函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span></span><br><span class="line">objc_initWeak(<span class="type">id</span> *location, <span class="type">id</span> newObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 无效对象直接释放</span></span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法有两个参数 <code>location</code> 和 <code>newObj</code>：</p><ul><li>location<br><code>__weak</code> 指针的地址</li><li>newObj<br>所引用的对象</li></ul><h4 id="2-添加引用"><a href="#2-添加引用" class="headerlink" title="(2) 添加引用"></a>(2) 添加引用</h4><p><code>objc_initWeak</code> 函数会调用 <code>storeWeak</code> 函数，用于更新指针指向，创建对应的弱引用表。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HaveOld:     true - 变量有值</span></span><br><span class="line"><span class="comment">//             false - 需要被及时清理，当前值可能为 nil</span></span><br><span class="line"><span class="comment">// HaveNew:     true - 需要被分配的新值，当前值可能为 nil</span></span><br><span class="line"><span class="comment">//             false - 不需要分配新值</span></span><br><span class="line"><span class="comment">// CrashIfDeallocating: true - 说明 newObj 已经释放或者 newObj 不支持弱引用，该过程需要暂停</span></span><br><span class="line"><span class="comment">//             false - 用 nil 替代存储</span></span><br><span class="line">template <span class="type">bool</span> HaveOld, <span class="type">bool</span> HaveNew, <span class="type">bool</span> CrashIfDeallocating&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="type">id</span> storeWeak(<span class="type">id</span> *location, objc_object *newObj) &#123;</span><br><span class="line">    <span class="comment">// 该过程用来更新弱引用指针的指向</span></span><br><span class="line">    <span class="comment">// 初始化 previouslyInitializedClass 指针</span></span><br><span class="line">    Class previouslyInitializedClass = <span class="literal">nil</span>;</span><br><span class="line">    <span class="type">id</span> oldObj;</span><br><span class="line">    <span class="comment">// 声明两个 SideTable</span></span><br><span class="line">    <span class="comment">// 【新旧散列创建】</span></span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line">    <span class="comment">// 获得新值和旧值的锁存位置（用地址作为唯一标示）</span></span><br><span class="line">    <span class="comment">// 通过地址来建立索引标志，防止桶重复</span></span><br><span class="line">    <span class="comment">// 下面指向的操作会改变旧值</span></span><br><span class="line">retry:</span><br><span class="line">    <span class="keyword">if</span> (HaveOld) &#123;</span><br><span class="line">        <span class="comment">// 更改指针，获得以 oldObj 为索引所存储的值地址</span></span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (HaveNew) &#123;</span><br><span class="line">        <span class="comment">// 更改新值指针，获得以 newObj 为索引所存储的值地址</span></span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁操作，防止多线程中竞争冲突</span></span><br><span class="line">    SideTable::lockTwoHaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">    <span class="comment">// 避免线程冲突重处理</span></span><br><span class="line">    <span class="comment">// location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改</span></span><br><span class="line">    <span class="keyword">if</span> (HaveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止弱引用间死锁</span></span><br><span class="line">    <span class="comment">// 并且通过 +initialize 初始化构造器保证所有弱引用的 isa 非空指向</span></span><br><span class="line">    <span class="keyword">if</span> (HaveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        <span class="comment">// 获得新对象的 isa 指针</span></span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        <span class="comment">// 判断 isa 非空且已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;</span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">            <span class="comment">// 对其 isa 指针进行初始化</span></span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (<span class="type">id</span>)newObj));</span><br><span class="line">            <span class="comment">// 如果该类已经完成执行 +initialize 方法是最理想情况</span></span><br><span class="line">            <span class="comment">// 如果该类 +initialize 在线程中</span></span><br><span class="line">            <span class="comment">// 例如 +initialize 正在调用 storeWeak 方法</span></span><br><span class="line">            <span class="comment">// 需要手动对其增加保护策略，并设置 previouslyInitializedClass 指针进行标记</span></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line">            <span class="comment">// 重新尝试</span></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【清除旧值】</span></span><br><span class="line">    <span class="keyword">if</span> (HaveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【分配新值】</span></span><br><span class="line">    <span class="keyword">if</span> (HaveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table,</span><br><span class="line">                                                      (<span class="type">id</span>)newObj, location,</span><br><span class="line">                                                      CrashIfDeallocating);</span><br><span class="line">        <span class="comment">// 如果弱引用被释放 weak_register_no_lock 方法返回 nil</span></span><br><span class="line">        <span class="comment">// 在引用计数表中设置若引用标记位</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            <span class="comment">// 弱引用位初始化操作</span></span><br><span class="line">            <span class="comment">// 引用计数那张散列表的weak引用对象的引用计数中标识为weak引用</span></span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之前不要设置 location 对象，这里需要更改指针指向</span></span><br><span class="line">        *location = (<span class="type">id</span>)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有新值，则无需更改</span></span><br><span class="line">    &#125;</span><br><span class="line">    SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>storeWeak</code> 函数用来更新弱引用指针的指向，创建对应的弱引用表：</p><ul><li><code>storeWeak</code> 方法实际上是接收的参数，分别是 <code>haveOld</code>、<code>haveNew</code> 和 <code>crashIfDeallocating</code> ，这三个参数都是以模板的方式传入的，是三个 <code>bool</code> 类型的参数。 分别表示 <code>weak</code> 指针之前是否指向了一个弱引用、<code>weak</code> 指针是否需要指向一个新的引用、若果被弱引用的对象正在析构，此时再弱引用该对象是否应该 crash。</li><li>该方法维护了 <code>oldTable</code> 和 <code>newTable</code> 分别表示旧的引用弱表和新的弱引用表，它们都是 <code>SideTable</code> 的 hash 表。</li><li>如果 <code>weak</code> 指针之前指向了一个弱引用，则会调用 <code>weak_unregister_no_lock</code> 函数将旧的 <code>weak</code> 指针地址移除。</li><li>如果 <code>weak</code> 指针需要指向一个新的引用，则会调用 <code>weak_register_no_lock</code> 函数将新的 <code>weak</code> 指针地址添加到弱引用表中。</li><li>调用 <code>setWeaklyReferenced_nolock</code> 方法修改 <code>weak</code> 新引用的对象的 bit 标志位。</li></ul><p>这里涉及到两个关键的函数：</p><ul><li>weak_unregister_no_lock<br><code>weak ptr</code> 地址 从 <code>obj</code> 的 <code>weak_entry_t</code> 中移除</li><li>weak_register_no_lock<br><code>weak ptr</code> 地址 注册到 <code>obj</code> 对应的 <code>weak_entry_t</code> 中</li></ul><p>其中 <code>weak_register_no_lock</code> 实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> </span><br><span class="line">weak_register_no_lock(weak_table_t *weak_table, <span class="type">id</span> referent_id, </span><br><span class="line">                      <span class="type">id</span> *referrer_id, <span class="type">bool</span> crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果referent为nil 或 referent 采用了TaggedPointer计数方式，直接返回，不做任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保被引用的对象可用（没有在析构，同时应该支持weak引用）</span></span><br><span class="line">    <span class="type">bool</span> deallocating;</span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">BOOL</span> (*allowsWeakReference)(objc_object *, SEL) = </span><br><span class="line">            (<span class="type">BOOL</span>(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((<span class="type">id</span>)referent, </span><br><span class="line">                                           SEL_allowsWeakReference);</span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, SEL_allowsWeakReference);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正在析构的对象，不能够被弱引用</span></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Cannot form weak reference to instance (%p) of &quot;</span></span><br><span class="line">                        <span class="string">&quot;class %s. It is possible that this object was &quot;</span></span><br><span class="line">                        <span class="string">&quot;over-released, or is in the process of deallocation.&quot;</span>,</span><br><span class="line">                        (<span class="type">void</span>*)referent, object_getClassName((<span class="type">id</span>)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">    <span class="comment">// 在 weak_table中找到referent对应的weak_entry,并将referrer加入到weak_entry中</span></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123; <span class="comment">// 如果能找到weak_entry,则讲referrer插入到weak_entry中</span></span><br><span class="line">        append_referrer(entry, referrer);   <span class="comment">// 将referrer插入到weak_entry_t的引用数组中</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 如果找不到，就新建一个</span></span><br><span class="line">        weak_entry_t new_entry(referent, referrer);  </span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>若引用计数使用了 <code>taggedPointer</code>，则不会做任何引用计数。</li><li>判断 <code>referent_id</code> 是否正在被析构以及 <code>referent_id</code> 是否支持 <code>weak</code> 引用。如果 <code>referent_id</code> 不能够被 <code>weak</code> 引用，则直接返回 <code>nil</code>。</li><li>如果 <code>referent_id</code> 能够被 <code>weak</code> 引用，则将 <code>referent_id</code> 对应的 <code>weak_entry_t</code> 从 <code>weak_table</code> 的 <code>weak_entry_t</code> 哈希数组中找出来，如果不存在，则新建。</li><li>调用 <code>append_referrer</code> 函数将 <code>referrer</code> 插入到 <code>weak_entry_t</code> 的引用数组中。</li><li>将 <code>weak_entry_t</code> 插入到 <code>weak_table</code> 中，并返回 <code>referent_id</code>。</li></ul><p><code>referrer</code> 插入到 <code>weak_entry_t</code> 中调用了函数 <code>append_referrer</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> append_referrer(weak_entry_t *entry, objc_object **new_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123; <span class="comment">// 如果 weak_entry 尚未使用动态数组，走这里</span></span><br><span class="line">        <span class="comment">// Try to insert inline.</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 inline_referrers 的位置已经存满了，则要转型为 referrers，做动态数组。</span></span><br><span class="line">        <span class="comment">// Couldn&#x27;t insert inline. Allocate out of line.</span></span><br><span class="line">        weak_referrer_t *new_referrers = (weak_referrer_t *)</span><br><span class="line">            calloc(WEAK_INLINE_COUNT, <span class="keyword">sizeof</span>(weak_referrer_t));</span><br><span class="line">        <span class="comment">// This constructed table is invalid, but grow_refs_and_insert</span></span><br><span class="line">        <span class="comment">// will fix it and rehash it.</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;</span><br><span class="line">        entry-&gt;mask = WEAK_INLINE_COUNT<span class="number">-1</span>;</span><br><span class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于动态数组的附加处理：</span></span><br><span class="line">    assert(entry-&gt;out_of_line()); <span class="comment">// 断言： 此时一定使用的动态数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123; <span class="comment">// 如果动态数组中元素个数大于或等于数组位置总空间的3/4，则扩展数组空间为当前长度的一倍</span></span><br><span class="line">        <span class="keyword">return</span> grow_refs_and_insert(entry, new_referrer); <span class="comment">// 扩容，并插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不需要扩容，直接插入到 weak_entry 中</span></span><br><span class="line">    <span class="comment">// 注意，weak_entry 是一个哈希表，key：w_hash_pointer(new_referrer) value: new_referrer</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里 weak_entry_t 的 hash 算法和 weak_table_t 的 hash 算法是一样的，同时扩容/减容的算法也是一样的</span></span><br><span class="line">    size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask); <span class="comment">// &#x27;&amp; (entry-&gt;mask)&#x27; 确保了 begin的位置只能大于或等于 数组的长度</span></span><br><span class="line">    size_t index = begin;  <span class="comment">// 初始的 hash index</span></span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;  <span class="comment">// 用于记录 hash 冲突的次数，也就是 hash 再位移的次数</span></span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != <span class="literal">nil</span>) &#123;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;  <span class="comment">// index + 1, 移到下一个位置，再试一次能否插入</span></span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry); <span class="comment">// index == begin 意味着数组绕了一圈都没有找到合适位置，报错处理。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123; <span class="comment">// 记录最大的hash冲突次数, max_hash_displacement意味着: 我们尝试至多max_hash_displacement次，肯定能够找到object对应的hash位置</span></span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 ref 存入 hash 数组，同时，更新元素个数 num_refs</span></span><br><span class="line">    weak_referrer_t &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 <code>weak_entry</code> 未使用动态数组，且静态数组还有空间，直接找空位存放。</li><li>如果没有位置存放，则升级为动态数组，如果动态数组中元素个数大于或等于数组位置总空间的 <code>3/4</code>，则数组空间扩容当前空间大小 1 倍。</li><li>插入到 <code>weak_entry</code> 中。</li></ul><p>如果 <code>weak</code> 指针之前指向了一个弱引用，则会调用 <code>weak_unregister_no_lock</code> 方法将旧的 <code>weak</code> 指针地址移除，<code>weak_unregister_no_lock</code> 实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">weak_unregister_no_lock(weak_table_t *weak_table, <span class="type">id</span> referent_id, </span><br><span class="line">                        <span class="type">id</span> *referrer_id)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123; <span class="comment">// 查找到referent所对应的weak_entry_t</span></span><br><span class="line">        remove_referrer(entry, referrer);  <span class="comment">// 在referent所对应的weak_entry_t的hash数组中，移除referrer</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 移除元素之后， 要检查一下weak_entry_t的hash数组是否已经空了</span></span><br><span class="line">        <span class="type">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123; <span class="comment">// 如果weak_entry_t的hash数组已经空了，则需要将weak_entry_t从weak_table中移除</span></span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>从 <code>weak_table</code> 中找出 <code>referent</code> 对应的 <code>weak_entry_t</code>。</li><li>在 <code>weak_entry_t</code> 中移除 <code>referrer</code>。</li><li>判断 <code>weak_entry_t</code> 中是否还有元素，如果已经没有元素了，则将 <code>weak_entry_t</code> 从 <code>weak_table</code> 中移除。</li></ul><p><strong>（1）（2）步总结如下：</strong></p><ul><li><p>1、调用 <code>indexForPointer</code> 获取对象所用的 <code>SideTable</code> 在 <code>SideTables</code> 中的 <code>index</code>，从而取到 <code>SideTable</code>。</p><ul><li><code>SideTables</code> 是全局 hash 数组，在 iPhone 和模拟器上，<code>SideTables</code> 存储 8 个 <code>SideTable</code>，Mac 上存储 64 个 <code>SideTable</code>，<code>SideTable</code> 数量即 <code>StripeCount</code>。</li><li>计算 <code>index</code> 时，将对象地址经过一定位移计算后，与 <code>StripeCount</code> 进行模运算，结果即 <code>index</code>，同时确保了结果不会超过 <code>StripeCount</code>。</li></ul></li><li><p>2、调用 <code>weak_entry_for_referent</code> 从 <code>weak_table</code> 中的 <code>weak_entries</code> 中获取对应 <code>weak_entry_t</code>。</p><ul><li><code>weak_table</code> 中的 <code>weak_entries</code> 同样是个 hash 数组，里面存储了多个 <code>weak_entry_t</code>，每个 <code>weak_entry_t</code> 存储 1 个对象的弱引用信息。</li><li>计算 <code>weak_entry_t</code> 在 <code>weak_entries</code> 数组中的 <code>index</code> 方式：将对象地址经过 <code>hash_pointer</code> 函数进行 hash，然后和 <code>mask</code> 进行与运算后得到 <code>index</code>，保证了 <code>index</code> 不会越界。<br>  如果对应 <code>index</code> 位置已经有 <code>weak_entry_t</code> 了，就取出其中的 <code>referent</code>（即弱引用对象指针的指针） 是否与目标 <code>referent</code> 相等，不相等的话后移一位继续判断，并将 <code>hash_displacement ++</code>，记录移动次数。当 <code>hash_displacement</code> 的值大于 <code>max_hash_displacement</code> 时，直接返回 <code>nil</code>。<br>  当 <code>index == begin</code> 时，即遍历一圈也没找到目标对象，直接调用 <code>bad_weak_table</code> 报错。</li></ul></li><li><p>3、runtime 调用 <code>objc_initWeak</code> 初始化 <code>weak</code> 指针地址指向对象地址，<code>objc_initWeak</code> 中调用 <code>storeWeak</code>，相关主要逻辑在 <code>storeWeak</code> 中。</p><ul><li>如果 <code>weak</code> 指针之前指向了一个弱引用，则会调用 <code>weak_unregister_no_lock</code> 函数将旧的 <code>weak</code> 指针地址移除。</li><li>如果 <code>weak</code> 指针需要指向一个新的引用，则会调用 <code>weak_register_no_lock</code> 函数将新的 <code>weak</code> 指针地址添加到弱引用表中。</li><li><code>weak_register_no_lock</code> 函数中调用 <code>append_referrer</code> 函数将 <code>referrer</code>（弱引用对象指针的指针）插入到 <code>weak_entry_t</code> 的引用数组。</li><li><code>append_referrer</code> 中会判断 <code>weak_entry</code> 是否是使用了动态数组及动态数组是否需要扩容（当前已使用空间大于等于空间 <code>3/4</code> 将进行扩容，扩容使空间翻倍）</li></ul></li></ul><h2 id="四、对象的释放"><a href="#四、对象的释放" class="headerlink" title="四、对象的释放"></a>四、对象的释放</h2><p>当对象引用计数变为 0 时，其 <code>dealloc</code> 方法会被调用，下面是 LLVM 官方文档 对 <code>dealloc</code> 过程的一个描述：</p><blockquote><p>A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.</p></blockquote><p>大致意思是：<code>dealloc</code> 方法在对象释放(最后一次 <code>release</code>)之后调用，但是对象的实例变量(<code>Ivars</code>)此时还没有释放。<code>dealloc</code> 方法返回时，会自动调用父类的 <code>dealloc</code> 方法。</p><p>上面提到，对象释放后，会调用 <code>dealloc</code> 方法，其内部的实例变量还未销毁，那它的实例变量何时销毁呢？文档中有相关介绍：</p><blockquote><p>The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.</p></blockquote><p>也就是说，ARC 环境下，实例变量在调用根类的 <code>dealloc</code> 方法(<code>[NSObject dealloc]</code>)后的某个时刻被销毁。但实例变量的销毁顺序是不固定的，无论是在单个类内还是在子类和父类之间。</p><p>下面是 <code>dealloc</code> 方法的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dealloc</code> 方法内部调用了 <code>_objc_rootDealloc</code> 函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_objc_rootDealloc(<span class="type">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_objc_rootDealloc 又会调用 rootDealloc 方法：</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果是 Tagged Pointer，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有开启指针优化 &amp; 对象没有被 weak 引用 &amp; 没有关联对象 &amp; 没有自定义的 C++ 析构方法 &amp; 没有用到 sideTable 来做引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 快速释放</span></span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(<span class="variable language_">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 慢速释放</span></span><br><span class="line">        object_dispose((<span class="type">id</span>)<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上逻辑可以知道，接下来会调用 <code>object_dispose</code> 函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> </span><br><span class="line">object_dispose(<span class="type">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 析构obj</span></span><br><span class="line">    objc_destructInstance(obj);</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部主要调用了 <code>objc_destructInstance</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *objc_destructInstance(<span class="type">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="comment">// c++ 析构函数</span></span><br><span class="line">        <span class="type">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="comment">// 判断是否有关联对象</span></span><br><span class="line">        <span class="type">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有 c++ 析构函数 则调用 c++ 析构函数.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx)</span><br><span class="line">            object_cxxDestruct(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有关联对象则移除关联对象</span></span><br><span class="line">        <span class="keyword">if</span> (assoc)</span><br><span class="line">            _object_remove_assocations(obj);</span><br><span class="line">        <span class="comment">// 清理相关的引用</span></span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清理相关引用逻辑主要是在 <code>clearDeallocating</code> 中实现的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// 没有开启 isa 指针优化 清理 obj 存储在 sideTable 中的引用计数等信息</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">         <span class="comment">// 开启了 isa 指针优化，或者使用了 sideTable</span></span><br><span class="line">        <span class="comment">// 清理强引用和弱引用信息</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看下 <code>clearDeallocating_slow</code> 函数的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE <span class="type">void</span></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到对应的 SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="variable language_">this</span>];</span><br><span class="line">    table.lock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否需要清理弱引用信息</span></span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">        <span class="comment">// 对象被弱引用</span></span><br><span class="line">        <span class="comment">// 在 SideTable 的 weak_table 中对 this 进行清理工作</span></span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (<span class="type">id</span>)<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要清理强引用信息</span></span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        <span class="comment">// 采用了 SideTable 做引用计数</span></span><br><span class="line">        <span class="comment">// 在 SideTable 的引用计数中移除 this</span></span><br><span class="line">        table.refcnts.erase(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面逻辑，如果对象被弱引用，调用 <code>weak_clear_no_lock</code> 清理 <code>weak_table</code>。如果对象采用了 <code>SideTable</code> 强引用计数，则移除相关强引用信息。</p><p>接下来看下 <code>weak_clear_no_lock</code> 逻辑：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清理 weak_table，并将所有 weak 指针置为 nil</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line">weak_clear_no_lock(weak_table_t *weak_table, <span class="type">id</span> referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到 referent 在 weak_table 中对应的 weak_entry_t</span></span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn&#x27;t happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出 weak 引用 referent 的 weak 指针地址数组以及数组长度</span></span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    size_t count;</span><br><span class="line">    <span class="comment">// 是否使用动态数组</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的所引用 weak 指针</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="comment">// 取出每个 weak ptr 的地址</span></span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="comment">// 如果 weak ptr 确实 weak 引用了referent，则将 weak ptr 设置为 nil，这也就是为什么 weak 指针会自动设置为nil的原因</span></span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                <span class="comment">// 如果所存储的weak ptr没有weak 引用referent，这可能是由于runtime代码的逻辑错误引起的，报错</span></span><br><span class="line">                _objc_inform(<span class="string">&quot;__weak variable at %p holds %p instead of %p. &quot;</span></span><br><span class="line">                             <span class="string">&quot;This is probably incorrect use of &quot;</span></span><br><span class="line">                             <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                             <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                             referrer, (<span class="type">void</span>*)*referrer, (<span class="type">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于 referent 要被释放了，因此 referent 的 weak_entry_t 也要移除出 weak_table</span></span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要逻辑是遍历所有弱引用该对象的 <code>weak</code> 指针，并将 <code>weak</code> 指针置为 <code>nil</code>，这也就是 <code>weak</code> 指针在对象释放的时候会被置为 <code>nil</code> 的原因。</p><p>以上是对象释放后，清理强弱引用相关逻辑，上面 <code>objc_destructInstance</code> 函数内部还有个 C++ 析构函数的调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *objc_destructInstance(<span class="type">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// c++ 析构函数</span></span><br><span class="line">        <span class="type">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有 c++ 析构函数 则调用 c++ 析构函数.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx)</span><br><span class="line">            object_cxxDestruct(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理管理对象...</span></span><br><span class="line">        <span class="comment">// 清理引用计数...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那调用的析构函数 <code>object_cxxDestruct</code> 是什么呢？内部有哪些逻辑呢？这里不再深究，直接给出总结：<br><code>object_cxxDestruct</code> 内部最终会调用 <code>.cxx_destruct</code> 的函数，《Effective Objective-C 2.0》提到过这个函数：</p><blockquote><p>When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it.</p></blockquote><p>根据介绍，<code>.cxx_destruct</code> 是编译器自动生成的，ARC 环境下，会借用这个函数实现自动内存释放的工作。</p><p>其实，<code>.cxx_destruct</code> 是在 clang 编译期间生成的，只有当前类拥有实例变量(不论是不是用 <code>property</code>)时，这个函数才会自动生成，且父类的实例变量不会导致子类拥有这个函数，其内部最终会调用 <code>emitCXXDestructMethod</code> 函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> emitCXXDestructMethod(CodeGenFunction &amp;<span class="built_in">CGF</span>, ObjCImplementationDecl *impl)</span><br><span class="line">&#123;</span><br><span class="line">   CodeGenFunction::RunCleanupsScope scope(<span class="built_in">CGF</span>);</span><br><span class="line"></span><br><span class="line">   llvm::Value *<span class="keyword">self</span> = <span class="built_in">CGF</span>.LoadObjCSelf();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> ObjCInterfaceDecl *iface = impl-&gt;getClassInterface();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> ObjCIvarDecl *ivar = iface-&gt;all_declared_ivar_begin(); ivar; ivar = ivar-&gt;getNextIvar())</span><br><span class="line">   &#123;</span><br><span class="line">     QualType type = ivar-&gt;getType();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Check whether the ivar is a destructible type.</span></span><br><span class="line">     QualType::DestructionKind dtorKind = type.isDestructedType();</span><br><span class="line">     <span class="keyword">if</span> (!dtorKind) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">     CodeGenFunction::Destroyer *destroyer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Use a call to objc_storeStrong to destroy strong ivars, for the</span></span><br><span class="line">     <span class="comment">// general benefit of the tools.</span></span><br><span class="line">     <span class="keyword">if</span> (dtorKind == QualType::DK_objc_strong_lifetime) &#123;</span><br><span class="line">       destroyer = destroyARCStrongWithStore;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Otherwise use the default for the destruction kind.</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       destroyer = <span class="built_in">CGF</span>.getDestroyer(dtorKind);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     CleanupKind cleanupKind = <span class="built_in">CGF</span>.getCleanupKind(dtorKind);</span><br><span class="line">     <span class="built_in">CGF</span>.EHStack.pushCleanup&lt;DestroyIvar&gt;(cleanupKind, <span class="keyword">self</span>, ivar, destroyer,</span><br><span class="line">                                          cleanupKind &amp; EHCleanup);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   assert(scope.requiresCleanups() &amp;&amp; <span class="string">&quot;nothing to do in .cxx_destruct?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述逻辑可以发现，该函数作用是遍历当前对象所有的实例变量（<code>Ivars</code>)，调用 <code>objc_storeStrong</code> 函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> objc_storeStrong(<span class="type">id</span> *object, <span class="type">id</span> value) &#123;</span><br><span class="line">  value = [value <span class="keyword">retain</span>];</span><br><span class="line">  <span class="type">id</span> oldValue = *object;</span><br><span class="line">  *object = value;</span><br><span class="line">  [oldValue release];</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到调用过 <code>objc_storeStrong</code> 函数后，这个实例变量就被 <code>release</code> 和设置成 <code>nil</code> 了。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> isa </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RunLoop 实现原理</title>
      <link href="/posts/21474/"/>
      <url>/posts/21474/</url>
      
        <content type="html"><![CDATA[<h2 id="1、RunLoop-的概念"><a href="#1、RunLoop-的概念" class="headerlink" title="1、RunLoop 的概念"></a>1、RunLoop 的概念</h2><p>我们都知道，APP 运行过程中有一个很重要的线程，就是主线程。但是，一般线程执行完任务后就会退出，而 APP 需要持续运行，所以就需要一个机制使主线程持续运行并随时处理用户事件，在 iOS 里，程序的持续运行就是通过 RunLoop 实现的。</p><p><strong>RunLoop 的作用：</strong></p><ul><li><p>保持程序持续运行；<br>程序一启动就会开启一个主线程，主线程开启之后会自动运行一个主线程对应的 RunLoop，RunLoop 保证主线程不会被销毁，也就保证了程序的持续运行；</p></li><li><p>处理 App 中的各种事件<br>比如：触摸事件，定时器事件等；</p></li><li><p>节省 CPU 资源，提高程序性能<br>程序运行起来时，当什么操作都没有做的时候，RunLoop 就告诉 CPU，现在没有事情做，我要去休息，这时 CPU 就会将其资源释放出来去做其他的事情，当有事情做的时候 RunLoop 就会立马起来去做事情；</p></li></ul><p>在 iOS 中，NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，CFRunLoopRef 这些 API 都是线程安全的，Apple 在其文档上对 NSRunLoop 非线程安全的提示：<br><img src="/images/lix_blog_56.png"></p><blockquote><p>通常不将 RunLoop 类视为线程安全的，并且只能在当前线程的上下文中调用其方法。永远不要尝试调用在不同线程中运行的 RunLoop 对象的方法，因为这样做可能会导致意外的结果。</p></blockquote><p>CFRunLoopRef 是开源的，源码下载地址：<a href="http://opensource.apple.com/tarballs/CF/">http://opensource.apple.com/tarballs/CF/</a></p><p>为了源码阅读更容易，便于理解 RunLoop 代码关键逻辑，本文所贴出的源码部分有删减，只留下了关键部分。</p><h2 id="2、RunLoop-的数据结构"><a href="#2、RunLoop-的数据结构" class="headerlink" title="2、RunLoop 的数据结构"></a>2、RunLoop 的数据结构</h2><p>在 CoreFoundation 中，RunLoop 主要有 5 个类：</p><ul><li>CFRunLoopRef</li><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef</li><li>CFRunLoopTimerRef</li><li>CFRunLoopObserverRef</li></ul><h3 id="1-CFRunLoopRef"><a href="#1-CFRunLoopRef" class="headerlink" title="(1) CFRunLoopRef"></a>(1) CFRunLoopRef</h3><p>NSRunLoop 是基于 <code>CFRunLoopRef</code> 封装的，提供了面向对象的 API，接下来看下 NSRunLoop（即 <code>CFRunLoopRef</code>）的数据结构：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoop * <span class="built_in">CFRunLoopRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runloop 所对应线程</span></span><br><span class="line">    pthread_t _pthread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  存放所有标记为 common 的 mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放 common mode item 的集合(source、timer、observer)</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前所在 mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放 mode 的集合</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据以上源码可知，RunLoop 也是一个结构体，即 <code>__CFRunLoop</code>，并且可以看到其中几个关键的成员变量：</p><ul><li><p>_commonModes<br>RunLoop 的内容发生变化时，RunLoop 会自动将 <code>_commonModeItems</code> 里的 Source&#x2F;Observer&#x2F;Timer 同步到 <code>_commonModes</code> 中所有 <code>Mode</code> 里。主线程的 RunLoop 中 <code>kCFRunLoopDefaultMode</code> 和 <code>UITrackingRunLoopMode</code> 都已经被标记为“Common”。<br>我们可以通过下面方法把一个 <code>Mode</code> 标记为 “Common”：<br><code>CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</code></p></li><li><p>_commonModeItems<br>添加 mode item 的时候，如果 <code>modeName</code> 传入 <code>NSRunLoopCommonModes</code>，则该 mode item 会被保存到 RunLoop 的 <code>_commonModeItems</code> 中，例如：<br><code>[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></p></li><li><p>_currentMode<br>runloop 当前所在 <code>mode</code></p></li><li><p>_modes<br>存放 <code>mode</code> 的集合</p></li></ul><p>也就是说，RunLoop 可以有多个 mode（CFRunLoopModeRef） 对象，但是同一时间只能运行某一种特定的 Mode。</p><p>CFRunLoop 对外暴露的管理 Mode 接口只有下面 2 个：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddCommonMode</span>(<span class="built_in">CFRunLoopRef</span> runloop, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, ...);</span><br></pre></td></tr></table></figure><p>Mode 暴露的管理 mode item 的接口有下面几个：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br></pre></td></tr></table></figure><p>只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop 会自动创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p><h3 id="2-CFRunLoopModeRef"><a href="#2-CFRunLoopModeRef" class="headerlink" title="(2) CFRunLoopModeRef"></a>(2) CFRunLoopModeRef</h3><p><code>CFRunLoopModeRef</code> 其实是指向 <code>__CFRunLoopMode</code> 结构体的指针，其源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoopMode *<span class="built_in">CFRunLoopModeRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoopMode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mode 的名称</span></span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mode 是否停止</span></span><br><span class="line">    Boolean _stopped;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从以上源码可知，每个 mode 对象中，可以存储多个 source、observer、timer（source&#x2F;observer&#x2F;timer 被统称为 mode item）。</p><p>系统默认注册了 5 个 Mode:</p><ul><li><p>kCFRunLoopDefaultMode<br>App的默认 Mode，通常主线程是在这个 Mode 下运行的，是大多数操作使用的模式。一般情况下，使用此模式来启动运行循环并配置输入源。</p></li><li><p>UIInitializationRunLoopMode<br>在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p></li><li><p>UITrackingRunLoopMode<br>界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p></li><li><p>GSEventReceiveRunLoopMode<br>接受系统事件的内部 Mode。</p></li><li><p>kCFRunLoopCommonModes<br>这是一个占位用的 Mode，作为标记 <code>kCFRunLoopDefaultMode</code> 和 U<code>ITrackingRunLoopMode</code> 用，并不是一种真正的 Mode</p></li></ul><h3 id="3-CFRunLoopSourceRef"><a href="#3-CFRunLoopSourceRef" class="headerlink" title="(3) CFRunLoopSourceRef"></a>(3) CFRunLoopSourceRef</h3><p><code>CFRunLoopSourceRef</code> 是事件源（输入源）。其分为 <code>source0</code> 和 <code>source1</code>：</p><ul><li><p><strong>source0</strong><br>非基于 port 的，接收点击事件，触摸事件等 APP 内部事件，也就是用户触发的事件。这种 source 是不能主动唤醒 RunLoop 的。<br>使用时，需要先调用 ：<br><code>CFRunLoopSourceSignal(source)</code><br>将这个 Source 标记为待处理，然后再调用：<br><code>CFRunLoopWakeUp(runloop)</code><br>来主动唤醒 RunLoop，让其处理这个事件。</p></li><li><p><strong>source1</strong><br>基于 Port 的，能主动唤醒 RunLoop，通过内核和其他线程通信，接收分发系统事件；触摸硬件，通过 Source1 接收和分发系统事件到 Source0 处理。</p></li></ul><p>关于 Port 内容后文会进行总结。</p><p><code>CFRunLoopSourceRef</code> 源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoopSource * <span class="built_in">CFRunLoopSourceRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoopSource</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// source 的优先级，值为小，优先级越高</span></span><br><span class="line">    <span class="built_in">CFIndex</span> _order; <span class="comment">/* immutable */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runloop 集合</span></span><br><span class="line">    <span class="built_in">CFMutableBagRef</span> _runLoops;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，表示 source 是 source0 还是 source1</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopSourceContext</span> version0;  <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">        <span class="built_in">CFRunLoopSourceContext1</span> version1; <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">    &#125; _context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-CFRunLoopObserverRef"><a href="#4-CFRunLoopObserverRef" class="headerlink" title="(4) CFRunLoopObserverRef"></a>(4) CFRunLoopObserverRef</h3><p><code>CFRunLoopObserverRef</code> 是观察者，每个 <code>Observer</code> 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit          = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> 源码如下：</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoopObserver * <span class="built_in">CFRunLoopObserverRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoopObserver</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// observer 对应的 runloop</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> _runLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// observer 观察了多少个 runloop</span></span><br><span class="line">    <span class="built_in">CFIndex</span> _rlCount;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFOptionFlags</span> _activities;          <span class="comment">/* immutable */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// observer 优先级</span></span><br><span class="line">    <span class="built_in">CFIndex</span> _order;                     <span class="comment">/* immutable */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// observer 回调函数</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverCallBack</span> _callout; <span class="comment">/* immutable */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (*<span class="built_in">CFRunLoopObserverCallBack</span>)(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="type">void</span> *info);</span><br></pre></td></tr></table></figure><p>例如，监听 RunLoop 的状态：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建observer</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopEntry&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeTimers&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeSources&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeWaiting&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopAfterWaiting&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopExit&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 把 observer 添加到 RunLoop 中</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure><h3 id="5-CFRunLoopTimerRef"><a href="#5-CFRunLoopTimerRef" class="headerlink" title="(5) CFRunLoopTimerRef"></a>(5) CFRunLoopTimerRef</h3><p><code>CFRunLoopTimerRef</code> 是基于时间的触发器，我们常用的 <code>NSTimer</code> 其实就是 <code>CFRunLoopTimerRef</code> ，他们之间是 toll-free bridged 的，可以相互转换。其包含一个时间长度和一个回调(函数指针)。<br>当其加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个回调。</p><p><strong>总结：</strong><br>一个 RunLoop 中，只能对应一个线程，但是可以包含多个 Mode，每个 mode，可以包含多个 source、observer、timer，其关系如下：<br><img src="/images/lix_blog_57.png" style="width:60%;"></p><ul><li>RunLoop 启动时只能选择其中一个 Mode，作为 currentMode。</li><li>如果需要切换 Mode，只能退出当前 Loop，再重新选择一个 Mode 进入。</li><li>不同 Mode 的 Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer 能分隔开来，互不影响。</li><li>如果 Mode 里没有任何 Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer，RunLoop 会立马退出。</li></ul><h2 id="3、RunLoop-的执行流程"><a href="#3、RunLoop-的执行流程" class="headerlink" title="3、RunLoop 的执行流程"></a>3、RunLoop 的执行流程</h2><p>当 APP 没有任何任务的时候，RunLoop 会进入休眠，RunLoop 就告诉 CPU，现在没有事情做，我要去休息，这时 CPU 就会将其资源释放出来去做其他的事情。当下次有任务的时候，例如用户点击了屏幕，RunLoop 就会结束休眠开始处理用户的点击事件。所以，为了看到 RunLoop 执行流程，可以在点击事件里加个断点，查看 RunLoop 相关的方法调用栈：<br><img src="/images/lix_blog_58.png"></p><p>根据上图发现，分析 RunLoop 执行流程，可以从 <code>CFRunLoopRunSpecific</code>、<code>__CFRunLoopRun</code> 函数入手，而对 <code>CFRunLoopRunSpecific</code> 函数的调用，可以在源码中找到，是在 <code>CFRunLoopRun</code> 函数中，源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="type">void</span>) &#123;   <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    int32_t result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SInt32 <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上源码可知：</p><ul><li>默认底层是通过 <code>CFRunLoopRun</code> 开启 RunLoop 的，并且超时时间设置的非常大：1.0e10，可以理解为不超时。</li><li>我们也可以通过 <code>CFRunLoopRunInMode</code> 函数设置自定义启动方式，可以自定义超时时间、mode。</li></ul><p>然后进入 <code>CFRunLoopRunSpecific</code> 函数，这是 RunLoop 的核心逻辑：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// __CFRunLoopRun中 具体要做的事情</span></span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 11. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int32_t __CFRunLoopRun(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopModeRef</span> rlm, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class="built_in">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class="line"></span><br><span class="line">    int32_t retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 处理block</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 处理Source0</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="comment">// 如果处理Source0的结果是true</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">// 再次处理block</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0</span>ULL == timeout_context-&gt;termTSR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 如果有Source1 (基于port) 处于ready状态，直接处理这个Source1然后跳转去处理消息。</span></span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopWaitForMultipleObjects(<span class="literal">NULL</span>, &amp;dispatchPort, <span class="number">0</span>, <span class="number">0</span>, &amp;livePort, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果有Source1, 就跳转到handle_msg</span></span><br><span class="line">            <span class="keyword">goto</span> handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 通知 Observers: RunLoop 的线程即将进入休眠(sleep)</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 调用mach_msg等待接受mach_port的消息。线程将进入休眠, 等待别的消息来唤醒当前线程：</span></span><br><span class="line">        <span class="comment">// 一个基于 port 的Source 的事件。</span></span><br><span class="line">        <span class="comment">// 一个 Timer 到时间了</span></span><br><span class="line">        <span class="comment">// RunLoop 自身的超时时间到了</span></span><br><span class="line">        <span class="comment">// 被其他什么调用者手动唤醒</span></span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        <span class="comment">// 8. 通知Observers: 结束休眠, RunLoop的线程刚刚被唤醒了</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 收到消息，处理消息。</span></span><br><span class="line">    handle_msg:;</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* 被timer唤醒 */</span>) &#123;</span><br><span class="line">            <span class="comment">// 01. 处理Timer</span></span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* 被gcd唤醒 */</span>) &#123;</span><br><span class="line">            <span class="comment">// 02. 处理gcd</span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 被Source1唤醒</span></span><br><span class="line">            <span class="comment">// 处理Source1</span></span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 9. 处理Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 10. 设置返回值, 根据不同的结果, 处理不同操作</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            <span class="comment">// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            <span class="comment">// 超出传入参数标记的超时时间了</span></span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">             <span class="comment">// 被外部调用者强制停止了</span></span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            <span class="comment">// source/timer/observer一个都没有了</span></span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上源码可知，RunLoop 内部是一个 do-while 循环；当调用 <code>CFRunLoopRun()</code> 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p><p>RunLoop 执行流程可用下面这张图概括：<br><img src="/images/lix_blog_59.png"><br><strong>通过上面的执行流程可以发现，RunLoop 处理了很多次 Block，即调用了很多次 <code>__CFRunLoopDoBlocks</code>，那这里处理的 Block 到底是什么 Block 呢？</strong><br>前面提到了 <code>__CFRunLoop</code> 结构体中的一些常见成员，其实还有两个和 Block 相关的成员：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> _block_item *_blocks_head; <span class="comment">// 存放 CFRunLoopPerformBlock 函数添加的 Block 的双向链表的头指针</span></span><br><span class="line">    <span class="keyword">struct</span> _block_item *_blocks_tail; <span class="comment">// 存放 CFRunLoopPerformBlock 函数添加的 Block 的双向链表的尾指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_blocks_head</code> 和 <code>_blocks_tail</code> 就是用于存放 <code>CFRunLoopPerformBlock</code> 函数添加的 Block 的，可见 RunLoop 是将添加的 Block 任务保存在双向链表中的。</p><p>我们可以通过 <code>CFRunLoopPerformBlock</code> 将一个 Block 任务加入到 RunLoop：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">CFRunLoopPerformBlock</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFTypeRef</span> mode, <span class="type">void</span>(block)( <span class="type">void</span>));</span><br></pre></td></tr></table></figure><p>可以看出添加 Block 任务的时候，是绑定到某个 runloop mode 的。调用上面的 api 之后，runloop 在执行的时候，会通过如下 API 执行对应 mode 中所有的 block：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__CFRunLoopDoBlocks(rl, rlm);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>CFRunLoopPerformBlock</code> 不会主动唤醒 RunLoop，添加完 Block 之后可以使用 <code>CFRunLoopWakeUp</code> 来主动唤醒 RunLoop。</p><h2 id="4、RunLoop-与线程的关系"><a href="#4、RunLoop-与线程的关系" class="headerlink" title="4、RunLoop 与线程的关系"></a>4、RunLoop 与线程的关系</h2><p><code>CFRunLoop</code> 是基于 <code>pthread</code> 来管理线程的，苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code> <code>和 CFRunLoopGetCurrent()</code>。 这两个函数内部的逻辑大致如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前线程的 RunLoop 对象，内部调用 _CFRunLoopGet0 函数</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="type">void</span>) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> rl = (<span class="built_in">CFRunLoopRef</span>)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看_CFRunLoopGet0方法</span></span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    <span class="comment">// 如果为空则t设置为主线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">    t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFLock(&amp;loopsLock);</span><br><span class="line">    <span class="comment">// 如果不存在 RunLoop，则创建</span></span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">    <span class="built_in">CFMutableDictionaryRef</span> dict = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">    <span class="comment">// 根据传入的主线程获取主线程对应的 RunLoop</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">    <span class="comment">// 保存主线程 将主线程-key 和 RunLoop-Value 保存到字典中</span></span><br><span class="line">    <span class="built_in">CFDictionarySetValue</span>(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">    <span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="type">void</span> * <span class="keyword">volatile</span> *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(dict);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(mainLoop);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从字典里面取 RunLoop：将线程作为 key 从字典里获取 RunLoop</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFUnlock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 RunLoop 为空，则创建一个新的 RunLoop，所以 RunLoop 会在第一次获取的时候创建</span></span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;  </span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">    loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建好之后，以线程为 key，RunLoop 为 value，一对一存储在字典中，下次获取的时候，则直接返回字典内的 RunLoop</span></span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123; </span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">        loop = newLoop;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// do not release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span></span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">    <span class="comment">// 线程结束是销毁 loop</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果传入线程和当前线程相同</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        <span class="comment">// 注册一个回调，当线程销毁时，顺便也销毁对应的 RunLoop</span></span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="type">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="type">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="type">void</span> (*)(<span class="type">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码分析可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个 Dictionary 字典里。<br>所以我们创建子线程 RunLoop 时，只需在子线程中获取当前线程的 RunLoop 对象即可 <code>[NSRunLoop currentRunLoop]</code>。如果不获取，那子线程就不会创建与之相关联的 RunLoop，并且只能在一个线程的内部获取其 RunLoop。<br>当通过调用 <code>[NSRunLoop currentRunLoop]</code> 方法获取 RunLoop 时，会先看一下字典里有没有子线程对应的 RunLoop，如果有则直接返回 RunLoop，如果没有则会创建一个，并将与之对应的子线程存入字典中。当线程结束时，RunLoop 会被销毁。</p><p><strong>Runloop 与线程的关系总结：</strong></p><ul><li>每条线程都有唯一的一个与之对应的 RunLoop 对象；</li><li>RunLoop 保存在一个全局的 Dictionary 里，线程作为 key，RunLoop 作为 value</li><li>调用 <code>[NSRunLoop currentRunLoop]</code> 方法获取 RunLoop 时，会先看一下字典里有没有子线程对应的 RunLoop，如果有则直接返回 RunLoop，如果没有则会创建一个，并将对应关系保存到字典里。</li><li>主线程的 RunLoop 已经自动创建好了，子线程的 RunLoop 需要主动创建；</li><li>RunLoop 在第一次获取时创建，在线程结束时销毁；</li></ul><h2 id="5、Runloop-的启动与退出"><a href="#5、Runloop-的启动与退出" class="headerlink" title="5、Runloop 的启动与退出"></a>5、Runloop 的启动与退出</h2><h3 id="1-创建-Runloop"><a href="#1-创建-Runloop" class="headerlink" title="(1) 创建 Runloop"></a>(1) 创建 Runloop</h3><p>无法直接创建 RunLoop，但是 RunLoop 在第一次获取时自动创建，获取 RunLoop：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Foundation</span><br><span class="line"><span class="comment">// 获得当前线程的 RunLoop 对象</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> currentRunLoop]; </span><br><span class="line"><span class="comment">// 获得主线程的 RunLoop 对象</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> mainRunLoop]; </span><br><span class="line"></span><br><span class="line">Core Foundation</span><br><span class="line"><span class="comment">// 获得当前线程的 RunLoop 对象</span></span><br><span class="line"><span class="built_in">CFRunLoopGetCurrent</span>(); </span><br><span class="line"><span class="comment">// 获得主线程的 RunLoop 对象</span></span><br><span class="line"><span class="built_in">CFRunLoopGetMain</span>(); </span><br></pre></td></tr></table></figure><h3 id="2-启动-Runloop"><a href="#2-启动-Runloop" class="headerlink" title="(2) 启动 Runloop"></a>(2) 启动 Runloop</h3><p>Apple 把 Runloop 启动方式分成了三种:</p><ul><li>无条件地（Unconditionally）</li><li>有时间限制（With a set time limit）</li><li>指定 Mode（In a particular mode）</li></ul><p>这三种方式分别对应下面三个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)run;</span><br><span class="line">- (<span class="type">void</span>)runUntilDate:(<span class="built_in">NSDate</span> *)limitDate;</span><br><span class="line">- (<span class="type">BOOL</span>)runMode:(<span class="built_in">NSRunLoopMode</span>)mode beforeDate:(<span class="built_in">NSDate</span> *)limitDate;</span><br></pre></td></tr></table></figure><ul><li>第 1 种方式，本质就是在 <code>NSDefaultRunLoopMode</code> 模式下无限循环调用 <code>runMode:beforeDate:</code> 方法，在此期间会处理来自输入源的数据；</li><li>第 2 种方式，本质也是在 <code>NSDefaultRunLoopMode</code> 模式下无限循环调用 <code>runMode:beforeDate:</code> 方法，区别在于它达到指定的超时时间后就不会再调用，在此期间会处理来自输入源的数据。</li><li>第 3 种方式，Runloop 只会运行一次，达到指定超时时间或者第一个 input source 被处理，则 Runloop 就会退出，这个方法会阻塞当前线程，直到返回结果（YES：输入源被处理或者达到指定的超时值，NO：没有启动成功）。</li></ul><h3 id="3-退出-Runloop"><a href="#3-退出-Runloop" class="headerlink" title="(3) 退出 Runloop"></a>(3) 退出 Runloop</h3><p>相较于 Runloop 的启动，它的退出就比较简单了，只有两种方法:</p><ul><li>设置超时时间</li><li>手动结束</li></ul><p>针对前面提到的第 2、3 中启动方式，可以直接设置超时时间控制退出。如果想要手动退出，可以使用下面函数，其参数就是 Runloop 对象：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopRef</span> rl)</span><br></pre></td></tr></table></figure><p>但是 Apple 文档中在介绍利用 <code>CFRunLoopStop()</code> 手动退出时提到:</p><blockquote><p>The difference is that you can use this technique on run loops you started unconditionally.</p></blockquote><p>这里的解释非常容易产生误会，如果在阅读时没有注意到 exit 和 terminate 的微小差异就很容易掉进坑里，因为在 run 方法的文档中还有这句话:</p><blockquote><p>If you want the run loop to terminate, you shouldn’t use this method</p></blockquote><p>也就是说，前面三种 Runloop 启动方式，对应退出方式如下：</p><ul><li><p><strong>run</strong><br>无法退出</p></li><li><p><strong>runUntilDate:</strong><br>只能通过设置超时时间进行退出</p></li><li><p><strong>runMode:beforeDate:</strong><br>可以通过设置超时时间或者使用 <code>CFRunLoopStop</code> 方法来退出</p></li></ul><p><code>CFRunLoopStop()</code> 函数只会结束当前的 <code>runMode:beforeDate:</code> 调用，而不会结束后续的调用，这也就是为什么 Runloop 的文档中说 <code>CFRunLoopStop()</code> 可以 exit(退出) 一个 Runloop，而在 run 等方法的文档中又说这样会导致 Runloop 无法 terminate(终结)。</p><p>如果既让 Runloop 长时间运行，又要在必要时刻手动退出 Runloop，<a href="https://developer.apple.com/documentation/foundation/nsrunloop/1412430-run">Apple 官方文档</a>提供了推荐方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BOOL</span> shouldKeepRunning = <span class="literal">YES</span>;        <span class="comment">// global</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *theRL = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="keyword">while</span> (shouldKeepRunning &amp;&amp; [theRL runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]]);</span><br></pre></td></tr></table></figure><p>在对应线程中通过如下逻辑退出 Runloop：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shouldKeepRunning = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br></pre></td></tr></table></figure><h2 id="6、RunLoop-的底层实现"><a href="#6、RunLoop-的底层实现" class="headerlink" title="6、RunLoop 的底层实现"></a>6、RunLoop 的底层实现</h2><h3 id="1-RunLoop-与-mach-port"><a href="#1-RunLoop-与-mach-port" class="headerlink" title="(1) RunLoop 与 mach port"></a>(1) RunLoop 与 mach port</h3><p>Apple 将 iOS 系统大致划分为下面 4 个层次：<br><img src="/images/lix_blog_210.png" style="width:50%;"><br>Darwin 的架构如下：<br><img src="/images/lix_blog_211.png" style="width:50%;"></p><p>Darwin 是 macOS 和 iOS 操作环境的操作系统部分，Darwin 是一种类 Unix 操作系统（即 Unix 衍生出的系统，在一定程度上继承了原始 Unix 特性），Darwin 的内核是 XNU，XNU 是 Apple 开发的用于 macOS、iOS、tvOS、watchOS 操作系统的内核，XNU 是 X is Not Unix 的缩写。它是一个宏内核 BSD 与微内核 Mach 混合内核，以期将两者的特性兼收并蓄，同时拥有两种内核的优点。</p><p><strong>关于 iOS 系统架构相关更多内容，可以看下我的这篇博客：<a href="https://www.lixkit.com/posts/28259/">《深入解析 iOS 系统架构》</a></strong></p><p><strong>Mach：</strong><br>Mach 是一个由卡内基梅隆大学开发的计算机操作系统微内核，Mach 核心之上可平行运行多个操作系统，XNU 内核以一个被深度定制的 Mach 内核作为基础。Mach 提供了诸如处理器调度、IPC (进程间通信)等少量且不可或缺的基础 API。在 Mach 中，所有东西都是“对象”，进程（在 Mach 中称为任务）、线程和虚拟内存都是对象。但是，在 Mach 架构中，对象间不能相互调用，对象间通信只能通过消息传递。“消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p><p><strong>BSD：</strong><br>XNU 中的 BSD 代码来自 FreeBSD 内核，FreeBSD 是一种开放源代码的类 Unix 的操作系统，基于 BSD Unix 的源代码派生发展而来。BSD 层确保了 Darwin 系统的 UNIX 特性，真正的内核是 Mach，但是对外部隐藏。BSD 提供了更高层次的抽象 API，例如：基于 Mach 的任务之上的 Unix 进程模型、文件系统、网络协议栈等相关 API。</p><p><strong>I&#x2F;O Kit：</strong><br>I&#x2F;O Kit 为设备驱动提供了一个面向对象(C++)的一个框架，框架提供每种设备驱动需要的常见特性，以使驱动程序可以用更少的时间和代码完成。</p><p><strong>用户态与内核态：</strong><br>内核控制着操作系统最核心的部分，为了防止应用程序崩溃而导致的内核崩溃，内核与应用程序之间需要进行严格的分离。基于软件的分离会产生巨大的开销，因此现代的操作系统都是依靠硬件来分离。分离的结果就是用户态与内核态。</p><p>用户态和内核态的切换有两种类型：</p><ul><li>自愿转换：比如系统调用；</li><li>非自愿转换：当发生异常、中断或处理器陷阱的时候，代码的执行会被挂起，并且保留发生错误时候的完整状态。控制权被转交给预定义的内核态错误处理程序或中断服务程序。</li></ul><p><strong>在 XNU 中，系统调用有四种类别：</strong></p><ul><li>BSD 系统调用</li><li>Mach 陷阱</li><li>机器相关调用</li><li>诊断调用</li></ul><p>Mach 消息的发送和接收都是通过同一个 API 函数 <code>mach_msg()</code> 进行的，这个函数在用户态和内核态都有实现。<code>mach_msg()</code> 函数调用了一个 Mach 陷阱（trap），在用户态调用 <code>mach_msg_trap()</code> 会引发陷阱机制，切换到内核态，在内核态中，内核实现的 <code>mach_msg()</code> 会完成实际的工作，如下图：<br><img src="/images/lix_blog_190.png"><br>RunLoop 的核心就是基于 mach port 的，其进入休眠时调用的函数是 <code>mach_msg()</code>，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。</p><p>前面提到的 <code>source1</code> 就是基于 mach port 的，它用来接收系统事件。当对应系统事件发生后（例如用户点击了屏幕），最终会通过 mach port 将事件转发给需要的 App 进程。随后苹果注册的那个 <code>source1</code> 就会触发回调，RunLoop 被唤醒，APP 开始处理对应事件。</p><h3 id="2-RunLoop-输入源"><a href="#2-RunLoop-输入源" class="headerlink" title="(2) RunLoop 输入源"></a>(2) RunLoop 输入源</h3><p>Runloop 作为线程的入口用来响应传入事件，Runloop 从两种不同类型的源接收事件：</p><ul><li><p>输入源（Input Source）<br>用于传输异步事件，通常是来自另一个线程或者其他程序的消息。输入源将异步事件传递给相应的处理程序，并调用 runUntilDate: 方法（在线程的关联 NSRunLoop 对象上调用）退出。</p></li><li><p>定时器源（Timer Source）<br>提供同步事件，预定的时间或者固定的时间间隔重复执行，计时器源将事件传递给其处理程序，但不会导致 Runloop 退出。<br><img src="/images/lix_blog_63.png"></p></li></ul><p><strong>输入源（Input Source）</strong><br>创建输入源时，可以将其分配给 Runloop 的一种或多种 mode。一般情况下应该在默认模式下运行 Runloop，但也可以指定自定义 mode。如果输入源不在当前监视的 mode 下，则它生成的任何事件都将保留，直到 Runloop 以正确的 mode 运行，输入源主要有：基于的端口的输入源、自定义输入源、Perform Selector 源。</p><p><strong>基于的端口的输入源（Port-based Source）</strong><br>监听应用程序的 Mach 端口，由内核自动发出信号，对应源码中的 <code>source1</code>。</p><p>Cocoa 和 Core Foundation 都提供了创建基于的端口输入源相关的对象和函数，如果使用 Cocoa 提供的相关方法，不需要直接创建输入源，可以使用 <code>NSPort</code> 相关的方法来创建一个 <code>Port</code> 对象，并将该对象添加到 Runloop 中，该 Port 对象会负责创建和配置输入源。使用 Core Foundation 函数实现稍微复杂些，我们需要手动的创建 Port 和它的 Runloop 源。使用 <code>CFMachPortRef</code>, <code>CFMessagePortRef</code>, 或者 <code>CFSocketRef</code> 函数来创建适当地对象。</p><p>例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)testsource1 &#123;</span><br><span class="line">    <span class="comment">// 声明两个端口</span></span><br><span class="line">    <span class="built_in">NSPort</span> *mainPort = [<span class="built_in">NSMachPort</span> port];</span><br><span class="line">    <span class="built_in">NSPort</span> *threadPort = [<span class="built_in">NSMachPort</span> port];</span><br><span class="line">    <span class="comment">// 设置线程的端口的代理回调为自己</span></span><br><span class="line">    threadPort.delegate = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给主线程 Runloop 加一个端口</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop]addPort:mainPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">// 子线程</span></span><br><span class="line">        <span class="comment">// 给子线程添加一个 Port，并运行子线程中的 Runloop</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:threadPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 秒后，从主线程向子线程发送一条消息</span></span><br><span class="line">    <span class="built_in">NSString</span> *s1 = <span class="string">@&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [s1 dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithArray:@[mainPort,data]];</span><br><span class="line">        <span class="comment">// 发送一条消息</span></span><br><span class="line">        <span class="comment">// 参数：date(发送时间)、msgid(消息标识)、components(发送消息附带参数)、reserved(预留参数，暂时用不到)</span></span><br><span class="line">        [threadPort sendBeforeDate:[<span class="built_in">NSDate</span> date] msgid:<span class="number">1000</span> components:array from:mainPort reserved:<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 NSMachPort 收到消息的回调，注意这个参数，可以先给一个id</span></span><br><span class="line">- (<span class="type">void</span>)handlePortMessage:(<span class="type">id</span>)message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;收到消息了，线程为：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">NSArray</span> *array = [message valueForKeyPath:<span class="string">@&quot;components&quot;</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *data =  array[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *s1 = [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RunLoopTest[10368:5612468] 收到消息了，线程为：&lt;NSThread: 0x6000015acf80&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">RunLoopTest[10368:5612468] hello</span><br></pre></td></tr></table></figure><p><strong>自定义输入源（Custom input Source）</strong><br>监听自定义事件源，必须从另一个线程手动发信号通知自定义源，对应源码中的 <code>source0</code>。<br>可以使用 <code>CoreFoundation</code> 中 <code>CFRunLoopSourceRef</code> 相关的函数来创建自定义输入源，可以使用多个回调函数配置自定义输入源，CoreFoundation 在必要时候调用这些函数来配置 <code>source</code>，处理传入的事件，并在从 Runloop 中移除 <code>source</code> 时将其移除。<br>除此之外，还需要定义事件的传递机制，这部分是运行在单独的线程上，负责向输入源提供数据并在适当的时候发出信号，事件的传递机制可自行定义。</p><p>例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span>&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> _runLoopRef;</span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> _source;</span><br><span class="line">    <span class="built_in">CFRunLoopSourceContext</span> _source_context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> testsource0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testsource0 &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;starting thread.......&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        _runLoopRef = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">        <span class="comment">// 初始化_source_context。</span></span><br><span class="line">        bzero(&amp;_source_context, <span class="keyword">sizeof</span>(_source_context));</span><br><span class="line">        <span class="comment">// 这里创建了一个基于事件的源，绑定了一个函数</span></span><br><span class="line">        _source_context.perform = fire;</span><br><span class="line">        <span class="comment">//参数</span></span><br><span class="line">        _source_context.info = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个source</span></span><br><span class="line">        _source = <span class="built_in">CFRunLoopSourceCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;_source_context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 source 添加到当前 RunLoop 中去</span></span><br><span class="line">        <span class="built_in">CFRunLoopAddSource</span>(_runLoopRef, _source, kCFRunLoopDefaultMode);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开启 RunLoop 第三个参数设置为 YES，执行完一次事件后返回</span></span><br><span class="line">        <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">9999999</span>, <span class="literal">YES</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;end thread.......&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CFRunLoopIsWaiting</span>(_runLoopRef)) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop 正在等待事件输入&quot;</span>);</span><br><span class="line">            <span class="comment">// 添加输入事件</span></span><br><span class="line">            <span class="built_in">CFRunLoopSourceSignal</span>(_source);</span><br><span class="line">            <span class="comment">// 唤醒线程，线程唤醒后发现由事件需要处理，于是立即处理事件</span></span><br><span class="line">            <span class="built_in">CFRunLoopWakeUp</span>(_runLoopRef);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop 正在处理事件&quot;</span>);</span><br><span class="line">            <span class="comment">// 添加输入事件，当前正在处理一个事件，当前事件处理完成后，立即处理当前新输入的事件</span></span><br><span class="line">            <span class="built_in">CFRunLoopSourceSignal</span>(_source);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> fire(<span class="type">void</span>* info) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;我现在正在处理后台任务&quot;</span>);</span><br><span class="line">    printf(<span class="string">&quot;%s&quot;</span>,info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RunLoopTest[<span class="number">10630</span>:<span class="number">5649707</span>] starting thread.......</span><br><span class="line">RunLoopTest[<span class="number">10630</span>:<span class="number">5649457</span>] RunLoop 正在等待事件输入</span><br><span class="line">RunLoopTest[<span class="number">10630</span>:<span class="number">5649707</span>] 我现在正在处理后台任务</span><br><span class="line">RunLoopTest[<span class="number">10630</span>:<span class="number">5649707</span>] end thread.......</span><br></pre></td></tr></table></figure><p>Perform Selector 源（Cocoa Perform Selector Source）<br>除了基于端口的源外，Cocoa 还定义了一个自定义输入源，允许在任何线程上 Perfrom Selector。与基于端口的源一样，Perfrom Selector 请求在目标线程上序列化，缓解了在一个线程上运行多个方法时可能出现的许多同步问题。与基于端口的源不同的是，Perform Selector 源在 Perfrom Selector 后会从 Runloop 中删除自己。</p><p>在另一个线程上 Perfrom Selector 时，目标线程必须具有活动的 Runloop。这意味对于我们创建的子线程，需要显式创建 Runloop。由于主线程的 Runloop 是自动创建的，所以可以在 <code>applicationDidFinishLaunching：</code>方法后随时 Perfrom Selector。Runloop 每次循环时，Runloop 都会处理所有的 Perfrom Selector 调用，而不是在每次循环时都只处理一个。</p><p><strong>在其他线程上 Perfrom Selector 的相关方法：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主线程的下一个 Runloop 周期中，执行指定的选择器。这些方法允许您选择阻塞当前线程，直到执行选择器结束。</span></span><br><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:</span><br><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:modes:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对拥有 NSThread 对象的任何线程执行指定的选择器。这些方法允许您选择阻塞当前线程，直到执行选择器结束。</span></span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:</span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:modes:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下一个 Runloop 周期和指定时长延迟(可选)后，在当前线程上执行指定的选择器。由于它要等到下一个 Runloop 周期来执行选择器，所以这些方法提供了一个来自当前执行代码的自动最小延迟，多个选择器时会按照顺序依次执行。</span></span><br><span class="line"><span class="comment">// performSelector:afterDelay: 方法内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效</span></span><br><span class="line">performSelector:withObject:afterDelay:</span><br><span class="line">performSelector:withObject:afterDelay:inModes:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消使用 performSelector:withObject:afterDelay: 或 performSelector:withObject:afterDelay:inModes: 发送的到当前线程的消息</span></span><br><span class="line">cancelPreviousPerformRequestsWithTarget:</span><br><span class="line">cancelPreviousPerformRequestsWithTarget:selector:object:</span><br></pre></td></tr></table></figure><p><strong>计时器源（Timer Source）</strong><br>定时器源在预定时间内同步地将事件传递给线程，定时器可以让线程在对应时刻通知自己执行一些事务，尽管定时器是基于时间的通知方式，但是并不是真的时间机制。就像输入源，定时器在 Runloop 中也是和特定 Mode 相关联的。如果定时器没有处在 Runloop 正在监视的 Mode 中的话，该定时器是不会触发的。必须要等到 Runloop 在定时器支持的 Mode 中运行时，该定时器才会正常运行。如果定时器被触发时机正好是在 Runloop 执行任务中，那么这个定时器源的相关事件只有在 Runloop 下一次运行循环时才能被执行。如果 Runloop 停止运行，那么该定时器源的事件将永远没办法执行。</p><p>反复执行的定时器会根据它的触发时间自动配置，并不是真实的触发时间。例如，一个定时器设置的是每 5 秒触发一次，在真实时间上可能是有点延迟的，如果真实时间的延迟大于定时器触发时间的话，那么这次触发时机将被错过。</p><p>创建定时器源，可以使用下面两个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</span><br><span class="line">scheduledTimerWithTimeInterval:invocation:repeats:</span><br></pre></td></tr></table></figure><p>上面这两个方法创建了定时器并添加到当前线程的默认 mode (<code>NSDefaultRunLoopMode</code>)中，但是也可以通过 <code>NSRunLoop</code> 的下面的实例方法来将 <code>NSTimer</code> 对象添加到其他 mode 中：<br><code>addTimer:forMode:</code></p><p>例如，下面两种实现方式效果是一样的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 分开处理，我们可以通过更多的自定义方式来处理timer，比如添加到不同的NSDefaultRunLoopMode。</span></span><br><span class="line"><span class="built_in">NSDate</span> *futureDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1.0</span>];</span><br><span class="line"><span class="built_in">NSTimer</span> *myTimer = [[<span class="built_in">NSTimer</span> alloc] initWithFireDate:futureDate interval:<span class="number">0.1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timedothing:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:myTimer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将创建和调度同时进行</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.2</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timedothing:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><h2 id="7、RunLoop-目前的应用"><a href="#7、RunLoop-目前的应用" class="headerlink" title="7、RunLoop 目前的应用"></a>7、RunLoop 目前的应用</h2><h3 id="1-AutoreleasePool"><a href="#1-AutoreleasePool" class="headerlink" title="(1) AutoreleasePool"></a>(1) AutoreleasePool</h3><ul><li>RunLoop 的进入的时候会调用 <code>objc_autoreleasePoolPush()</code> 创建新的自动释放池。</li><li>RunLoop 的进入休眠的时候会调用 <code>objc_autoreleasePoolPop()</code> 和 <code>objc_autoreleasePoolPush()</code> 销毁自动释放池、创建一个新的自动释放池。</li><li>RunLoop 即将退出时会调用 <code>objc_autoreleasePoolPop()</code> 释放自动自动释放池内对象。</li></ul><h3 id="2-事件响应"><a href="#2-事件响应" class="headerlink" title="(2) 事件响应"></a>(2) 事件响应</h3><p>苹果注册了一个 <code>Source1</code> (基于 mach port 的) 用来接收系统事件，当一个硬件事件(触摸&#x2F;锁屏&#x2F;摇晃等)发生后，首先由 IOKit.framework 生成一个 <code>IOHIDEvent</code> 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏&#x2F;静音等)、触摸、加速、接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 <code>Source1</code> 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p><p><code>_UIApplicationHandleEventQueue()</code> 会把 <code>IOHIDEvent</code> 处理并包装成 <code>UIEvent</code> 进行处理或分发，其中包括识别 <code>UIGesture</code>&#x2F;处理屏幕旋转&#x2F;发送给 <code>UIWindow</code> 等。通常事件比如 <code>UIButton</code> 点击、<code>touchesBegin</code>&#x2F;<code>Move</code>&#x2F;<code>End</code>&#x2F;<code>Cancel</code> 事件都是在这个回调中完成的。<br><img src="/images/lix_blog_64.png"></p><h3 id="3-手势识别"><a href="#3-手势识别" class="headerlink" title="(3) 手势识别"></a>(3) 手势识别</h3><p>当上面的 <code>_UIApplicationHandleEventQueue()</code> 识别了一个手势时，其首先会调用 Cancel 将当前的 <code>touchesBegin</code>&#x2F;<code>Move</code>&#x2F;<code>End</code> 系列回调打断。随后系统将对应的 <code>UIGestureRecognizer</code> 标记为待处理。</p><p>苹果注册了一个 Observer 监测 <code>BeforeWaiting</code> (Loop 即将进入休眠) 事件，这个 Observe r的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 <code>GestureRecognizer</code>，并执行 <code>GestureRecognizer</code> 的回调。</p><p>当有 <code>UIGestureRecognizer</code> 的变化(创建&#x2F;销毁&#x2F;状态改变)时，这个回调都会进行相应处理。</p><h3 id="4-界面更新"><a href="#4-界面更新" class="headerlink" title="(4) 界面更新"></a>(4) 界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 <code>UIView</code>&#x2F;<code>CALayer</code> 的层次时，或者手动调用了 <code>UIView/CALayer</code> 的 <code>setNeedsLayout</code>&#x2F;<code>setNeedsDisplay</code> 方法后，这个 <code>UIView</code>&#x2F;<code>CALayer</code> 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 <code>BeforeWaiting</code>(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 <code>UIView</code>&#x2F;<code>CAlayer</code> 以执行实际的绘制和调整，并更新 UI 界面。</p><p>这个函数内部的调用栈大概是这样的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> layoutSublayers];</span><br><span class="line">                            [<span class="built_in">UIView</span> layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> display];</span><br><span class="line">                            [<span class="built_in">UIView</span> drawRect];</span><br></pre></td></tr></table></figure><h3 id="5-定时器"><a href="#5-定时器" class="headerlink" title="(5) 定时器"></a>(5) 定时器</h3><p><code>NSTimer</code> 其实就是 <code>CFRunLoopTimerRef</code>，他们之间是 toll-free bridged 的。一个 <code>NSTimer</code> 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><h3 id="6-PerformSelector"><a href="#6-PerformSelector" class="headerlink" title="(6) PerformSelector"></a>(6) PerformSelector</h3><p>当调用 <code>NSObject</code> 的 <code>performSelecter:afterDelay:</code> 后，实际上其内部会创建一个 <code>Timer</code> 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个 <code>Timer</code> 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><p><code>performSelector:withObject:</code> 只是发消息，不会有 Timer ，所以不会有上面的问题，在子线程调用，不需要开启 Runloop </p><h3 id="7-关于-GCD"><a href="#7-关于-GCD" class="headerlink" title="(7) 关于 GCD"></a>(7) 关于 GCD</h3><p>根据前面 RunLoop 的执行流程可以知道，GCD  也是可以唤醒  RunLoop 的，GCD 由子线程返回到 主线程，只有在这种情况下才会触发 RunLoop，会触发 RunLoop 的 <code>Source 1</code> 事件：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;main queue&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当调用 <code>dispatch_async(dispatch_get_main_queue(), block)</code> 时，<code>libDispatch</code> 会向主线程的 RunLoop 发送消息，RunLoop 会被唤醒，并从消息中取得这个 block，并在回调 <code>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE()</code> 里执行这个 block。但这个逻辑仅限于 <code>dispatch</code> 到主线程，<code>dispatch</code> 到其他线程仍然是由 <code>libDispatch</code> 处理的。</p><h3 id="8-关于网络请求"><a href="#8-关于网络请求" class="headerlink" title="(8) 关于网络请求"></a>(8) 关于网络请求</h3><p>iOS 中，关于网络请求的接口有如下几层：<br><img src="/images/lix_blog_65.png" style="width:50%;"><br><code>CFSocket</code> 是最底层的接口，只负责 socket 通信。</p><ul><li><p><code>CFNetwork</code> 是基于 <code>CFSocket</code> 等接口的上层封装，<code>ASIHttpRequest</code> 工作于这一层。</p></li><li><p><code>NSURLConnection</code> 是基于 <code>CFNetwork</code> 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</p></li></ul><p>+<code> NSURLSession</code> 是 iOS7 中新增的接口，表面上是和 <code>NSURLConnection</code> 并列的，但底层仍然用到了 <code>NSURLConnection</code> 的部分功能 (比如 <code>com.apple.NSURLConnectionLoader</code> 线程)，AFNetworking 2 和 Alamofire 工作于这一层。</p><p>下面主要介绍下 <code>NSURLConnection</code> 的工作过程。</p><p>通常使用 <code>NSURLConnection</code> 时，你会传入一个 <code>Delegate</code>，当调用了 <code>[connection start]</code> 后，这个 <code>Delegate</code> 就会不停收到事件回调。实际上，<code>start</code> 这个函数的内部会会获取 <code>CurrentRunLoop</code>，然后在其中的 <code>DefaultMode</code> 添加了 4 个 <code>Source0</code> (即需要手动触发的 Source)。其中 <code>CFMultiplexerSource</code> 是负责各种 <code>Delegate</code> 回调的，<code>CFHTTPCookieStorage</code> 是处理各种 <code>Cookie</code> 的。</p><p>当开始网络传输时，我们可以看到 <code>NSURLConnection</code> 创建了两个新线程：<code>com.apple.CFSocket.private</code> 和 <code>com.apple.NSURLConnectionLoader</code>。其中 <code>CFSocket</code> 线程是处理底层 socket 连接的。<code>NSURLConnectionLoader</code> 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 <code>Source0</code> 通知到上层的 <code>Delegate</code>。<br><img src="/images/lix_blog_66.png"><br><code>NSURLConnectionLoader</code> 中的 RunLoop 接收来自底层 <code>CFSocket</code> 的 <code>Source1</code> 通知。当收到通知后，在合适的时机向 <code>Delegate</code> 线程 RunLoop 发送 <code>CFMultiplexerSource</code> 等 <code>Source0</code> 通知，同时唤醒 <code>Delegate</code> 线程的 RunLoop 来让其处理这些通知。接收到 <code>CFMultiplexerSource</code> 通知后，Delegate 线程的 RunLoop 执行对应 <code>Delegate</code> 回调。</p><h2 id="8、Runloop-开发中的使用场景"><a href="#8、Runloop-开发中的使用场景" class="headerlink" title="8、Runloop 开发中的使用场景"></a>8、Runloop 开发中的使用场景</h2><p>唯一需要显式运行 Runloop 是在创建子线程时。主线程的 Runloop 已自动创建并运行。对于子线程，需要自行判断是否需要 Runloop，如果需要，则开发者自行创建。例如，下列操作需要启动 Runloop：</p><ul><li>使用端口或自定义输入源与其他线程通信。</li><li>在子线程上使用计时器。</li><li>调用 performSelector… 相关方法。</li><li>线程保活，以执行周期性任务。</li></ul><p>以下是在实际开发是，Runloop 的一些使用场景：</p><h3 id="1-线程保活"><a href="#1-线程保活" class="headerlink" title="(1) 线程保活"></a>(1) 线程保活</h3><p>当子线程中的任务执行完毕后，线程就被会被立刻销毁。如果 APP 中需要经常在子线程中执行任务，频繁的创建和销毁线程，会造成资源的浪费，这时候我们就可以使用 Runloop 来让该线程长时间存活而不被销毁，实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">KeepAliveThread.h</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^KeepAliveThreadTask)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KeepAliveThread</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子线程执行任务</span></span><br><span class="line">- (<span class="type">void</span>)executeTask:(KeepAliveThreadTask)task;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束线程</span></span><br><span class="line">- (<span class="type">void</span>)stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">KeepAliveThread.m</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KeepAliveThread</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *thread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> shouldKeepRunning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KeepAliveThread</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Public methods</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.shouldKeepRunning = <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (weakSelf &amp;&amp; weakSelf.shouldKeepRunning) &#123;</span><br><span class="line">                [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.thread start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)executeTask:(KeepAliveThreadTask)task &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.thread || !task) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(p_executeTask:) onThread:<span class="keyword">self</span>.thread withObject:task waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)stop &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.thread) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(p_stop) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Private methods</span></span><br><span class="line">- (<span class="type">void</span>)p_stop &#123;</span><br><span class="line">    <span class="keyword">self</span>.shouldKeepRunning = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    <span class="keyword">self</span>.thread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)p_executeTask:(KeepAliveThreadTask)task &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="2-保证-Timer-正常运行"><a href="#2-保证-Timer-正常运行" class="headerlink" title="(2) 保证 Timer 正常运行"></a>(2) 保证 Timer 正常运行</h3><p>创建 Timer 有下面两种方式，两种实现方式是等价的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式 1</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerUpdate) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">[timer fire];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 2</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerUpdate) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>当滑动 <code>UIScrollView</code> 时，主线程的 RunLoop 会切换到 <code>UITrackingRunLoopMode</code> 这个 Mode，执行的也是 <code>UITrackingRunLoopMode</code> 下的任务（Mode 中的 item），而 Timer 是添加在 <code>NSDefaultRunLoopMode</code> 下的，所以 Timer 任务并不会执行，只有当 <code>UITrackingRunLoopMode</code> 的任务执行完毕，Runloop 切换到 <code>NSDefaultRunLoopMode</code> 后，才会继续执行 Timer。解决方法很简单，我们只需要在添加 Timer 时，将 mode 设置为 <code>NSRunLoopCommonModes</code> 即可：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerUpdate) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">[timer fire];</span><br></pre></td></tr></table></figure><p>如果是在子线程中使用 Timer，由于子线程的 Runloop 并不会自动创建，所以必须在子线程中创建并启动 Runloop，否则 Timer 无法正常运行，创建并启动 Runloop 方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br></pre></td></tr></table></figure><p>由于子线程中不会涉及到 UI 更新，所以无需再主动将 Timer 添加到 <code>NSRunLoopCommonModes</code> 下。</p><h3 id="3-利用-Runloop-优化-UITableView-加载图片时滑动卡顿问题"><a href="#3-利用-Runloop-优化-UITableView-加载图片时滑动卡顿问题" class="headerlink" title="(3) 利用 Runloop 优化 UITableView 加载图片时滑动卡顿问题"></a>(3) 利用 Runloop 优化 UITableView 加载图片时滑动卡顿问题</h3><p><code>UITableView</code> 滚动时，主线程的 Runloop 会切换到 <code>UITrackingRunLoopMode</code> 这个 Mode，我们可以在 <code>NSDefaultRunLoopMode</code> 中设置图片，避免一边滑动一边设置 image 引起的卡顿问题：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = ...</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 在 NSDefaultRunLoopMode 下设置图片</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(p_loadImgeWithIndexPath:)</span><br><span class="line">                       withObject:indexPath</span><br><span class="line">                       afterDelay:<span class="number">0.0</span></span><br><span class="line">                          inModes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)p_loadImgeWithIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [<span class="keyword">self</span>.tableView cellForRowAtIndexPath:indexPath];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子线程下载图片</span></span><br><span class="line">    [ImageDownload loadImageWithUrl:<span class="string">@&quot;xxxx&quot;</span> success:^(<span class="built_in">UIImage</span> *image) &#123;</span><br><span class="line">        <span class="comment">// 回到主线程刷新UI</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            cell.imageView.image = image;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-利用-Runloop-监控卡顿"><a href="#4-利用-Runloop-监控卡顿" class="headerlink" title="(4) 利用 Runloop 监控卡顿"></a>(4) 利用 Runloop 监控卡顿</h3><p>根据 Runloop 的执行流程可以发现，Runloop 对我们业务逻辑的处理时间在两个阶段：</p><ul><li><code>kCFRunLoopBeforeSources</code> 和 <code>kCFRunLoopBeforeWaiting</code> 之间</li><li><code>kCFRunLoopAfterWaiting</code> 之后</li></ul><p>所以，如果主线程 Runloop 处在 <code>kCFRunLoopBeforeSources</code> 时间过长，也就是迟迟无法将任务处理完成，顺利到达 <code>kCFRunLoopBeforeWaiting</code> 阶段，说明发生了卡顿。</p><p>同样的，如果 Runloop 处在 <code>kCFRunLoopAfterWaiting</code> 时间过长，也是发生了卡顿。</p><p>所以，如果我们要利用 Runloop 来监控卡顿的话，就要关注 <code>kCFRunLoopBeforeSources</code> 和 <code>kCFRunLoopAfterWaiting</code> 两个阶段，一般卡顿时间超过 250ms 会被明显感知，所以，可以以连续 5 次卡顿时长超过 50ms 可以认为发生卡顿，或者根据需要调整统计阀值。以下是通过 Runloop 监听卡顿的一个例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LagMonitor</span>() </span>&#123;</span><br><span class="line">    <span class="type">int</span> timeoutCount;</span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> runLoopObserver;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    dispatch_semaphore_t dispatchSemaphore;</span><br><span class="line">    <span class="built_in">CFRunLoopActivity</span> runLoopActivity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LagMonitor</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Interface</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">id</span> instance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> dispatchOnce;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;dispatchOnce, ^&#123;</span><br><span class="line">        instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始监控</span></span><br><span class="line">- (<span class="type">void</span>)beginMonitor &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;开始监控&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (runLoopObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建信号量，注意这里信号量为 0</span></span><br><span class="line">    dispatchSemaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建 Observer</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>,(__bridge <span class="type">void</span>*)<span class="keyword">self</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    runLoopObserver = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</span><br><span class="line">                                              kCFRunLoopAllActivities,</span><br><span class="line">                                              <span class="literal">YES</span>,</span><br><span class="line">                                              <span class="number">0</span>,</span><br><span class="line">                                              runLoopObserverCallBack,</span><br><span class="line">                                              &amp;context);</span><br><span class="line">    <span class="comment">// 将 Observer 添加到主线程的 RunLoop</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), runLoopObserver, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在子线程持续监控</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             信号量 P 操作，成功的话信号量会 - 1，这里超时时间为 50ms，即等待 50ms 后还没成功就返回失败</span></span><br><span class="line"><span class="comment">             操作成功，信号量 - 1，返回值为 0；操作失败，返回值非 0</span></span><br><span class="line"><span class="comment">             由于初始信号量为 0，这里会阻塞，直到 runLoopObserverCallBack 函数中对信号量做了 V 操作，即 RunLoop 状态发生改变的时候。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">long</span> semaphoreWait = dispatch_semaphore_wait(<span class="keyword">self</span>-&gt;dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="number">50</span> * <span class="built_in">NSEC_PER_MSEC</span>));</span><br><span class="line">            <span class="keyword">if</span> (semaphoreWait != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 发生超时，说明 RunLoop 保持在一个状态的时间超过了 50ms</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">self</span>-&gt;runLoopObserver) &#123;</span><br><span class="line">                    <span class="keyword">self</span>-&gt;timeoutCount = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">self</span>-&gt;dispatchSemaphore = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">self</span>-&gt;runLoopActivity = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果是在 BeforeSources 或 AfterWaiting 这两个状态持续时间达到超时时间，就代表发生了卡顿</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;runLoopActivity == kCFRunLoopBeforeSources || <span class="keyword">self</span>-&gt;runLoopActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    <span class="comment">// 出现五次出结果</span></span><br><span class="line">                    <span class="keyword">if</span> (++<span class="keyword">self</span>-&gt;timeoutCount &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 发生了卡顿，可以使用 PLCrashReporter 等收集堆栈并上报</span></span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;发生了卡顿，&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>-&gt;timeoutCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束监控</span></span><br><span class="line">- (<span class="type">void</span>)endMonitor &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;结束监控&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!runLoopObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), runLoopObserver, kCFRunLoopCommonModes);</span><br><span class="line">    <span class="comment">// 释放 Observer</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(runLoopObserver);</span><br><span class="line">    runLoopObserver = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Private</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> runLoopObserverCallBack(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="type">void</span> *info) &#123;</span><br><span class="line">    LagMonitor *lagMonitor = (__bridge LagMonitor*)info;</span><br><span class="line">    lagMonitor-&gt;runLoopActivity = activity;</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_t semaphore = lagMonitor-&gt;dispatchSemaphore;</span><br><span class="line">    <span class="comment">// 对信号量进行 V 操作，信号量 + 1</span></span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面只是统计卡顿的基础版本，如果真的使用到项目中上面逻辑还有不少需要优化的地方，例如：</p><ul><li>避免多次重复上报同一个卡顿堆栈<ul><li>可以先将堆栈保存到内存中，以堆栈栈顶函数为特征，如果相同认为整个堆栈是同一个，不重复上报。</li></ul></li><li>准确定位真正卡顿的堆栈<ul><li>假如主线程有三个任务，只有第一个是引起卡顿的任务，当开始上报卡顿时获取到的堆栈可能是后两个不耗时的任务的堆栈。这种情况可以每 50ms 甚至更短时间获取一次堆栈，只保留最近一定数量（例如最近 20 个）堆栈信息，当发生卡顿时相同堆栈数量最多的堆栈就是真正引起卡顿的堆栈。</li></ul></li></ul><p>目前也有一些比较成熟的卡顿监控方案，例如：<a href="https://github.com/Tencent/matrix">matrix</a>。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> runloop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Runtime 拾遗</title>
      <link href="/posts/60564/"/>
      <url>/posts/60564/</url>
      
        <content type="html"><![CDATA[<h2 id="1、self-和-super"><a href="#1、self-和-super" class="headerlink" title="1、self 和 super"></a>1、self 和 super</h2><p><code>super</code> 是每个开发者都很熟悉的东西，我们经常在重写父类方法的时候，经常通过 <code>super</code> 去调用一下父类的实现，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// your code</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 <code>super</code> 到底是什么呢？先看一个例子，假设继承链为 Son -&gt; Parent -&gt; NSObject，那么下面逻辑将会如何打印？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[self class] = %@&quot;</span>, [<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[self superclass] = %@&quot;</span>, [<span class="keyword">self</span> superclass]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[super class] = %@&quot;</span>, [<span class="variable language_">super</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[super superclass] = %@&quot;</span>, [<span class="variable language_">super</span> superclass]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子或许看起来很简单，按照常规理解，上面代码打印结果可能是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> <span class="keyword">class</span>] = Son</span><br><span class="line">[<span class="keyword">self</span> superclass] = Parent</span><br><span class="line">[<span class="variable language_">super</span> <span class="keyword">class</span>] = Parent</span><br><span class="line">[<span class="variable language_">super</span> superclass] = <span class="built_in">NSObject</span></span><br></pre></td></tr></table></figure><p>然而，实际打印结果却并非如此，正确打印结果为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> <span class="keyword">class</span>] = Son</span><br><span class="line">[<span class="keyword">self</span> superclass] = Parent</span><br><span class="line">[<span class="variable language_">super</span> <span class="keyword">class</span>] = Son</span><br><span class="line">[<span class="variable language_">super</span> superclass] = Parent</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_50.png"><br>结果很意外，<code>[super class]</code> 竟然还是 Son，<code>[super superclass]</code> 竟然还是 Parent。</p><p>为了探索原理，现在使 Son 重写 Parent 类的 test 方法，并在其中调用 <code>[super test]</code>，如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    [<span class="variable language_">super</span> test];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Son.m</span><br></pre></td></tr></table></figure><p>将 Son.m 转成 C&#x2F;C++ 代码，test 实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> _I_Son_test(Son * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    ((<span class="type">void</span> (*)(__rw_objc_super *, SEL))(<span class="type">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(<span class="type">id</span>)<span class="keyword">self</span>, (<span class="type">id</span>)class_getSuperclass(objc_getClass(<span class="string">&quot;Son&quot;</span>))&#125;, sel_registerName(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了逻辑更清晰，对 <code>[super test]</code> 的实现简化处理后如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __rw_objc_super arg = &#123;</span><br><span class="line">    <span class="keyword">self</span>,</span><br><span class="line">    class_getSuperclass(objc_getClass(<span class="string">&quot;Son&quot;</span>))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">objc_msgSendSuper(arg, <span class="keyword">@selector</span>(test));</span><br><span class="line"></span><br><span class="line">__rw_objc_super 对应结构体如下：</span><br><span class="line"><span class="comment">/// Specifies the superclass of an instance. </span></span><br><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull <span class="type">id</span> receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class <span class="keyword">class</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class super_class;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简化处理后：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull <span class="type">id</span> receiver;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据以上实现可知，<code>[super test]</code> 转成 C&#x2F;C++ 后实际上是执行 <code>objc_msgSendSuper</code> 函数。<br>在 <code>objc_msgSendSuper</code> 函数中，有 2 个参数：</p><ul><li>第 1 个参数是 <code>objc_super</code> 结构体<br>  结构体里面有两个变量，一个是接收消息的 <code>receiver</code>，可以看到这里 <code>receiver = self</code>，一个是当前类的父类 <code>super_class</code>。</li><li>第 2 个参数是当前方法的 <code>selector</code>。</li></ul><p>对于 <code>objc_super</code> 结构体中两个成员变量的作用：</p><ul><li>receiver<br>消息接受者，<code>receiver = self</code>，即 Son 的实例对象。</li><li>super_class<br>从 <code>super_class</code> 开始查找 <code>selector</code>，即从 Parent 开始查找 test 方法。</li></ul><p>也就是说，Son 中调用的 <code>[super test]</code> 是从 Parent 开始查找 test 对应 <code>selector</code>，查找到 <code>selector</code> 后，以 <code>self</code>(即 Son 的实例对象) 为消息接受者发送消息。这么设计的原因也很好理解，如果不是从 Parent 开始查找方法而是从 Son 开始查找方法，那边对于 test 方法的调用，将会陷入递归死循环。</p><p>这个也很容易验证，我们使 Parent 中 test 方法实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Parent</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;self = %@&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span> = &lt;Son: <span class="number">0x100609aa0</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_51.png"><br>对于前面为什么 <code>[super class] = Son</code> 也比较容易理解了，<code>class</code> 方法的实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于是调用的是实例方法，所以是减号开头的方法</span></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>class</code> 方法查找路径为：Parent -&gt; NSObject -&gt; nil，最终会在 NSObject 中找到 <code>class</code> 方法。</p><p>调用 <code>class</code> 方法时，消息接受者为 <code>self</code>(即 Son 的实例对象)，所以 <code>[super class] = Son</code>。<code>[super superclass] = Parent</code> 也是同理。</p><h2 id="2、isKindOfClass-和-isMemberOfClass"><a href="#2、isKindOfClass-和-isMemberOfClass" class="headerlink" title="2、isKindOfClass 和 isMemberOfClass"></a>2、isKindOfClass 和 isMemberOfClass</h2><p>先看一个例子，TestObject 是 NSObject 子类，下面代码打印结果是什么？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;result1 = %d&quot;</span>, [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;result2 = %d&quot;</span>, [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;result3 = %d&quot;</span>, [[TestObject <span class="keyword">class</span>] isKindOfClass:[TestObject <span class="keyword">class</span>]]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;result4 = %d&quot;</span>, [[TestObject <span class="keyword">class</span>] isMemberOfClass:[TestObject <span class="keyword">class</span>]]);</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;result1 = %d&quot;</span>, [<span class="built_in">NSObject</span> isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;result2 = %d&quot;</span>, [<span class="built_in">NSObject</span> isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;result3 = %d&quot;</span>, [TestObject isKindOfClass:[TestObject <span class="keyword">class</span>]]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;result4 = %d&quot;</span>, [TestObject isMemberOfClass:[TestObject <span class="keyword">class</span>]]);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result1 = <span class="number">1</span></span><br><span class="line">result2 = <span class="number">0</span></span><br><span class="line">result3 = <span class="number">0</span></span><br><span class="line">result4 = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>结果看起来很奇怪，原因是什么呢？可以看下 <code>isKindOfClass</code>、<code>isMemberOfClass</code> 的源码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="comment">// 判断 self 是否是 cls 类型</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="comment">// 判断 self 是否是 cls 类型或 cls 的子类</span></span><br><span class="line">    <span class="comment">// 注意下面是有个 for 循环的，顺着 superclass 查找</span></span><br><span class="line"><span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="comment">// 这里 self 是 class，类对象的类对象，就是元类。所以这里是判断元类是否是 cls 类型</span></span><br><span class="line">    <span class="keyword">return</span> object_getClass((<span class="type">id</span>)<span class="keyword">self</span>) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="comment">// 这里 self 就是 class，所以这里是判断元类是否是 cls 类型或 cls 的子类</span></span><br><span class="line">    <span class="comment">// 注意下面是有个 for 循环的，顺着 superclass 查找</span></span><br><span class="line">    <span class="keyword">for</span> (Class tcls = object_getClass((<span class="type">id</span>)<span class="keyword">self</span>); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上源码可以知道，前面例子中调用的都是类方法，以下面逻辑为例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]</span><br></pre></td></tr></table></figure><p><code>object_getClass(self)</code> 即 <code>self-&gt;isa</code> 的指向，<code>[NSObject class]</code> 就是 NSObject 类本身，其 <code>isa</code> 指向是 NSObject 元类，NSObject 元类是 NSObject 的子类。所以上面判断结果是 YES。</p><p>对于下面逻辑：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]</span><br></pre></td></tr></table></figure><p>同样，NSObject 元类是 NSObject 的子类，自然不等于 NSObject，所以判断结果为 NO。</p><p>对于下面逻辑：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[TestObject <span class="keyword">class</span>] isKindOfClass:[TestObject <span class="keyword">class</span>]]</span><br></pre></td></tr></table></figure><p><code>TestObject-&gt;isa</code> 是 TestObject 元类，TestObject 元类继承自 NSObject 元类，NSObject 元类继承自 NSObject。所以上面逻辑判断路径是：<br><strong>TestObject 元类 -&gt; NSObject 元类 -&gt; NSObject</strong>，逐个判断他们是否是 TestObject，结果肯定是 NO。</p><p>下面逻辑同理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[TestObject <span class="keyword">class</span>] isMemberOfClass:[TestObject <span class="keyword">class</span>]]</span><br></pre></td></tr></table></figure><p>TestObject 元类肯定不是 TestObject，所以判断结果为 NO。</p><p>最后，再附上这张经典的图：<br><img src="/images/lix_blog_52.png"></p><h2 id="3、Method-Swizzling"><a href="#3、Method-Swizzling" class="headerlink" title="3、Method Swizzling"></a>3、Method Swizzling</h2><h3 id="1-Method-Swizzling-原理简述"><a href="#1-Method-Swizzling-原理简述" class="headerlink" title="(1) Method Swizzling 原理简述"></a>(1) Method Swizzling 原理简述</h3><p>Method Swizzling 即常说的 Hook（后续也直接称为 Hook），利用 Runtime 动态替换方法的实现。<br><img src="/images/lix_blog_189.png" style="width:70%;"></p><p>Runtime 提供了很多和方法操作相关的 API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class_getInstanceMethod：获取实例方法</span><br><span class="line">class_getClassMethod：获取类方法</span><br><span class="line"></span><br><span class="line">method_getImplementation：获取方法的实现 IMP</span><br><span class="line">method_setImplemrntation：设置方法的实现 IMP</span><br><span class="line"></span><br><span class="line">method_getTypeEncoding：获取方法编码</span><br><span class="line"></span><br><span class="line">class_addMethod：新增方法</span><br><span class="line"></span><br><span class="line">class_replaceMethod：替换方法的实现 IMP。如：A 替换 B，即：B 指向 A，A 还是指向 A</span><br><span class="line">method_exchangeImplementations：交换两个方法的实现 IMP。如：A 交换 B，即：B 指向 A，A 指向 B</span><br></pre></td></tr></table></figure><h3 id="2-Method-Swizzling-的实现"><a href="#2-Method-Swizzling-的实现" class="headerlink" title="(2) Method Swizzling 的实现"></a>(2) Method Swizzling 的实现</h3><p>为了保证 Hook 相关逻辑一定被执行到，一般将相关逻辑放在 <code>+load</code> 方法中。</p><p>Hook 逻辑如果多次执行，可能会引起 Hook 无效假象。例如，Hook 逻辑执行了两次，会导致方法交换后，又被交换回原始状态。为了避免 +load 方法被主动调用导致 Hook 逻辑多次执行，一般还需要保证相关逻辑只被执行一次。</p><p>Hook 的目的一般都是知道原方法何时被执行，并在原方法执行前后增加一些其他逻辑。假设原方法是 <code>xxxxMethod</code>，与 <code>swizzled_xxxxMethod</code> 进行交换，只需要在 <code>swizzled_xxxxMethod</code> 中调用 <code>[self swizzled_xxxxMethod]</code> 即可调用原方法的实现。这里不会引起死循环是因为两个方法的实现已经替换了。</p><p>Method Swizzling 的简单(但有缺陷)实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </span><br><span class="line">        [<span class="keyword">self</span> methodSwizzlingWithClass:<span class="keyword">self</span> originalSEL:<span class="keyword">@selector</span>(xxxxMethod) swizzledSEL:<span class="keyword">@selector</span>(swizzled_xxxxMethod)]; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)methodSwizzlingWithClass:(Class)cls originalSEL:(SEL)originalSEL swizzledSEL:(SEL)swizzledSEL &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(cls, originalSEL); </span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(cls, swizzledSEL);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)swizzled_xxxxMethod &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzled_xxxxMethod];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是 Hook 一个方法的核心逻辑，演示了如果交换两个方法的实现。但是该实现是有缺陷的。</p><p>例如，子类中 Hook 了父类的方法，将 <code>parentMethod</code> 方法（仅在父类有实现）与 <code>swizzled_parentMethod</code> 方法进行交换，但是  <code>swizzled_parentMethod</code> 方法是在子类实现的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SonObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// parentMethod 是父类中的方法</span></span><br><span class="line">        [<span class="keyword">self</span> methodSwizzlingWithClass:<span class="keyword">self</span> originalSEL:<span class="keyword">@selector</span>(parentMethod) swizzledSEL:<span class="keyword">@selector</span>(swizzled_parentMethod)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这是在子类实现的</span></span><br><span class="line">- (<span class="type">void</span>)swizzled_parentMethod &#123;</span><br><span class="line">    <span class="comment">// 重新调用一下原方法</span></span><br><span class="line">    [<span class="keyword">self</span> swizzled_parentMethod];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;swizzled_parentMethod&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>子类调用 parentMethod 是没有问题的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[SonObject new] parentMethod];</span><br></pre></td></tr></table></figure><p>但是父类再调用 parentMethod 就会发生 Crash：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ParentObject new] parentMethod];</span><br></pre></td></tr></table></figure><p>Crash 内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[ParentObject swizzled_parentMethod]: unrecognized selector sent to instance 0x2821cc740</span><br></pre></td></tr></table></figure><p>可以看到，父类再调用 <code>parentMethod</code> 时，由于交换了方法的实现，实际调用的是 <code>swizzled_parentMethod</code>，但是父类并没有实现该方法，引起了 Crash。</p><p><strong>改进：</strong>Hook 应当只影响当前类而不影响父类<br>实现方式也很简单，假设要被 Hook 的方法是 <code>originalMethod</code>，要与 <code>originalMethod</code> 交换实现的方法是 <code>swizzled_originalMethod</code>，先使用 <code>class_addMethod</code> 尝试添加一下 <code>originalMethod</code>。<br>如果添加失败，说明当前类中已经实现了 <code>originalMethod</code>，直接 Hook 即可。<br>如果添加成功，说明当前类之前没有实现 <code>originalMethod</code>，但是这次新增了 <code>originalMethod</code>，所以再调用 <code>class_replaceMethod</code> 将 <code>swizzled_originalMethod</code> 的实现替换为 <code>originalMethod</code> 的实现即可。</p><p>改进后实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)methodSwizzlingWithClass:(Class)cls originalSEL:(SEL)originalSEL swizzledSEL:(SEL)swizzledSEL &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(cls, originalSEL);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(cls, swizzledSEL);</span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> success = class_addMethod(cls, originalSEL, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">       class_replaceMethod(cls, swizzledSEL, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就保证了子类 <code>parentMethod</code> 方法（我们使用 <code>class_addMethod</code> 手动添加的）的实现被交换成了 <code>swizzled_parentMethod</code>，而父类的 <code>parentMethod</code> 方法没有被交换，不受任何影响。</p><p>需要注意的是，类方法是存储在元类中的，如果 Hook 的是类方法，需要与元类的相关方法进行交换，实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)classMethodSwizzlingWithClass:(Class)cls originalSEL:(SEL)originalSEL swizzledSEL:(SEL)swizzledSEL &#123;</span><br><span class="line">    Method originalMethod = class_getClassMethod(cls, originalSEL);</span><br><span class="line">    Method swizzledMethod = class_getClassMethod(cls, swizzledSEL);</span><br><span class="line">    Class metaClass = object_getClass(cls);</span><br><span class="line">    <span class="type">BOOL</span> success = class_addMethod(metaClass, originalSEL, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        class_replaceMethod(metaClass, swizzledSEL, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-数组、字典的方法交换"><a href="#3-数组、字典的方法交换" class="headerlink" title="(3) 数组、字典的方法交换"></a>(3) 数组、字典的方法交换</h3><p>在 iOS 中 <code>NSArray</code>、<code>NSDictionary</code> 等这些类都是类簇(Class Clusters)。所以当我们直接对这些类进行 Hook 时，不会产生我们想要的效果，需要对这些类的<strong>“真身”</strong>进行 Hook：<br><img src="/images/lix_blog_55.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Runtime 之消息机制</title>
      <link href="/posts/39373/"/>
      <url>/posts/39373/</url>
      
        <content type="html"><![CDATA[<h2 id="1、objc-msgSend-简介"><a href="#1、objc-msgSend-简介" class="headerlink" title="1、objc_msgSend 简介"></a>1、objc_msgSend 简介</h2><p>在 OC 中，所有的方法调用底层都会转换成 <code>objc_msgSend</code> 函数进行调用，例如，对于下面方法调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[myObject test1];</span><br><span class="line">[myObject test2:<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>将其转换成 C++ 源码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((<span class="type">void</span> (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *)objc_msgSend)((<span class="type">id</span>)myObject, sel_registerName(<span class="string">&quot;test1&quot;</span>));</span><br><span class="line">((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">int</span>))(<span class="type">void</span> *)objc_msgSend)((<span class="type">id</span>)myObject, sel_registerName(<span class="string">&quot;test2:&quot;</span>),<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>简化处理后：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(myObject, sel_registerName(<span class="string">&quot;test1&quot;</span>));</span><br><span class="line">objc_msgSend(myObject, sel_registerName(<span class="string">&quot;test2:&quot;</span>),<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>可在源码中找到 <code>objc_msgSend</code> 函数定义：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT <span class="type">id</span> _Nullable</span><br><span class="line">objc_msgSend(<span class="type">id</span> _Nullable <span class="keyword">self</span>, SEL _Nonnull op, ...)</span><br></pre></td></tr></table></figure><p><code>objc_msgSend</code> 函数会有一个可能为空的返回值，一般来说需要至少两个参数：消息调用者及方法名，以及不确定个数的方法参数。</p><p><code>objc_msgSend</code> 伪代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> objc_msgSend(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, ...) &#123;</span><br><span class="line">  Class <span class="keyword">class</span> = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">  IMP imp = class_getMethodImplementation(<span class="keyword">class</span>, _cmd);</span><br><span class="line">  <span class="keyword">return</span> imp ? imp(<span class="keyword">self</span>, _cmd, ...) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 <code>objc_msgSend</code> 主要做的就是获取 IMP 并调用，并且在找到对应方法实现 IMP 调用的时候，会默认带入两个参数：<code>self</code> 和<code> _cmd</code>，<code>_cmd</code> 就是 SEL。所以我们可以在方法里使用 <code>self</code> 和 <code>_cmd</code>。</p><p>实际上，<code>objc_msgSend</code> 是使用汇编来实现的，采用汇编来实现，主要是因为有的方法返回 id，有的返回 int，单独一个方法定义满足不了多种类型返回值，汇编对可变参数处理起来更方便。再加上汇编程序执行效率高，所以 <code>objc_msgSend</code> 这种高频率调用的函数使用汇编实现有助于提高系统运行效率。</p><h2 id="2、objc-msgSend-源码分析"><a href="#2、objc-msgSend-源码分析" class="headerlink" title="2、objc_msgSend 源码分析"></a>2、objc_msgSend 源码分析</h2><h3 id="1-方法快速查找流程（汇编实现）"><a href="#1-方法快速查找流程（汇编实现）" class="headerlink" title="(1) 方法快速查找流程（汇编实现）"></a>(1) 方法快速查找流程（汇编实现）</h3><p>源码下载地址：<a href="https://opensource.apple.com/tarballs/objc4/">https://opensource.apple.com/tarballs/objc4/</a></p><p><code>objc_msgSend</code> 相关源码主要在 objc-msg-arm64.s 中，从源码可以看出 <code>objc_msgSend</code> 是使用汇编实现的。</p><p><code>objc_msgSend</code> 部分源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    ENTRY _objc_msgSend</span><br><span class="line">    UNWIND _objc_msgSend, NoFrame</span><br><span class="line">    <span class="comment">// 检查 objc_msgSend 第一个参数（消息接受者）是否为 nil</span></span><br><span class="line">    cmp p0, #<span class="number">0</span>          <span class="comment">// nil check and tagged pointer check</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_TAGGED_POINTERS</span></span><br><span class="line">    <span class="comment">// 如果支持 tagged pointer，如果 p0 &lt;= 0,执行 LNilOrTagged 函数</span></span><br><span class="line">    b.le    LNilOrTagged        <span class="comment">//  (MSB tagged pointer looks negative)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    b.eq    LReturnZero</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ldr p13, [x0]       <span class="comment">// p13 = isa</span></span><br><span class="line">    GetClassFromIsa_p16 p13     <span class="comment">// p16 = class</span></span><br><span class="line">LGetIsaDone:</span><br><span class="line">    CacheLookup NORMAL      <span class="comment">// calls imp or objc_msgSend_uncached</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_TAGGED_POINTERS</span></span><br><span class="line">LNilOrTagged:</span><br><span class="line">    b.eq    LReturnZero     <span class="comment">// nil check</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// tagged</span></span><br><span class="line">    ......</span><br><span class="line">    cmp x10, x16</span><br><span class="line">    b.ne    LGetIsaDone</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ext tagged</span></span><br><span class="line">    ......</span><br><span class="line">    b   LGetIsaDone</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">LReturnZero:</span><br><span class="line">    <span class="comment">// x0 is already zero</span></span><br><span class="line">    mov x1, #<span class="number">0</span></span><br><span class="line">    movi    d0, #<span class="number">0</span></span><br><span class="line">    movi    d1, #<span class="number">0</span></span><br><span class="line">    movi    d2, #<span class="number">0</span></span><br><span class="line">    movi    d3, #<span class="number">0</span></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    END_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure><p>首先会对 <code>objc_msgSend</code> 的第一个参数是否为 <code>nil</code>，即消息接收者是否存在：</p><ul><li>如果不存在，函数将直接 return，所以给 <code>nil</code> 对象发送消息不会引发 crash。</li><li>如果存在，则继续执行，进入缓存查找逻辑 <code>CacheLookup</code>（传入的参数是 NORMAL）。</li></ul><p><code>CacheLookup</code> 源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.macro CacheLookup</span><br><span class="line">    <span class="comment">// p1 = SEL, p16 = isa（p1 存放着 SEL，p16 存放这当前消息接收者的 isa 指针）</span></span><br><span class="line">    ldp p10, p11, [x16, #<span class="built_in">CACHE</span>] <span class="comment">// p10 = buckets, p11 = occupied|mask</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__LP64__</span></span><br><span class="line">    and w11, w11, <span class="number">0xffff</span>    <span class="comment">// p11 = mask</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    and w12, w1, w11        <span class="comment">// x12 = _cmd &amp; mask</span></span><br><span class="line">    add p12, p10, p12, LSL #(<span class="number">1</span>+PTRSHIFT)</span><br><span class="line">                     <span class="comment">// p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</span></span><br><span class="line"></span><br><span class="line">    ldp p17, p9, [x12]      <span class="comment">// &#123;imp, sel&#125; = *bucket</span></span><br><span class="line"><span class="number">1</span>:  cmp p9, p1          <span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">    b.ne    <span class="number">2</span>f          <span class="comment">//     scan more</span></span><br><span class="line">    CacheHit $<span class="number">0</span>         <span class="comment">// call or return imp</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>:  <span class="comment">// not hit: p12 = not-hit bucket</span></span><br><span class="line">    CheckMiss $<span class="number">0</span>            <span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">    cmp p12, p10        <span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">    b.eq    <span class="number">3</span>f</span><br><span class="line">    ldp p17, p9, [x12, #-BUCKET_SIZE]!  <span class="comment">// &#123;imp, sel&#125; = *--bucket</span></span><br><span class="line">    b   <span class="number">1</span>b          <span class="comment">// loop</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:  <span class="comment">// wrap: p12 = first bucket, w11 = mask</span></span><br><span class="line">    add p12, p12, w11, UXTW #(<span class="number">1</span>+PTRSHIFT)</span><br><span class="line">                                <span class="comment">// p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clone scanning loop to miss instead of hang when cache is corrupt.</span></span><br><span class="line">    <span class="comment">// The slow path may detect any corruption and halt later.</span></span><br><span class="line"></span><br><span class="line">    ldp p17, p9, [x12]      <span class="comment">// &#123;imp, sel&#125; = *bucket</span></span><br><span class="line"><span class="number">1</span>:  cmp p9, p1          <span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">    b.ne    <span class="number">2</span>f          <span class="comment">//     scan more</span></span><br><span class="line">    CacheHit $<span class="number">0</span>         <span class="comment">// call or return imp</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>:  <span class="comment">// not hit: p12 = not-hit bucket</span></span><br><span class="line">    CheckMiss $<span class="number">0</span>            <span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">    cmp p12, p10        <span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">    b.eq    <span class="number">3</span>f</span><br><span class="line">    ldp p17, p9, [x12, #-BUCKET_SIZE]!  <span class="comment">// &#123;imp, sel&#125; = *--bucket</span></span><br><span class="line">    b   <span class="number">1</span>b          <span class="comment">// loop</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:  <span class="comment">// double wrap</span></span><br><span class="line">    JumpMiss $<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>.macro 在汇编中用于定义宏，所以 <code>CacheLookup</code> 是被定义成了宏。<br><code>CacheLookup</code> 的功能其实就是去当前类的方法缓存中去查找方法：</p><ul><li>如果在缓存中找到方法，即命中，会调用 <code>CacheHit</code>，直接调用对应方法或返回方法 imp。</li><li>如果没有找到方法，则会调用 <code>CheckMiss</code>。</li></ul><p><code>CheckMiss</code> 源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.macro CheckMiss</span><br><span class="line">    <span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">.if $<span class="number">0</span> == GETIMP</span><br><span class="line">    cbz p9, LGetImpMiss</span><br><span class="line">.elseif $<span class="number">0</span> == NORMAL</span><br><span class="line">    cbz p9, __objc_msgSend_uncached</span><br><span class="line">.elseif $<span class="number">0</span> == LOOKUP</span><br><span class="line">    cbz p9, __objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>因为前面 <code>CacheLookup</code> 传入的参数是 NORMAL，所以这里 <code>CheckMiss</code> 调用了 <code>__objc_msgSend_uncached</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">MethodTableLookup</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在 __objc_msgSend_uncached 中，调用了 MethodTableLookup：</span><br><span class="line">.macro MethodTableLookup</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// push frame</span></span><br><span class="line">    SignLR</span><br><span class="line">    stp fp, lr, [sp, #<span class="number">-16</span>]!</span><br><span class="line">    mov fp, sp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save parameter registers: x0..x8, q0..q7</span></span><br><span class="line">    sub sp, sp, #(<span class="number">10</span>*<span class="number">8</span> + <span class="number">8</span>*<span class="number">16</span>)</span><br><span class="line">    stp q0, q1, [sp, #(<span class="number">0</span>*<span class="number">16</span>)]</span><br><span class="line">    stp q2, q3, [sp, #(<span class="number">2</span>*<span class="number">16</span>)]</span><br><span class="line">    stp q4, q5, [sp, #(<span class="number">4</span>*<span class="number">16</span>)]</span><br><span class="line">    stp q6, q7, [sp, #(<span class="number">6</span>*<span class="number">16</span>)]</span><br><span class="line">    stp x0, x1, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">0</span>*<span class="number">8</span>)]</span><br><span class="line">    stp x2, x3, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">2</span>*<span class="number">8</span>)]</span><br><span class="line">    stp x4, x5, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">4</span>*<span class="number">8</span>)]</span><br><span class="line">    stp x6, x7, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">6</span>*<span class="number">8</span>)]</span><br><span class="line">    str x8,     [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">8</span>*<span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)</span></span><br><span class="line">    <span class="comment">// receiver and selector already in x0 and x1</span></span><br><span class="line">    mov x2, x16</span><br><span class="line">    mov x3, #<span class="number">3</span></span><br><span class="line">    bl  _lookUpImpOrForward</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMP in x0</span></span><br><span class="line">    mov x17, x0</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// restore registers and return</span></span><br><span class="line">    ldp q0, q1, [sp, #(<span class="number">0</span>*<span class="number">16</span>)]</span><br><span class="line">    ldp q2, q3, [sp, #(<span class="number">2</span>*<span class="number">16</span>)]</span><br><span class="line">    ldp q4, q5, [sp, #(<span class="number">4</span>*<span class="number">16</span>)]</span><br><span class="line">    ldp q6, q7, [sp, #(<span class="number">6</span>*<span class="number">16</span>)]</span><br><span class="line">    ldp x0, x1, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">0</span>*<span class="number">8</span>)]</span><br><span class="line">    ldp x2, x3, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">2</span>*<span class="number">8</span>)]</span><br><span class="line">    ldp x4, x5, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">4</span>*<span class="number">8</span>)]</span><br><span class="line">    ldp x6, x7, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">6</span>*<span class="number">8</span>)]</span><br><span class="line">    ldr x8,     [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">8</span>*<span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">    mov sp, fp</span><br><span class="line">    ldp fp, lr, [sp], #<span class="number">16</span></span><br><span class="line">    AuthenticateLR</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>可以看到，<code>MethodTableLookup</code> 中又调用了 <code>_lookUpImpOrForward</code>。<br>并且调用 <code>lookUpImpOrForward</code> 函数时传入参数如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x0 = receiver </span><br><span class="line">x1 = selector </span><br><span class="line">x2 = <span class="keyword">class</span> </span><br><span class="line">x3 = LOOKUP_INITIALIZE | LOOKUP_RESOLVER</span><br></pre></td></tr></table></figure><p>到这里，快速查找流程结束，进入慢速查找流程。</p><h3 id="2-方法慢速查找流程（C-C-实现）"><a href="#2-方法慢速查找流程（C-C-实现）" class="headerlink" title="(2) 方法慢速查找流程（C&#x2F;C++ 实现）"></a>(2) 方法慢速查找流程（C&#x2F;C++ 实现）</h3><p><code>_lookUpImpOrForward</code> 在 C++ 中对应的函数为 <code>lookUpImpOrForward</code>，位于 objc-runtime-new.m 中：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(<span class="type">id</span> inst, SEL sel, Class cls, <span class="type">int</span> behavior)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> IMP forward_imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    IMP imp = <span class="literal">nil</span>;</span><br><span class="line">    Class curClass;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class="line">      <span class="comment">// cache_getImp 为汇编实现，内部实际上就是执行前面快速查找流程</span></span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done_nolock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询是否为已知类</span></span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类没有实现，尝试实现</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">        <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类如果没有初始化，进行初始化操作</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass = cls;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> attempts = unreasonableClassCount();;) &#123;</span><br><span class="line">        <span class="comment">//  当前类方法列表（如果方法列表已排序采用二分查找算法，否则直接遍历查找），如果找到，则返回，将方法缓存到 cache 中。</span></span><br><span class="line">        Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="comment">// 跳转到 done</span></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// curClass = superclass 继续查找，一直到 curClass == nil 的时候让 imp = forward_imp, break，终止循环</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath((curClass = curClass-&gt;superclass) == <span class="literal">nil</span>)) &#123;</span><br><span class="line">            <span class="comment">// 没找到，也没有父类了，使用转发 </span></span><br><span class="line">            imp = forward_imp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(--attempts == <span class="number">0</span>)) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Memory corruption in class list.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取父类的缓存</span></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (slowpath(imp == forward_imp)) &#123;</span><br><span class="line">            <span class="comment">// 父类中找到的是forward_imp,则终止查找</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fastpath(imp)) &#123;</span><br><span class="line">            <span class="comment">// 找到imp，则跳转到 done，进行方法缓存</span></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">        <span class="comment">// 进入动态方法决议</span></span><br><span class="line">        <span class="keyword">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"> done_nolock:</span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以发现，是通过 <code>getMethodNoSuper_nolock</code> 函数去类的方法列表查找方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> method_t *</span><br><span class="line">getMethodNoSuper_nolock(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    <span class="comment">// fixme nil cls? </span></span><br><span class="line">    <span class="comment">// fixme nil sel?</span></span><br><span class="line"></span><br><span class="line">    auto <span class="keyword">const</span> methods = cls-&gt;data()-&gt;methods();</span><br><span class="line">    <span class="keyword">for</span> (auto mlists = methods.beginLists(),</span><br><span class="line">              end = methods.endLists();</span><br><span class="line">         mlists != end;</span><br><span class="line">         ++mlists)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// &lt;rdar://problem/46904873&gt; getMethodNoSuper_nolock is the hottest</span></span><br><span class="line">        <span class="comment">// caller of search_method_list, inlining it turns</span></span><br><span class="line">        <span class="comment">// getMethodNoSuper_nolock into a frame-less function and eliminates</span></span><br><span class="line">        <span class="comment">// any store from this codepath.</span></span><br><span class="line">        method_t *m = search_method_list_inline(*mlists, sel);</span><br><span class="line">        <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过函数中以下源码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto <span class="keyword">const</span> methods = cls-&gt;data()-&gt;methods();</span><br><span class="line"></span><br><span class="line">cls-&gt;data() 返回的就是 class_rw_t：</span><br><span class="line">class_rw_t* data() &#123;</span><br><span class="line">    <span class="keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知，查找的方法列表就是 <code>class_rw_t</code> 中的 <code>methods</code> ：<br><img src="/images/lix_blog_45.png" style="width:50%;"></p><p><code>getMethodNoSuper_nolock</code> 函数中读取了方法列表后，具体 sel 查找是通过 <code>search_method_list_inline</code> 函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE <span class="keyword">static</span> method_t *</span><br><span class="line">search_method_list_inline(<span class="keyword">const</span> method_list_t *mlist, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> methodListIsFixedUp = mlist-&gt;isFixedUp();</span><br><span class="line">    <span class="type">int</span> methodListHasExpectedSize = mlist-&gt;entsize() == <span class="keyword">sizeof</span>(method_t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fastpath(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize)) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMethodInSortedMethodList(sel, mlist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Linear search of unsorted method list</span></span><br><span class="line">        <span class="keyword">for</span> (auto&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// sanity-check negative results</span></span><br><span class="line">    <span class="keyword">if</span> (mlist-&gt;isFixedUp()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (auto&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;linear search worked when binary search did not&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上源码可知，查找方法列表前会对否排好序进行判断，如果方法列表已排序，则会调用 <code>findMethodInSortedMethodList</code> 函数进行查找，<code>findMethodInSortedMethodList</code> 函数实际上进行的是进行二分查找，通过二分查找提高查找效率。否则直接遍历去查询方法列表。</p><p><code>lookUpImpOrForward</code> 源码分析：</p><ul><li><p>1、对类做合法性检查及处理，判断是否时已知类、类是否实现、是否已经初始化，如果类没有实现或初始化，进行一下对应的实现及初始化操作。</p><ul><li>函数的 <code>behavior</code> 参数 <code>value</code> 为 <code>LOOKUP_INITIALIZE | LOOKUP_RESOLVER</code>，所以不再去查找缓存（因为之前已经查找过缓存了）。</li></ul></li><li><p>2、到当前类的方法列表中、查询此方法，如果找到方法，则将方法(<code>Method</code> 中的 <code>IMP</code>)存放到当前类的 <code>cache</code> 中去，并且返回 IMP，方法结束。如果没找到，则执行第 3 步。</p><ul><li>此处当前类的方法列表即 <code>class_rw_t</code> 中的 <code>methods</code>。</li><li>查找方法列表前会对否排好序进行判断，如果方法列表已排序，使用二分查找算法进行查找，提高查找效率。否则直接遍历去查询方法列表。</li></ul></li><li><p>3、递归向父类中查找，先查找缓存，再查找类方法列表，如果找到方法，执行第 4 步（<code>forward_imp</code> 判断）。如果没有找到，<code>imp = forward_imp</code>，然后执行第 4 步。</p></li><li><p>4、判断此方法是否是 <code>forward_imp</code> 方法，如果不是，则将此方法存放到当前类的 <code>cache</code> 中，并且返 <code>IMP</code>，方法结束。如果此方法是 <code>forward_imp</code>，直接执行第 5 步。</p><ul><li><code>forward_imp</code> 实际上就是：<code>_objc_msgForward_impcache</code>。</li><li><code>_objc_msgForward_impcache</code> 其实是一个存放在内存中的函数指针，为汇编实现，内部会调用 <code>__objc_msgForward</code> 函数（消息转发的函数）。</li></ul></li><li><p>6、判断当前是否执行执行过方法解析（动态方法决议），如果没有执行过，进入动态方法解析阶段。如果执行过 1 次动态方法解析，则走到消息转发流程。</p></li></ul><h3 id="3-动态方法解析（动态方法决议）"><a href="#3-动态方法解析（动态方法决议）" class="headerlink" title="(3) 动态方法解析（动态方法决议）"></a>(3) 动态方法解析（动态方法决议）</h3><p>根据前面 <code>lookUpImpOrForward</code> 源码可知，在方法查找时，如果发现方法是 <code>forward_imp</code>，会判断是否执行执行过方法解析，如果没有执行过，进入动态方法解析阶段，进入 <code>resolveMethod_locked</code> 函数。<br><code>resolveMethod_locked</code> 函数源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NEVER_INLINE IMP</span><br><span class="line">resolveMethod_locked(<span class="type">id</span> inst, SEL sel, Class cls, <span class="type">int</span> behavior)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// 不是元类</span></span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        <span class="comment">// 对象方法的动态方法解析</span></span><br><span class="line">        resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是元类</span></span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        <span class="comment">// 类方法的动态方法解析</span></span><br><span class="line">        resolveClassMethod(inst, sel, cls);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(inst, sel, cls)) &#123;</span><br><span class="line">            <span class="comment">// 对象方法的动态方法解析</span></span><br><span class="line">            resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// chances are that calling the resolver have populated the cache</span></span><br><span class="line">    <span class="comment">// so attempt using it</span></span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(inst, sel, cls, behavior | LOOKUP_CACHE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中调用的 <code>lookUpImpOrNil</code> 函数源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> IMP</span><br><span class="line">lookUpImpOrNil(<span class="type">id</span> obj, SEL sel, Class cls, <span class="type">int</span> behavior = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(obj, sel, cls, behavior | LOOKUP_CACHE | LOOKUP_NIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>lookUpImpOrNil</code> 函数内部就是直接调用了 <code>lookUpImpOrForward</code> 函数，重新进入慢速查找流程，注意这里 <code>behavior</code> 的参数值，进到 <code>lookUpImpOrForward</code> 里后是需要先去缓存中查找方法的（快速查找流程）。</p><p><code>resolveInstanceMethod</code> 函数源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> resolveInstanceMethod(<span class="type">id</span> inst, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    SEL resolve_sel = <span class="keyword">@selector</span>(resolveInstanceMethod:);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!lookUpImpOrNil(cls, resolve_sel, cls-&gt;ISA())) &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="comment">// 如果你没有实现类方法 +(BOOL)resolveInstanceMethod:(SEL)sel</span></span><br><span class="line">        <span class="comment">// NSObject 已经实现了，所以一般不会走这里</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用类方法： +(BOOL)resolveInstanceMethod:(SEL)sel，</span></span><br><span class="line">    <span class="type">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="keyword">typeof</span>(msg))objc_msgSend;</span><br><span class="line">    <span class="type">bool</span> resolved = msg(cls, resolve_sel, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是否有 sel 对应的 IMP。如在 +(BOOL)resolveInstanceMethod:(SEL)sel 中动态添加了 sel 对应方法，此时再次去查找这个 IMP 就能找到，并且在这一步就会将其保存到缓存中，下次调用从缓存中就可以找到了。</span></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(inst, sel, cls);</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: method %c[%s %s] &quot;</span></span><br><span class="line">                         <span class="string">&quot;dynamically resolved to %p&quot;</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn&#x27;t add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span></span><br><span class="line">                         <span class="string">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resolveInstanceMethod</code> 函数源码解析：</p><ul><li><p>如果实现了 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 方法直接调用该方法。</p></li><li><p>调用 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 方法后，还会调用一次 <code>lookUpImpOrNil</code> 函数查找一下方法。所以如果在 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 方法中动态添加了 <code>sel</code> 对应方法之后，调用 <code>lookUpImpOrNil</code> 函数就能找到对应 <code>imp</code>，并且会将方法保存到缓存里，下次就能直接从缓存中找到并调用了。</p></li><li><p>根据源码可发现 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 方法返回值并没什么实际用处，只用来做日志打印而已，所以返回 YES 还是 NO 都无所谓。但是在实际开发的时候还应当按照 OC 规范去做，处理了 sel 就返回 YES，否则返回 NO。</p></li></ul><p><code>resolveClassMethod</code> 主要逻辑和 <code>resolveInstanceMethod</code> 基本一样，源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static void resolveClassMethod(id inst, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    ASSERT(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    if (!lookUpImpOrNil(inst, @selector(resolveClassMethod:), cls)) &#123;</span><br><span class="line">        // Resolver not implemented.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class nonmeta;</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock(runtimeLock);</span><br><span class="line">        nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst);</span><br><span class="line">        // +initialize path should have realized nonmeta already</span><br><span class="line">        if (!nonmeta-&gt;isRealized()) &#123;</span><br><span class="line">            _objc_fatal(&quot;nonmeta class %s (%p) unexpectedly not realized&quot;,</span><br><span class="line">                        nonmeta-&gt;nameForLogging(), nonmeta);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved = msg(nonmeta, @selector(resolveClassMethod:), sel);</span><br><span class="line"></span><br><span class="line">    // Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span><br><span class="line">    // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span><br><span class="line">    IMP imp = lookUpImpOrNil(inst, sel, cls);</span><br><span class="line"></span><br><span class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        if (imp) &#123;</span><br><span class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</span><br><span class="line">                         &quot;dynamically resolved to %p&quot;, </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#x27;+&#x27; : &#x27;-&#x27;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Method resolver didn&#x27;t add anything?</span><br><span class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;</span><br><span class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#x27;+&#x27; : &#x27;-&#x27;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态方法解析总结：</p><ul><li><p>如果不是元类（说明当前是对象方法），进行对象方法的动态方法解析。</p><ul><li>如果实现了 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 方法并且在方法中动态添加了 <code>sel</code> 对应方法，后面调用 <code>lookUpImpOrNil</code> 函数就能找到对应 <code>imp</code>，并且会将方法保存到缓存里。下次就能直接从缓存中找到 <code>sel</code> 并调用了。</li></ul></li><li><p>如果是元类（说明当前是类方法），先进行类方法的动态方法解析，如果没在 <code>+ (BOOL)resolveClassMethod:(SEL)sel</code> 中动态添加 <code>sel</code> 对应方法，则执行一次对象方法解析。</p><ul><li>上面如果 <code>!lookUpImpOrNil(inst, sel, cls)</code> 条件成立，说明执行过类方法的动态方法解析之后仍然没有找到 <code>sel</code>，也就是没在 <code>+ (BOOL)resolveClassMethod:(SEL)sel</code> 中动态添加 <code>sel</code> 对应方法。</li><li>这里为什么要再执行一次对象方法解析？因为元类的父类是根元类，根元类的父类是根类（NSObject）。如果整个继承链都没找到 <code>+(BOOL)resolveClassMethod:(SEL)sel</code> 方法，最终会找到根类（NSObject），根类是 class 对象，class 对象中保存的是对象方法，所以需要再做一次对象方法动态方法决议。</li></ul></li></ul><p><img src="/images/lix_blog_47.png"><br><strong>对象方法、类方法动态方法解析查找路径：</strong></p><ul><li>对象方法：类 -&gt; 父类 -&gt; 根类 -&gt; nil</li><li>类方法：元类 -&gt; 根元类 -&gt; 根类 -&gt; nil</li></ul><p>根据以上查找路径可知，无论是对象方法的动态方法解析还是类方法的动态方法解析，都会查找到根类（NSObject），所以都会走到根类（NSObject）的 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 方法。也就是说，我们可以直接使用 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 方法处理对象方法和类方法的动态方法解析。</p><p>动态方法解析 Demo：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象方法的动态方法解析</span></span><br><span class="line">- (<span class="type">void</span>)myInstanceMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    <span class="comment">// 调用了未实现的对象方法 xxxxInstanceMethod</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(xxxxInstanceMethod)) &#123;</span><br><span class="line">        Method resolveMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(myInstanceMethod));</span><br><span class="line">        IMP myInstanceIMP = method_getImplementation(resolveMethod);</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span>* types = method_getTypeEncoding(resolveMethod);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, types);</span><br><span class="line">        <span class="keyword">return</span> class_addMethod(<span class="keyword">self</span>, sel, myInstanceIMP, types);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法的动态方法解析</span></span><br><span class="line">+ (<span class="type">void</span>)myClassMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="comment">// 调用了未实现的类方法 xxxxClassMethod</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(xxxxClassMethod)) &#123;</span><br><span class="line">        Method resolveMethod = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(myClassMethod));</span><br><span class="line">        IMP myClassIMP = method_getImplementation(resolveMethod);</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span>* types = method_getTypeEncoding(resolveMethod);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, types);</span><br><span class="line">        <span class="keyword">return</span> class_addMethod(object_getClass(<span class="keyword">self</span>), sel, myClassIMP, types);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以全都在 + (BOOL)resolveInstanceMethod:(SEL)sel 方法中处理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)myInstanceMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)myClassMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(xxxxInstanceMethod)) &#123;</span><br><span class="line">        <span class="comment">// 调用了未实现的对象方法 xxxxInstanceMethod</span></span><br><span class="line">        Method resolveMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(myInstanceMethod));</span><br><span class="line">        IMP myInstanceIMP = method_getImplementation(resolveMethod);</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span>* types = method_getTypeEncoding(resolveMethod);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, types);</span><br><span class="line">        <span class="keyword">return</span> class_addMethod(<span class="keyword">self</span>, sel, myInstanceIMP, types);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(xxxxClassMethod)) &#123;</span><br><span class="line">        <span class="comment">// 调用了未实现的类方法 xxxxClassMethod</span></span><br><span class="line">        Method resolveMethod = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(myClassMethod));</span><br><span class="line">        IMP myClassIMP = method_getImplementation(resolveMethod);</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span>* types = method_getTypeEncoding(resolveMethod);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, types);</span><br><span class="line">        <span class="keyword">return</span> class_addMethod(object_getClass(<span class="keyword">self</span>), sel, myClassIMP, types);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-消息转发"><a href="#4-消息转发" class="headerlink" title="(4) 消息转发"></a>(4) 消息转发</h3><p>根据 <code>lookUpImpOrForward</code> 函数实现可知，如果执行过方法动态解析仍然没有找到对应方法，则走到消息转发流程，<code>lookUpImpOrForward</code> 方法也会把需要消息转发的 <code>_objc_msgForward_impcache</code> 作为 <code>imp</code> 返回。</p><p><code>_objc_msgForward_impcache</code> 在汇编中实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"><span class="comment">// No stret specialization.</span></span><br><span class="line">b   __objc_msgForward</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">adrp    x17, __objc_forward_handler@PAGE</span><br><span class="line">ldr p17, [x17, __objc_forward_handler@PAGEOFF]</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward</span><br></pre></td></tr></table></figure><p>可以看到 <code>_objc_msgForward_impcache</code> 是一个内部函数指针，最终会拿到 <code>__objc_forward_handler</code> 的地址并调用，其 OC 实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noreturn, cold)) <span class="type">void</span></span><br><span class="line">objc_defaultForwardHandler(<span class="type">id</span> <span class="keyword">self</span>, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span></span><br><span class="line">                <span class="string">&quot;(no message forward handler is installed)&quot;</span>, </span><br><span class="line">                class_isMetaClass(object_getClass(<span class="keyword">self</span>)) ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                object_getClassName(<span class="keyword">self</span>), sel_getName(sel), <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *_objc_forward_handler = (<span class="type">void</span>*)objc_defaultForwardHandler;</span><br></pre></td></tr></table></figure><p>其中 <code>_objc_fatal</code> 作用就是打日志并调用 <code>__builtin_trap()</code> 触发 crash，根据以上源码可知，这里是将 <code>objc_defaultForwardHandler</code> 赋值给 <code>_objc_forward_handler</code>，但是再看下 <code>objc_defaultForwardHandler</code> 实现发现，这里只是 crash 并打印信息，也是那个熟悉的 <code>crash：unrecognized selector sent to instance xxxxxxxx</code>，并没有其他内容。</p><p>所以，要想实现消息转发，就需要在某处给 <code>_objc_forward_handler</code> 重新赋值：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> objc_setForwardHandler(<span class="type">void</span> *fwd, <span class="type">void</span> *fwd_stret)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_forward_handler = fwd;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_STRET</span></span><br><span class="line">    _objc_forward_stret_handler = fwd_stret;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 <code>_objc_forward_stret_handler</code> 是用在非 arm64 下的，这里不再深究。</p><p>对 <code>objc_setForwardHandler</code> 的调用，以及之后的消息转发相关方法调用栈，是在 CoreFoundation 中的，但是 Apple 故意在相关开源的代码中删除了在 CFRuntime.c 文件 <code>__CFInitialize()</code> 中调用 <code>objc_setForwardHandler</code> 的代码（<a href="https://opensource.apple.com/source/CF/">CoreFoundation 源码地址</a>）。<br>借助逆向可分析下：<br><img src="/images/lix_blog_48.png"><br>根据逆向结果可以发现，<code>__CFInitialize()</code> 中是以 <code>__CF_forwarding_prep_0</code> 和 <code>___forwarding_prep_1___</code> 作为参数调用的。</p><p>接下来制造一个简单 crash 查看方法调用栈：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MessageCrashTest[<span class="number">7942</span>:<span class="number">944693</span>] -[TestObject test]: unrecognized selector sent to instance <span class="number">0x100508d80</span></span><br><span class="line">MessageCrashTest[<span class="number">7942</span>:<span class="number">944693</span>] *** Terminating app due to uncaught exception <span class="string">&#x27;NSInvalidArgumentException&#x27;</span>, reason: <span class="string">&#x27;-[TestObject test]: unrecognized selector sent to instance 0x100508d80&#x27;</span></span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">    <span class="number">0</span>   CoreFoundation                      <span class="number">0x00007fff34801b57</span> __exceptionPreprocess + <span class="number">178</span></span><br><span class="line">    <span class="number">1</span>   libobjc.A.dylib                     <span class="number">0x00007fff6d6765bf</span> objc_exception_throw + <span class="number">48</span></span><br><span class="line">    <span class="number">2</span>   CoreFoundation                      <span class="number">0x00007fff34880be7</span> -[<span class="built_in">NSObject</span>(<span class="built_in">NSObject</span>) doesNotRecognizeSelector:] + <span class="number">205</span></span><br><span class="line">    <span class="number">3</span>   CoreFoundation                      <span class="number">0x00007fff347663bb</span> ___forwarding___ + <span class="number">1009</span></span><br><span class="line">    <span class="number">4</span>   CoreFoundation                      <span class="number">0x00007fff34765d98</span> _CF_forwarding_prep_0 + <span class="number">120</span></span><br><span class="line">    <span class="number">5</span>   MessageCrashTest                    <span class="number">0x0000000100000f26</span> main + <span class="number">79</span></span><br><span class="line">    <span class="number">6</span>   libdyld.dylib                       <span class="number">0x00007fff6e81ecc9</span> start + <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到 <code>_CF_forwarding_prep_0</code> 函数内部调用了 <code>___forwarding___</code> 函数，然后调用 <code>doesNotRecognizeSelector</code> 方法，最后抛出异常。</p><p><code>___forwarding___</code> 也是不开源的，但是国外大神通过逆向分析后写了伪代码( <a href="http://www.arigrant.com/blog/2013/12/13/a-selector-left-unhandled">链接</a> )：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __forwarding__(<span class="type">BOOL</span> isStret, <span class="type">void</span> *frameStackPointer, ...) &#123;</span><br><span class="line">  <span class="type">id</span> receiver = *(<span class="type">id</span> *)frameStackPointer;</span><br><span class="line">  SEL sel = *(SEL *)(frameStackPointer + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  Class receiverClass = object_getClass(receiver);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (class_respondsToSelector(receiverClass, <span class="keyword">@selector</span>(forwardingTargetForSelector:))) &#123;</span><br><span class="line">    <span class="type">id</span> forwardingTarget = [receiver forwardingTargetForSelector:sel];</span><br><span class="line">    <span class="keyword">if</span> (forwardingTarget) &#123;</span><br><span class="line">      <span class="keyword">return</span> objc_msgSend(forwardingTarget, sel, ...);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="type">char</span> *className = class_getName(object_getClass(receiver));</span><br><span class="line">  <span class="keyword">const</span> <span class="type">char</span> *zombiePrefix = <span class="string">&quot;_NSZombie_&quot;</span>;</span><br><span class="line">  size_t prefixLen = strlen(zombiePrefix);</span><br><span class="line">  <span class="keyword">if</span> (strncmp(className, zombiePrefix, prefixLen) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">CFLog</span>(kCFLogLevelError,</span><br><span class="line">          <span class="string">@&quot;-[%s %s]: message sent to deallocated instance %p&quot;</span>,</span><br><span class="line">          className + prefixLen,</span><br><span class="line">          sel_getName(sel),</span><br><span class="line">          receiver);</span><br><span class="line">    &lt;breakpoint-interrupt&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (class_respondsToSelector(receiverClass, <span class="keyword">@selector</span>(methodSignatureForSelector:))) &#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *methodSignature = [receiver methodSignatureForSelector:sel];</span><br><span class="line">    <span class="keyword">if</span> (methodSignature) &#123;</span><br><span class="line">      <span class="type">BOOL</span> signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</span><br><span class="line">      <span class="keyword">if</span> (signatureIsStret != isStret) &#123;</span><br><span class="line">        <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">              <span class="string">@&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &#x27;%s&#x27;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;</span>,</span><br><span class="line">              sel_getName(sel),</span><br><span class="line">              signatureIsStret ? <span class="string">&quot;&quot;</span> : not,</span><br><span class="line">              isStret ? <span class="string">&quot;&quot;</span> : not);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (class_respondsToSelector(receiverClass, <span class="keyword">@selector</span>(forwardInvocation:))) &#123;</span><br><span class="line">        <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> _invocationWithMethodSignature:methodSignature</span><br><span class="line">                                                                          frame:frameStackPointer];</span><br><span class="line">        [receiver forwardInvocation:invocation];</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> *returnValue = <span class="literal">NULL</span>;</span><br><span class="line">        [invocation getReturnValue:&amp;value];</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">              <span class="string">@&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement forwardInvocation: -- dropping message&quot;</span>,</span><br><span class="line">              receiver,</span><br><span class="line">              className);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="type">char</span> *selName = sel_getName(sel);</span><br><span class="line">  SEL *registeredSel = sel_getUid(selName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sel != registeredSel) &#123;</span><br><span class="line">    <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">          <span class="string">@&quot;*** NSForwarding: warning: selector (%p) for message &#x27;%s&#x27; does not match selector known to Objective C runtime (%p)-- abort&quot;</span>,</span><br><span class="line">          sel,</span><br><span class="line">          selName,</span><br><span class="line">          registeredSel);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (class_respondsToSelector(receiverClass, <span class="keyword">@selector</span>(doesNotRecognizeSelector:))) &#123;</span><br><span class="line">    [receiver doesNotRecognizeSelector:sel];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">          <span class="string">@&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement doesNotRecognizeSelector: -- abort&quot;</span>,</span><br><span class="line">          receiver,</span><br><span class="line">          className);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The point of no return.</span></span><br><span class="line">  kill(getpid(), <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其逻辑大致如下：</p><ul><li>1、调用 <code>forwardingTargetForSelector</code>，会返回一个新的 <code>target</code>，使用这个 <code>target</code> 作为新的 <code>receiver</code> 执行 <code>selector</code>，如果返回内容为 <code>nil</code> 或者和旧 <code>receiver</code> 一样，进行第 2 步。</li><li>2、调用 <code>methodSignatureForSelector</code> 获取方法签名后，判断返回类型信息是否正确，然后调用 <code>forwardInvocation</code> 执行 <code>NSInvocation</code> 对象，并将结果返回。如果对象没实现 <code>methodSignatureForSelector</code> 方法，进行第 3 步。</li><li>3、调用 <code>doesNotRecognizeSelector</code> 方法。</li></ul><p>也就是说，调用了未实现的方法，如果在动态方法解析阶段未处理，我们还可以在消息转发阶段通过以下处理方式避免 crash，例如：</p><p>假设调用了当前类(AObject)中未实现的如下方法，且没有在动态方法解析阶段动态处理该方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">int</span>)test:(<span class="type">int</span>)arg;</span><br></pre></td></tr></table></figure><p> 我们现在将其转发到 BObject 中的如下相同方法：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (int)test:(int)arg;</span><br></pre></td></tr></table></figure><br><strong>方式 1：</strong>在 AObject 类中实现如下方法转发到 BObject：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test:)) &#123;</span><br><span class="line">        <span class="comment">// 返回一个可以处理方法的对象，需保证对象里有相同方法</span></span><br><span class="line">        <span class="keyword">return</span> [[BObject alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 AObject 类没有实现该方法，还可以使用下面方式转发消息。</p><p><strong>方式 2：</strong>在 AObject 类中实现如下方法执行 NSInvocation：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，调用如下方法返回对应方法签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test:)) &#123;</span><br><span class="line"><span class="comment">//        根据 Types 获取方法签名</span></span><br><span class="line"><span class="comment">//        return [NSMethodSignature signatureWithObjCTypes:&quot;v20@0:8i16&quot;];</span></span><br><span class="line"><span class="comment">//        return [NSMethodSignature signatureWithObjCTypes:&quot;i@:i&quot;];</span></span><br><span class="line"><span class="comment">//        如果 BObject 中实现了相同方法，可以使用下面方法获取方法签名</span></span><br><span class="line">        <span class="keyword">return</span> [[[BObject alloc] init] methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在下面方法中做转发处理</span></span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="keyword">if</span> (anInvocation.selector == <span class="keyword">@selector</span>(test:)) &#123;</span><br><span class="line"><span class="comment">//        方法 1：调用 BObject 中同名方法</span></span><br><span class="line"><span class="comment">//        [anInvocation invokeWithTarget:[[BObject alloc] init]];</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        方法 2：修改 anInvocation，改为调用 BObject 中其他方法</span></span><br><span class="line"><span class="comment">//        anInvocation.target == [[BObject alloc] init]</span></span><br><span class="line"><span class="comment">//        anInvocation.selector == xxxxTest:</span></span><br><span class="line"><span class="comment">//        [anInvocation invoke];</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        方法 3：直接使用 BObject 的对象调用 test 方法</span></span><br><span class="line"><span class="comment">//        [[[BObject alloc] init] test:xxxxx]</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        方法 4：什么都不做也可以，也不会 crash 了</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于类方法的处理，也是一样的，只不过改调用对应类方法而已：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转发方式 1</span></span><br><span class="line">+ (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test:)) &#123;</span><br><span class="line">        <span class="comment">// 注意，由于是类方法，所以这里应当返回 class，当然，如果想转发后调用 BObject 中的对象方法，这里就返回对象（例如：return [[BObject alloc] init];）即可</span></span><br><span class="line">        <span class="keyword">return</span> [BObject <span class="keyword">class</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，如果 AObject 类没有实现上面方法，还可以使用下面方式转发消息：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转发方式 2</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;i@:i&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="comment">// 转发逻辑，或不做任何处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NSInvocation 其他两个常用方法：</p><ul><li>获取参数<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arg;</span><br><span class="line"><span class="comment">// 如果只有一个参数 arg，那么这个参数的 index 是 2，即第三个参数，因为前两个参数是 self 和 _cmd</span></span><br><span class="line">[anInvocation getArgument:&amp;arg atIndex:<span class="number">2</span>];</span><br></pre></td></tr></table></figure></li><li>获取返回值<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret;</span><br><span class="line">[anInvocation getReturnValue:&amp;ret];</span><br></pre></td></tr></table></figure></li></ul><h2 id="3、消息发送完整流程图"><a href="#3、消息发送完整流程图" class="headerlink" title="3、消息发送完整流程图"></a>3、消息发送完整流程图</h2><p>附上一张本人绘制的消息发送完整流程图：<br><img src="/images/lix_blog_49.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Runtime 之 method</title>
      <link href="/posts/1794/"/>
      <url>/posts/1794/</url>
      
        <content type="html"><![CDATA[<h2 id="1、method-与-Class"><a href="#1、method-与-Class" class="headerlink" title="1、method 与 Class"></a>1、method 与 Class</h2><p>先看下 Class 的结构：<br><img src="/images/lix_blog_39.png"><br><code>class_rw_t</code> 里面的 <code>methods</code>、<code>properties</code>、<code>protocols</code> 是二维数组，是可读可写的，包含了类的初始内容、分类的内容：<br><img src="/images/lix_blog_40.png"><br>也就是说，这里的 <code>methods</code> 既包含分类中的方法，也包含了类的初始方法。实际上，我们在使用 category 为类增加方法时，会将 category 中的方法插到初始的方法前面。</p><p><code>class_ro_t</code> 里面的 <code>baseMethodList</code>、<code>baseProtocols</code>、<code>ivars</code>、<code>baseProperties</code> 是一维数组，是只读的，包含了类的初始内容：<br><img src="/images/lix_blog_41.png"><br>也就是说，class 中 <code>method</code> 是 <code>method_t</code> 结构体的形式进行存储的，<code>method_t</code> 结构体就是对方法&#x2F;函数的一个封装。</p><h2 id="2、method-t"><a href="#2、method-t" class="headerlink" title="2、method_t"></a>2、method_t</h2><p><code>method_t</code> 是对方法&#x2F;函数的封装：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> method_t &#123;</span><br><span class="line">    SEL name; <span class="comment">// 函数名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *types; <span class="comment">// 编码（返回值类型、参数类型）</span></span><br><span class="line">    IMP imp; <span class="comment">// 指向函数的指针（函数地址）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-IMP"><a href="#1-IMP" class="headerlink" title="(1) IMP"></a>(1) IMP</h3><p>IMP 是指向函数的指针，即 imp 存储了函数的地址，是函数的具体实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">id</span> _Nullable (*IMP)(<span class="type">id</span> _Nonnull, SEL _Nonnull, ...);</span><br></pre></td></tr></table></figure><ul><li>前面的 <code>id</code> 代表返回值。</li><li>第一个参数指向 <code>self</code>（它代表当前类实例的地址，如果是类则指向的是它的元类），作为消息的接受者；</li><li>第二个参数代表方法的 <code>SEL</code>；</li><li>… 代表可选参数;</li></ul><h3 id="2-SEL"><a href="#2-SEL" class="headerlink" title="(2) SEL"></a>(2) SEL</h3><p>SEL 一般称做选择器或选择子，代表方法\函数名，底层结构跟 <code>char *</code> 类似，是方法在 Runtime 期间的标识符。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL</span><br></pre></td></tr></table></figure><ul><li>可以通过 <code>@selector() </code>和 <code>sel_registerName() </code>获得</li><li>可以通过 <code>sel_getName()</code> 和 <code>NSStringFromSelector()</code> 转成字符串</li><li>在类加载的时候，编译器会生成与方法相对应的 SEL，并注册到 Objective-C 的 Runtime 运行系统。不论两个类是否存在依存关系，只要他们拥有相同的方法名，那么他们的 SEL 都是相同的。</li></ul><h3 id="3-types"><a href="#3-types" class="headerlink" title="(3) types"></a>(3) types</h3><p>types 是个 <code>char</code> 指针，其实存储着方法的参数类型、返回值类型，即是 Type Encoding 编码。</p><p>iOS 中提供了一个叫做 <code>@encode</code> 的指令，可以将具体的类型表示成字符串编码，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, <span class="keyword">@encode</span>(<span class="type">int</span>)); <span class="comment">// 打印 i</span></span><br></pre></td></tr></table></figure><p>types 对照表：<br><img src="/images/lix_blog_42.png"><br>例如，对于以下方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">int</span>)test:(<span class="type">int</span>)age height:(<span class="type">float</span>)height;</span><br></pre></td></tr></table></figure><p>其 types 为：<br><code>i24@0:8i16f20</code>(开发时也可以简写为 <code>i@:if</code>)<br><img src="/images/lix_blog_43.png"></p><ul><li><code>i</code> 代表返回值类型为 <code>int</code></li><li><code>@</code> 代表 <code>id</code> 类型参数（<code>self</code>）</li><li><code>:</code> 代表 <code>SEL</code> 类型参数（<code>_cmd</code>）</li><li><code>i</code> 代表 <code>int</code> 类型参数（<code>age</code>）</li><li><code>f</code> 代表 <code>float</code> 类型参数（<code>height</code>）</li></ul><p>对于数字：</p><ul><li><code>24</code> 代表所有参数占用的字节数</li><li>（<code>id</code> 和 <code>SEL</code> 为指针类型，各占 8 字节；<code>int</code>、<code>float</code> 均占 <code>4</code> 字节。总计 8+8+4+4&#x3D;24 字节）</li><li><code>0</code> 代表 <code>@</code>（<code>self</code>）从第 0 个字节开始</li><li><code>8</code> 代表 <code>:</code>（<code>_cmd</code>）从第 8 个字节开始</li><li><code>16</code> 代表 <code>i</code>（<code>age</code>）从第 16 字节开始</li><li><code>20</code> 代表 <code>f</code>（<code>height</code>）从第 20 字节开始</li></ul><h2 id="2、方法缓存"><a href="#2、方法缓存" class="headerlink" title="2、方法缓存"></a>2、方法缓存</h2><h3 id="1-cache-t-的结构"><a href="#1-cache-t-的结构" class="headerlink" title="(1) cache_t 的结构"></a>(1) cache_t 的结构</h3><p>再来来看下 class 结构：<br><img src="/images/lix_blog_44.png" style="width:60%;"><br>每一个类都维护了一个 <code>cache</code>，当我们在调用一个方法时，runtime 会先在 <code>cache</code> 中查找对应方法，没有找到对应方法，再从 <code>methods</code> 中寻找。并且每次调用方法的时候，都会将方法存到 <code>cache</code> 中。</p><p>接下来看下 <code>cache_t</code> 的数据结构：<br><img src="/images/lix_blog_46.png"><br>Class 内部结构中有个方法缓存（<code>cache_t</code>），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度。</p><p><code>cache_t</code> 结构体里面有三个元素：</p><ul><li><code>_buckets</code> 散列表，是一个数组，数组里面的每一个元素就是一个 <code>bucket_t</code>，<code>bucket_t</code> 结构：<ul><li><code>SEL</code> 作为 <code>key</code></li><li>函数的实现 <code>IMP</code> 为 <code>value</code></li></ul></li><li><code>_mask</code> 散列表的长度<ul><li><code>_mask</code> 它代表的是散列表的长度 -1，最初分配的值是 4，方法 <code>SEL &amp; _mask</code> 得到的值，就是对应 <code>bucket_t</code> 在散列表中的索引。</li></ul></li><li><code>_occupied</code> 已经缓存的方法数量</li></ul><h3 id="2-cache-t-的存入"><a href="#2-cache-t-的存入" class="headerlink" title="(2) cache_t 的存入"></a>(2) cache_t 的存入</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> cache_t::insert(Class cls, SEL sel, IMP imp, <span class="type">id</span> receiver)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 插入新的方法缓存,数量+1</span></span><br><span class="line">    mask_t newOccupied = occupied() + <span class="number">1</span>; </span><br><span class="line">    <span class="type">unsigned</span> oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(isConstantEmptyCache())) &#123; </span><br><span class="line">        <span class="comment">//如果还没有缓存过方法</span></span><br><span class="line">        <span class="comment">// INIT_CACHE_SIZE 这是一个容量为 4 的宏,最初分配的容量就是 4</span></span><br><span class="line">        <span class="keyword">if</span> (!capacity) capacity = INIT_CACHE_SIZE; </span><br><span class="line">        <span class="comment">// 创建-分配内存</span></span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="comment">/* freeOld */</span><span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fastpath(newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="comment">// 保证缓存表存的方法数小于等于 容量的3/4 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//超过容量的3/4,容量翻倍</span></span><br><span class="line">        capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">        <span class="comment">// 不能超过最大值,最大值是1&lt;&lt;16</span></span><br><span class="line">        <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">            capacity = MAX_CACHE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超过容量后,将之前缓存的方法全部清空 &quot;true&quot;</span></span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    mask_t m = capacity - <span class="number">1</span>;</span><br><span class="line">    mask_t begin = cache_hash(sel, m); </span><br><span class="line">    mask_t i = begin; <span class="comment">// 通过 sel &amp; mask 计算出sel该存放的位置 &quot;i&quot;</span></span><br><span class="line">    <span class="comment">// 如果计算出来的值没有缓存方法,则直接插入,保存;</span></span><br><span class="line">    <span class="comment">// 如果已经有方法插入了,在__arm64__架构 i--(其他架构i++),即,如果被占用,往上走一格,还被占用继续往上走,因为规则限定了3/4,所以肯定能找到没有保存方法的位置.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fastpath(b[i].sel() == <span class="number">0</span>)) &#123;</span><br><span class="line">            incrementOccupied();</span><br><span class="line">            <span class="comment">// 保存方法</span></span><br><span class="line">            b[i].set&lt;Atomic, Encoded&gt;(sel, imp, cls);  </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b[i].sel() == sel) &#123;</span><br><span class="line">        <span class="comment">// 这种情况是其他线程,已经把方法添加到这里了,那就直接退出循环</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (fastpath((i = cache_next(i, m)) != begin)); <span class="comment">// &quot;i&quot;不等于初始位置 i--,继续循环.</span></span><br><span class="line"></span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)sel, cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><p>先看缓存中是否已经存在了该方法，如果已经存在，直接 return 掉，不再缓存。</p></li><li><p>如果当前 <code>cache</code> 还没被初始化，则分配一个大小为 4 的数组，并设置 <code>_mask</code> 为 3。</p></li><li><p>如果存入缓存后的大小小于当前大小的 3&#x2F;4，则当前缓存大小还可以使用，无需扩容。</p></li><li><p>否则缓存太满，需要扩容，扩容为原来大小的 2 倍。放弃旧的缓存，已缓存的数据全部清空，新扩容的缓存为空，并将 <code>_occupied</code> 重新初始化为 0。</p></li><li><p>方法的存储并不是按照数组一样从上到下存储，而是通过 <code>SEL &amp; _mask</code> （例如：<code>@selector(myMethod:)  &amp; _mask）</code>的值作为索引来存储的，所以难免会存在内存利用率低，但是加快了方法查找的速度，即：空间换时间。</p></li><li><p>在 arm64 架构下，如果 <code>SEL &amp; _mask</code> 结果为 <code>i</code>，若索引 <code>i</code> 位置已经有 <code>bucket_t</code> 值了，就取出 <code>bucket_t</code> 中的 <code>key</code> 与 <code>SEL</code> 进行比较，如果不相同，则继续往 <code>i -1</code> 继续寻找，直到找到未被占用的位置，然后将对应 <code>bucket</code> 存进去。如果找到 <code>i = 0</code> 仍然未找到合适位置，则从 <code>i = _mask</code> （即最后一个索引）开始继续往上寻找。</p></li><li><p>方法缓存是先于 <code>isa</code> 的方法查找，就是说，缓存中找不到，再到自己的方法列表中查找，找到之后也会缓存到 <code>cache_t</code> 中，如果是父类的方法，也是会缓存到自己的表当中的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block 实现原理</title>
      <link href="/posts/42759/"/>
      <url>/posts/42759/</url>
      
        <content type="html"><![CDATA[<h2 id="1、block-的底层结构"><a href="#1、block-的底层结构" class="headerlink" title="1、block 的底层结构"></a>1、block 的底层结构</h2><p>假设对于以下 block：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> (^myblock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;myblock is %d&quot;</span>,a); <span class="comment">// 注意，block 内部访问了外部变量</span></span><br><span class="line">&#125;;</span><br><span class="line">myblock();</span><br></pre></td></tr></table></figure><p>将以上代码转换成对应的 C++ 代码，可以看到，Block 底层的结构如下：<br><img src="/images/lix_blog_26.png"><br><em>(备注：上图 __main_block_func_0 函数里实际上还有 block 里 <code>NSLog(@&quot;myblock is %d&quot;,a);</code>相关代码，为了看起来方便，这里直接去掉了。)</em></p><ul><li>impl 是 block 的实现，其中包含了 isa 指针以及 block 函数实现。</li><li>Desc 是 block 的描述信息，包含了 block 大小等信息。</li><li>如果 block 内部还访问了局部变量，block 结构体中还会包含捕获的局部变量。</li></ul><p>block 结构体的第一个成员变量是结构体(不是结构体指针) <code>__block_impl impl</code>，所以，block 结构体相当于就是：<br><img src="/images/lix_blog_27.png"><br>从 block 的结构体包含 isa 指针可以看出，<font color=#ff0000>block 的本质就是一个对象，</font>NSBlock 对象也是继承自 NSObject 对象的。并且如果 block 访问了外部变量的话，还会把外部变量包装到自己内部。</p><p>.cpp 中关于执行 block 的逻辑如下：<br><img src="/images/lix_blog_28.png"><br>可以看出，执行 block，实际上就是 <code>block-&gt;FuncPtr()</code>，也就是通过 block 对象执行其实现函数。</p><h2 id="2、外部变量的捕获"><a href="#2、外部变量的捕获" class="headerlink" title="2、外部变量的捕获"></a>2、外部变量的捕获</h2><p>当在 block 内访问外部变量时，block 对变量的捕获方式如下：<br><img src="/images/lix_blog_29.png"><br>例如，对于以下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> test()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>; <span class="comment">// auto</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> b = <span class="number">2</span>; <span class="comment">// static</span></span><br><span class="line">    block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;a is %d, b is %d&quot;</span>, a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一个 auto 变量 a（对于一个局部变量，无论是基本数据类型还是 OC 对象类型，默认就是 auto 变量）、一个 static 变量 b，将代码转换成   C++ 代码，如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __test_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __test_block_desc_0* Desc;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> *b;</span><br><span class="line">  __test_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __test_block_desc_0 *desc, <span class="type">int</span> _a, <span class="type">int</span> *_b, <span class="type">int</span> flags=<span class="number">0</span>) : a(_a), b(_b) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现，对于局部变量，访问 auto 变量，block 捕获的是其值，而访问 static 变量，block 捕获的是指针，所以在 block 内部可以直接修改 static 局部变量的值，但不可以修改 auto 变量的值。</p><p>对于全局变量，可以保证变量的生命周期足够长，block 内部也就没有必要再去捕获，block 内部访问全局变量直接访问即可，也可以在 block 内部直接修改全局变量。</p><p>如果在 block 内部访问了 <code>self</code>，block 也会捕获 <code>self</code>，因为 <code>self</code> 是局部变量。如果访问了 <code>self</code> 内部的属性，捕获的也是 <code>self</code>，而不是内部具体的属性。为什么 <code>self</code> 是局部变量呢？我们在方法内能访问 <code>self</code>，是因为 OC 方法在底层转换为 C 语言函数后，会默认自动带上 <code>self</code> 和 <code>_cmd</code> 两个参数，我们在方法内部访问的 <code>self</code> 实际上就是参数传进来的 <code>self</code>，方法的参数也是一种局部变量。</p><p>当 block 内部访问了对象类型的 auto 变量时：</p><ul><li><p>如果 block 是在栈上，将不会对 auto 变量产生强引用</p></li><li><p>如果 block 被拷贝到堆上</p><ul><li>会调用 block 内部的 <code>copy</code> 函数</li><li><code>copy</code> 函数内部会调用 <code>_Block_object_assign</code> 函数</li><li><code>_Block_object_assign</code> 函数会根据 auto 对象类型变量的修饰符（<code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code>）做出相应的操作，形成强引用（retain）或者弱引用</li></ul></li><li><p>如果 block 从堆上移除</p><ul><li>会调用 block 内部的 <code>dispose</code> 函数</li><li><code>dispose</code> 函数内部会调用 <code>_Block_object_dispose</code> 函数</li><li><code>_Block_object_dispose</code> 函数会自动释放引用的 auto 变量（release）</li></ul></li></ul><h2 id="3、block-类型"><a href="#3、block-类型" class="headerlink" title="3、block 类型"></a>3、block 类型</h2><p>block 有 3 种类型，可以通过调用 class 方法（例如：[myBlock class]）或者 isa 指针查看具体类型，最终都是继承自 NSBlock 类型。<br><strong>Block 的三种类型：</strong></p><ul><li>全局 block<br><code>__NSGlobalBlock__</code> （ <code>_NSConcreteGlobalBlock</code> ）</li><li>栈 block<br><code>__NSStackBlock__</code> （ <code>_NSConcreteStackBlock</code> ）</li><li>堆 block<br><code>__NSMallocBlock__</code> （ <code>_NSConcreteMallocBlock</code> ）</li></ul><p><strong>在 MRC 情况下：</strong><br><img src="/images/lix_blog_30.png"><br><strong>在 ARC 情况下：</strong><br>在 ARC 环境下，为了延长 block 的生命周期，避免栈 block 那样作用域结束 block 就被废弃的情况，编译器会根据需要自动将栈上的 block 复制到堆上（变成堆 block），复制到堆上调用的就是 block 的 <code>copy</code> 方法，比如以下情况：</p><ul><li>block 作为函数返回值时</li><li>将 block 赋值给 <code>__strong</code> 指针时</li><li>block 作为 Cocoa API 中方法名含有 <code>usingBlock</code> 的方法参数时</li><li>block 作为 GCD API 的方法参数时</li></ul><p>MRC 下 block 属性的建议写法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="type">void</span> (^block)(<span class="type">void</span>);</span><br></pre></td></tr></table></figure><p>ARC 下 block 属性的建议写法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">void</span> (^block)(<span class="type">void</span>);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="type">void</span> (^block)(<span class="type">void</span>);</span><br></pre></td></tr></table></figure><h2 id="4、-block-修饰符"><a href="#4、-block-修饰符" class="headerlink" title="4、__block 修饰符"></a>4、__block 修饰符</h2><p>如果我们直接在 block 中修改 auto 变量，编译器会报错，要求使用 <code>__block</code> 修饰 auto 变量，如下：<br><img src="/images/lix_blog_31.png"></p><p>当使用 <code>__block</code> 修饰了 auto 变量后，就不再报错，并且成功修改了 auto 变量的值：<br><img src="/images/lix_blog_32.png"><br>备注：<br>向下面这样就不需要使用 <code>__block</code> 修饰仍然可以生效，因为 block 相当于只是使用了变量，而不是直接修改了对象的值：<br><img src="/images/lix_blog_33.png"></p><h3 id="1-block-修饰符作用"><a href="#1-block-修饰符作用" class="headerlink" title="(1) __block 修饰符作用"></a>(1) __block 修饰符作用</h3><ul><li><code>__block</code> 可以用于解决 block 内部无法修改 auto 变量值的问题</li><li><code>__block</code> 不能修饰全局变量、静态变量（static）</li><li>编译器会将<code> __block</code> 修饰的变量包装成一个对象</li></ul><p>接下来将前述的代码转成 C++ 代码，看下 <code>__block</code> 修饰 auto 变量后的逻辑：<br><img src="/images/lix_blog_34.png"></p><p><img src="/images/lix_blog_35.png"><br>从上述 C++ 代码可知，当使用 <code>__block</code> 修饰了 auto 变量 age 后：</p><ul><li><p>会在当前 block 结构体创建 <code>__Block_byref_age_0</code> 结构体类型的指针成员变量。<br><code>__Block_byref_age_0 *age;</code></p></li><li><p><code>__Block_byref_age_0</code> 结构体中包含 isa 指针，所以也是一个对象。<br><code>void *__isa;</code></p></li><li><p><code>__Block_byref_age_0</code> 结构体中包含一个指向自己的指针 __forwarding。<br><code>__Block_byref_age_0 *__forwarding;</code></p></li><li><p><code>__Block_byref_age_0</code> 结构体中包含了之前在 block 中访问的、被 <code>__block</code> 修饰的 auto 变量。<br><code>int age;</code></p></li><li><p>当在 block 中修改被 <code>__block</code> 修饰的 auto 变量时，是通过 <code>__forwarding</code> 间接修改的。<br><code>(age-&gt;__forwarding-&gt;age) = 200;</code></p></li><li><p>并且，当 block 访问了<code>__block</code> 修饰的 auto 变量后，block 结构体中的 <code>Desc</code> 结构体多了 <code>copy</code> 和 <code>dispose</code> 两个和内存管理有关的两个函数。</p></li></ul><h3 id="2-forwarding-指针的作用"><a href="#2-forwarding-指针的作用" class="headerlink" title="(2) __forwarding 指针的作用"></a>(2) __forwarding 指针的作用</h3><p>从上述可知，当在 block 中修改被 <code>__block</code> 修饰的 auto 变量时，是通过 <code>__forwarding</code> 间接修改的。<br>现在将对应的 C++ 代码中结构体拿出来，对 block 强制转换成对应结构体类型：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_age_0 &#123;</span><br><span class="line">    <span class="type">void</span> *__isa;</span><br><span class="line">    <span class="keyword">struct</span> __Block_byref_age_0 *__forwarding;</span><br><span class="line">    <span class="type">int</span> __flags;</span><br><span class="line">    <span class="type">int</span> __size;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    <span class="type">void</span> (*<span class="keyword">copy</span>)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*dispose)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">    <span class="type">void</span> *isa;</span><br><span class="line">    <span class="type">int</span> Flags;</span><br><span class="line">    <span class="type">int</span> Reserved;</span><br><span class="line">    <span class="type">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">    <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">    <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">    <span class="keyword">struct</span> __Block_byref_age_0 *age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        __block <span class="type">int</span> age = <span class="number">100</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">            age = <span class="number">200</span>;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;my age is %d&quot;</span>, age);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> __main_block_impl_0 *blockImpl = (__bridge <span class="keyword">struct</span> __main_block_impl_0 *)block;</span><br><span class="line">        </span><br><span class="line">        block();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断点调试结果如下，验证了前述的结论：<br><img src="/images/lix_blog_36.png"><br>为什么 block 在修改 <code>__block</code> 修饰的 <code>age</code> 变量时候，要通过 <code>__Block_byref_age_0</code> 结构体中指向结构体自身的 <code>__forwarding</code> 指针去间接找到自己成员变量 <code>age</code> 然后去修改呢？</p><p>这样设计的目的是为了方便内存管理。block 被复制到堆上时，会将 block 中引用的变量也复制到堆中。</p><p>重新看下源码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_age_0 *age = __cself-&gt;age; <span class="comment">// bound by ref</span></span><br><span class="line">            (age-&gt;__forwarding-&gt;age) = <span class="number">200</span>;</span><br><span class="line">            <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_jm_dztwxsdn7bvbz__xj2vlp8980000gn_T_main_b05610_mi_0,(age-&gt;__forwarding-&gt;age));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>通过源码可以知道，当修改 <code>__block</code> 修饰的变量时，是根据变量生成的结构体 <code>__Block_byref_age_0</code> 找到其中 <code>__forwarding</code> 指针，<code>__forwarding</code> 指针指向的是结构体自己，因此可以找到 <code>age</code> 变量进行修改。</p><p>当 block 在栈中时，<code>__Block_byref_age_0</code> 结构体内的 <code>__forwarding</code> 指针指向结构体自己。</p><p>而当 block 被复制到堆中时，栈中的 <code>__Block_byref_age_0</code> 结构体也会被复制到堆中一份，而此时栈中的 <code>__Block_byref_age_0</code> 结构体中的 <code>__forwarding</code> 指针指向的就是堆中的 <code>__Block_byref_age_0</code> 结构体，堆中 <code>__Block_byref_age_0</code> 结构体内的 <code>__forwarding</code> 指针依然指向自己。</p><p>此时当对 age 进行修改时：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈中的age</span></span><br><span class="line">__Block_byref_age_0 *age = __cself-&gt;age; <span class="comment">// bound by ref</span></span><br><span class="line"><span class="comment">// age-&gt;__forwarding获取堆中的age结构体</span></span><br><span class="line"><span class="comment">// age-&gt;__forwarding-&gt;age 修改堆中age结构体的age变量</span></span><br><span class="line">(age-&gt;__forwarding-&gt;age) = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>通过 <code>__forwarding</code> 指针巧妙的将修改的变量赋值在堆中的 <code>__Block_byref_age_0</code> 中。</p><p>通过一张图展示 <code>__forwarding</code> 指针的作用：<br><img src="/images/lix_blog_204.png" alt="upload successful"><br>因此 block 内部拿到的变量实际就是在堆上的。当 block 进行 <code>copy</code> 被复制到堆上时，<code>_Block_object_assign</code> 函数内做的这一系列操作。</p><h3 id="3-block-的内存管理"><a href="#3-block-的内存管理" class="headerlink" title="(3)__block 的内存管理"></a>(3)__block 的内存管理</h3><p><strong>对 <code>__block</code> 变量的引用：</strong></p><ul><li>当 block 在栈上时，并不会对 <code>__block</code> 变量产生强引用</li><li>当 block 被 <code>copy</code> 到堆时<ul><li>会调用 block 内部的 <code>copy</code> 函数</li><li><code>copy</code> 函数内部会调用 <code>_Block_object_assign</code> 函数</li><li>利用 <code>_Block_object_assign</code> 函数对 <code>__block</code> 变量的进行相应持有<ul><li>编译器会将 <code>__block</code> 变量包装成一个结构体对象 A（例如前述的 <code>struct __Block_byref_age_0 *age</code>，并对这个结构体对象 A 进行强引用。</li><li>对于 OC 对象，<code>_Block_object_assign</code> 函数会根据所指向对象的修饰符（<code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code>）做出相应的操作，在结构体对象 A 中形成强引用（<code>retain</code>）或者弱引用（注意：这里仅限于 ARC 时会 <code>retain</code>，MRC 时不会 <code>retain</code>）</li></ul></li></ul></li></ul><p>简而言之，block 访问了 <code>__block</code> 修饰的 auto 变量，编译器会自动生成对应的结构体对象，block 会对这个结构体对象进行强引用，但是这个结构体对象内部对 auto 变量是强引用还是弱引用，取决于这个 auto 变量对象修饰符（<code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code>）。</p><p>例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^Block)(<span class="type">void</span>);</span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="number">20</span>;</span><br><span class="line">        __block <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">        __<span class="keyword">weak</span> <span class="built_in">NSObject</span> *weakObj = object;</span><br><span class="line"></span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        __block Person *person = p;</span><br><span class="line">        __block __<span class="keyword">weak</span> Person *weakPerson = p;</span><br><span class="line"></span><br><span class="line">        Block block = ^ &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,number); <span class="comment">// 局部变量</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,age); <span class="comment">// __block修饰的局部变量</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>,object); <span class="comment">// 对象类型的局部变量</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>,weakObj); <span class="comment">// __weak修饰的对象类型的局部变量</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>,person); <span class="comment">// __block修饰的对象类型的局部变量</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>,weakPerson); <span class="comment">// __block，__weak修饰的对象类型的局部变量</span></span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码转化为 C++ 代码查看不同变量之间的区别:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> number;</span><br><span class="line">  <span class="built_in">NSObject</span> *__<span class="keyword">strong</span> object;</span><br><span class="line">  <span class="built_in">NSObject</span> *__<span class="keyword">weak</span> weakObj;</span><br><span class="line">  __Block_byref_age_0 *age; <span class="comment">// by ref</span></span><br><span class="line">  __Block_byref_person_1 *person; <span class="comment">// by ref</span></span><br><span class="line">  __Block_byref_weakPerson_2 *weakPerson; <span class="comment">// by ref</span></span><br><span class="line"></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> _number, <span class="built_in">NSObject</span> *__<span class="keyword">strong</span> _object, <span class="built_in">NSObject</span> *__<span class="keyword">weak</span> _weakObj, __Block_byref_age_0 *_age, __Block_byref_person_1 *_person, __Block_byref_weakPerson_2 *_weakPerson, <span class="type">int</span> flags=<span class="number">0</span>) : number(_number), object(_object), weakObj(_weakObj), age(_age-&gt;__forwarding), person(_person-&gt;__forwarding), weakPerson(_weakPerson-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述 <code>__main_block_impl_0</code> 结构体中看出，没有使用 <code>__block</code> 修饰的变量（<code>object</code> 和 <code>weakObj</code>）则根据他们本身被 block 捕获的指针类型对他们进行强引用或弱引用。而一旦使用 <code>__block</code> 修饰的变量，<code>__main_block_impl_0 </code>结构体内一律使用强指针引用生成的结构体。</p><p>接着我们来看 <code>__block</code> 修饰的变量生成的结构体有什么不同：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_age_0 &#123;</span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">__Block_byref_age_0 *__forwarding;</span><br><span class="line"> <span class="type">int</span> __flags;</span><br><span class="line"> <span class="type">int</span> __size;</span><br><span class="line"> <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __Block_byref_person_1 &#123;</span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">__Block_byref_person_1 *__forwarding;</span><br><span class="line"> <span class="type">int</span> __flags;</span><br><span class="line"> <span class="type">int</span> __size;</span><br><span class="line"> <span class="type">void</span> (*__Block_byref_id_object_copy)(<span class="type">void</span>*, <span class="type">void</span>*);</span><br><span class="line"> <span class="type">void</span> (*__Block_byref_id_object_dispose)(<span class="type">void</span>*);</span><br><span class="line"> Person *__<span class="keyword">strong</span> person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __Block_byref_weakPerson_2 &#123;</span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">__Block_byref_weakPerson_2 *__forwarding;</span><br><span class="line"> <span class="type">int</span> __flags;</span><br><span class="line"> <span class="type">int</span> __size;</span><br><span class="line"> <span class="type">void</span> (*__Block_byref_id_object_copy)(<span class="type">void</span>*, <span class="type">void</span>*);</span><br><span class="line"> <span class="type">void</span> (*__Block_byref_id_object_dispose)(<span class="type">void</span>*);</span><br><span class="line"> Person *__<span class="keyword">weak</span> weakPerson;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上面分析的那样，<code>__block</code> 修饰对象类型的变量生成的结构体内部多了 <code>__Block_byref_id_object_copy</code> 和 <code>__Block_byref_id_object_dispose</code> 两个函数，用来对对象类型的变量进行内存管理的操作。而结构体对对象的引用类型，则取决于 block 捕获的对象类型的变量。<code>weakPerson</code> 是弱指针，所以 <code>__Block_byref_weakPerson_2</code> 对 <code>weakPerson</code> 就是弱引用，<code>person</code> 是强指针，所以 <code>__Block_byref_person_1</code> 对 <code>person</code> 就是强引用。</p><p><strong>对 <code>__block</code> 变量的释放：</strong><br>当 block 从堆中移除时</p><ul><li>会调用 block 内部的 <code>dispose</code> 函数<br>+<code> dispose</code> 函数内部会调用 <code>_Block_object_dispose</code> 函数</li><li><code>_Block_object_dispose</code> 函数会自动释放引用的 <code>__block</code> 变量（<code>release</code>）</li></ul><h2 id="5、block-的循环引用"><a href="#5、block-的循环引用" class="headerlink" title="5、block 的循环引用"></a>5、block 的循环引用</h2><h3 id="1-Block-内访问-self-导致的循环引用"><a href="#1-Block-内访问-self-导致的循环引用" class="headerlink" title="(1) Block 内访问 self 导致的循环引用"></a>(1) Block 内访问 self 导致的循环引用</h3><p>在 Block 内部访问 访问 <code>self</code> 可能会导致循环引用，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)testFunc &#123;</span><br><span class="line">    <span class="keyword">self</span>.TestBlock = ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.name = <span class="string">@&quot;lifengfeng&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法是使用 <code>__weak</code> 修饰 <code>self</code>，为了延长 <code>self</code> 生命周期，避免 Block 在执行过程中 <code>self</code> 被销毁，在 block 内部使用 <code>__strong</code> 修饰的 <code>self</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)testFunc &#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.TestBlock = ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        strongSelf.name = <span class="string">@&quot;lifengfeng&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是，为什么 Block 内部使用 <code>__strong</code> 修饰 <code>self</code> 后，为什么不会重新循环引用呢？</strong><br>很简单，Block 外部使用 <code>__weak</code> 修饰 <code>self</code>，会使 Block 捕获 <code>self</code> 时候对 <code>self</code> 进行弱引用，内部再使用 <code>__strong</code> 修饰 <code>self</code>，相当于在 Block 对应函数实现里对 <code>self</code> 进行一次引用计数 +1，延长了 <code>self</code> 的生命周期，但 Block 对捕获的 <code>self</code> 仍然是弱引用的。</p><h3 id="2-NSTimer-导致的循环引用"><a href="#2-NSTimer-导致的循环引用" class="headerlink" title="(2) NSTimer 导致的循环引用"></a>(2) NSTimer 导致的循环引用</h3><p>例如，使用 <code>NSTimer</code> 可能产生循环引用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerTest) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p><strong><code>NSTimer</code> 循环引用的原因：</strong><br><code>NSTimer</code> 被添加到主线程的 RunLoop 中，在停止 <code>NSTimer</code> 之前，<code>NSTimer</code> 会被 RunLoop 一直持有。而 <code>NSTimer</code> 又持有了 Target，导致了 Target 无法释放。</p><p>其解决办法主要有下面三种方式：</p><h4 id="a、使用-block"><a href="#a、使用-block" class="headerlink" title="a、使用 block"></a>a、使用 block</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">    [weakself timerTest];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="b、使用代理对象"><a href="#b、使用代理对象" class="headerlink" title="b、使用代理对象"></a>b、使用代理对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXXProxy.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXXProxy</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="type">id</span>)target;</span><br><span class="line"><span class="comment">// 注意这里是 weak</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="type">id</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXXProxy.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;XXXProxy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXXProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="type">id</span>)target</span><br><span class="line">&#123;</span><br><span class="line">    XXXProxy *proxy = [[XXXProxy alloc] init];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:[XXXProxy proxyWithTarget:<span class="keyword">self</span>] selector:<span class="keyword">@selector</span>(timerTest) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>这样就避免了循环引用。</p><p>这里使用的是我们自己继承自 <code>NSObject</code> 实现的代理对象，但是系统提供了一个效率更高的代理对象：<code>NSProxy</code>，使用该对象做代理时，不再从自己方法列表查找方法，直接走消息转发流程，而且该类不是继承自 <code>NSObject</code> 的，而是实现 <code>&lt;NSObject&gt;</code> 协议的基类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSProxy</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class   isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXXProxy.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXXProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="type">id</span>)target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="type">id</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXXProxy.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;XXXProxy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXXProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="type">id</span>)target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// NSProxy 对象不需要调用 init，因为它本来就没有 init 方法</span></span><br><span class="line">    XXXProxy *proxy = [XXXProxy alloc];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSProxy 没有 forwardingTargetForSelector: 方法</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>接下来看一个关于NSProxy 比较有意思的示例，以下代码如何打印？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ViewController *vc = [[ViewController alloc] init];</span><br><span class="line"><span class="comment">// XXXProxy 是继承自 NSProxy </span></span><br><span class="line">XXXProxy *proxy = [XXXProxy  proxyWithTarget:vc];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,[proxy isKindOfClass:[ViewController <span class="keyword">class</span>]]);</span><br></pre></td></tr></table></figure><p>按照以往理解，以上代码应该打印 0，但实际结果是打印 1，因为 <code>NSProxy</code> 不是任何类的子类，也是一个基类，内部调用的所有方法，都将直接进行转发。所以上面<br><code>[proxy isKindOfClass:[ViewController class]]</code><br>等价于<br><code>[vc isKindOfClass:[ViewController class]]</code></p><p>而如果 <code>XXXProxy</code> 继承自 <code>NSObject</code>，那么结果就是打印 0 了。</p><h4 id="c、使用-GCD-替代"><a href="#c、使用-GCD-替代" class="headerlink" title="c、使用 GCD 替代"></a>c、使用 GCD 替代</h4><p>另外需要注意的是，由于 <code>NSTimer</code> 是基于 Runloop 的，所以如果 Runloop 循环期间任务很重的话，很容易出现 <code>NSTimer</code> 计时不准问题，解决办法就是使用 GCD 实现定时器，GCD 是直接跟系统内核挂钩的，不会受 Runloop 影响：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建定时器</span></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置时间</span></span><br><span class="line">uint64_t start = <span class="number">2.0</span>; <span class="comment">// 2秒后开始执行</span></span><br><span class="line">uint64_t interval = <span class="number">1.0</span>; <span class="comment">// 每隔1秒执行</span></span><br><span class="line">dispatch_source_set_timer(timer,</span><br><span class="line">                          dispatch_time(DISPATCH_TIME_NOW, start * <span class="built_in">NSEC_PER_SEC</span>),</span><br><span class="line">                          interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调</span></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1111&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// dispatch_source_set_event_handler_f(timer, myTimerFireMethod);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动定时器</span></span><br><span class="line">dispatch_resume(timer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.timer = timer;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> block </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC 对象一探究竟之三：alloc 与 init</title>
      <link href="/posts/25223/"/>
      <url>/posts/25223/</url>
      
        <content type="html"><![CDATA[<p>一般我们都是通过如下方式创建一个对象：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyObject *objc = [[MyObject alloc] init];</span><br></pre></td></tr></table></figure><p>那么，<code>alloc</code> 和 <code>init</code> 方法都分别做了什么事呢？</p><h2 id="1、alloc"><a href="#1、alloc" class="headerlink" title="1、alloc"></a>1、alloc</h2><p>alloc 方法实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">id</span>)alloc &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，内部就是调用了 <code>_objc_rootAlloc</code> 函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span></span><br><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>callAlloc 函数实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="type">id</span></span><br><span class="line">callAlloc(Class cls, <span class="type">bool</span> checkNil, <span class="type">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        <span class="comment">// 如果类没有实现自定义的 +allocWithZone 方法</span></span><br><span class="line">        <span class="keyword">return</span> _objc_rootAllocWithZone(cls, <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL, <span class="keyword">struct</span> _NSZone *))objc_msgSend)(cls, <span class="keyword">@selector</span>(allocWithZone:), <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL))objc_msgSend)(cls, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上逻辑是先判断是否实现了自定义的 <code>+allocWithZone</code> 方法<br>如果实现了，通过 <code>objc_msgSend</code> 方式直接调用自定义的  <code>+allocWithZone</code> 方法<br>如果没有实现，则调用 <code>_objc_rootAllocWithZone</code> 函数</p><p>一般我们不会自定义 <code>+allocWithZone</code> 方法，所以接下来看下 <code>_objc_rootAllocWithZone</code> 函数的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span></span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span></span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, <span class="number">0</span>, <span class="literal">nil</span>,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_objc_rootAllocWithZone()</code> 内部进入到了 alloc 源码的核心操作 <code>_class_createInstanceFromZone()</code> 函数，其实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="type">id</span></span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="type">void</span> *zone,</span><br><span class="line">                              <span class="type">int</span> construct_flags = OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              <span class="type">bool</span> cxxConstruct = <span class="literal">true</span>,</span><br><span class="line">                              size_t *outAllocatedSize = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类或者父类是否有 C++ 构造方法或析够方法</span></span><br><span class="line">    <span class="type">bool</span> hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    <span class="type">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    <span class="comment">//是否能alloc nonpointer isa</span></span><br><span class="line">    <span class="type">bool</span> fast = cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line">    <span class="comment">// 计算对象所需大小，这里 extraBytes == 0，由前一函数传递</span></span><br><span class="line">    size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="comment">// 将计算好的 size 通过指针地址传递出去，不影响我们理解主流程，可以忽略</span></span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    <span class="type">id</span> obj;</span><br><span class="line">    <span class="comment">// 判断是否有 zone,在之前的版本是有 zone 的</span></span><br><span class="line">    <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">        obj = (<span class="type">id</span>)malloc_zone_calloc((malloc_zone_t *)zone, <span class="number">1</span>, size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// alloc 开辟内存的地方</span></span><br><span class="line">        obj = (<span class="type">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里是内存开辟错误执行的流程，字面意思可以看到，系统调用了 alloc 失败句柄</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!obj)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            <span class="keyword">return</span> _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        <span class="comment">// 初始化 isa，并将类与 isa 关联</span></span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be</span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">        <span class="comment">// 老版本的内存分配</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若没有 C++ 构造函数，则将关联好类的 isa 返回</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若有 c++ 构造函数，则走 c++ 构造流程</span></span><br><span class="line">    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    <span class="keyword">return</span> object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是下面三个主要逻辑：</p><ul><li>cls-&gt;instanceSize()：计算需要开辟的内存空间大小，也就是创建对象所需的大小，这里会对对象做 16 字节对齐。</li><li>calloc()：通过 instanceSize 计算的内存大小，向内存中申请对应大小的内存，并赋值给 obj，因此 obj 是指向内存地址的指针。</li><li>obj-&gt;initInstanceIsa()：初始化 isa，并将类与 isa 关联。<img src="/images/lix_blog_25.png" style="width:50%;"></li></ul><h2 id="2、init"><a href="#2、init" class="headerlink" title="2、init"></a>2、init</h2><p>init 方法源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootInit(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">id</span></span><br><span class="line">_objc_rootInit(<span class="type">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// In practice, it will be hard to rely on this function.</span></span><br><span class="line">    <span class="comment">// Many classes do not properly chain -init calls.</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 init 的实现仅仅是返回传入的 self 本身，可以理解为就是一个空壳，开发者可以根据需要增加自定义的 init 实现。也就是说，调用了 alloc 方法之后，无需调用 init 方法，就能直接调用实例方法了，因为这个时候对象已经创建好了。但是实际开发中不要这么做，因为对应的类中很有可能有自定义的 init 方法。 </p><h2 id="3、new"><a href="#3、new" class="headerlink" title="3、new"></a>3、new</h2><p>new 方法实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">id</span>)new &#123;</span><br><span class="line">    <span class="keyword">return</span> [callAlloc(<span class="keyword">self</span>, <span class="literal">false</span><span class="comment">/*checkNil*/</span>) init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，new 方法实际上就是等价于 [[XXXObject alloc] init];</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC 对象一探究竟之二：内存中的对象</title>
      <link href="/posts/16257/"/>
      <url>/posts/16257/</url>
      
        <content type="html"><![CDATA[<h2 id="1、NSObject-对象的内存占用"><a href="#1、NSObject-对象的内存占用" class="headerlink" title="1、NSObject 对象的内存占用"></a>1、NSObject 对象的内存占用</h2><p>首先，我们知道，在 32 位系统中，指针占用 4 个字节；在 64 位系统中，指针占用 8 个字节。这里，我们只考虑 64 位情况。</p><p>对于 NSObject 对象， 其实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure><p>一个指针占用 8 个字节，而 Class 又是指向 objc_class 结构体的指针，那么是否意味着 NSObject 对象占用 8 个字节内存空间呢？我们可以验证一下。</p><p>可以使用如下方法获取创建一个实例对象，所分配的内存大小：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line">malloc_size((__bridge <span class="keyword">const</span> <span class="type">void</span> *)obj);</span><br></pre></td></tr></table></figure><p>如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="type">void</span> *)obj));</span><br></pre></td></tr></table></figure><p>打印结果：<br>16</p><p><strong>那么问题来了，为什么不是 8 个字节而是 16 个字节？</strong></p><p>我们可以去 <a href="https://opensource.apple.com/tarballs/objc4/">https://opensource.apple.com/tarballs/objc4/</a> 下载 Apple 提供 OC 的实现源码，直接 Xcode 打开，看下创建实例对象时内存是如何分配的，以下是从源码中拿出的关键部分代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSObject.mm</span></span><br><span class="line">+ (<span class="type">id</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAllocWithZone(<span class="keyword">self</span>, (malloc_zone_t *)zone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">id</span> _objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> obj;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span></span><br><span class="line">    (<span class="type">void</span>)zone;</span><br><span class="line">    obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (!zone) &#123;</span><br><span class="line">        obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        obj = class_createInstanceFromZone(cls, <span class="number">0</span>, zone);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!obj)) obj = callBadAllocHandler(cls);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-runtime-new.m</span></span><br><span class="line"><span class="type">id</span></span><br><span class="line">class_createInstance(Class cls, size_t extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">id</span></span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="type">void</span> *zone,</span><br><span class="line">                              <span class="type">bool</span> cxxConstruct = <span class="literal">true</span>,</span><br><span class="line">                              size_t *outAllocatedSize = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class&#x27;s info bits all at once for performance</span></span><br><span class="line">    <span class="type">bool</span> hasCxxCtor = cls-&gt;hasCxxCtor();</span><br><span class="line">    <span class="type">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    <span class="type">bool</span> fast = cls-&gt;canAllocNonpointer();</span><br><span class="line"></span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    <span class="type">id</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        obj = (<span class="type">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">            obj = (<span class="type">id</span>)malloc_zone_calloc ((malloc_zone_t *)zone, <span class="number">1</span>, size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj = (<span class="type">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be</span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span><br><span class="line">        obj = _objc_constructOrFree(obj, cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 _class_createInstanceFromZone 方法实现可以看出，创建实例对象所分配的内存由以下代码决定：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t size = cls-&gt;instanceSize(extraBytes);</span><br></pre></td></tr></table></figure><p>instanceSize 方法实现源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">    size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_14.png"><br>从 Apple 的代码可以看出，<font color=#ff0000>创建对象时候，如果对象占用内存小于 16 字节，就会分配 16 字节内存</font>（除了这个原因外，内存对齐也会对最终分配的内存有影响，内存对齐后续会介绍）。</p><p>所以，NSObject 对象虽然只占用 8 个字节内存，实际上会分配 16 字节。</p><p>注意，在 runtime 中，还有下面这个获取对象所占用内存的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line">class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>如果用该方法获取 NSObject 对象所占用内存大小时，该方法将会返回 8 而不是 16，以下是从 Apple 提供的源码相关代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-class.m</span></span><br><span class="line">size_t class_getInstanceSize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-runtime-new.m</span></span><br><span class="line"><span class="comment">// Class&#x27;s ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line">uint32_t alignedInstanceSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_15.png"><br>这块 Apple 的注释也已经写的很清楚了，<font color=#ff0000>class_getInstanceSize 获取到的大小, 是内存对齐之后的大小，这实际上是获取对象成员变量所占用的内存大小。</font>所以可以理解为是创建对象至少所需要的内存大小。由于 NSObject 对象中只有一个 isa 成员变量，所以使用该方法获取到的大小为 8，由于小于最低 16 字节，所以会直接分配 16 字节内存，也就意味着有 8 字节目前是空着还没有利用的。</p><p>也可以借助 LLDB 如下命令获取内存分布情况：<br><code>x/数量格式字节数  内存地址</code></p><p><strong>【格式】</strong><br>x是16进制，f是浮点，d是10进制<br><strong>【字节大小】</strong><br>b：byte 1字节，h：half word 2字节<br>w：word 4字节，g：giant word 8字节</p><p>例如：<br><code>x/2xg 内存地址</code></p><p>2xg 代表打印 2 段，每段都是 16 进制格式显示，每段都是 8 个字节。</p><p>通过该命令再看下 NSObject 对象的内存分布：<br><img src="/images/lix_blog_16.png"><br>可以看出，第 2 段 8 个字节是还没有被利用的。</p><h2 id="2、自定义对象的内存占用"><a href="#2、自定义对象的内存占用" class="headerlink" title="2、自定义对象的内存占用"></a>2、自定义对象的内存占用</h2><p>各数据类型占用内存大小：<br><img src="/images/lix_blog_17.png"><br>根据上图可以知道，一个 int 型成员变量占用 4 个字节内存，假设有以下自定义的 Student 类，有两个 int 类型成员变量：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="type">int</span> _no;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>那么这个 Student 对象占用多大内存？<br>同样，可以使用如下命令将其转成 C&#x2F;C++ 代码看其实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  OC源文件  -o  输出的CPP文件</span><br></pre></td></tr></table></figure><p>在生成的 C&#x2F;C++ 代码可以找到 Student 的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student_IMPL &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> <span class="built_in">NSObject_IVARS</span>;</span><br><span class="line">    <span class="type">int</span> _no;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_18.png"><br>前面已经知道 NSObject_IMPL：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是说，Student_IMPL 实际上可以认为是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student_IMPL &#123;</span><br><span class="line">    Class isa; <span class="comment">// 8 字节</span></span><br><span class="line">    <span class="type">int</span> _no; <span class="comment">// 4 字节</span></span><br><span class="line">    <span class="type">int</span> _age; <span class="comment">// 4 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以，可以确定 Student 的实例对象会占用 16 字节内存，可以验证确认一下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line">stu-&gt;_no = <span class="number">101</span>;</span><br><span class="line">stu-&gt;_age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;stu size：%zd&quot;</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="type">void</span> *)stu));</span><br></pre></td></tr></table></figure><p>打印结果：<br><code>stu size：16</code></p><p>而且，在内存中，三个成员 isa、_no、_age 的内存地址也是连续的。stu 的内存地址和第一个成员 isa 的地址是一样的。</p><h2 id="3、内存对齐"><a href="#3、内存对齐" class="headerlink" title="3、内存对齐"></a>3、内存对齐</h2><p>先看一个内存对齐的例子，假设有 StudentOne、StudentTwo 两个结构体，它们的成员完全一样的，只是把 a、b 两个成员换个顺序，然后使用 sizeof 获取结构体所占用内存大小：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> StudentOne &#123;</span><br><span class="line">    <span class="type">char</span> a;         <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="type">double</span> b;       <span class="comment">// 8 字节</span></span><br><span class="line">    <span class="type">int</span> c;          <span class="comment">// 4 字节</span></span><br><span class="line">    <span class="type">short</span> d;        <span class="comment">// 2 字节</span></span><br><span class="line">&#125; StuStruct1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> StudentTwo &#123;</span><br><span class="line">    <span class="type">double</span> b;       <span class="comment">// 8 字节</span></span><br><span class="line">    <span class="type">char</span> a;         <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="type">short</span> d;        <span class="comment">// 2 字节</span></span><br><span class="line">    <span class="type">int</span> c;          <span class="comment">// 4 字节</span></span><br><span class="line">&#125; StuStruct2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;StuStruct1 size：%lu，StuStruct2 size：%lu&quot;</span>, <span class="keyword">sizeof</span>(StuStruct1), <span class="keyword">sizeof</span>(StuStruct2));</span><br></pre></td></tr></table></figure><p>打印结果：<br><code>StuStruct1 size：24，StuStruct2 size：16</code></p><p>结果就是成员一样的两个结构体所占用内存的大小却不一样，这就是内存对齐的结果。</p><p><strong>关于 sizeof</strong><br>sizeof 是操作符，不是函数，它的作用对象是数据类型，主要作用于编译时。因此，它作用于变量时，也是对其类型进行操作。得到的结果是该数据类型占用空间大小，即 size_t 类型。<br>例如，64 位架构下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>) = <span class="number">4</span></span><br><span class="line"><span class="keyword">sizeof</span>([<span class="built_in">NSObject</span> <span class="keyword">class</span>])) = <span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span>([[MyNSObject alloc]init]) = <span class="number">8</span></span><br></pre></td></tr></table></figure><p>sizeof 只会计算类型所占用的内存大小，不会关心具体的对象的内存布局。所以自定义一个 NSObject 对象，无论该对象生命多少个成员变量，最后得到的内存大小都是 8 个字节。</p><p><strong>对齐系数：</strong><br>每个特定的平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。我们可以通过预编译命令 #pragma pack(n)，n&#x3D;1、2、4、8、16 来改变这一系数，其中的 n 就是要指定的“对齐系数”。 Xcode 的默认对齐系数是 8。</p><p>内存对齐的原则</p><ul><li>数据成员对齐规则：（Struct 或者 Union 的数据成员）第一个数据成员放在偏移为 0 的位置。以后每个数据成员的位置为 min(对齐系数，自身长度) 的整数倍，下个位置不为本数据的整数倍位置的自动补齐。</li><li>数据成员为结构体：该数据成员内的最大长度的整数倍的位置开始存储。</li><li>收尾工作：结构体的总大小，也就是 sizeof 的结果，对齐原则是 min(对齐系数，最大成员长度) 的整数倍，不足的要补⻬。</li></ul><p>再回头看下 StudentOne 和 StudentTwo 两个结构体：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> StudentOne &#123;</span><br><span class="line">    <span class="type">char</span> a;              <span class="comment">// 1 byte，位置[0]</span></span><br><span class="line">    <span class="type">char</span> _pad0[<span class="number">7</span>];      <span class="comment">//补齐7字节成为8(随后跟着的 double 大小)的倍数，原则一</span></span><br><span class="line">    <span class="type">double</span> b;               <span class="comment">// 8 bytes，位置[8-15]</span></span><br><span class="line">    <span class="type">int</span> c;                       <span class="comment">// 4 bytes，位置[16-19]</span></span><br><span class="line">    <span class="type">short</span> d;                  <span class="comment">// 2 byte，位置[20-21]，到这里，结构体占用内存大小为 22 字节</span></span><br><span class="line">    <span class="type">char</span> _pad1[<span class="number">2</span>];     <span class="comment">// 补齐 2 字节让结构体的大小成为最大成员大小 double（8字节）的倍数，原则三</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> StudentTwo &#123;</span><br><span class="line">    <span class="type">double</span> b;       <span class="comment">// 8 字节，位置[0-7]</span></span><br><span class="line">    <span class="type">char</span> a;         <span class="comment">// 1 字节，位置[8]</span></span><br><span class="line">    <span class="type">char</span> _pad0[<span class="number">1</span>];  <span class="comment">// 补齐 1 字节成为 2(随后跟着的 short 大小)的倍数，原则一</span></span><br><span class="line">    <span class="type">short</span> d;        <span class="comment">// 2 字节，位置[10-11]</span></span><br><span class="line">    <span class="type">int</span> c;          <span class="comment">// 4 字节，位置[12-15]，到这里，结构体占用内存大小为 16 字节，满足原则三</span></span><br><span class="line">&#125; StuStruct2;</span><br></pre></td></tr></table></figure><p>所以 StudentOne 占用 24 字节内存，StudentTwo 占用 16 字节内存。</p><p>如果在代码执行前加一句 #pragma pack(1) 时就代表不进行内存对齐，上述结构体打印大小的结果就都为 16。</p><p><strong>需要内存对齐原因</strong><br>经过内存对齐之后可以发现，size反而变大了。那为什么还要进行内存对齐呢？因为 CPU 存取内存并不是以 byte 为单位的，而是以块为单位，每块可以为 2&#x2F;4&#x2F;8&#x2F;16 字节，每次内存存取都会产生一个固定的开销，减少内存存取次数将提升程序的性能。所以 CPU 一般会以 2&#x2F;4&#x2F;8&#x2F;16&#x2F;32 字节为单位来进行存取操作。我们将上述这些存取单位也就是块大小称为（memory access granularity）内存存取粒度。如果没有内存对齐，会大大增加CPU 在存取过程中的消耗。</p><p>为了说明内存对齐背后的原理，我们通过一个例子来说明从未地址与对齐地址读取数据的差异。这个例子很简单：在一个存取粒度为 4 字节的内存中，先从地址 0 读取 4 个字节到寄存器，然后从地址 1 读取 4 个字节到寄存器。</p><p>当从地址 0 开始读取数据时，是读取对齐地址的数据，直接通过一次读取就能完成。当从地址 1 读取数据时读取的是非对齐地址的数据。需要读取两次数据才能完成。<br><img src="/images/lix_blog_19.png"><br>而且在读取完两次数据后，还要将 0-3 的数据向上偏移 1 字节，将 4-7 的数据向下偏移 3 字节。最后再将两块数据合并放入寄存器。<br><img src="/images/lix_blog_20.png"><br>对一个内存未对齐的数据进行了这么多额外的操作，这对 CPU 的开销很大，大大降低了CPU 性能。</p><h2 id="4、calloc-分析"><a href="#4、calloc-分析" class="headerlink" title="4、calloc 分析"></a>4、calloc 分析</h2><p>先看一个例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">    <span class="type">int</span> _height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Student *stu = [[Student alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;\nclass_getInstanceSize=%zd\nmalloc_size=%zd&quot;</span>,</span><br><span class="line">        class_getInstanceSize([Student <span class="keyword">class</span>]), <span class="comment">// 24</span></span><br><span class="line">        malloc_size((__bridge <span class="keyword">const</span> <span class="type">void</span> *)(stu))); <span class="comment">// 32</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class_getInstanceSize=<span class="number">16</span></span><br><span class="line">malloc_size=<span class="number">16</span></span><br></pre></td></tr></table></figure><p>从以上结果可以看出，Student 有 2 个自定义的成员变量，内存对齐后所需大小为 16 字节，实际分配了 16 字节，满足预期结果。</p><p>那么再给 Student 增加一个成员变量，打印结果将会是多少呢：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">    <span class="type">int</span> _height;</span><br><span class="line">    <span class="type">int</span> _no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>先从内存对齐的角度计算下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student_IMPL &#123;</span><br><span class="line">    Class isa; <span class="comment">// 8 字节，位置[0-7]</span></span><br><span class="line">    <span class="type">int</span> _age; <span class="comment">// 4 字节，位置[8-11]</span></span><br><span class="line">    <span class="type">int</span> _height; <span class="comment">// 4 字节，位置[12-15]</span></span><br><span class="line">    <span class="type">int</span> _no; <span class="comment">// 4 字节，位置[16-19]，目前占用 20 字节，不满足最大成员（isa 8 字节）的倍数，应补齐4字节变成 24 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从结果可以猜测打印结果可能是下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class_getInstanceSize=24</span><br><span class="line">malloc_size=24</span><br></pre></td></tr></table></figure><p>运行代码看下结果是否符合预期，运行代码打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class_getInstanceSize=24</span><br><span class="line">malloc_size=32</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_21.png"><br>结果是出乎意料的，class_getInstanceSize 结果符合预期，内存对齐后占用空间是 24 字节，但是从 malloc_size 结果可以看出系统实际上分配了 32 字节大小，问题出在哪里呢？</p><p>下面是前面提到的创建实例对象时内存分配相关源码中的部分逻辑：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span></span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="type">void</span> *zone,</span><br><span class="line">                              <span class="type">bool</span> cxxConstruct = <span class="literal">true</span>,</span><br><span class="line">                              size_t *outAllocatedSize = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    <span class="type">id</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这行是重点</span></span><br><span class="line">            obj = (<span class="type">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">    size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，创建实例对象的时候，我们传给 calloc 的是内存对齐后的大小 24，但是 calloc 中实际分配了 32，可以验证一下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *p = calloc(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%lu&quot;</span>,malloc_size(p));</span><br></pre></td></tr></table></figure><p>打印结果：<br><code>32</code><br><img src="/images/lix_blog_22.png"><br>接下来就要从源码角度分析 calloc 的实现了，下面为 calloc 的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">calloc(size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *retval;</span><br><span class="line">    retval = malloc_zone_calloc(default_zone, num_items, size);</span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 calloc 里主要调用了 malloc_zone_calloc：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    MALLOC_TRACE(TRACE_calloc | DBG_FUNC_START, (uintptr_t)zone, num_items, size, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="keyword">if</span> (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;= malloc_check_start)) &#123;</span><br><span class="line">        internal_check();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = zone-&gt;calloc(zone, num_items, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (malloc_logger) &#123;</span><br><span class="line">        malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE | MALLOC_LOG_TYPE_CLEARED, (uintptr_t)zone,</span><br><span class="line">                (uintptr_t)(num_items * size), <span class="number">0</span>, (uintptr_t)ptr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MALLOC_TRACE(TRACE_calloc | DBG_FUNC_END, (uintptr_t)zone, num_items, size, (uintptr_t)ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中关键代码是 ptr &#x3D; zone-&gt;calloc(zone, num_items, size); 到这里打断点调试看下：</p><p>根据 LLDB 打印结果可以确定调用的是 default_zone_calloc：<br><img src="/images/lix_blog_23.png"><br>接下来再看下 default_zone_calloc 的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> *</span><br><span class="line">default_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    zone = runtime_default_zone();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> zone-&gt;calloc(zone, num_items, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再断点调试一下，可以确定调用的 naco_calloc。<br><img src="/images/lix_blog_24.png"><br>naco_calloc 实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> *</span><br><span class="line">nano_calloc(nanozone_t *nanozone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    size_t total_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (calloc_get_size(num_items, size, <span class="number">0</span>, &amp;total_bytes)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (total_bytes &lt;= NANO_MAX_SIZE) &#123; <span class="comment">// NANO_MAX_SIZE  256 </span></span><br><span class="line">        <span class="type">void</span> *p = _nano_malloc_check_clear(nanozone, total_bytes, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* FALLTHROUGH to helper zone */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    malloc_zone_t *zone = (malloc_zone_t *)(nanozone-&gt;helper_zone);</span><br><span class="line">    <span class="keyword">return</span> zone-&gt;calloc(zone, <span class="number">1</span>, total_bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ANO_MAX_SIZE 为 256，此时 total_bytes 肯定小于 256，继续执行走到<code>void *p = _nano_malloc_check_clear(nanozone, total_bytes, 1);</code></p><p>再来看下 _nano_malloc_check_clear 的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> *</span><br><span class="line">_nano_malloc_check_clear(nanozone_t *nanozone, size_t size, boolean_t cleared_requested)</span><br><span class="line">&#123;</span><br><span class="line">    MALLOC_TRACE(TRACE_nano_malloc, (uintptr_t)nanozone, size, cleared_requested, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    size_t slot_key;</span><br><span class="line">    size_t slot_bytes = segregated_size_to_fit(nanozone, size, &amp;slot_key); <span class="comment">// Note slot_key is set here</span></span><br><span class="line">    mag_index_t mag_index = nano_mag_index(nanozone);</span><br><span class="line"></span><br><span class="line">    nano_meta_admin_t pMeta = &amp;(nanozone-&gt;meta_data[mag_index][slot_key]);</span><br><span class="line"></span><br><span class="line">    ptr = OSAtomicDequeue(&amp;(pMeta-&gt;slot_LIFO), offsetof(<span class="keyword">struct</span> chained_block_s, next));</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            <span class="comment">/**略**/</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ptr = segregated_next_block(nanozone, pMeta, slot_bytes, mag_index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cleared_requested &amp;&amp; ptr) &#123;</span><br><span class="line">        memset(ptr, <span class="number">0</span>, slot_bytes); <span class="comment">// <span class="doctag">TODO:</span> Needs a memory barrier after memset to ensure zeroes land first?</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟着断点继续往下走，执行到 <code>segregated_size_to_fit(nanozone, size, &amp;slot_key)</code>，segregated_size_to_fit 对应实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NANO_MAX_SIZE           256 <span class="comment">/* Buckets sized &#123;16, 32, 48, ..., 256&#125; */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHIFT_NANO_QUANTUM      4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NANO_REGIME_QUANTA_SIZE (1 &lt;&lt; SHIFT_NANO_QUANTUM)   <span class="comment">// 16</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> MALLOC_INLINE size_t</span><br><span class="line">segregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)</span><br><span class="line">&#123;</span><br><span class="line">    size_t k, slot_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == size) &#123;</span><br><span class="line">        size = NANO_REGIME_QUANTA_SIZE; <span class="comment">// Historical behavior</span></span><br><span class="line">    &#125;</span><br><span class="line">    k = (size + NANO_REGIME_QUANTA_SIZE - <span class="number">1</span>) &gt;&gt; SHIFT_NANO_QUANTUM; <span class="comment">// round up and shift for number of quanta</span></span><br><span class="line">    slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM;                           <span class="comment">// multiply by power of two quanta size</span></span><br><span class="line">    *pKey = k - <span class="number">1</span>;                                                  <span class="comment">// Zero-based!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slot_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面关键部分：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = (size + NANO_REGIME_QUANTA_SIZE - <span class="number">1</span>) &gt;&gt; SHIFT_NANO_QUANTUM;</span><br><span class="line">slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM;</span><br></pre></td></tr></table></figure><p>也就是：<br><code>(size + 16 - 1) &gt;&gt; 4 &lt;&lt; 4</code></p><p>我们可以知道，这实际上就是对 size 进行了 16 字节对齐。</p><p>而我们前面的 size 为 24，经过 16 字节对齐后正好是 32。</p><p>根据结果，可以总结出结论：<br><font color=#ff0000>在进行内存对齐时，对象的成员变量（结构体成员）是 8 字节对齐，对象本身是 16 字节对齐。</font></p><p>例如前面例子中 Student 对象的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student_IMPL &#123;</span><br><span class="line">    Class isa; <span class="comment">// 8 字节，位置[0-7]</span></span><br><span class="line">    <span class="type">int</span> _age; <span class="comment">// 4 字节，位置[8-11]</span></span><br><span class="line">    <span class="type">int</span> _height; <span class="comment">// 4 字节，位置[12-15]</span></span><br><span class="line">    <span class="type">int</span> _no; <span class="comment">// 4 字节，位置[16-19]，目前占用 20 字节，不满足最大成员（isa 8 字节）的倍数，应补齐4字节变成 24 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Student_IMPL 结构体内存对齐前是 20 字节，内存对齐后是 24 字节，在创建 Student 实例对象的时候，虽然它只占用了 24 字节，但是 calloc 里在分配内存的时候会再次对实例对象进行 16 字节对齐，最终分配了 32 字节内存。</p><p><strong>这里为什么要针对对象再进行 16 字节对齐呢？</strong><br>是因为 OC 的对象中，其对应结构体一定会存在一个 8 字节的 isa 成员。如果对象也以 8 字节对齐，这时候如果存在两个甚至多个无成员变量的对象(只有 1 个 isa)在内存当中连续存放的话，对象之间 isa 都是紧邻的，如果内存访问出现了一点错误或者偏移，就会访问到其他对象，就会出现一些野指针、内存访问错误等问题，发生混乱。所以为了使得对象之间的访问更加的安全，就需要给对象之前预留一部分的空间，根据 CUP 按照每块 2&#x2F;4&#x2F;8&#x2F;16 字节大小进行读取数据，所以预留 8 字节按照 16 字节进行对齐可以使对象访问更加安全。也提高了寻址访问效率，也就是空间换时间。</p><p><strong>【备注】</strong><br><strong>class_getInstanceSize、malloc_size、sizeof 的区别：</strong></p><ul><li><p>class_getInstanceSize：<br>是一个函数（调用时需要开辟额外的内存空间），程序运行时才获取，计算的是创建对象至少需要的内存大小，是对象内部成员按照 8 字节进行对齐后的结果，位于 #import &lt;objc&#x2F;runtime.h&gt;</p></li><li><p>malloc_size：<br>堆空间实际分配给对象的内存大小，也就是对象 16 字节对齐后的大小，位于 #import &lt;malloc&#x2F;malloc.h&gt;</p></li><li><p>sizeof：<br>是一个运算符，获取的是类型的大小（int、size_t、结构体、指针变量等），这些数值在程序编译时就转成常数，程序运行时是直接获取的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC 对象一探究竟之一：对象的底层实现</title>
      <link href="/posts/60413/"/>
      <url>/posts/60413/</url>
      
        <content type="html"><![CDATA[<h2 id="一、NSObject-对象"><a href="#一、NSObject-对象" class="headerlink" title="一、NSObject 对象"></a>一、NSObject 对象</h2><h3 id="1、NSObject-的底层实现"><a href="#1、NSObject-的底层实现" class="headerlink" title="1、NSObject 的底层实现"></a>1、NSObject 的底层实现</h3><p>我们在 iOS 开发过程中，所编写的 Objective-C 代码，其底层实现都是使用的 C\C++ 代码，所以 Objective-C 的面向对象都是基于 C\C++ 的数据结构实现的。</p><p>例如，对于以下代码（main.m）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进到 NSObject.h 可以看到 NSObject 的结构如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用以下命令将 Objective-C 代码（main.m）转换为 C\C++ 代码（main.cpp）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure><p>(等价于：<code>clang -rewrite-objc main.m -o main.cpp</code>)</p><p>但是有些 OC 代码要转成 C&#x2F;C++ 代码时，在真机、模拟器、不同架构之间可能会存在较大差异。所以可以结合 xcrun 命令指定真机以及架构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m  -o main.cpp</span><br></pre></td></tr></table></figure><p>在使用 clang 转换 OC 为 C++ 代码时，可能会遇到以下问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot create __weak reference in file using manual reference</span><br></pre></td></tr></table></figure><p>解决方案：指定支持 ARC、运行时系统版本，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m  -o  main.cpp</span><br></pre></td></tr></table></figure><p>转换成 cpp 文件之后，我们可以找到 NSObject 的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_0.png"><br>由此，我们可以确定，<font color=#ff0000>NSObject 对象，实际上就是 C&#x2F;C++ 的结构体。</font></p><p>在上面 NSObject_IMPL 结构体中，有一个 Class 类型的成员 isa，那么 Class 又是什么呢？我们可以在我们生成的 main.cpp 中看到：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_1.png"><br>所以，<font color=#ff0000>Class 是指向 objc_class 结构体的指针。</font></p><h3 id="2、对象的分类"><a href="#2、对象的分类" class="headerlink" title="2、对象的分类"></a>2、对象的分类</h3><p>对象主要有以下类型：instance 对象、class 对象、meta-class 对象</p><h4 id="1-instance-对象"><a href="#1-instance-对象" class="headerlink" title="(1) instance 对象"></a>(1) instance 对象</h4><p>instance 对象即实例对象，也是开发者接触最多的一个对象。<font color=#ff0000>实例对象中不存储方法，只存储成员变量。</font>instance 在内存中存储了如下信息：</p><ul><li>isa 指针</li><li>其他成员变量</li></ul><p>isa 指针在 instance 对象中所有成员变量的第一位，是第一个成员变量。所以，isa 指针在内存中的地址就是当前 instance 对象的地址。</p><p>instance 对象中没有存储方法，方法实际上存储在 class 对象和 meta-class 对象中的。class 对象中存储了实例方法，meta-class 对象中存储了类方法。</p><p>为什么 instance 对象中不存储方法？原因很简单，一个类可能会被创建无数个实例对象，每个实例对象中都存储一份相同的方法信息，是对内存的一种浪费。而对于成员变量来说，每个实例对象的成员变量可能被赋不同值，所以是必须每个实例对象要存储自己的成员变量信息。</p><h4 id="2-class-对象"><a href="#2-class-对象" class="headerlink" title="(2) class 对象"></a>(2) class 对象</h4><p>class 对象即类对象，每个类在内存中有且只有一个 class 对象，创建类对象的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class classObject1 = [instanceObject <span class="keyword">class</span>];</span><br><span class="line">Class classObject2 = object_getClass(instanceObject);</span><br><span class="line">Class classObject3 = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br></pre></td></tr></table></figure><p>对于同一个 Class 类型，创建出来的所有 class 对象实际上都是同一个，可以验证一下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *instanceObject1 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">NSObject</span> *instanceObject2 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"></span><br><span class="line">Class classObject1 = [instanceObject1 <span class="keyword">class</span>];</span><br><span class="line">Class classObject2 = [instanceObject2 <span class="keyword">class</span>];</span><br><span class="line">Class classObject3 = object_getClass(instanceObject1); <span class="comment">// 接收的参数是实例对象</span></span><br><span class="line">Class classObject4 = object_getClass(instanceObject2);<span class="comment">// 接收的参数是实例对象</span></span><br><span class="line">Class classObject5 = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;instanceObject1=%p\ninstanceObject2=%p&quot;</span>,</span><br><span class="line">      instanceObject1,</span><br><span class="line">      instanceObject2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;classObject1=%p\nclassObject2=%p\nclassObject3=%p\nclassObject4=%p\nclassObject5=%p&quot;</span>,</span><br><span class="line">      classObject1,</span><br><span class="line">      classObject2,</span><br><span class="line">      classObject3,</span><br><span class="line">      classObject4,</span><br><span class="line">      classObject5);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">instanceObject1=<span class="number">0x100507f30</span></span><br><span class="line">instanceObject2=<span class="number">0x100507f40</span></span><br><span class="line">classObject1=<span class="number">0x7fff915dc118</span></span><br><span class="line">classObject2=<span class="number">0x7fff915dc118</span></span><br><span class="line">classObject3=<span class="number">0x7fff915dc118</span></span><br><span class="line">classObject4=<span class="number">0x7fff915dc118</span></span><br><span class="line">classObject5=<span class="number">0x7fff915dc118</span></span><br></pre></td></tr></table></figure><p>可以发现，<font color=#ff0000>创建的多个 class 对象，内存地址都是一样的。</font></p><p>class 对象在内存中主要存储了如下信息：</p><ul><li><font color=#ff0000>isa 指针</font></li><li><font color=#ff0000>superclass 指针</font></li><li>类的属性信息（@property）、类的<font color=#ff0000>对象方法</font>信息（instance method）</li><li>类的协议信息（protocol）、类的成员变量信息（ivar）</li><li>……</li></ul><p>此处的类的成员变量信息指的是：成员变量的描述信息(类型、变量名等)</p><p>这里需要注意的是，其中存储的方法信息为对象方法信息，而不是类方法信息。对象的方法并没有直接存储于对象的结构体中，是因为如果每一个对象都保存了自己能执行的方法，那么对内存的占用有极大的影响。</p><h4 id="3-meta-class-对象"><a href="#3-meta-class-对象" class="headerlink" title="(3) meta-class 对象"></a>(3) meta-class 对象</h4><p>meta-class 对象即元类对象，每个类在内存中有且只有一个 meta-class 对象，创建 meta-class 对象方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class metaClassObject = object_getClass(classObject); <span class="comment">// 接收的参数是类对象</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class metaClassObject = object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>meta-class 对象和 class 对象的内存结构是一样的，只不过跟 class 对象相比有些字段是空的，例如属性信息、对象方法信息等这些相应字段 value 是空的。<br>meta-class 对象在内存中存储的信息主要包括：</p><ul><li><font color=#ff0000>isa 指针</font></li><li><font color=#ff0000>superclass 指针</font></li><li>类的<font color=#ff0000>类方法</font>信息（class method）</li><li>……</li></ul><p>类方法就存储在 meta-class 对象中。</p><h2 id="二、isa-指针和-superclass-指针"><a href="#二、isa-指针和-superclass-指针" class="headerlink" title="二、isa 指针和 superclass 指针"></a>二、isa 指针和 superclass 指针</h2><h3 id="1、isa-指针"><a href="#1、isa-指针" class="headerlink" title="1、isa 指针"></a>1、isa 指针</h3><p>根据前面内容可以知道，当我们创建了一个 instance 对象时，instance 对象中存储了成员变量，对象方法存储在对应的 class 对象中，类方法存储在对应的 meta-class 对象中。当我们调用这个 instance 对象的对象方法或者类方法时，肯定就需要某种机制，将这些相应的对象关联起来，以保证可以正常调用到对应方法，这就是 isa 指针的作用。<br><img src="/images/lix_blog_2.png"></p><ul><li><p><font color=#ff0000>instance 的 isa 指向 class</font><br>当调用对象方法时，通过 instance 的 isa 找到 class，最后找到对象方法的实现进行调用。</p></li><li><p><font color=#ff0000>class 的 isa 指向 meta-class</font><br>当调用类方法时，通过 class 的 isa 找到 meta-class，最后找到类方法的实现进行调用。</p></li></ul><h3 id="2、superclass-指针"><a href="#2、superclass-指针" class="headerlink" title="2、superclass 指针"></a>2、superclass 指针</h3><h4 id="1-class-对象的-superclass-指针"><a href="#1-class-对象的-superclass-指针" class="headerlink" title="(1) class 对象的 superclass 指针"></a>(1) class 对象的 superclass 指针</h4><p>对于 superclass 指针，假设有下面两个类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person 继承自 NSObject</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 继承自 Person</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这时候会存在 3 个主要的 class 对象：Student、Person、NSObject，假设这时候，Student 的 instance 对象想要调用 Person 的某个对象方法时，对象是如何找到 Person 以及对应的对象方法呢？根据 superclass 名字也很容易猜到，superclass 指针指向自己父类的 class 对象：<br><img src="/images/lix_blog_3.png"></p><ul><li><font color=#ff0000>instance 对象中没有 superclass 指针。</font></li><li><font color=#ff0000>class 对象的 superclass 指针指向父类的 class 对象。</font></li><li><font color=#ff0000>当 Student 的 instance 对象要调用 Person 的对象方法时，会先通过 isa 找到 Student 的 class，然后通过 superclass 找到 Person 的 class，最后找到对象方法的实现进行调用。</font></li></ul><h4 id="2-meta-class-对象的-superclass-指针"><a href="#2-meta-class-对象的-superclass-指针" class="headerlink" title="(2) meta-class 对象的 superclass 指针"></a>(2) meta-class 对象的 superclass 指针</h4><p>还以上面 Student 、Person 为例，如果 Student 的 class 要调用 Person 的类方法时，那如何找到对应方法呢？<br><img src="/images/lix_blog_4.png"><br>meta-class 对象的 superclass 指针指向父类的 meta-class 对象，当 Student 的 class 要调用 Person 的类方法时，会先通过 isa 找到 Student 的 meta-class，然后通过 superclass 找到 Person 的 meta-class，最后找到类方法的实现进行调用。</p><h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p><img src="/images/lix_blog_5.png"><br>上面是一个非常经典的图，从上图可知：</p><ul><li>在实现中，Root Class 就是 NSObject</li><li>NSObject 的 meta-class 父类是 NSObject 类</li><li>instance 的 isa 指向 class</li><li>class 的 isa 指向 meta-class</li><li>meta-class 的 isa 指向基类的 meta-class</li><li>基类的 meta-class 的 isa 指向它自己</li><li>class 的 superclass 指向父类的 class，如果没有父类，superclass 指针为 nil</li><li>meta-class 的 superclass 指向父类的 meta-class</li><li>基类的 meta-class 的 superclass 指向基类的 class</li><li>instance 调用对象方法的路径：isa 找到 class，方法不存在，就通过 superclass 找父类</li><li>class 调用类方法的路径：isa 找 meta-class，方法不存在，就通过 superclass 找父类</li></ul><h2 id="三、isa-的结构及实现"><a href="#三、isa-的结构及实现" class="headerlink" title="三、isa 的结构及实现"></a>三、isa 的结构及实现</h2><h3 id="1、isa-的结构"><a href="#1、isa-的结构" class="headerlink" title="1、isa 的结构"></a>1、isa 的结构</h3><p>在 Objc 2.0 之前，objc_class 源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>2006 年发布 Objc 2.0 之后，objc_class 的定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="type">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Object</span> </span>&#123; </span><br><span class="line">    Class isa; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>objc_class 继承于 objc_object。所以在 objc_class 中也会包含 isa_t 类型的结构体 isa。至此，可以得出结论：Objective-C 中类也是一个对象。在 objc_class 中，除了 isa 之外，还有 3 个成员变量，分别是：</p><ul><li>super_class<br>指向当前类的父类</li><li>cache<br>用于缓存指针和 vtable，加速方法的调用</li><li>bits<br>就是存储类的方法、属性和遵循的协议等信息的地方</li></ul><p>对 objc_class 进行简化，其结构体实际上就是下面样子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    isa_t isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前面提到 NSObject 中也有个 isa，NSObject 中 isa 与 objc_class 中 isa 关系如下图：<br><img src="/images/lix_blog_6.png"><br>objc_class 中的 isa 是 isa_t 类型的，isa_t 是一个联合体（union）</p><p><strong>联合体</strong><br>联合体与结构体非常类似，主要区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而联合体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p><p><strong>位域</strong><br>位域定义与结构定义相仿，其形式为：<br>struct 位域结构名<br>{ 位域列表 };</p><p>其中位域列表的形式为：<br>类型说明符 位域名：位域长度</p><p>例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> bits</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a:<span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> b:<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c:<span class="number">6</span>;</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure><p>说明 data 为 bits 结构体变量，共占两个字节（1 个字节存储 8 位无符号数）。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。</p><p>isa_t 的定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        ISA_BITFIELD; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line"><span class="meta">      uintptr_t nonpointer        : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t has_assoc         : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t has_cxx_dtor      : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t shiftcls          : 33; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span></span><br><span class="line"><span class="meta">      uintptr_t magic             : 6;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t weakly_referenced : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t deallocating      : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t has_sidetable_rc  : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t extra_rc          : 19</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_BITFIELD                                                        \</span></span><br><span class="line"><span class="meta">      uintptr_t nonpointer        : 1;                                         \</span></span><br><span class="line"><span class="meta">      uintptr_t has_assoc         : 1;                                         \</span></span><br><span class="line"><span class="meta">      uintptr_t has_cxx_dtor      : 1;                                         \</span></span><br><span class="line"><span class="meta">      uintptr_t shiftcls          : 44; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \</span></span><br><span class="line"><span class="meta">      uintptr_t magic             : 6;                                         \</span></span><br><span class="line"><span class="meta">      uintptr_t weakly_referenced : 1;                                         \</span></span><br><span class="line"><span class="meta">      uintptr_t deallocating      : 1;                                         \</span></span><br><span class="line"><span class="meta">      uintptr_t has_sidetable_rc  : 1;                                         \</span></span><br><span class="line"><span class="meta">      uintptr_t extra_rc          : 8</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> RC_ONE   (1ULL&lt;&lt;56)</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> RC_HALF  (1ULL&lt;&lt;7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">error</span> unknown architecture for packed isa</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>也就是说，在 64 位环境下，isa_t 就是下面这个样子（后续都将以 64 位为例）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC_ONE   (1ULL&lt;&lt;56)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC_HALF  (1ULL&lt;&lt;7)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      uintptr_t nonpointer        : <span class="number">1</span>;</span><br><span class="line">      uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">      uintptr_t has_cxx_dtor      : <span class="number">1</span>;  </span><br><span class="line">      uintptr_t shiftcls          : <span class="number">33</span>;</span><br><span class="line">      uintptr_t magic             : <span class="number">6</span>;   </span><br><span class="line">      uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">      uintptr_t deallocating      : <span class="number">1</span>; </span><br><span class="line">      uintptr_t has_sidetable_rc  : <span class="number">1</span>; </span><br><span class="line">      uintptr_t extra_rc          : <span class="number">19</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以，也可以理解为 isa_t 的结构是联合体+位域。<br>isa_t 内存结构如下图：<br><img src="/images/lix_blog_7.png"><br>各参数解释如下：<br><img src="/images/lix_blog_9.png"></p><h3 id="2、isa-t-的实现"><a href="#2、isa-t-的实现" class="headerlink" title="2、isa_t 的实现"></a>2、isa_t 的实现</h3><p>以下是 objc_object 结构体的部分内容：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// initIsa() should be used to init the isa of new objects only.</span></span><br><span class="line">    <span class="comment">// If this object already has an isa, use changeIsa() for correctness.</span></span><br><span class="line">    <span class="comment">// initInstanceIsa(): objects with no custom RR/AWZ</span></span><br><span class="line">    <span class="comment">// initClassIsa(): class objects</span></span><br><span class="line">    <span class="comment">// initProtocolIsa(): protocol objects</span></span><br><span class="line">    <span class="comment">// initIsa(): other objects</span></span><br><span class="line">    <span class="type">void</span> initIsa(Class cls <span class="comment">/*nonpointer=false*/</span>);</span><br><span class="line">    <span class="type">void</span> initClassIsa(Class cls <span class="comment">/*nonpointer=maybe*/</span>);</span><br><span class="line">    <span class="type">void</span> initProtocolIsa(Class cls <span class="comment">/*nonpointer=maybe*/</span>);</span><br><span class="line">    <span class="type">void</span> initInstanceIsa(Class cls, <span class="type">bool</span> hasCxxDtor);</span><br><span class="line">private:</span><br><span class="line">    <span class="type">void</span> initIsa(Class newCls, <span class="type">bool</span> nonpointer, <span class="type">bool</span> hasCxxDtor);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>当系统通过 alloc 为一个对象分配内存时，会同时初始化 isa。对于对象来说，isa 的基础作用就是将对象和类进行绑定，告诉系统对象的归属。</p><p>初始化 isa 主要是调用下面这两个方法（已精简处理）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line">objc_object::initInstanceIsa(Class cls, <span class="type">bool</span> hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    initIsa(cls, <span class="literal">true</span>, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line">objc_object::initIsa(Class cls, <span class="type">bool</span> nonpointer, <span class="type">bool</span> hasCxxDtor) </span><br><span class="line">&#123;     </span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    <span class="keyword">if</span> (!nonpointer) &#123;</span><br><span class="line">        isa = isa_t((uintptr_t)cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isa_t newisa(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        isa = newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，initIsa 中间首先有个断言，如果对象是 Tagged Pointer 就不继续执行了，这里涉及到了 Tagged Pointer，那什么是 Tagged Pointer 呢？</p><p>以 NSNumber 对象为例，一个 NSNumber 对象，值是一个整数。正常情况下，如果这个整数只是一个 NSInteger 的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下是占 8 个字节的。一个指针所占用的内存在 32 位 CPU 下为 4 个字节，在 64 位 CPU 下也是 8 个字节。</p><p>如果没有 Tagged Pointer 对象，32 位和 64 位下这个 NSNumber 内存占用情况如下：<br><img src="/images/lix_blog_10.png" style="width:60%;"></p><p>可以看出，如果没有 Tagged Pointer 对象，64 位设备相较于 32 位设备，NSNumber、NSDate 这样的对象所占用的内存会翻倍。不仅仅是内存上的浪费，作为一个对象，我们还需要在堆上为其分配内存、维护它的引用计数、管理它的生命期。这些都给程序增加了额外的逻辑，造成运行效率上的损失。</p><p>在 2013 年 9 月，苹果推出了 iPhone5s，与此同时，iPhone5s 配备了首个采用 64 位架构的 A7 双核处理器，为了节省内存和提高执行效率，苹果提出了 Tagged Pointer 的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。</p><p>由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节，拿整数来说，4 个字节所能表示的有符号整数就可以达到 20 多亿（注：2^31&#x3D;2147483648，另外 1 位作为符号位)，对于绝大多数情况都是可以处理的。</p><p>所以可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。所以，引入了 Tagged Pointer 对象之后，64 位 CPU 下 NSNumber 的内存占用变成了下面这样：<br><img src="/images/lix_blog_11.png" style="width:60%;"></p><p>所以，<font color=#ff0000>Tagged Pointer 指针的值不再是地址了，而是真正的值。</font>所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，<font color=#ff0000>它的内存并不存储在堆中，也不需要 malloc 和 free。</font></p><p>接下来看一个 Tagged Pointer 例子，下面代码，执行结果是什么？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abcdefghijk&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面代码发现会必现 crash，因为这里 self.name 是正常 NSString 对象，其本质在 setter 方法中必然会对旧值有 release 操作，由于是在子线程赋值，很大概率出现同时 release，这就导致 crash 发生。</p><p>而下面代码执行却不会出现 crash：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abc&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在上面代码中，给 self.name 赋的值是一个 Tagged Pointer，不需要 release，所以不会出现前面同时 release 引发的 crash。</p><p>以上就是关于 Tagged Pointer 相关内容，接下来回到对  initIsa 方法的分析，再看下 initIsa 函数的源码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line">objc_object::initIsa(Class cls, <span class="type">bool</span> nonpointer, <span class="type">bool</span> hasCxxDtor) </span><br><span class="line">&#123;     </span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    <span class="keyword">if</span> (!nonpointer) &#123;</span><br><span class="line">        isa = isa_t((uintptr_t)cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isa_t newisa(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        isa = newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在判断了非 Tagged Pointer 之后，又判断了 nonpointer 是否为 true，前面提到 nonpointer 含义是是否开启了 isa指针 优化，1 代表优化过，0 代表未优化。</p><p>根据源码也可以看到，<font color=#ff0000>在早期，也就是未进行 isa 指针优化前，isa 直接指向了 class 的地址。优化后，isa 内部存储了更加多的信息，并且不再直接指向 class 地址（isa 地址与 ISA_MASK 进行位运算后，才是 class 地址）。</font></p><p>在 initInstanceIsa 方法中，调用 initIsa 方法的时候 nonpointer&#x3D; true，所以我们可以将方法简化为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> objc_object::initIsa(Class cls, <span class="type">bool</span> nonpointer, <span class="type">bool</span> hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    isa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">    isa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">    isa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ISA_MAGIC_VALUE &#x3D; 0x000001a000000001ULL 对应二进制是11010000000000000000000000000000000000001，当对 bits 赋值之后，isa_t 的变化如下图：<br><img src="/images/lix_blog_12.png"><br>从上图可知，这一步对 nonpointer 和 magic 进行了赋值。可以看到 nonpointer 被赋值为 1。</p><p>在设置 nonpointer 和 magic 值之后，会设置 isa 的 has_cxx_dtor，这一位表示当前对象有 C++ 或者 ObjC 的析构器(destructor)，如果没有析构器就会快速释放内存。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.has_cxx_dtor = hasCxxDtor;</span><br></pre></td></tr></table></figure><p>最后就要将当前对象对应的类指针存入 isa 结构体中了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>由于类的指针要按照字节（8 bits）对齐内存（关于字节对齐下篇文章会专门分析），其指针后三位肯定都是没有意义的 0。将当前地址右移三位的就是为了将 Class 指针中无用的后三位清除，以减小内存的浪费，为 isa 留下更多空间用于性能的优化。</p><p>对于 isa 和对应的 Class 对象之间关系，我们都知道可以使用 object_getClass(obj) 获取 Class 对象，object_getClass(obj) 源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class object_getClass(<span class="type">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Class </span><br><span class="line">objc_object::getIsa() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ISA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Class </span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (Class)(isa.bits &amp; ISA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上源码可知，isa 地址，经过与 ISA_MASK 进行位运算，就是对应 class 或 meta-class 地址。</p><p>实际上，从 64bit 开始，isa 不再直接指向 class 或 meta-class 地址，而是需要 isa 地址与 ISA_MASK 进行一次位运算后，才是 class 或 meta-class 的地址。</p><h3 id="3、拾遗：objc-class-中的-cache、bits"><a href="#3、拾遗：objc-class-中的-cache、bits" class="headerlink" title="3、拾遗：objc_class 中的 cache、bits"></a>3、拾遗：objc_class 中的 cache、bits</h3><p>再回头看 objc_class 的结构：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    isa_t isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 bits 就是存储类的方法、属性和遵循的协议等信息的地方，在 objc_class 结构体中的注释写到 class_data_bits_t 相当于 class_rw_t 指针加上 rr&#x2F;alloc 的标志。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br></pre></td></tr></table></figure><p>它为我们提供了便捷方法用于返回其中的 class_rw_t * 指针：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class_rw_t* data() &#123;</span><br><span class="line">   <span class="keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 bits 与 FAST_DATA_MASK 进行位运算，转换成 class_rw_t * 返回。ObjC 类中的属性、方法还有遵循的协议等信息都保存在 class_rw_t 中：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中还有一个指向常量的指针 ro，其中存储了当前类在编译期就已经确定的属性、方法以及遵循的协议：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">    uint32_t reserved;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用下图表示其关系：<br><img src="/images/lix_blog_13.png"><br>对于 objc_class 结构体中的 cache，作用主要是为了优化方法调用的性能。当对象 receiver 调用方法 message 时，首先根据对象 receiver 的 isa 指针查找到它对应的类，然后在类的 methods 中搜索方法，如果没有找到，就使用 super_class 指针到父类中的 methods 查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有 20% 的方法经常被调用，占总调用次数的 80%。所以使用 Cache 来缓存经常调用的方法，当调用方法时，优先在 Cache 查找，如果没有找到，再到 methods 查找。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
            <tag> isa </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFNetworking 实现分析</title>
      <link href="/posts/26714/"/>
      <url>/posts/26714/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>AFNetworking 是 iOS 中常用的网络请求库，其使用也比较简单，以 POST 请求为例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 AFHTTPSessionManager 实例</span></span><br><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求序列化器为 JSON</span></span><br><span class="line">manager.requestSerializer = [AFJSONRequestSerializer serializer];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置响应序列化器为 JSON</span></span><br><span class="line">manager.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求参数</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *parameters = @&#123;<span class="string">@&quot;title&quot;</span>: <span class="string">@&quot;foo&quot;</span>, <span class="string">@&quot;body&quot;</span>: <span class="string">@&quot;bar&quot;</span>, <span class="string">@&quot;userId&quot;</span>: @<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 POST 请求</span></span><br><span class="line">[manager POST:<span class="string">@&quot;https://www.lixkit.com/posts&quot;</span></span><br><span class="line">   parameters:parameters</span><br><span class="line">      headers:<span class="literal">nil</span></span><br><span class="line">     progress:<span class="literal">nil</span></span><br><span class="line">      success:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="type">id</span> responseObject) &#123;</span><br><span class="line">          <span class="comment">// 请求成功的回调</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;POST 请求成功，响应数据：%@&quot;</span>, responseObject);</span><br><span class="line">      &#125;</span><br><span class="line">      failure:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">          <span class="comment">// 请求失败的回调</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;POST 请求失败，错误信息：%@&quot;</span>, error);</span><br><span class="line">      &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>AFNetworking（4.0） 核心类可以按照下图进行分层：<br><img src="/images/lix_blog_194.png" style="width:70%;"></p><p>各层职责：</p><ul><li><code>AFHTTPSessionManager</code><ul><li>继承自 <code>AFURLSessionManager</code>，提供对外 API 处理常见的 HTTP 请求（如 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 等）</li></ul></li><li><code>AFURLSessionManager</code><ul><li>提供对 <code>NSURLSession</code> 的封装，基于 <code>NSURLSession</code> 提供了实际的 HTTP 请求实现</li></ul></li><li><code>AFHTTPRequestSerializer</code><ul><li>用于将请求参数序列化为适合 HTTP 请求体的格式，支持 <code>JSON</code>、<code>XML</code>、<code>Property List</code> 等格式的请求序列化</li></ul></li><li><code>AFHTTPResponseSerializer</code><ul><li>用于将 HTTP 响应数据反序列化为常见的数据结构，解析 <code>JSON</code>、<code>XML</code>、<code>Property List</code> 等格式的响应数据</li></ul></li><li><code>AFNetworkReachabilityManager</code><ul><li>用于监控和报告当前网络连接状态</li></ul></li><li><code>AFSecurityPolicy</code><ul><li>管理和验证服务器的安全策略</li></ul></li></ul><h2 id="二、源码解读"><a href="#二、源码解读" class="headerlink" title="二、源码解读"></a>二、源码解读</h2><h3 id="1、AFHTTPSessionManager-AFURLSessionManager"><a href="#1、AFHTTPSessionManager-AFURLSessionManager" class="headerlink" title="1、AFHTTPSessionManager&#x2F;AFURLSessionManager"></a>1、AFHTTPSessionManager&#x2F;AFURLSessionManager</h3><p>以 <code>POST</code> 请求为例，其实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POST 请求方法</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                             parameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                                headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                               progress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgress</span><br><span class="line">                                success:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="type">id</span> _Nullable responseObject))success</span><br><span class="line">                                failure:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个 POST 请求任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@&quot;POST&quot;</span></span><br><span class="line">                                                        URLString:URLString</span><br><span class="line">                                                       parameters:parameters</span><br><span class="line">                                                          headers:headers</span><br><span class="line">                                                   uploadProgress:uploadProgress</span><br><span class="line">                                                 downloadProgress:<span class="literal">nil</span></span><br><span class="line">                                                          success:success</span><br><span class="line">                                                          failure:failure];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [dataTask resume];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回任务对象</span></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并返回一个 NSURLSessionDataTask</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                      parameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                                         headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                                  uploadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="type">id</span> _Nullable responseObject))success</span><br><span class="line">                                         failure:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用请求序列化器创建 NSMutableURLRequest 对象</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:method</span><br><span class="line">                                                                   URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString]</span><br><span class="line">                                                                  parameters:parameters</span><br><span class="line">                                                                       error:&amp;serializationError];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *headerField <span class="keyword">in</span> headers.keyEnumerator) &#123;</span><br><span class="line">        [request setValue:headers[headerField] forHTTPHeaderField:headerField];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果序列化出错，调用失败回调并返回 nil</span></span><br><span class="line">    <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(<span class="literal">nil</span>, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 NSURLSessionDataTask，提供 block 形式回调</span></span><br><span class="line">    dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="type">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="comment">// 任务完成后的回调</span></span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                failure(dataTask, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                success(dataTask, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述逻辑可以看出 AFNetworking 是基于 <code>NSURLSession</code> 实现的网络请求，<code>AFURLSessionManager</code> 是 <code>AFHTTPSessionManager</code> 的父类，<code>AFURLSessionManager</code> 对 <code>NSURLSession</code> 及其任务（包括 <code>NSURLSessionUploadTask</code>）进行了封装，并将原本通过 <code>NSURLSessionDelegate</code> 接收的回调改为了使用 <code>block</code> 回调的形式。</p><h3 id="2、AFHTTPRequestSerializer"><a href="#2、AFHTTPRequestSerializer" class="headerlink" title="2、AFHTTPRequestSerializer"></a>2、AFHTTPRequestSerializer</h3><p><code>AFHTTPSessionManager</code> 中持有了 <code>AFHTTPRequestSerializer</code> 的实例，在发起网络请求前可以配置 <code>requestSerializer</code> 参数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFHTTPSessionManager</span> : <span class="title">AFURLSessionManager</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>AFHTTPRequestSerializer</code> 负责将请求参数序列化为适合 HTTP 请求体的格式，它提供了对 HTTP 请求的高级封装，支持多种序列化格式和请求配置，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPRequestSerializer *requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求头</span></span><br><span class="line">[requestSerializer setValue:<span class="string">@&quot;application/json&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>];</span><br><span class="line">[requestSerializer setValue:<span class="string">@&quot;application/json&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Accept&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求超时时间</span></span><br><span class="line">requestSerializer.timeoutInterval = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p><code>AFHTTPRequestSerializer</code> 有两个子类：<code>AFJSONRequestSerializer</code>、<code>AFPropertyListRequestSerializer</code>，两个子类都实现了 <code>AFURLRequestSerialization</code> 协议。</p><p><code>AFURLRequestSerialization</code> 协议中声明了如下方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLRequestSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 返回一个包含指定参数的请求，该请求是原始请求的副本，并将参数编码到请求中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param request 原始请求。 </span></span><br><span class="line"><span class="comment">                这是一个 `NSURLRequest` 对象，表示最初的 HTTP 请求。</span></span><br><span class="line"><span class="comment"> @param parameters 要编码的参数。 </span></span><br><span class="line"><span class="comment">                   这是一个可选的参数，通常是一个 `NSDictionary` 或 `NSArray`，包含需要添加到请求中的参数。</span></span><br><span class="line"><span class="comment"> @param error 尝试编码请求参数时发生的错误。 </span></span><br><span class="line"><span class="comment">              这是一个指向 `NSError` 对象的指针，用于在编码过程中发生错误时传递错误信息。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return 一个序列化后的请求。 </span></span><br><span class="line"><span class="comment">         返回一个新的 `NSURLRequest` 对象，其中包含了编码后的参数。如果编码过程中发生错误，返回 `nil`。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">这个方法的主要功能是将指定的参数编码到一个新的 <span class="built_in">NSURLRequest</span> 中，并返回这个新的 <span class="built_in">NSURLRequest</span>。</span><br><span class="line"></span><br><span class="line">以 AFJSONRequestSerializer 为例，其对该方法的实现如下：</span><br><span class="line">- (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="type">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保 request 参数不为空</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求方法在需要将参数编码到 URI 的方法列表中，直接调用父类的方法进行序列化</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="variable language_">super</span> requestBySerializingRequest:request withParameters:parameters error:error];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个可变的 NSMutableURLRequest 对象，复制自原始请求</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 HTTP 请求头，如果原始请求中没有设置相应的字段</span></span><br><span class="line">    [<span class="keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="type">id</span> field, <span class="type">id</span> value, <span class="type">BOOL</span> * __unused stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有参数需要编码</span></span><br><span class="line">    <span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="comment">// 如果 Content-Type 头字段没有设置，默认设置为 application/json</span></span><br><span class="line">        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>]) &#123;</span><br><span class="line">            [mutableRequest setValue:<span class="string">@&quot;application/json&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查参数是否为有效的 JSON 对象</span></span><br><span class="line">        <span class="keyword">if</span> (![<span class="built_in">NSJSONSerialization</span> isValidJSONObject:parameters]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                <span class="comment">// 如果参数不是有效的 JSON 对象，设置错误信息并返回 nil</span></span><br><span class="line">                <span class="built_in">NSDictionary</span> *userInfo = @&#123;<span class="built_in">NSLocalizedFailureReasonErrorKey</span>: <span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@&quot;The `parameters` argument is not valid JSON.&quot;</span>, <span class="string">@&quot;AFNetworking&quot;</span>, <span class="literal">nil</span>)&#125;;</span><br><span class="line">                *error = [[<span class="built_in">NSError</span> alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:<span class="built_in">NSURLErrorCannotDecodeContentData</span> userInfo:userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将参数序列化为 JSON 数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *jsonData = [<span class="built_in">NSJSONSerialization</span> dataWithJSONObject:parameters options:<span class="keyword">self</span>.writingOptions error:error];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果序列化过程中发生错误，返回 nil</span></span><br><span class="line">        <span class="keyword">if</span> (!jsonData) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置请求体为序列化后的 JSON 数据</span></span><br><span class="line">        [mutableRequest setHTTPBody:jsonData];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回包含序列化参数的新请求</span></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，上述实现主要是将请求参数序列化为 <code>JSON</code> 格式，并将请求头的 <code>Content-Type</code> 设置为 <code>application/json</code>。</p><p>开发时，可以直接使用 <code>AFJSONRequestSerializer</code> 和 <code>AFPropertyListRequestSerializer</code>，也可以实现 <code>AFURLRequestSerialization</code> 协议自定义一个 <code>requestSerializer</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用 AFJSONRequestSerializer，也可以自定义</span></span><br><span class="line">manager.requestSerializer = [AFJSONRequestSerializer serializer];</span><br></pre></td></tr></table></figure><p>总结下 <code>AFHTTPRequestSerializer</code> 有两个子类的作用：</p><ul><li><code>AFJSONRequestSerializer</code><ul><li>将请求参数序列化为 JSON 格式</li><li>它会将请求头的 <code>Content-Type</code> 设置为 <code>application/json</code></li></ul></li><li><code>AFPropertyListRequestSerializer</code><ul><li>将请求参数序列化为 <code>Property List</code> 格式</li><li>自动设置 <code>Content-Type</code> 为 <code>application/x-plist</code></li></ul></li></ul><h3 id="3、AFHTTPResponseSerializer"><a href="#3、AFHTTPResponseSerializer" class="headerlink" title="3、AFHTTPResponseSerializer"></a>3、AFHTTPResponseSerializer</h3><p>与 <code>AFHTTPRequestSerializer</code> 一样，<code>AFHTTPSessionManager</code> 中也持有了 <code>AFHTTPResponseSerializer</code> 的实例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFHTTPSessionManager</span> : <span class="title">AFURLSessionManager</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上述 <code>responseSerializer</code> 在 <code>NSURLSessionTaskDelegate</code> 的 HTTP 请求完成的方法中调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - NSURLSessionTaskDelegate</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上述调用了 <code>responseSerializer</code> 的 <code>responseObjectForResponse:data:error:</code> 这个方法，这个方法实际上是 <code>AFURLResponseSerialization</code> 协议中声明的方法。</p><p>与 <code>AFHTTPRequestSerializer</code> 类似，<code>AFHTTPResponseSerializer</code> 也有多个子类，每个子类都实现了 <code>AFURLResponseSerialization</code> 协议中的如下方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 从与指定响应关联的数据中解码出响应对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param response 要处理的响应。</span></span><br><span class="line"><span class="comment">                 这是一个 `NSURLResponse` 对象，包含响应的元数据，如状态码和头信息。这个参数可以为 `nil`。</span></span><br><span class="line"><span class="comment"> @param data 要解码的响应数据。</span></span><br><span class="line"><span class="comment">             这是一个 `NSData` 对象，包含服务器返回的原始数据。这个参数可以为 `nil`。</span></span><br><span class="line"><span class="comment"> @param error 尝试解码响应数据时发生的错误。</span></span><br><span class="line"><span class="comment">              这是一个指向 `NSError` 对象的指针，用于在解码过程中发生错误时传递错误信息。如果解码成功，这个参数应为 `nil`。如果解码失败，这个参数将包含具体的错误信息。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return 从指定响应数据中解码出的对象。</span></span><br><span class="line"><span class="comment">         返回一个解码后的对象，通常是 `NSDictionary`、`NSArray`、`UIImage` 等。如果解码过程中发生错误，返回 `nil`。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)responseObjectForResponse:(<span class="keyword">nullable</span> <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>简而言之，该方法的作用是将 HTTP 的 <code>response</code> 解析成指定的数据类型并返回。</p><p>以其中一个子类 <code>AFJSONResponseSerializer</code> 为例，其实现的该方法如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - AFURLResponseSerialization</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 解析并返回从服务器响应数据中解码出的对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param response 要处理的响应。</span></span><br><span class="line"><span class="comment">                 这是一个 `NSURLResponse` 对象，包含响应的元数据，如状态码和头信息。</span></span><br><span class="line"><span class="comment"> @param data 要解码的响应数据。</span></span><br><span class="line"><span class="comment">             这是一个 `NSData` 对象，包含服务器返回的原始数据。</span></span><br><span class="line"><span class="comment"> @param error 尝试解码响应数据时发生的错误。</span></span><br><span class="line"><span class="comment">              这是一个指向 `NSError` 对象的指针，用于在解码过程中发生错误时传递错误信息。如果解码成功，这个参数应为 `nil`。如果解码失败，这个参数将包含具体的错误信息。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return 从指定响应数据中解码出的对象。通常是 `NSDictionary` 或 `NSArray` 对象。如果解码过程中发生错误，返回 `nil`。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 验证响应和数据是否有效，如果无效则返回 nil</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">        <span class="comment">// 如果错误不存在或错误域是 NSURLErrorCannotDecodeContentData 或 AFURLResponseSerializationErrorDomain，则返回 nil</span></span><br><span class="line">        <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 Rails 返回单个空格作为 `head :ok` 的情况，这是 Safari 中的一个 bug</span></span><br><span class="line">    <span class="comment">// 详见 https://github.com/rails/rails/issues/1742</span></span><br><span class="line">    <span class="type">BOOL</span> isSpace = [data isEqualToData:[<span class="built_in">NSData</span> dataWithBytes:<span class="string">&quot; &quot;</span> length:<span class="number">1</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果数据长度为 0 或数据是单个空格，则返回 nil</span></span><br><span class="line">    <span class="keyword">if</span> (data.length == <span class="number">0</span> || isSpace) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试将数据解析为 JSON 对象</span></span><br><span class="line">    <span class="type">id</span> responseObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="keyword">self</span>.readingOptions error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果解析失败，设置错误信息并返回 nil</span></span><br><span class="line">    <span class="keyword">if</span> (!responseObject)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果配置为移除包含 null 值的键，则移除这些键</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removesKeysWithNullValues) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span>.readingOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回解析后的对象</span></span><br><span class="line">    <span class="keyword">return</span> responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述主要逻辑是将服务器返回的原始数据（<code>NSData</code>）解码为 <code>JSON</code> 对象（如 <code>NSDictionary</code> 或 <code>NSArray</code>），并进行必要的验证和错误处理。</p><p><code>AFHTTPResponseSerializer</code> 内置了如下几个子类：</p><ul><li><code>AFJSONResponseSerializer</code><ul><li>将服务器返回的 JSON 数据序列化为 <code>NSDictionary</code> 或 <code>NSArray</code> 对象</li></ul></li><li><code>AFXMLParserResponseSerializer</code><ul><li>将服务器返回的 XML 数据序列化为 NSXMLParser 对象</li></ul></li><li><code>AFPropertyListResponseSerializer</code><ul><li>将服务器返回的 <code>Property List</code> 数据序列化为 <code>NSDictionary</code> 或 <code>NSArray</code> 对象</li></ul></li><li><code>AFImageResponseSerializer</code><ul><li>将服务器返回的图像数据序列化为 <code>UIImage</code> 对象</li></ul></li><li><code>AFCompoundResponseSerializer</code><ul><li>允许组合多个响应序列化器，根据不同的 <code>MIME</code> 类型处理响应</li></ul></li></ul><p>也可以实现 <code>AFURLResponseSerialization</code> 自定义 <code>responseSerializer</code>。</p><h3 id="4、AFNetworkReachabilityManager"><a href="#4、AFNetworkReachabilityManager" class="headerlink" title="4、AFNetworkReachabilityManager"></a>4、AFNetworkReachabilityManager</h3><h4 id="（1）实现方式"><a href="#（1）实现方式" class="headerlink" title="（1）实现方式"></a>（1）实现方式</h4><p><code>AFNetworkReachabilityManager</code> 是 AFNetworking 实现的一个工具类，用于检测当前网络是否可达，以及网络连接类型的变化（如 WiFi 或蜂窝网络）。</p><p>主要功能如下：</p><ul><li>监控网络状态变化：检测网络连接是否可达。</li><li>监听网络连接类型：区分 WiFi 和蜂窝网络。</li><li>提供回调接口：在网络状态变化时执行指定的回调。</li></ul><p><code>AFNetworkReachabilityManager</code> 使用示例如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并启动网络可达性管理器</span></span><br><span class="line">AFNetworkReachabilityManager *reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置网络状态变化回调</span></span><br><span class="line">[reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusNotReachable:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;网络不可达&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWiFi:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;通过 WiFi 连接&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWWAN:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;通过蜂窝网络连接&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusUnknown:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;未知网络状态&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动网络可达性监听</span></span><br><span class="line">[reachabilityManager startMonitoring];</span><br></pre></td></tr></table></figure><p><code>AFNetworkReachabilityManager</code> 基于系统的 <code>SCNetworkReachability</code> API 实现，其 <code>startMonitoring</code>、<code>stopMonitoring</code> 实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 开始监控</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 这个方法会首先停止任何现有的网络状态监控，然后设置新的监控回调，并将其添加到主线程的 RunLoop 中，以便在网络状态变化时能够触发回调。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @note 这个方法会异步获取当前的网络状态，并触发状态变化回调。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)startMonitoring &#123;</span><br><span class="line">    <span class="comment">// 停止现有的网络状态监控</span></span><br><span class="line">    [<span class="keyword">self</span> stopMonitoring];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 networkReachability 不存在，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.networkReachability) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弱引用 self，避免在 block 中产生循环引用</span></span><br><span class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 定义网络状态变化时的回调 block</span></span><br><span class="line">    AFNetworkReachabilityStatusCallback callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        <span class="comment">// 强引用 self，确保在 block 内 self 不会被释放</span></span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新网络状态</span></span><br><span class="line">        strongSelf.networkReachabilityStatus = status;</span><br><span class="line">        <span class="comment">// 如果定义了网络状态变化回调 block，则调用它</span></span><br><span class="line">        <span class="keyword">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">            strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strongSelf;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 SCNetworkReachabilityContext，上下文信息包括回调 block</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityContext</span> context = &#123;<span class="number">0</span>, (__bridge <span class="type">void</span> *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">// 设置网络状态变化时的回调函数</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilitySetCallback</span>(<span class="keyword">self</span>.networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class="line">    <span class="comment">// 将 networkReachability 添加到主线程的 RunLoop 中，开始监控网络状态变化</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityScheduleWithRunLoop</span>(<span class="keyword">self</span>.networkReachability, <span class="built_in">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步获取当前的网络状态，并触发状态变化回调</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>),^&#123;</span><br><span class="line">        <span class="built_in">SCNetworkReachabilityFlags</span> flags;</span><br><span class="line">        <span class="comment">// 获取当前的网络状态标志位</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SCNetworkReachabilityGetFlags</span>(<span class="keyword">self</span>.networkReachability, &amp;flags)) &#123;</span><br><span class="line">            <span class="comment">// 触发网络状态变化回调</span></span><br><span class="line">            AFPostReachabilityStatusChange(flags, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 停止监控</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 这个方法会将 networkReachability 从主线程的 RunLoop 中移除，从而停止网络状态的监控。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)stopMonitoring &#123;</span><br><span class="line">    <span class="comment">// 如果 networkReachability 不存在，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.networkReachability) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 networkReachability 从主线程的 RunLoop 中移除，停止网络状态监控</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityUnscheduleFromRunLoop</span>(<span class="keyword">self</span>.networkReachability, <span class="built_in">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）SCNetworkReachability"><a href="#（2）SCNetworkReachability" class="headerlink" title="（2）SCNetworkReachability"></a>（2）SCNetworkReachability</h4><p><code>SCNetworkReachability</code> 是苹果提供的一个系统级 API，用于检测网络连接状态和监控网络连接的变化。它是 System Configuration 框架的一部分，适用于 iOS 和 macOS 应用程序。</p><p>主要功能如下：</p><ul><li>检测网络连接状态：判断当前网络是否可达。</li><li>监控网络状态变化：监听网络连接状态的变化，并在状态变化时触发回调。</li></ul><p><code>SCNetworkReachability</code> 使用示例如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SystemConfiguration/SystemConfiguration.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，当网络状态变化时调用</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> ReachabilityCallback(<span class="built_in">SCNetworkReachabilityRef</span> target, <span class="built_in">SCNetworkReachabilityFlags</span> flags, <span class="type">void</span>* info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kSCNetworkReachabilityFlagsReachable) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; kSCNetworkReachabilityFlagsIsWWAN) &#123;</span><br><span class="line">            printf(<span class="string">&quot;网络通过蜂窝网络连接\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            printf(<span class="string">&quot;网络通过 WiFi 连接\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        printf(<span class="string">&quot;网络不可达\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 SCNetworkReachability 引用</span></span><br><span class="line">        <span class="built_in">SCNetworkReachabilityRef</span> reachability = <span class="built_in">SCNetworkReachabilityCreateWithName</span>(<span class="literal">NULL</span>, <span class="string">&quot;www.apple.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置回调函数</span></span><br><span class="line">        <span class="built_in">SCNetworkReachabilityContext</span> context = &#123;<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="built_in">SCNetworkReachabilitySetCallback</span>(reachability, ReachabilityCallback, &amp;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 SCNetworkReachability 引用添加到 RunLoop 中</span></span><br><span class="line">        <span class="built_in">SCNetworkReachabilityScheduleWithRunLoop</span>(reachability, <span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行 RunLoop</span></span><br><span class="line">        <span class="built_in">CFRunLoopRun</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放 SCNetworkReachability 引用</span></span><br><span class="line">        <span class="built_in">CFRelease</span>(reachability);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SCNetworkReachability</code> 主要基于系统的网络栈和通知机制，使用时需要将 <code>SCNetworkReachability</code> 引用添加到 <code>RunLoop</code> 中，以确保系统能够在网络状态变化时触发回调。</p><p><code>SCNetworkReachability</code> 使用系统的网络栈来检测网络连接状态，包括是否有网络连接、连接类型（WiFi 或蜂窝网络）等。</p><p>网络栈是操作系统中负责网络通信的一组协议和软件模块的集合。它处理从应用层到物理层的所有网络通信任务，包括数据封装、路由、传输控制等。对于 <code>SCNetworkReachability</code> 来说，它主要依赖于网络栈中的 IP 层和链路层来检测网络连接状态。</p><p><code>SCNetworkReachability</code> 主要通过两种方式检查网络连接状态：</p><ul><li>通过发送网络探测请求（如 ICMP ping）</li><li>使用系统的路由表来确定目标主机或 IP 地址是否可达：查询路由表，查看是否存在到达目标主机或 IP 地址的有效路径。如果存在有效路径，则目标主机或 IP 地址被认为是可达的。</li></ul><h3 id="5、AFSecurityPolicy"><a href="#5、AFSecurityPolicy" class="headerlink" title="5、AFSecurityPolicy"></a>5、AFSecurityPolicy</h3><p><code>AFSecurityPolicy</code> 也是被 <code>AFHTTPSessionManager</code> 持有的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFHTTPSessionManager</span> : <span class="title">AFURLSessionManager</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>AFSecurityPolicy</code> 主要负责验证服务器的证书，确保网络通信的安全性。通过自定义安全策略，开发者可以灵活地控制 <code>SSL/TLS</code> 连接的验证过程。 </p><p>主要作用：</p><ul><li>证书验证：验证服务器证书的有效性。</li><li>公钥验证：验证服务器的公钥。</li><li>支持自定义证书：允许使用自定义证书进行验证。</li><li>配置不同的验证模式：通过 <code>SSL/TLS</code> 连接中的证书链来验证服务器的身份，提供三种验证模式：不验证、验证证书、验证公钥。<ul><li><code>AFSSLPinningModeNone</code><ul><li>不进行 SSL Pinning 验证，只依赖系统默认的证书验证机制。</li><li>适用于不需要额外安全验证的场景。</li></ul></li><li><code>AFSSLPinningModeCertificate</code><ul><li>验证服务器提供的证书是否与本地预置的证书匹配。</li><li>适用于需要确保服务器证书与预期证书完全一致的场景。</li></ul></li><li><code>AFSSLPinningModePublicKey</code><ul><li>验证服务器提供的证书中的公钥是否与本地预置的公钥匹配。</li><li>适用于需要确保服务器公钥与预期公钥一致的场景。</li></ul></li></ul></li></ul><p>使用 <code>AFSecurityPolicy</code> 自定义证书的示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;AFNetworking/AFNetworking.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)configureSecurityPolicy &#123;</span><br><span class="line">    <span class="comment">// 获取自定义证书的路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *cerPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;my_custom_certificate&quot;</span> ofType:<span class="string">@&quot;cer&quot;</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *certData = [<span class="built_in">NSData</span> dataWithContentsOfFile:cerPath];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个安全策略，使用证书验证模式</span></span><br><span class="line">    AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许使用无效或自签名证书</span></span><br><span class="line">    securityPolicy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不验证证书域名</span></span><br><span class="line">    securityPolicy.validatesDomainName = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置自定义证书</span></span><br><span class="line">    securityPolicy.pinnedCertificates = [<span class="built_in">NSSet</span> setWithObject:certData];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 AFHTTPSessionManager 使用自定义的安全策略</span></span><br><span class="line">    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">    manager.securityPolicy = securityPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起网络请求</span></span><br><span class="line">    [manager GET:<span class="string">@&quot;https://lixkit.com&quot;</span> parameters:<span class="literal">nil</span> headers:<span class="literal">nil</span> progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="type">id</span> responseObject) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;请求成功: %@&quot;</span>, responseObject);</span><br><span class="line">    &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;请求失败: %@&quot;</span>, error);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AFSecurityPolicy</code> 主要实现源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFSecurityPolicy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定的 bundle 中获取所有的证书</span></span><br><span class="line">+ (<span class="built_in">NSSet</span> *)certificatesInBundle:(<span class="built_in">NSBundle</span> *)bundle &#123;</span><br><span class="line">    <span class="comment">// 获取 bundle 中所有的 .cer 文件路径</span></span><br><span class="line">    <span class="built_in">NSArray</span> *paths = [bundle pathsForResourcesOfType:<span class="string">@&quot;cer&quot;</span> inDirectory:<span class="string">@&quot;.&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个可变集合，用于存储证书数据</span></span><br><span class="line">    <span class="built_in">NSMutableSet</span> *certificates = [<span class="built_in">NSMutableSet</span> setWithCapacity:[paths count]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *path <span class="keyword">in</span> paths) &#123;</span><br><span class="line">        <span class="comment">// 读取证书数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *certificateData = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">        [certificates addObject:certificateData];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回包含所有证书数据的集合</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithSet:certificates];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个默认的安全策略（不进行 SSL Pinning）</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultPolicy &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = AFSSLPinningModeNone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的 Pinning 模式创建安全策略，并使用默认的证书</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;</span><br><span class="line">    <span class="comment">// 从主 bundle 中获取所有证书</span></span><br><span class="line">    <span class="built_in">NSSet</span> &lt;<span class="built_in">NSData</span> *&gt; *defaultPinnedCertificates = [<span class="keyword">self</span> certificatesInBundle:[<span class="built_in">NSBundle</span> mainBundle]];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> policyWithPinningMode:pinningMode withPinnedCertificates:defaultPinnedCertificates];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的 Pinning 模式和证书集合创建安全策略</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = pinningMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置自定义证书</span></span><br><span class="line">    [securityPolicy setPinnedCertificates:pinnedCertificates];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认验证域名</span></span><br><span class="line">    <span class="keyword">self</span>.validatesDomainName = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置自定义证书</span></span><br><span class="line">- (<span class="type">void</span>)setPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    _pinnedCertificates = pinnedCertificates;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">        <span class="comment">// 创建一个可变集合，用于存储公钥</span></span><br><span class="line">        <span class="built_in">NSMutableSet</span> *mutablePinnedPublicKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity:[<span class="keyword">self</span>.pinnedCertificates count]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificate <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">            <span class="comment">// 提取证书中的公钥</span></span><br><span class="line">            <span class="type">id</span> publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class="line">            <span class="keyword">if</span> (!publicKey) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置公钥集合</span></span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = [<span class="built_in">NSSet</span> setWithSet:mutablePinnedPublicKeys];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark -</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 评估服务器信任</span></span><br><span class="line">- (<span class="type">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果域名存在，允许无效证书，验证域名且不进行 SSL Pinning 或没有自定义证书</span></span><br><span class="line">    <span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;为了验证自签名证书的域名，必须使用 pinning。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个策略数组，用于设置服务器信任策略</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="type">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="type">id</span>)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器信任策略</span></span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不进行 SSL Pinning</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; !AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;</span><br><span class="line">            <span class="comment">// 创建一个可变数组，用于存储自定义证书</span></span><br><span class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="type">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置自定义证书为信任的锚点证书</span></span><br><span class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 验证服务器信任链</span></span><br><span class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取服务器信任链中的证书</span></span><br><span class="line">            <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查服务器证书是否包含在自定义证书中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</span><br><span class="line">            <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 获取服务器信任链中的公钥</span></span><br><span class="line">            <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查服务器公钥是否包含在自定义公钥中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">                        trustedPublicKeyCount += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上述主要逻辑如下：</p><ul><li>获取证书<ul><li><code>certificatesInBundle:</code> 方法从指定的 <code>bundle</code> 中获取所有的 <code>.cer</code> 证书，并返回证书数据的集合。</li></ul></li><li>创建默认安全策略<ul><li><code>defaultPolicy</code> 方法创建一个默认的安全策略，不进行 SSL Pinning。</li></ul></li><li>根据 Pinning 模式创建安全策略<ul><li><code>policyWithPinningMode:</code> 方法根据指定的 Pinning 模式创建安全策略，并使用默认的证书。</li><li><code>policyWithPinningMode:withPinnedCertificates:</code> 方法根据指定的 Pinning 模式和证书集合创建安全策略。</li></ul></li><li>初始化方法<ul><li><code>init</code> 方法初始化安全策略实例，并默认设置 <code>validatesDomainName</code> 为 YES。</li><li><code>validatesDomainName</code> 属性决定了在验证服务器证书时，是否需要检查证书中的域名（Common Name 或 Subject Alternative Name）是否与请求的域名匹配。这种验证可以防止中间人攻击（MITM），确保服务器的身份是可信的。</li></ul></li><li>设置自定义证书<ul><li><code>setPinnedCertificates:</code> 方法设置自定义证书，并提取证书中的公钥。</li></ul></li><li>评估服务器信任<ul><li><code>evaluateServerTrust:forDomain:</code> 方法评估服务器的信任，根据不同的 Pinning 模式（<code>AFSSLPinningModeNone</code>、<code>AFSSLPinningModeCertificate</code>、<code>AFSSLPinningModePublicKey</code>）进行相应的验证。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MLeaksFinder 实现分析</title>
      <link href="/posts/27553/"/>
      <url>/posts/27553/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><a href="https://github.com/Tencent/MLeaksFinder">MLeaksFinder</a> 是腾讯 WeRead 团队开源的 iOS 内存泄露检测工具。<br>MLeaksFinder 的使用非常简单，使用 pod 添加了 MLeaksFinder 依赖之后，如果页面出现了内存泄露，APP 进行弹窗提示：<br><img src="/images/lix_blog_121.png"></p><p>接下来，通过 MLeaksFinder 源码，看下 MLeaksFinder 的实现原理。</p><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><h3 id="1、willDealloc-方法"><a href="#1、willDealloc-方法" class="headerlink" title="1、willDealloc 方法"></a>1、willDealloc 方法</h3><p>MLeaksFinder 在 <code>NSObject (MemoryLeak)</code> 新增了一个 <code>willDealloc</code> 方法，其实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">NSObject</span> classNamesWhitelist] containsObject:className])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSNumber</span> *senderPtr = objc_getAssociatedObject([<span class="built_in">UIApplication</span> sharedApplication], kLatestSenderKey);</span><br><span class="line">    <span class="keyword">if</span> ([senderPtr isEqualToNumber:@((uintptr_t)<span class="keyword">self</span>)])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="type">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="type">id</span> strongSelf = weakSelf;</span><br><span class="line">        [strongSelf assertNotDealloc];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)assertNotDealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> ([MLeakedObjectProxy isAnyObjectLeakedAtPtrs:[<span class="keyword">self</span> parentPtrs]]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [MLeakedObjectProxy addLeakedObject:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Possibly Memory Leak.\nIn case that %@ should not be dealloced, override -willDealloc in %@ by returning NO.\nView-ViewController stack: %@&quot;</span>, className, className, [<span class="keyword">self</span> viewStack]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>willDealloc</code> 方法主要逻辑如下：</p><ul><li>白名单校验，过滤掉一些系统 UI 组件。<ul><li>某些系统的私有 <code>View</code>，由于系统机制(也可能是 BUG)原因不会被释放，所以增加白名单过滤掉这些 <code>View</code>。</li></ul></li><li>判断 <code>self</code> 是否是 <code>LatestSender</code>，如果是则不检测。<ul><li>某些情况下，刚刚触发的事件（点击、操作）可能会暂时保留对象，可能会导致短期内无法释放。此处判断是为了防止出现误报。</li><li><code>UIApplication+MemoryLeak</code> 中 hook 了 <code>sendAction:to:from:forEvent:</code> 方法，以 <code>kLatestSenderKey</code> 作为关联对象的 Key 将 <code>LatestSender</code> 保存到了 <code>UIApplication</code> 中。</li></ul></li><li>延迟 2 秒，如果 2 秒后 <code>self</code> 还没有销毁，则判定发生内存泄露。<ul><li>对象销毁后，当前的 GCD 延迟任务仍然会执行，但 <code>self</code> 变成了 <code>nil</code>，<code>assertNotDealloc</code> 就执行不到了。</li><li>对象被销毁后，<code>dispatch_after</code> 提交的任务仍会执行，这是因为任务的调度与对象的生命周期无关。调用 <code>dispatch_after</code> 时，GCD 会将 <code>block</code> 注册到一个定时器中。当指定时间到达时，定时器会将该 <code>block</code> 提交到目标队列，无论对象是否已经被销毁。</li></ul></li></ul><p><code>assertNotDealloc</code> 方法主要逻辑如下：</p><ul><li>判断 <code>self</code> 的父指针（<code>parentPtrs</code>）是否有内存泄露，如果有，直接 <code>return</code>。<ul><li>其父指针集合中有内存泄露，那么当前对象很有可能也会发生泄漏。父对象的泄漏弹窗提示已经包含了关于父子关系链的相关信息，子对象不再重复提示，避免过多弹窗。</li></ul></li><li>调用 <code>MLeakedObjectProxy</code> 的 <code>addLeakedObject:</code> 方法。</li></ul><p>接下来看下 <code>addLeakedObject:</code> 方法的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)addLeakedObject:(<span class="type">id</span>)object &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="built_in">NSThread</span> isMainThread], <span class="string">@&quot;Must be in main thread.&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    MLeakedObjectProxy *proxy = [[MLeakedObjectProxy alloc] init];</span><br><span class="line">    proxy.object = object;</span><br><span class="line">    proxy.objectPtr = @((uintptr_t)object);</span><br><span class="line">    proxy.viewStack = [object viewStack];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="type">void</span> *<span class="keyword">const</span> kLeakedObjectProxyKey = &amp;kLeakedObjectProxyKey;</span><br><span class="line">    objc_setAssociatedObject(object, kLeakedObjectProxyKey, proxy, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    </span><br><span class="line">    [leakedObjectPtrs addObject:proxy.objectPtr];</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _INTERNAL_MLF_RC_ENABLED</span></span><br><span class="line">    [MLeaksMessenger alertWithTitle:<span class="string">@&quot;Memory Leak&quot;</span></span><br><span class="line">                            message:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, proxy.viewStack]</span><br><span class="line">                           delegate:proxy</span><br><span class="line">              additionalButtonTitle:<span class="string">@&quot;Retain Cycle&quot;</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    [MLeaksMessenger alertWithTitle:<span class="string">@&quot;Memory Leak&quot;</span></span><br><span class="line">                            message:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, proxy.viewStack]];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该方法中主要逻辑就是将发生内存泄露的 <code>self</code> 保存到 <code>leakedObjectPtrs</code> 中，并 alert 弹窗提示开发者发生了内存泄露。</p><h3 id="2、willDealloc-调用时机"><a href="#2、willDealloc-调用时机" class="headerlink" title="2、willDealloc 调用时机"></a>2、willDealloc 调用时机</h3><p>既然通过 <code>NSObject+MemoryLeak</code> 新增的 <code>willDealloc</code> 方法中检测内存泄露并弹窗提示，那么 <code>willDealloc</code> 方法调用时机是什么呢？</p><h4 id="（1）UINavigationController-MemoryLeak"><a href="#（1）UINavigationController-MemoryLeak" class="headerlink" title="（1）UINavigationController (MemoryLeak)"></a>（1）UINavigationController (MemoryLeak)</h4><p>忽略其中 iPad 适配逻辑，精简后的 <code>UINavigationController (MemoryLeak)</code> 主要逻辑如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="type">void</span> *<span class="keyword">const</span> kPoppedDetailVCKey = &amp;kPoppedDetailVCKey;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UINavigationController</span> (<span class="title">MemoryLeak</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="comment">// 确保方法交换只执行一次</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> swizzleSEL:<span class="keyword">@selector</span>(popViewControllerAnimated:) withSEL:<span class="keyword">@selector</span>(swizzled_popViewControllerAnimated:)];</span><br><span class="line">        [<span class="keyword">self</span> swizzleSEL:<span class="keyword">@selector</span>(popToViewController:animated:) withSEL:<span class="keyword">@selector</span>(swizzled_popToViewController:animated:)];</span><br><span class="line">        [<span class="keyword">self</span> swizzleSEL:<span class="keyword">@selector</span>(popToRootViewControllerAnimated:) withSEL:<span class="keyword">@selector</span>(swizzled_popToRootViewControllerAnimated:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)swizzled_popViewControllerAnimated:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *poppedViewController = [<span class="keyword">self</span> swizzled_popViewControllerAnimated:animated];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有被弹出的视图控制器，则返回 nil</span></span><br><span class="line">    <span class="keyword">if</span> (!poppedViewController) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为被弹出的视图控制器设置 kHasBeenPoppedKey 关联对象，用于标记该视图控制器已经被弹出</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="type">void</span> *<span class="keyword">const</span> kHasBeenPoppedKey;</span><br><span class="line">    objc_setAssociatedObject(poppedViewController, kHasBeenPoppedKey, @(<span class="literal">YES</span>), OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> poppedViewController;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">UIViewController</span> *&gt; *)swizzled_popToViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">UIViewController</span> *&gt; *poppedViewControllers = [<span class="keyword">self</span> swizzled_popToViewController:viewController animated:animated];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对弹出的每个视图控制器进行内存泄漏检查</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIViewController</span> *viewController <span class="keyword">in</span> poppedViewControllers) &#123;</span><br><span class="line">        [viewController willDealloc];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> poppedViewControllers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">UIViewController</span> *&gt; *)swizzled_popToRootViewControllerAnimated:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">UIViewController</span> *&gt; *poppedViewControllers = [<span class="keyword">self</span> swizzled_popToRootViewControllerAnimated:animated];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对弹出的每个视图控制器进行内存泄漏检查</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIViewController</span> *viewController <span class="keyword">in</span> poppedViewControllers) &#123;</span><br><span class="line">        [viewController willDealloc];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> poppedViewControllers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    <span class="comment">// 调用父类的 willDealloc 方法，如果返回 NO，则当前对象无需检测</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="variable language_">super</span> willDealloc]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对导航控制器的所有子视图控制器进行内存泄漏检查</span></span><br><span class="line">    [<span class="keyword">self</span> willReleaseChildren:<span class="keyword">self</span>.viewControllers];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>可以看到，上面主要 hook 了 <code>UINavigationController</code> 的下面这几个方法：</p><ul><li><code>popViewControllerAnimated:</code><ul><li>当前 <code>UIViewController</code> 被 pop 后，将该 <code>UIViewController</code> 标记成 <code>BeenPopped</code>。</li></ul></li><li><code>popToViewController:animated:</code><ul><li>该方法的返回值是包含所有被 pop 的 <code>UIViewController</code> 数组。</li><li>遍历该数组，逐个调用内部 <code>UIViewController</code> 的 <code>willDealloc</code>。</li></ul></li><li><code>popToRootViewControllerAnimated:</code><ul><li>该方法的返回值也是包含所有被 pop 的 <code>UIViewController</code> 数组。</li><li>遍历该数组，逐个调用内部 <code>UIViewController</code> 的 <code>willDealloc</code>。</li></ul></li></ul><p>可以看到，在 <code>UIViewController</code> 被 pop 后，该 <code>UIViewController</code> 的 <code>willDealloc</code> 方法会被调用。</p><h4 id="（2）UIViewController-MemoryLeak"><a href="#（2）UIViewController-MemoryLeak" class="headerlink" title="（2）UIViewController (MemoryLeak)"></a>（2）UIViewController (MemoryLeak)</h4><p><code>UIViewController (MemoryLeak)</code> 中逻辑如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">void</span> *<span class="keyword">const</span> kHasBeenPoppedKey = &amp;kHasBeenPoppedKey;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">MemoryLeak</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> swizzleSEL:<span class="keyword">@selector</span>(viewDidDisappear:) withSEL:<span class="keyword">@selector</span>(swizzled_viewDidDisappear:)];</span><br><span class="line">        [<span class="keyword">self</span> swizzleSEL:<span class="keyword">@selector</span>(viewWillAppear:) withSEL:<span class="keyword">@selector</span>(swizzled_viewWillAppear:)];</span><br><span class="line">        [<span class="keyword">self</span> swizzleSEL:<span class="keyword">@selector</span>(dismissViewControllerAnimated:completion:) withSEL:<span class="keyword">@selector</span>(swizzled_dismissViewControllerAnimated:completion:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)swizzled_viewDidDisappear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzled_viewDidDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果视图控制器被标记为已弹出，则进行内存泄漏检测</span></span><br><span class="line">    <span class="keyword">if</span> ([objc_getAssociatedObject(<span class="keyword">self</span>, kHasBeenPoppedKey) boolValue]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willDealloc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)swizzled_viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzled_viewWillAppear:animated];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置已弹出标记为 NO，表示视图控制器将要显示</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, kHasBeenPoppedKey, @(<span class="literal">NO</span>), OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)swizzled_dismissViewControllerAnimated:(<span class="type">BOOL</span>)flag completion:(<span class="type">void</span> (^)(<span class="type">void</span>))completion &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzled_dismissViewControllerAnimated:flag completion:completion];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取被 dismiss 的视图控制器</span></span><br><span class="line">    <span class="built_in">UIViewController</span> *dismissedViewController = <span class="keyword">self</span>.presentedViewController;</span><br><span class="line">    <span class="keyword">if</span> (!dismissedViewController &amp;&amp; <span class="keyword">self</span>.presentingViewController) &#123;</span><br><span class="line">        dismissedViewController = <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有被 dismiss 的视图控制器，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!dismissedViewController) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对被 dismiss 的视图控制器进行内存泄漏检测</span></span><br><span class="line">    [dismissedViewController willDealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    <span class="comment">// 调用父类的 willDealloc 方法，如果返回 NO，则当前对象无需检测</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="variable language_">super</span> willDealloc]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对视图控制器的所有子视图控制器进行内存泄漏检测</span></span><br><span class="line">    [<span class="keyword">self</span> willReleaseChildren:<span class="keyword">self</span>.childViewControllers];</span><br><span class="line">    <span class="comment">// 对当前展示的视图控制器进行内存泄漏检测</span></span><br><span class="line">    [<span class="keyword">self</span> willReleaseChild:<span class="keyword">self</span>.presentedViewController];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果视图已加载，对视图本身进行内存泄漏检测</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isViewLoaded) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willReleaseChild:<span class="keyword">self</span>.view];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面主要 hook 了 <code>UIViewController</code> 的下面这几个方法：</p><ul><li><code>viewDidDisappear:</code><ul><li>如果当前 <code>UIViewController</code> 被标记为已弹出（<code>kHasBeenPoppedKey</code>），则会调用 <code>willDealloc</code> 方法进行内存泄漏检测</li></ul></li><li><code>viewWillAppear:</code><ul><li>将 <code>UIViewController</code> 的已弹出标记重置为 NO。</li></ul></li><li><code>dismissViewControllerAnimated:completion:</code><ul><li>获取被 dismiss 的 <code>UIViewController</code> 并调用 <code>willDealloc</code> 方法进行内存泄漏检测。</li></ul></li></ul><p>由于 <code>UIViewController</code> 的这个 category 中也实现了 <code>willDealloc</code> 方法，所以上一步 <code>UINavigationController (MemoryLeak)</code> 中，调用的 <code>willDealloc</code> 实际上这里的 <code>willDealloc</code> 方法。</p><p><code>UIViewController(MemoryLeak)</code> 的 <code>willDealloc</code> 中又调用了 <code>[super willDealloc]</code>，此处会走进前面的 <code>NSObject (MemoryLeak)</code> 中的 <code>willDealloc</code> 中，执行真正的内存泄露检测逻辑。</p><h4 id="（3）总结"><a href="#（3）总结" class="headerlink" title="（3）总结"></a>（3）总结</h4><p>总结前述主要逻辑如下：</p><ul><li><code>NSObject (MemoryLeak)</code> 的 <code>willDealloc</code> 是内存泄露检测核心逻辑。<ul><li>使用 GCD 创建 2s 的延迟任务，如果 2s 后对象还没释放，则弹窗提示发生内存泄露。</li><li>对象销毁后，当前的 GCD 延迟任务仍然会执行，但 self 变成了 <code>nil</code>，所以后续弹窗提示的方法就执行不到了。</li></ul></li><li><code>willDealloc</code> 执行时机如下：<ul><li>调用了 <code>UINavigationController</code> 如下 pop 方法后，遍历方法返回的被 pop 的 <code>UIViewController</code> 数组，逐个调用内部 <code>UIViewController</code> 的 <code>willDealloc：</code><ul><li><code>popToViewController:animated:</code></li><li><code>popToRootViewControllerAnimated:</code></li></ul></li><li><code>UIViewController</code> 的 <code>viewDidDisappear</code> 方法被调用，且 <code>UIViewController</code> 已经被标记成 <code>HasBeenPopped</code> 时，调用 <code>willDealloc</code>。<ul><li><code>UINavigationController (MemoryLeak)</code> hook <code>popViewControllerAnimated:</code> 方法，当 <code>UIViewController</code> 被 pop 时将其标记成 <code>HasBeenPopped</code>。</li></ul></li><li><code>UIViewController</code> 被 dismiss 时，调用 <code>willDealloc</code>。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDWebImage 实现分析</title>
      <link href="/posts/14548/"/>
      <url>/posts/14548/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>SDWebImage 是 iOS 开发中比较常用的一个开源库，支持加载网络图片到 <code>UIImageView</code> &#x2F; <code>UIButton</code> 等 UI 控件上。</p><p>其使用方式也比较简单，以 <code>UIImageView</code> 加载网络图片为例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.imageView sd_setImageWithURL:<span class="keyword">self</span>.imageURL placeholderImage:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>SDWebImage(3.8.3)  核心类可以按照下图进行分层：<br><img src="/images/lix_blog_192.png" style="width:70%;"></p><p>各层职责：</p><ul><li><code>UIImageView+WebCache</code> &#x2F; <code>UIButton+WebCache</code><ul><li>提供给开发者使用的接口，简化图像加载的调用。</li></ul></li><li><code>SDWebImageManager</code><ul><li>协调下载、缓存等操作，是图像加载的核心调度层。</li></ul></li><li><code>SDWebImageDownloader</code> &#x2F; <code>SDWebImageDownloaderOperation</code><ul><li>负责从网络上下载图像，处理下载进度和完成回调。</li></ul></li><li><code>SDImageCache</code><ul><li>负责管理图像的内存缓存和磁盘缓存，提高图像加载的效率。</li></ul></li><li><code>SDWebImageDecoder</code><ul><li>将下载的图像数据解码为可以直接使用的 UIImage 对象。</li></ul></li><li><code>SDWebImageCompat</code> &#x2F; <code>SDWebImagePrefetcher</code><ul><li>提供一些辅助功能和工具类，增强框架的功能性和灵活性。</li></ul></li></ul><p>SDWebImage 在 GitHub 中给出的时序图如下：<br><img src="/images/lix_blog_193.png"></p><h2 id="二、源码解读"><a href="#二、源码解读" class="headerlink" title="二、源码解读"></a>二、源码解读</h2><h3 id="1、UIImageView-WebCache-UIButton-WebCache"><a href="#1、UIImageView-WebCache-UIButton-WebCache" class="headerlink" title="1、UIImageView+WebCache&#x2F;UIButton+WebCache"></a>1、UIImageView+WebCache&#x2F;UIButton+WebCache</h3><p>以 <code>UIImageView</code> 加载网络图片为例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.imageView sd_setImageWithURL:<span class="keyword">self</span>.imageURL placeholderImage:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>该方法最终调用的是如下方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url placeholderImage:(<span class="built_in">UIImage</span> *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">// 取消当前图像加载操作</span></span><br><span class="line">    [<span class="keyword">self</span> sd_cancelCurrentImageLoad];</span><br><span class="line">    <span class="comment">// 将 URL 与 UIImageView 关联起来</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果选项中不包含 SDWebImageDelayPlaceholder，则立即设置占位图像</span></span><br><span class="line">    <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="keyword">self</span>.image = placeholder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查 URL 是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否启用了活动指示器，如果启用则添加活动指示器</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> showActivityIndicatorView]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</span><br><span class="line">        <span class="comment">// 使用 SDWebImageManager 下载图像</span></span><br><span class="line">        <span class="type">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="type">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">            <span class="comment">// 移除活动指示器</span></span><br><span class="line">            [wself removeActivityIndicator];</span><br><span class="line">            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 如果下载成功且包含 SDWebImageAvoidAutoSetImage 选项，则调用完成回调并返回</span></span><br><span class="line">                <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                    <span class="comment">// 如果下载成功，则设置图像并更新布局</span></span><br><span class="line">                    wself.image = image;</span><br><span class="line">                    [wself setNeedsLayout];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果下载失败且包含 SDWebImageDelayPlaceholder 选项，则设置占位图像并更新布局</span></span><br><span class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                        wself.image = placeholder;</span><br><span class="line">                        [wself setNeedsLayout];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果完成回调存在且下载完成，则调用完成回调</span></span><br><span class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">// 将下载操作与 UIImageView 关联起来</span></span><br><span class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@&quot;UIImageViewImageLoad&quot;</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 URL 为空，立即调用完成回调并返回错误</span></span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [<span class="keyword">self</span> removeActivityIndicator];</span><br><span class="line">            <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@&quot;Trying to load a nil url&quot;</span>&#125;];</span><br><span class="line">                completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要逻辑如下：</p><ul><li><strong>取消当前正在进行的图片加载</strong><ul><li>调用 <code>sd_cancelCurrentImageLoad</code> 方法，确保当前没有正在进行的图片加载操作</li></ul></li><li><strong>设置占位图</strong><ul><li>在主线程中设置占位图</li></ul></li><li><strong>图片下载</strong><ul><li>通过 <code>SDWebImageManager</code> 单例，执行图片下载的操作</li></ul></li><li><strong>图片下载完成</strong><ul><li>将下载完成的 <code>UIImage</code> 设置到当前 <code>UIImageView</code> 上</li></ul></li></ul><h3 id="2、SDWebImageManager"><a href="#2、SDWebImageManager" class="headerlink" title="2、SDWebImageManager"></a>2、SDWebImageManager</h3><p><code>SDWebImageManager</code> 是个单例，主要负责协调下载、缓存等操作，是图像加载的核心调度层，其中持有了 <code>SDImageCache</code> 和 <code>SDWebImageDownloader</code>，且两者都是单例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageManager</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="type">id</span> &lt;SDWebImageManagerDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDImageCache *imageCache;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDWebImageDownloader *imageDownloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>SDWebImageManager</code> 还有个 <code>delegate</code> 属性，<code>SDWebImageManagerDelegate</code> 声明了两个可选实现的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法用于控制在缓存未命中时，是否应该下载 该 URL 对应的图片</span></span><br><span class="line">- (<span class="type">BOOL</span>)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(<span class="built_in">NSURL</span> *)imageURL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法允许在图片下载完成后，缓存到磁盘和内存之前对图片进行转换</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(<span class="built_in">UIImage</span> *)image withURL:(<span class="built_in">NSURL</span> *)imageURL;</span><br></pre></td></tr></table></figure><p>前述的图片下载通过 <code>SDWebImageManager</code> 单例中的如下方法实现的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 URL 生成缓存 Key                                </span></span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查缓存是否存在</span></span><br><span class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓存中不存在或需要刷新，并且 delegate 允许下载</span></span><br><span class="line">        <span class="keyword">if</span> ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;</span><br><span class="line">            <span class="comment">// 如果缓存中存在且需要刷新，则先返回缓存的图片</span></span><br><span class="line">            <span class="keyword">if</span> (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    <span class="comment">// 在主线程先回调缓存的图片</span></span><br><span class="line">                    completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始下载图片</span></span><br><span class="line">            <span class="type">id</span> &lt;SDWebImageOperation&gt; subOperation = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="type">BOOL</span> finished) &#123;</span><br><span class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="type">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果 delegate 想要转换图片，则先执行 delegate 的图片转换逻辑</span></span><br><span class="line">                    <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                <span class="type">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                <span class="comment">// 存储图片到缓存</span></span><br><span class="line">                                [<span class="keyword">self</span>.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? <span class="literal">nil</span> : data) forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                                <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                                    <span class="comment">// 回调 UIImage</span></span><br><span class="line">                                    completedBlock(transformedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果 delegate 不需要转换图片</span></span><br><span class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            <span class="comment">// 存储到缓存</span></span><br><span class="line">                            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage recalculateFromImage:<span class="literal">NO</span> imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        dispatch_main_sync_safe(^&#123;</span><br><span class="line">                            <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                                <span class="comment">// 回调 UIImage</span></span><br><span class="line">                                completedBlock(downloadedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            &#125;];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要逻辑如下：</p><ul><li><strong>使用 <code>URL</code> 生成缓存 <code>Key</code></strong><ul><li><code>[url absoluteString]</code> 作为 <code>key</code></li></ul></li><li><strong>使用缓存 <code>Key</code> 从 <code>SDImageCache</code> 中读取缓存</strong><ul><li>如果缓存存在，先将缓存的 <code>UIImage</code> 回调出去</li></ul></li><li><strong>判断是否需要下载</strong><ul><li>如果缓存中不存在图片或需要刷新，并且 <code>delegate</code> 允许下载图片，则通过 <code>SDWebImageDownloader</code> 下载，下载完成后更新到缓存并回调</li><li>如果缓存中存在图片且需要刷新，则先返回缓存中的图片，然后继续通过 <code>SDWebImageDownloader</code> 下载以刷新图片，下载完成后更新到缓存并回调</li><li>如果缓存中不存在图片且不允许下载，则空回调</li></ul></li></ul><h3 id="3、SDImageCache"><a href="#3、SDImageCache" class="headerlink" title="3、SDImageCache"></a>3、SDImageCache</h3><h4 id="（1）缓存的查找"><a href="#（1）缓存的查找" class="headerlink" title="（1）缓存的查找"></a>（1）缓存的查找</h4><p><code>SDImageCache</code> 中，缓存读取方法实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSOperation</span> *)queryDiskCacheForKey:(<span class="built_in">NSString</span> *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    <span class="keyword">if</span> (!doneBlock) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        doneBlock(<span class="literal">nil</span>, SDImageCacheTypeNone);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先从内存中查找缓存</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        <span class="comment">// 如果内存缓存中存在图片，则回调内存中图片，缓存类型为 SDImageCacheTypeMemory</span></span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再查找磁盘缓存</span></span><br><span class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</span><br><span class="line">    <span class="comment">// 异步执行</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="comment">// 如果操作被取消，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">// 从磁盘缓存中获取图片</span></span><br><span class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                <span class="comment">// 计算图片的缓存大小</span></span><br><span class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                <span class="comment">// 将图片存储到内存缓存中</span></span><br><span class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在主线程回调，返回图片和缓存类型为 SDImageCacheTypeDisk</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要逻辑如下：</p><ul><li><strong>先从内存中查找缓存</strong><ul><li>内存中如果存在缓存，则回调内存中的缓存</li><li>内存中不存在缓存，则从磁盘查找缓存</li><li>内存缓存使用 <code>NSCache</code> 存储<ul><li>可以通过 <code>SDImageCache</code> 单例的 <code>maxMemoryCountLimit</code> 属性设置最大存储图片数量，默认为 0，即无限制。</li><li>可以通过 <code>SDImageCache</code> 单例的 <code>maxMemoryCost</code> 属性设置最大存储图片内存大小，默认为 0，即无限制，系统内存不足时系统自动清理。</li></ul></li></ul></li><li><strong>再从磁盘中查找缓存</strong><ul><li>异步查找缓存</li><li>从磁盘查到缓存后，将缓存写入到内存缓存中一份</li><li>磁盘缓存使用 <code>NSFileManager</code> 实现，缓存到 <code>Library/Caches</code> 中<ul><li>可以通过 <code>SDImageCache</code> 单例的 <code>maxCacheAge</code> 属性设置缓存有效期，默认有效期为 7 天。</li><li>可以通过 <code>SDImageCache</code> 单例的 <code>maxCacheSize</code> 属性设置最大存储图片内存大小，默认为 0，即无限制。</li></ul></li></ul></li></ul><h4 id="（2）磁盘缓存的清理"><a href="#（2）磁盘缓存的清理" class="headerlink" title="（2）磁盘缓存的清理"></a>（2）磁盘缓存的清理</h4><p><code>SDImageCache</code> 实例初始化时，注册了三个通知用于缓存的清理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)initWithNamespace:(<span class="built_in">NSString</span> *)ns diskCacheDirectory:(<span class="built_in">NSString</span> *)directory &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内存警告时清理内存缓存</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(clearMemory)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用即将终止时清理磁盘缓存</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(cleanDisk)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationWillTerminateNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用进入后台创建后台任务清理缓存</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(backgroundCleanDisk)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即缓存清理时机如下：</p><ul><li><strong>内存警告时清理内存缓存</strong></li><li><strong>应用即将终止时清理磁盘缓存</strong></li><li><strong>应用进入后台创建后台任务清理缓存</strong></li></ul><p>磁盘清理具体逻辑如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    <span class="comment">// 在后台线程中执行磁盘清理操作</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="comment">// 获取磁盘缓存目录的 URL</span></span><br><span class="line">        <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.diskCachePath isDirectory:<span class="literal">YES</span>];</span><br><span class="line">        <span class="comment">// 需要预取的文件属性键</span></span><br><span class="line">        <span class="built_in">NSArray</span> *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, <span class="built_in">NSURLContentModificationDateKey</span>, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建目录枚举器，预取缓存文件的属性</span></span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [<span class="keyword">self</span>-&gt;_fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></span><br><span class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算过期日期</span></span><br><span class="line">        <span class="built_in">NSDate</span> *expirationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-<span class="keyword">self</span>.maxCacheAge];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *cacheFiles = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="built_in">NSUInteger</span> currentCacheSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举缓存目录中的所有文件。这个循环有两个目的：</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  1. 删除超过过期日期的文件。</span></span><br><span class="line">        <span class="comment">//  2. 存储文件属性以便后续基于大小的清理。</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过目录</span></span><br><span class="line">            <span class="keyword">if</span> ([resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除超过过期日期的文件</span></span><br><span class="line">            <span class="built_in">NSDate</span> *modificationDate = resourceValues[<span class="built_in">NSURLContentModificationDateKey</span>];</span><br><span class="line">            <span class="keyword">if</span> ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储文件引用并记录其总大小</span></span><br><span class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">            currentCacheSize += [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line">            [cacheFiles setObject:resourceValues forKey:fileURL];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除过期文件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</span><br><span class="line">            [<span class="keyword">self</span>-&gt;_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果剩余的磁盘缓存超过了配置的最大大小，则执行基于大小的清理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.maxCacheSize &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span>.maxCacheSize) &#123;</span><br><span class="line">            <span class="comment">// 目标是将缓存大小减少到最大缓存大小的一半</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span>.maxCacheSize / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按文件的最后修改时间排序（最旧的文件排在前面）</span></span><br><span class="line">            <span class="built_in">NSArray</span> *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></span><br><span class="line">                                                            usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="type">id</span> obj1, <span class="type">id</span> obj2) &#123;</span><br><span class="line">                                                                <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</span><br><span class="line">                                                            &#125;];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除文件直到缓存大小降到目标大小以下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>-&gt;_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</span><br><span class="line">                    <span class="built_in">NSDictionary</span> *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在主线程中回调</span></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要逻辑如下：</p><ul><li><strong>按有效期 <code>maxCacheAge</code> 清理过期缓存</strong></li><li><strong>按大存储内存 <code>maxCacheSize</code> 清理缓存</strong><ul><li>按照文件最后修改时间的逆序，移除过早的缓存，仅保留 <code>maxCacheSize</code> 一半大小的缓存</li></ul></li></ul><h4 id="（3）缓存的写入"><a href="#（3）缓存的写入" class="headerlink" title="（3）缓存的写入"></a>（3）缓存的写入</h4><p>在 <code>SDWebImageManager</code> 中，图片下载完成后会调用 <code>SDImageCache</code> 的如下方法将图片写入到缓存：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)storeImage:(<span class="built_in">UIImage</span> *)image recalculateFromImage:(<span class="type">BOOL</span>)recalculate imageData:(<span class="built_in">NSData</span> *)imageData forKey:(<span class="built_in">NSString</span> *)key toDisk:(<span class="type">BOOL</span>)toDisk &#123;</span><br><span class="line">    <span class="comment">// 检查图片和键是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (!image || !key) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果启用了内存缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        <span class="comment">// 计算图片的缓存成本</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);</span><br><span class="line">        <span class="comment">// 将图片存储到内存缓存中</span></span><br><span class="line">        [<span class="keyword">self</span>.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要存储到磁盘</span></span><br><span class="line">    <span class="keyword">if</span> (toDisk) &#123;</span><br><span class="line">        <span class="comment">// 异步执行磁盘存储操作</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">            <span class="built_in">NSData</span> *data = imageData;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (image &amp;&amp; (recalculate || !data)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_IPHONE</span></span><br><span class="line">                <span class="comment">// 检查图片是否具有 Alpha 通道</span></span><br><span class="line">                <span class="type">int</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(image.CGImage);</span><br><span class="line">                <span class="type">BOOL</span> hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class="line">                                  alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class="line">                                  alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class="line">                <span class="type">BOOL</span> imageIsPng = hasAlpha;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果图片数据存在，则检查其前缀以确定是否为 PNG</span></span><br><span class="line">                <span class="keyword">if</span> ([imageData length] &gt;= [kPNGSignatureData length]) &#123;</span><br><span class="line">                    imageIsPng = ImageDataHasPNGPreffix(imageData);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据图片类型生成相应的 NSData</span></span><br><span class="line">                <span class="keyword">if</span> (imageIsPng) &#123;</span><br><span class="line">                    data = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data = <span class="built_in">UIImageJPEGRepresentation</span>(image, (<span class="built_in">CGFloat</span>)<span class="number">1.0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                <span class="comment">// 在 macOS 上，将图片表示转换为 JPEG 数据</span></span><br><span class="line">                data = [<span class="built_in">NSBitmapImageRep</span> representationOfImageRepsInArray:image.representations usingType: <span class="built_in">NSJPEGFileType</span> properties:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将图片数据存储到磁盘</span></span><br><span class="line">            [<span class="keyword">self</span> storeImageDataToDisk:data forKey:key];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要逻辑如下：</p><ul><li><strong>先存到内存缓存</strong><ul><li>先检查确认启用了内存缓存，再存储到内存缓存</li></ul></li><li><strong>再存到磁盘缓存(异步)</strong><ul><li>先检查图片是否是 PNG<ul><li>先通过 <code>CGImageGetAlphaInfo</code> 获取 <code>UIImage</code> 的 <code>Alpha</code> 通道信息，推测是否是 PNG<ul><li>PNG 格式支持透明度，因此具有 <code>Alpha</code> 通道的图像通常被认为是 PNG</li><li>但这并不排除其他格式（如 TIFF 或 WebP）也可能支持透明度</li></ul></li><li>如果 <code>imageData</code> 存在，则检查其 <code>NSData</code> 前缀以确定是否为 PNG 格式<ul><li>PNG 文件具有独特的签名（前八个字节），通过检查这些字节可以准确判断图像是否为 PNG 格式</li><li>根据是否是 PNG，决定是通过 <code>UIImagePNGRepresentation</code> 还是 <code>UIImageJPEGRepresentation</code> 将 <code>UIImage</code> 转成 <code>NSData</code></li></ul></li></ul></li><li>使用 <code>NSFileManager</code> 将上一步得到的 <code>NSData</code> 写入沙盒（<code>Library/Caches</code>）</li></ul></li></ul><h3 id="4、SDWebImageDownloader-SDWebImageDownloaderOperation"><a href="#4、SDWebImageDownloader-SDWebImageDownloaderOperation" class="headerlink" title="4、SDWebImageDownloader&#x2F;SDWebImageDownloaderOperation"></a>4、SDWebImageDownloader&#x2F;SDWebImageDownloaderOperation</h3><p><code>SDWebImageDownloader</code> 和 <code>SDWebImageDownloaderOperation</code> 共同协作来实现图片的下载。</p><p><code>SDWebImageDownloader</code> 是一个负责管理图片下载任务的类。它提供了一个全局的入口来启动、取消和管理图片下载请求。主要职责包括：</p><ul><li>管理下载队列<ul><li><code>SDWebImageDownloader</code> 维护一个下载队列，用于管理所有的下载任务。</li></ul></li><li>配置下载选项、<ul><li>可以配置下载的并发数、超时时间、缓存策略等。</li></ul></li><li>处理下载回调<ul><li>提供下载进度、完成、失败等回调接口。</li></ul></li><li>创建下载操作<ul><li>为每个下载请求创建一个 <code>SDWebImageDownloaderOperation</code> 实例，并将其添加到下载队列中。</li></ul></li></ul><p><code>SDWebImageDownloaderOperation</code> <strong>是具体执行图片下载任务的类</strong>。它继承自 <code>NSOperation</code>，因此可以利用 <code>NSOperationQueue</code> 来管理并发下载。主要职责包括：</p><ul><li>执行下载任务<ul><li>具体的图片下载逻辑在这个类中实现，包括发起网络请求、处理响应数据等。</li></ul></li><li>管理下载状态<ul><li>维护下载任务的状态，如正在进行、已完成、已取消等。</li></ul></li><li>处理下载回调<ul><li>在下载过程中，通过回调将进度、完成、失败等信息传递给 <code>SDWebImageDownloader</code>。</li></ul></li></ul><p><code>SDWebImageManager</code> 中调用了 <code>SDWebImageDownloader</code> 的如下方法进行图片的下载：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    __block SDWebImageDownloaderOperation *operation;</span><br><span class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加进度和完成回调，并创建下载操作</span></span><br><span class="line">    [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</span><br><span class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = wself.downloadTimeout;</span><br><span class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</span><br><span class="line">            timeoutInterval = <span class="number">15.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建请求，配置缓存策略和超时时间</span></span><br><span class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];</span><br><span class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 配置 HTTP 头字段</span></span><br><span class="line">        <span class="keyword">if</span> (wself.headersFilter) &#123;</span><br><span class="line">            request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders <span class="keyword">copy</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.allHTTPHeaderFields = wself.HTTPHeaders;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化下载操作</span></span><br><span class="line">        operation = [[wself.operationClass alloc] initWithRequest:request</span><br><span class="line">                                                        inSession:<span class="keyword">self</span>.session</span><br><span class="line">                                                          options:options</span><br><span class="line">                                                         progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize) &#123;</span><br><span class="line">                                                             SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                             <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</span><br><span class="line">                                                             __block <span class="built_in">NSArray</span> *callbacksForURL;</span><br><span class="line">                                                             <span class="built_in">dispatch_sync</span>(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                                 callbacksForURL = [sself.URLCallbacks[url] <span class="keyword">copy</span>];</span><br><span class="line">                                                             &#125;);</span><br><span class="line">                                                             <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;</span><br><span class="line">                                                                 <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                                     SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</span><br><span class="line">                                                                     <span class="keyword">if</span> (callback) callback(receivedSize, expectedSize);</span><br><span class="line">                                                                 &#125;);</span><br><span class="line">                                                             &#125;</span><br><span class="line">                                                         &#125;</span><br><span class="line">                                                        completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="type">BOOL</span> finished) &#123;</span><br><span class="line">                                                            SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                            <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</span><br><span class="line">                                                            __block <span class="built_in">NSArray</span> *callbacksForURL;</span><br><span class="line">                                                            dispatch_barrier_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                                callbacksForURL = [sself.URLCallbacks[url] <span class="keyword">copy</span>];</span><br><span class="line">                                                                <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                                                                    [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                                &#125;</span><br><span class="line">                                                            &#125;);</span><br><span class="line">                                                            <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;</span><br><span class="line">                                                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</span><br><span class="line">                                                                <span class="keyword">if</span> (callback) callback(image, data, error, finished);</span><br><span class="line">                                                            &#125;</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                        cancelled:^&#123;</span><br><span class="line">                                                            SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                            <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</span><br><span class="line">                                                            dispatch_barrier_async(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                                [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                            &#125;);</span><br><span class="line">                                                        &#125;];</span><br><span class="line">        operation.shouldDecompressImages = wself.shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置认证信息</span></span><br><span class="line">        <span class="keyword">if</span> (wself.urlCredential) &#123;</span><br><span class="line">            operation.credential = wself.urlCredential;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wself.username &amp;&amp; wself.password) &#123;</span><br><span class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:wself.username password:wself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置操作优先级</span></span><br><span class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将操作添加到下载队列</span></span><br><span class="line">        [wself.downloadQueue addOperation:operation];</span><br><span class="line">        <span class="keyword">if</span> (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            <span class="comment">// 模拟 LIFO 执行顺序，通过将新操作添加为最后一个操作的依赖项</span></span><br><span class="line">            [wself.lastAddedOperation addDependency:operation];</span><br><span class="line">            wself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(<span class="built_in">NSURL</span> *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</span><br><span class="line">    <span class="comment">// URL 将用作回调字典的键，因此不能为 nil。如果为 nil，立即调用完成回调并返回。</span></span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 dispatch_barrier_sync 确保对 URLCallbacks 字典的访问是线程安全的</span></span><br><span class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</span><br><span class="line">        <span class="type">BOOL</span> first = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">// 如果 URLCallbacks 字典中没有该 URL，则创建一个新的回调数组，并标记为第一次请求</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.URLCallbacks[url]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.URLCallbacks[url] = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">            first = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理同一 URL 的多个同时下载请求</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span>.URLCallbacks[url];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</span><br><span class="line">        <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</span><br><span class="line">        [callbacksForURL addObject:callbacks];</span><br><span class="line">        <span class="keyword">self</span>.URLCallbacks[url] = callbacksForURL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是第一次请求该 URL，则调用 createCallback 创建下载操作</span></span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            createCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中，可以看出是使用 <code>NSURLSession</code> 实现图片的下载。</p><p>其中，下载回调是保存在 <code>NSMutableDictionary</code> 中：</p><ul><li><code>key</code> 为 <code>URL</code></li><li><code>value</code> 是一个数组，数组元素为字典，字典中保存了 <code>progressBlock</code>、<code>completedBlock</code> 两个回调</li></ul><p><strong>针对每一个 <code>URL</code>，只会在这个 <code>URL</code> 首次下载时才会真正执行下载，其余的只会将回调保存到字典中</strong>。在对应阶段，使用 <code>URL</code> 取出保存的回调数组，遍历执行回调，并使用 <code>dispatch_barrier_sync</code> 确保线程安全。</p><h3 id="5、SDWebImageDecoder"><a href="#5、SDWebImageDecoder" class="headerlink" title="5、SDWebImageDecoder"></a>5、SDWebImageDecoder</h3><p><code>SDWebImageDecoder</code> 主要负责图片的解码和解压缩，<code>SDWebImageDecoder</code> 中只提供了如下一个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)decodedImageWithImage:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="comment">// 下载大量图片时，使用 autorelease 释放位图上下文和所有变量，帮助系统在内存警告时释放内存。</span></span><br><span class="line">    <span class="comment">// 在 iOS7 上，不要忘记调用 [[SDImageCache sharedImageCache] clearMemory];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 防止 &quot;CGBitmapContextCreateImage: invalid context 0x0&quot; 错误</span></span><br><span class="line">    <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 不解码动画图片</span></span><br><span class="line">        <span class="keyword">if</span> (image.images != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取图像的 alpha 信息</span></span><br><span class="line">        <span class="built_in">CGImageAlphaInfo</span> alpha = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef);</span><br><span class="line">        <span class="type">BOOL</span> anyAlpha = (alpha == kCGImageAlphaFirst ||</span><br><span class="line">                         alpha == kCGImageAlphaLast ||</span><br><span class="line">                         alpha == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">                         alpha == kCGImageAlphaPremultipliedLast);</span><br><span class="line">        <span class="comment">// 如果图像包含 alpha 通道，直接返回原图</span></span><br><span class="line">        <span class="keyword">if</span> (anyAlpha) &#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取当前图像的颜色空间模型和颜色空间引用</span></span><br><span class="line">        <span class="built_in">CGColorSpaceModel</span> imageColorSpaceModel = <span class="built_in">CGColorSpaceGetModel</span>(<span class="built_in">CGImageGetColorSpace</span>(imageRef));</span><br><span class="line">        <span class="built_in">CGColorSpaceRef</span> colorspaceRef = <span class="built_in">CGImageGetColorSpace</span>(imageRef);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否为不支持的颜色空间</span></span><br><span class="line">        <span class="type">BOOL</span> unsupportedColorSpace = (imageColorSpaceModel == kCGColorSpaceModelUnknown ||</span><br><span class="line">                                      imageColorSpaceModel == kCGColorSpaceModelMonochrome ||</span><br><span class="line">                                      imageColorSpaceModel == kCGColorSpaceModelCMYK ||</span><br><span class="line">                                      imageColorSpaceModel == kCGColorSpaceModelIndexed);</span><br><span class="line">        <span class="comment">// 如果是不支持的颜色空间，则创建一个 RGB 颜色空间</span></span><br><span class="line">        <span class="keyword">if</span> (unsupportedColorSpace) &#123;</span><br><span class="line">            colorspaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">        size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">        <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">NSUInteger</span> bytesPerRow = bytesPerPixel * width;</span><br><span class="line">        <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// kCGImageAlphaNone 在 CGBitmapContextCreate 中不支持。</span></span><br><span class="line">        <span class="comment">// 由于原始图像没有 alpha 信息，使用 kCGImageAlphaNoneSkipLast 创建没有 alpha 信息的位图图形上下文。</span></span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">                                                     width,</span><br><span class="line">                                                     height,</span><br><span class="line">                                                     bitsPerComponent,</span><br><span class="line">                                                     bytesPerRow,</span><br><span class="line">                                                     colorspaceRef,</span><br><span class="line">                                                     kCGBitmapByteOrderDefault | kCGImageAlphaNoneSkipLast);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将图像绘制到上下文中，并检索没有 alpha 通道的新位图图像</span></span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">        <span class="built_in">CGImageRef</span> imageRefWithoutAlpha = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">UIImage</span> *imageWithoutAlpha = [<span class="built_in">UIImage</span> imageWithCGImage:imageRefWithoutAlpha</span><br><span class="line">                                                         scale:image.scale</span><br><span class="line">                                                   orientation:image.imageOrientation];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果创建了新的颜色空间，则释放它</span></span><br><span class="line">        <span class="keyword">if</span> (unsupportedColorSpace) &#123;</span><br><span class="line">            <span class="built_in">CGColorSpaceRelease</span>(colorspaceRef);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放上下文和图像引用</span></span><br><span class="line">        <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">        <span class="built_in">CGImageRelease</span>(imageRefWithoutAlpha);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> imageWithoutAlpha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>decodedImageWithImage:</code> 方法主要是通过 <code>CGBitmapContextCreate</code> 进行图片的解压缩，该方法均是在子线程被调用。</p><p><code>decodedImageWithImage:</code> 方法调用时机如下：</p><ul><li><code>SDWebImageDownloaderOperation</code> 中图片下载完成后</li><li><code>SDImageCache</code> 中从磁盘读取缓存后</li></ul><p><strong><code>decodedImageWithImage:</code> 方法的入参已经是 <code>UIImage</code> 了，为什么还需要对 <code>UIImage</code> 进行解压缩呢？</strong></p><p><code>UIImage</code> 展示到 <code>UIImageView</code> 上，要经过以下流程：</p><ul><li><strong>将 <code>UIImage</code> 赋值给 <code>UIImageView</code></strong><ul><li>将 <code>UIImage</code> 对象赋值给 <code>UIImageView</code>，准备显示图像。</li></ul></li><li><strong>图片解码（<code>CPU</code>）</strong><ul><li>解码即解压缩，将压缩的图片数据（如 JPEG、PNG）解码为未压缩的位图数据。</li><li>解码是一个非常耗时的 <code>CPU</code> 操作，默认情况下在主线程中执行。</li></ul></li><li><strong>图片绘制（<code>GPU</code>）</strong><ul><li>解码后的位图数据提交给 <code>GPU</code> 进行渲染。</li><li><code>GPU</code> 负责将位图数据渲染到帧缓冲区。</li></ul></li><li><strong>显示到屏幕（<code>GPU</code>）</strong><ul><li><code>GPU</code> 渲染完成后，将渲染后的位图放到帧缓冲区。</li><li>帧缓冲区的内容被视频控制器读取并显示到屏幕上。</li></ul></li></ul><p>而 <code>decodedImageWithImage:</code> 的作用就是进行 <code>UIImage</code> 的解压缩操作，在图片下载完成或从磁盘缓存读取后，<strong>先利用 <code>CGBitmapContextCreate</code> 在子线程提前对 <code>UIImage</code> 进行解压缩，这样就避免了主线程的解压缩的操作，加快了图片的显示速度和流畅度，尤其是在快速滑动的列表中。</strong></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 逆向工程之 fishhook</title>
      <link href="/posts/61621/"/>
      <url>/posts/61621/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在上一篇文章整理了在插件开发中如何 HOOK 动态语言 Objective-C 中的方法，实际上静态语言 C 语言中的函数也是有办法 HOOK 的，这也说明了绝对的静态语言是不存在的。</p><p>为了实现 HOOK C 语言中的函数，我们需要用到 Facebook 的一个开源框架 fishhook，通过 fishhook 我们可以很轻松的 HOOK C 语言中的函数，从而达到修改函数功能的目的。</p><p>我在参考了 fishhook 官方 demo 和 Draveness 的文章后，发现对 C 函数的 HOOK 也是非常简单的。</p><p>在开始之前需要先简单了解两个概念：</p><p><strong>Mach-O：</strong>对于每个操作系统中的可执行程序都是有格式的，如 ELF 是 Linux 下可执行文件的格式，PE32／PE32+ 是 windows 的可执行文件的格式，那么对于 OS X 和 iOS 来说 Mach-O 是其可执行文件的格式。 OS X 和 iOS 开发中的可执行文件、库文件、Dsym 文件、动态库、动态连接器都是这种格式的。</p><p><strong>镜像：</strong>在 Mach-O 文件系统中，所有的可执行文件、dylib 以及 Bundle 都是镜像。</p><h2 id="二、fishhook的使用"><a href="#二、fishhook的使用" class="headerlink" title="二、fishhook的使用"></a>二、fishhook的使用</h2><p>我们先通过一个简单的 demo 去了解一下 fishhook 的使用，fishhook GitHub链接：<a href="https://github.com/facebook/fishhook">https://github.com/facebook/fishhook</a></p><p>下载下来 fishhook 后你会发现这个框架非常简单，只有两个文件“fishhook.h”和“fishhook.c”。</p><p>我们打开文件“fishhook.h”会发现只有一个结构体和两个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct rebinding &#123;</span><br><span class="line">  const char *name;</span><br><span class="line">  void *replacement;</span><br><span class="line">  void **replaced;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FISHHOOK_VISIBILITY</span><br><span class="line">int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel);</span><br><span class="line"></span><br><span class="line">FISHHOOK_VISIBILITY</span><br><span class="line">int rebind_symbols_image(void *header,</span><br><span class="line">                         intptr_t slide,</span><br><span class="line">                         struct rebinding rebindings[],</span><br><span class="line">                         size_t rebindings_nel);</span><br></pre></td></tr></table></figure><p>我们先看 <code>rebinding</code> 结构体，结构体中 <code>name</code> 是一个原始函数（要被替换的函数）名字符串，<code>replacement</code> 是替换后的新的函数指针，<code>replaced</code> 是我们自己创建的一个与原始函数签名相同（参数的个数、类型、顺序相同）的函数的指针的指针。关于 <code>rebinding</code> 暂且先不要纠结，后面看过代码就知道如何使用了。</p><p><code>rebind_symbols</code> 函数和 <code>rebind_symbols_image</code> 函数是用来 HOOK 函数的两个方法，只不过参数不同而已，前者比较简单，两个参数一个是 <code>rebinding</code> 数组，一个是数组中 <code>rebinding</code> 个数。后者就稍微复杂点，根据源码中的注释说明，该函数是在仅指定镜像的时候使用。所以，我们这里直接使用 <code>rebind_symbols</code> 函数就可以了。</p><p>C 语言中有个 <code>strlen</code> 函数，用来获取字符串的长度，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.m</span><br><span class="line">//  FishHookDemo</span><br><span class="line">//</span><br><span class="line">//  Created by 李峰峰 on 2017/7/2.</span><br><span class="line">//  Copyright © 2017年 李峰峰. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        char *str = &quot;imlifengfeng&quot;;</span><br><span class="line">        long result = strlen(str);</span><br><span class="line">        printf(&quot;结果:%ld\n&quot;,result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/lix_blog_153.png"></p><p>接下来我们就修改 <code>strlen</code> 函数的返回值，使无论字符串真实长度是什么，都返回 666。我们使用前面说到的 <code>rebind_symbols</code> 函数去实现。</p><p>首先我们要声明一个与 <code>strlen</code> 函数签名相同的函数，方法名任意，我们定义为 <code>original_strlen</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int (*original_strlen)(const char *__s);</span><br></pre></td></tr></table></figure><p>然后再定义一个替换后的函数，使其不管参数是什么直接返回 666，方法名也任意，我们定义为 <code>new_strlen</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int new_strlen(const char *__s) &#123;</span><br><span class="line">    return 666;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们就使用 <code>rebind_symbols</code> 函数进行绑定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct rebinding strlen_rebinding = &#123; &quot;strlen&quot;, new_strlen, (void *)&amp;original_strlen &#125;;</span><br><span class="line">rebind_symbols((struct rebinding[1])&#123;strlen_rebinding&#125;, 1);</span><br></pre></td></tr></table></figure><p>上面这些操作完成之后再调用 <code>strlen</code> 函数无论字符串真实长度是什么都会直接返回 666。完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.m</span><br><span class="line">//  FishHookDemo2</span><br><span class="line">//</span><br><span class="line">//  Created by 李峰峰 on 2017/7/2.</span><br><span class="line">//  Copyright © 2017年 李峰峰. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;fishhook.h&quot;</span><br><span class="line"></span><br><span class="line">static int (*original_strlen)(const char *__s);</span><br><span class="line"></span><br><span class="line">int new_strlen(const char *__s) &#123;</span><br><span class="line">    return 666;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        struct rebinding strlen_rebinding = &#123; &quot;strlen&quot;, new_strlen, (void *)&amp;original_strlen &#125;;</span><br><span class="line">        rebind_symbols((struct rebinding[1])&#123;strlen_rebinding&#125;, 1);</span><br><span class="line">        char *str = &quot;imlifengfeng&quot;;</span><br><span class="line">        long test = strlen(str);</span><br><span class="line">        printf(&quot;结果:%ld\n&quot;,test);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/lix_blog_154.png"></p><p>可以看到我们已经达到了 HOOK C 函数的目的，已经理解的可以自己尝试 HOOK 一些其他的函数去实现一些更复杂的功能。</p><h2 id="三、fishhook的原理"><a href="#三、fishhook的原理" class="headerlink" title="三、fishhook的原理"></a>三、fishhook的原理</h2><h3 id="1、Mach-O"><a href="#1、Mach-O" class="headerlink" title="1、Mach-O"></a>1、Mach-O</h3><p>前面提到了 Mach-O 是 OS X 和 iOS 可执行文件的格式，我们这里再来简单看下 Mach-O 文件格式的结构，无需深究。</p><p>每一个 Mach-O 文件都会被分为不同的 Segments，比如 <code>__TEXT</code>, <code>__DATA</code>, <code>__LINKEDIT</code>：</p><p><img src="/images/lix_blog_155.png"></p><p>Mach-O 中的 <code>segment_command</code>（32 位与 64 位不同）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct segment_command_64 &#123; /* for 64-bit architectures */</span><br><span class="line">    uint32_t    cmd;        /* LC_SEGMENT_64 */</span><br><span class="line">    uint32_t    cmdsize;    /* includes sizeof section_64 structs */</span><br><span class="line">    char        segname[16];    /* segment name */</span><br><span class="line">    uint64_t    vmaddr;     /* memory address of this segment */</span><br><span class="line">    uint64_t    vmsize;     /* memory size of this segment */</span><br><span class="line">    uint64_t    fileoff;    /* file offset of this segment */</span><br><span class="line">    uint64_t    filesize;   /* amount to map from the file */</span><br><span class="line">    vm_prot_t   maxprot;    /* maximum VM protection */</span><br><span class="line">    vm_prot_t   initprot;   /* initial VM protection */</span><br><span class="line">    uint32_t    nsects;     /* number of sections in segment */</span><br><span class="line">    uint32_t    flags;      /* flags */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个 <code>segment_command</code> 中又包含了不同的 <code>section</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct section_64 &#123; /* for 64-bit architectures */</span><br><span class="line">    char        sectname[16];   /* name of this section */</span><br><span class="line">    char        segname[16];    /* segment this section goes in */</span><br><span class="line">    uint64_t    addr;       /* memory address of this section */</span><br><span class="line">    uint64_t    size;       /* size in bytes of this section */</span><br><span class="line">    uint32_t    offset;     /* file offset of this section */</span><br><span class="line">    uint32_t    align;      /* section alignment (power of 2) */</span><br><span class="line">    uint32_t    reloff;     /* file offset of relocation entries */</span><br><span class="line">    uint32_t    nreloc;     /* number of relocation entries */</span><br><span class="line">    uint32_t    flags;      /* flags (section type and attributes)*/</span><br><span class="line">    uint32_t    reserved1;  /* reserved (for offset or index) */</span><br><span class="line">    uint32_t    reserved2;  /* reserved (for count or sizeof) */</span><br><span class="line">    uint32_t    reserved3;  /* reserved */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、dyld-与动态链接"><a href="#2、dyld-与动态链接" class="headerlink" title="2、dyld 与动态链接"></a>2、dyld 与动态链接</h3><p>dyld（the dynamic link editor）是 Apple 的动态链接器（GitHub地址：<a href="https://github.com/opensource-apple/dyld">dyld</a>），系统 kernel 做好启动程序的初始准备后，交给 dyld 负责，关于其作用顺序，可参考文章《<a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html">dyld: Dynamic Linking On OS X</a>》，相关部分翻译内容如下：<br>（1）从kernel留下的原始调用栈引导和启动自己<br>（2）将程序依赖的动态链接库递归加载进内存，当然这里有缓存机制<br>（3）non-lazy符号立即link到可执行文件，lazy的存表里<br>（4）运行可执行文件的静态初始化程序<br>（5）找到可执行文件的main函数，准备参数并调用<br>（6）程序执行中负责绑定lazy符号、提供runtime dynamic loading services、提供调试器接口<br>（7）程序main函数return后执行static terminator<br>（8）某些场景下main函数结束后调libSystem的_exit函数</p><p>一句话总结就是：负责将各种各样程序需要的镜像加载到程序运行的内存空间中！</p><p>其作用的时间是 OC 运行时初始化之前！</p><p>dyld 加载镜像后会执行相关回调函数，当一个镜像被动态链接时，都会执行回调 <code>void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)</code>，传入文件的 <code>mach_header</code> 以及一个虚拟内存地址 <code>intptr_t</code>。</p><p>我们先使用 Xcode 新建一个简单的 C 项目，项目名为 test ,项目新建后默认 main.c 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.c</span><br><span class="line">//  test</span><br><span class="line">//</span><br><span class="line">//  Created by 李峰峰 on 2017/7/4.</span><br><span class="line">//  Copyright © 2017年 李峰峰. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // insert code here...</span><br><span class="line">    printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们打开终端 cd 到 main.c 文件目录，使用 gcc 命令编译  main.c 源文件生成可执行文件，执行完成后会生成名为 a.out 的可执行文件。之后通过 nm 命令查看可执行文件中的符号：</p><p><img src="/images/lix_blog_156.png"></p><p>从上图可以看出，<code>_printf</code> 这个符号是未定义（<code>undefined</code>）的，换句话说，编译器还不知道这个符号对应什么东西。</p><p>那如果我们自己增加一个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.c</span><br><span class="line">//  test</span><br><span class="line">//</span><br><span class="line">//  Created by 李峰峰 on 2017/7/4.</span><br><span class="line">//  Copyright © 2017年 李峰峰. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // insert code here...</span><br><span class="line">    printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那结果是什么样的呢？如下：<br><img src="/images/lix_blog_158.png"></p><p>可见我们手动添加的 <code>test</code> 函数所对应的符号 <code>_test</code> 并不是为定义的，它包含一个内存地址以及 <code>__TEXT</code> 段。</p><p>为了更深入理解，我们需要用到一个神器 Hopper Disassembler ，这是一个类似于 IDA 的反汇编工具，个人感觉它比 IDA 好用的多，感兴趣的可以自己从网上下载，它最新图标是下面这样的：</p><p><img src="/images/lix_blog_157.png"></p><p>我们使用该工具分析一下之前的 a.out 的可执行文件：</p><p><img src="/images/lix_blog_159.png"></p><p>可以发现 <code>nm</code> 打印出的另一个符号 <code>dyld_stub_binder</code> 对应另一个同名函数。<code>dyld_stub_binder</code> 会在目标符号（例如 <code>printf</code>）被调用时，将其链接到指定的动态链接库 <code>libSystem</code>，再执行 <code>printf</code> 的实现（<code>printf</code> 符号位于 <code>__DATA</code> 端中的 <code>lazy</code> 符号表中）。</p><p>每一个镜像中的 <code>__DATA</code> 端都包含两个与动态链接有关的表，其中一个是 <code>__nl_symbol_ptr</code>，另一个是 <code>__la_symbol_ptr</code>：</p><ul><li><p><code>__nl_symbol_ptr</code> 中的 non-lazy 符号是在动态链接库绑定的时候进行加载的</p></li><li><p><code>__la_symbol_ptr</code> 中的符号会在该符号被第一次调用时，通过 dyld 中的 <code>dyld_stub_binder</code> 过程来进行加载</p></li></ul><p>在上述代码调用 <code>printf</code> 时，由于符号是没有被加载的，就会通过 <code>dyld_stub_binder</code> 动态绑定符号：</p><p><img src="/images/lix_blog_160.png"></p><h3 id="3、fishhook-的原理"><a href="#3、fishhook-的原理" class="headerlink" title="3、fishhook 的原理"></a>3、fishhook 的原理</h3><p>dyld 通过更新 Mach-O 二进制文件 <code>__DATA</code> 段中的一些指针来绑定 <code>lazy</code> 和 <code>non-lazy</code> 的符号；而 fishhook 先确定某一个符号在 <code>__DATA</code> 段中的位置，然后保存原符号对应的函数指针，并使用新的函数指针覆盖原有符号的函数指针，实现重绑定。</p><p>对于前面我们 HOOK <code>strlen</code> 函数的例子，过程如下图示：</p><p><img src="/images/lix_blog_161.png"></p><p>其中最复杂的部分就是从二进制文件中寻找某个符号的位置，在 fishhook 的 README 中，有这样一张图：</p><p><img src="/images/lix_blog_162.png"></p><p>这张图初看很复杂，不过它演示的是寻找符号的过程，我们根据这张图来分析一下这个过程：</p><ol><li><p>从 <code>__DATA</code> 段中的 <code>lazy</code> 符号指针表中查找某个符号，获得这个符号的偏移量 1061，然后在每一个 section_64 中查找 reserved1，通过这两个值找到 Indirect Symbol Table 中符号对应的条目</p></li><li><p>在 Indirect Symbol Table 找到符号表指针以及对应的索引 16343 之后，就需要访问符号表</p></li><li><p>然后通过符号表中的偏移量，获取字符串表中相关函数的符号</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 逆向工程之插件开发</title>
      <link href="/posts/37809/"/>
      <url>/posts/37809/</url>
      
        <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>iOS 逆向工程是指在软件层面上进行逆向分析的一个过程，基于 iOS 逆向工程技术，我们可以监控甚至改变 APP 的运行逻辑，从而达到获取核心信息，了解软件设计原理等目的。通过一段时间对 iOS 逆向工程的研究发现很有趣，会在博客记录学习开发过程中的心得和笔记。</p><h3 id="二、用到的设备或工具"><a href="#二、用到的设备或工具" class="headerlink" title="二、用到的设备或工具"></a>二、用到的设备或工具</h3><ul><li>一台越狱设备：iPhone 手机越狱和 Android 手机 ROOT 一样非常简单，具体的越狱方法网上很多，这里不在讨论。</li><li>Cydia：一般越狱过的手机都会自动被安装该软件，相当于App Store，可以搜索安装越狱app，也可以用来管理（卸载）我们开发的插件。</li><li>Theos：越狱开发工具包。</li><li>ldid：模拟给 iPhone 签名的流程，使我们能够在真实的设备上安装越狱的 apps&#x2F;hacks。</li><li>dkpg：一个 Debian 的一个命令行工具，它可以用来安装、删除、构建和管理 Debian 的软件包。</li></ul><h3 id="三、软件或工具的介绍与安装"><a href="#三、软件或工具的介绍与安装" class="headerlink" title="三、软件或工具的介绍与安装"></a>三、软件或工具的介绍与安装</h3><h4 id="1、Theos"><a href="#1、Theos" class="headerlink" title="1、Theos"></a>1、Theos</h4><p>越狱开发中除了 Thoes 外还有一个叫 iOSOpenDev 的工具，功能和 Thoes 是一样的，不同点是 iOSOpenDev 是整合到 Xcode 中使用的，通过本人亲身实践发现使用 Thoes 开发更简单方便，感兴趣的可以去了解下 iOSOpenDev，这里不再讲解，个人建议使用 Thoes，本文也将以 Thoes 为基础进行开发。</p><p><strong>安装 Thoes 方法如下：</strong><br>首先设置环境变量，我们将 Thoes 安装在 &#x2F;opt&#x2F;theos 中，打开 terminal 然后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export THEOS=/opt/theos</span><br></pre></td></tr></table></figure><p>通过在命令行执行 <code>echo $THEOS</code> 可以看到这个变量是否正确设置。每次你打开 terminal 都需要重新设置一下。<br><img src="/images/lix_blog_141.png"></p><p>然后下载Theos：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git clone git://github.com/DHowett/theos.git $THEOS</span><br></pre></td></tr></table></figure><p>之后会提示输入密码，输入密码等待下载完成即可。</p><h4 id="2、ldid"><a href="#2、ldid" class="headerlink" title="2、ldid"></a>2、ldid</h4><p>ldid 是一个用来给 iOS 可执行程序签名的工具，使我们开发的越狱 APP 或者插件能够安装到越狱手机上。<br>我们可以从<a href="http://joedj.net/ldid">http://joedj.net/ldid</a>上下载 ldid 后拷贝到“&#x2F;opt&#x2F;theos&#x2F;bin&#x2F;”目录中，然后使用下面命令行赋予可执行权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /opt/theos/bin/ldid</span><br></pre></td></tr></table></figure><h4 id="3、dkpg"><a href="#3、dkpg" class="headerlink" title="3、dkpg"></a>3、dkpg</h4><p>Dpkg 能够把你的 APP 打包成 Debian Package，可以分发的 Cydia 的存储目录中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install dpkg</span><br></pre></td></tr></table></figure><h4 id="4、配置-libsubstrate-dylib"><a href="#4、配置-libsubstrate-dylib" class="headerlink" title="4、配置 libsubstrate.dylib"></a>4、配置 libsubstrate.dylib</h4><p>在开始开发之前，还需要下载 libsubstrate.dylib，然后 copy 到“&#x2F;opt&#x2F;theos&#x2F;lib”目录下即可，点击下载：<a href="http://www.mediafire.com/?2upm53uzzj0488u">libsubstrate.dylib</a></p><p>由于某些的原因，访问国外网站需要梯子，如果你没有梯子，可以从我网盘下载：<br><a href="http://pan.baidu.com/s/1hsL0llM">http://pan.baidu.com/s/1hsL0llM</a></p><p>最后我们在开发之前可以看下 Theos 中的模板，执行如下命令可以看到默认存在的模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$THEOS/bin/nic.pl</span><br></pre></td></tr></table></figure><p>有的人会在使用模板创建项目的时候会有如下提示：<br><img src="/images/lix_blog_142.png"></p><p>原因是没有执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export THEOS=/opt/theos</span><br></pre></td></tr></table></figure><p>上面已经说了，每次都要执行一次，如果不想每次都执行也可以直接使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/theos/bin/nic.pl</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_143.png"></p><p>可以看到上面一共有 17 个模板。<br>实际上安装 后默认只有 12 个模板，想要添加更多模板，可以从[<a href="https://github.com/DHowett/theos-nic-">https://github.com/DHowett/theos-nic-</a> templates&#x2F;archive&#x2F;master.zip55.tar](<a href="https://github.com/DHowett/theos-nic-">https://github.com/DHowett/theos-nic-</a> templates&#x2F;archive&#x2F;master.zip55.tar)下载额外的 5 个模板，下载后解压得到的 5 个 .tar 文件复制到“&#x2F;opt&#x2F;theos&#x2F;templates&#x2F;iphone&#x2F;”目录下即可。</p><h3 id="四、创建工程"><a href="#四、创建工程" class="headerlink" title="四、创建工程"></a>四、创建工程</h3><p>首先介绍一下本教程所写插件实现的功能：“修改”设备信息。实际上对于系统硬件信息是不能修改的，但是我们可以修改获取设备信息的方法的返回值，比如我们获取系统版本用如下方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[UIDevice currentDevice] systemVersion];</span><br></pre></td></tr></table></figure><p>如果我们的系统是 10.0.2 版本，该方法会返回字符串“10.0.2”，我们要做的就是当别的 APP 调用上面方法时，我们拦截住并返回一个我们设定的任意值，比如我们让上面方法返回 “11.0.2”，这就是传说中的 HOOK。</p><p>首先我们新建一个文件夹 MyDemo，cd 到该文件夹中，然后按照上面所说的，我们使用如下命令查看与选择模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$THEOS/bin/nic.pl</span><br></pre></td></tr></table></figure><p><img src="/images/lix_blog_144.png"></p><p>我们选择模板 15（iphone&#x2F;tweak），之后根据提示输入 Project Name（tweak 工程名）、Package Name（deb 包的名字，类似于bundle identifier）、Author（作者）、Bundle filter（tweak作用对象的 bundle identifier）即可，具体的根据实际情况填写。<br><img src="/images/lix_blog_145.png"></p><p>最后在 MyDemo 目录中生成的文件如下：<br><img src="/images/lix_blog_146.png"></p><p>介绍一下上面的几个文件：<br><strong>(1) control 文件</strong><br>主要记录的 deb 包管理系统所需要的基本信息，会被打包进 deb 包中，该文件中主要是我们创建工程时所填写的信息，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Package: com.imlifengfeng.tweakdemo</span><br><span class="line">Name: tweakdemo</span><br><span class="line">Depends: mobilesubstrate</span><br><span class="line">Version: 0.0.1</span><br><span class="line">Architecture: iphoneos-arm</span><br><span class="line">Description: An awesome MobileSubstrate tweak!</span><br><span class="line">Maintainer: imlifengfeng</span><br><span class="line">Author: imlifengfeng</span><br><span class="line">Section: Tweaks</span><br></pre></td></tr></table></figure><p><strong>(2) Makefile 文件</strong><br>用于指定工程用到的文件、框架、库等信息，将整个过程自动化，文件默认内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">include $(THEOS)/makefiles/common.mk</span><br><span class="line"></span><br><span class="line">TWEAK_NAME = tweakdemo</span><br><span class="line">tweakdemo_FILES = Tweak.xm</span><br><span class="line"></span><br><span class="line">include $(THEOS_MAKE_PATH)/tweak.mk</span><br><span class="line"></span><br><span class="line">after-install::</span><br><span class="line">install.exec &quot;killall -9 SpringBoard&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意一下上面第一行，如果在使用命令行做操作（如打包、安装）时，如果没有执行下面命令会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export THEOS=/opt/theos</span><br></pre></td></tr></table></figure><p>这个是新手容易犯的错误，还是一样，想省事也可以把上面第一行直接改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include /opt/theos/makefiles/common.mk</span><br></pre></td></tr></table></figure><p>我们需要在 Makefile 文件中做一些配置：</p><p>设置我们用到的框架：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tweakDemo_FRAMEWORKS = UIKit CoreGraphics</span><br></pre></td></tr></table></figure><p>注意一下前缀 tweakDemo，这是你的项目名，根据自己项目名填写。</p><p>指定 iOS SDK 版本（这里指定采用最新版 SDK，插件适用最低版本9.0）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TARGET = iphone:latest:9.0</span><br></pre></td></tr></table></figure><p>上面的 latest 可以也设置成具体版本，如 10.0。<br>已连接目标真机的IP：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOS_DEVICE_IP=192.168.2.61</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里使用的 ssh 连接的，关于连接真机，有个注意的一点是最新的越狱方法已经不再需要手机安装 OpenSSH 插件了，安装后反而无法连接。但是 OpenSSH 功能是默认禁用的，需要手动开启。开启方法也很简单，在 Cydia 中搜索 Filza 并安装，进入以下路径：&#x2F;private&#x2F;var&#x2F;containers&#x2F;Bundle&#x2F;Application&#x2F;yalu102&#x2F;yalu102.app&#x2F;，用文本编辑器打开 dropbear.plist 文件，替换 127.0.0.1:22 为 22，重启设备，重新使用越狱工具恢复越狱即可。</p><p>最终配置完后的文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">include /opt/theos/makefiles/common.mk</span><br><span class="line"></span><br><span class="line">TWEAK_NAME = tweakDemo</span><br><span class="line">tweakDemo_FILES = Tweak.xm</span><br><span class="line">tweakDemo_FRAMEWORKS = UIKit CoreGraphics</span><br><span class="line">TARGET = iphone:latest:9.0</span><br><span class="line">THEOS_DEVICE_IP=192.168.2.61</span><br><span class="line">include /opt/theos/makefiles/tweak.mk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">after-install::</span><br><span class="line">install.exec &quot;killall -9 SpringBoard&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>(3) Tweak.xm 文件</strong><br>该文件就是我们写相关代码的文件，使用的是 Logos 语言。</p><p><strong>(4) tweakdemo.plist文件</strong><br>这个文件主要用来设置插件的作用范围，对哪些 APP 有效，比如可以设置哪些 APP 调用我们 HOOK 的方法时返回我们设定的值。</p><p>用 Xcode 打开其内容如下：<br><img src="/images/lix_blog_147.png"></p><p>用Sublime等编辑器打开内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; Filter = &#123; Bundles = ( &quot;com.apple.springboard&quot; ); &#125;; &#125;</span><br></pre></td></tr></table></figure><p>写完相关的代码记得把作用的 APP 的 bundle identifier 加上。</p><h3 id="五、插件代码编写"><a href="#五、插件代码编写" class="headerlink" title="五、插件代码编写"></a>五、插件代码编写</h3><p>上面介绍了生成的几个文件，可以知道我们在 Tweak.xm 文件中写 Tweak 代码。我们要实现的功能就是 HOOK 获取设备信息的方法，为了验证效果，我们先写一个 APP（bundle identifier 为imlifengfeng.InfoGetter）用来获取设备信息，界面如下：<br><img src="/images/lix_blog_148.png"><br>核心代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ViewController.m</span><br><span class="line">//  InfoGetter</span><br><span class="line">//</span><br><span class="line">//  Created by 李峰峰 on 2017/6/20.</span><br><span class="line">//  Copyright © 2017年 李峰峰. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (weak, nonatomic) IBOutlet UILabel *infoLabel;//信息显示Label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)nameBtnClick:(id)sender &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *deviceName = [[UIDevice currentDevice] name];</span><br><span class="line">    _infoLabel.text = deviceName;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)versionBtnClick:(id)sender &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *sysVersion = [[UIDevice currentDevice] systemVersion];</span><br><span class="line">    _infoLabel.text = sysVersion;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)modelBtnClick:(id)sender &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *deviceModel = [[UIDevice currentDevice] model];</span><br><span class="line">    _infoLabel.text = deviceModel;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>也就是说我们要HOOK住的三个方法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[UIDevice currentDevice] name]</span><br><span class="line">[[UIDevice currentDevice] systemVersion]</span><br><span class="line">[[UIDevice currentDevice] model]</span><br></pre></td></tr></table></figure><p>开始写之前先简单下 Logos 语言，非常简单：<br><strong>(1) %hook</strong><br>指定需要 hook 的 class，必须以 <code>%end</code> 结尾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">- (void)_menuButtonDown:(id)down</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;你好&quot;);</span><br><span class="line">    %orig;//call the original _menuButtonDown;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>这段代码的意思是勾住(hook) <code>_SpringBoard_</code> 类里的<code>__menuButtonDown:_</code> 函数，先将一句话写入 <code>_syslog_</code> , 再执行函数的原有操作。</p><p><strong>(2) %log</strong><br>该指令在 <code>%hook</code> 内部使用，将函数的类名、参数等信息写入 <code>syslog</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%hoot SpringBoard</span><br><span class="line">- (void)_menubuttonDown:(id)down</span><br><span class="line">&#123;</span><br><span class="line">    %log((NSString *)@&quot;iOSRE&quot;,(NSString *)@&quot;Debug&quot;);</span><br><span class="line">    %orig;//call the original _menuButtonDown;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p><strong>(3) %orig</strong><br>该指令在 <code>_%hook_</code> 内部使用，执行被勾住(hook)的方法的原始代码。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">- (void)_menuButtonDown:(id)down</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;你好&quot;);</span><br><span class="line">    %orig; // </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>如果去掉 <code>_%orig_</code> 那么原始方法不会执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hook SpringBoard</span><br><span class="line">- (void)_menuButtonDown:(id)down</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;你好&quot;);</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>还可以利用 <code>_%orig_</code> 更改原始行数的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SBLockScreenDateViewController</span><br><span class="line">- (void)setCustomSubtitleText:(id)arg1 withColor:(id)arg2</span><br><span class="line">&#123;</span><br><span class="line">    %orig(@&quot;Re&quot;,arg2);</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>这个方法会改变锁屏界面的日期显示。</p><p><strong>(4) %group</strong><br>该指令用于将<code>_ %hook _</code>分组，便于代码管理及按条件初始化分组，必须以 <code>_%end_</code> 结尾；一个<code>_ %group _</code>可以包含多个<code>_ %hook _</code>, 所有不属于某个自定义<code>_ group _</code>的<code>_ %hook _</code>会被隐式归类到<code>_ %group_ungroupes _</code>中。用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%group iOS7Hook</span><br><span class="line">%hook iOS7Class </span><br><span class="line">- (id)iOS7Method &#123;</span><br><span class="line">     id result = %orig; </span><br><span class="line">     NSLog(@&quot;This class &amp; method only exist in iOS 7.&quot;); </span><br><span class="line">     return result;</span><br><span class="line"> &#125; %end </span><br><span class="line">%end // iOS7Hook</span><br><span class="line"></span><br><span class="line">%group iOS8Hook </span><br><span class="line">%hook iOS8Class </span><br><span class="line">- (id)iOS8Method &#123;</span><br><span class="line">   id result = %orig; </span><br><span class="line">   NSLog(@&quot;This class &amp; method only exist in iOS 8.&quot;); return result;</span><br><span class="line"> &#125;</span><br><span class="line">%end</span><br><span class="line">%end // iOS8Hook</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>(5) %init</strong><br>该指令用于初始化某个 <code>_%group _</code>，必须在<code>_ %hook _</code>或<code>_ %ctor _</code>内调用；如果带参数，则初始化指定的 <code>group</code>，如果不带参数，则初始化 <code>__ungrouped_</code> ，如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ifndef kCFCoreFoundationVersionNumber_iOS_8_0 </span><br><span class="line">#define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10 #endif</span><br><span class="line">%hook SpringBoard </span><br><span class="line">- (void)applicationDidFinishLaunching:(id)application &#123;</span><br><span class="line">    %orig; </span><br><span class="line">    %init; // Equals to %init(_ungrouped)</span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp; kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_8_0)</span><br><span class="line">      %init(iOS7Hook);</span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_8_0)</span><br><span class="line">      %init(iOS8Hook);</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>只有调用了 <code>%init</code>，对应的 <code>%group</code> 才能起作用。</p><p><strong>(6) %new</strong><br>在 <code>_%hook_</code> 内部使用，给一个现有 <code>_class_</code> 加新函数，功能与 <code>_class_addMethod_</code> 相同。它的用法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard </span><br><span class="line">%new </span><br><span class="line">- (void)namespaceNewMethod &#123;</span><br><span class="line">     NSLog(@&quot;We&#x27;ve added a new method to SpringBoard.&quot;); </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p><strong>(7) %c</strong><br>该指令的作用等同于 <code>_objc_getClass_</code> 或 <code>_NSClassFromString_</code>，即动态获 一个类的定义,在 <code>_%hook_</code> 或 <code>_%ctor_</code> 内使用。</p><p>由于我们只是要 HOOK 住三个方法，所以我们只能用到 <code>%hook</code>。</p><p>具体怎么实现呢？非常简单，我们要 HOOK 的方法是 <code>UIDevice</code> 类中的 <code>name</code>、<code>systemVersion</code>、<code>model</code> 三个方法，所以我们在 Tweak.xm 文件中直接写代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;SpringBoard/SpringBoard.h&gt;</span><br><span class="line"></span><br><span class="line">%hook UIDevice</span><br><span class="line"></span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line"> return @&quot;我是假name&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)systemVersion</span><br><span class="line">&#123;</span><br><span class="line">    return @&quot;我是假systemVersion&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)model</span><br><span class="line">&#123;</span><br><span class="line">    return @&quot;我是假model&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>然后在 tweakdemo.plist 文件中加上上面我们写的测试 APP 的 bundle identifier，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; Filter = &#123; Bundles = ( &quot;com.apple.springboard&quot;,&quot;imlifengfeng.InfoGetter&quot;); &#125;; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后就可以安装插件到手机了，cd 进入项目目录，依次执行三个命令：make、make package、make install即可将插件安装到手机。<br>如果在安装（make install）时出现如下错误：<br><img src="/images/lix_blog_149.png"></p><p>只需要配置一下设备 IP 环境即可，用如下命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export THEOS_DEVICE_IP=192.168.2.61</span><br></pre></td></tr></table></figure><p>注意将上面 IP 改成你真机的 IP。</p><p>安装后在手机桌面是看不到插件的，可以通过 Cydia 查看或卸载：<br><img src="/images/lix_blog_150.png"></p><p>之后就可以通过我们的测试 APP 进行测试了，测试结果如下：<br><strong>安装插件前：</strong><br><img src="/images/lix_blog_151.png"></p><p><strong>安装插件后：</strong><br><img src="/images/lix_blog_152.png"></p><p>以上就是这个简单插件开发的整个过程。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
