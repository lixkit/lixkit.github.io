<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="李峰峰博客">
  <meta name="keyword" content="李峰峰, iOS, 底层原理">
  <meta name="baidu-site-verification" content="codeva-SYZlEXwvUN" />
  <meta name="sogou_site_verification" content="YdqRkfPyHk" />


  <meta name="description" content="一、概述提到线程，不得不讲下 CPU，CPU 是计算机的“大脑”，负责着程序的执行和数据的处理。 现代 CPU 基本都是多核 CPU，这里的“核”是指 CPU 的物理核心，物理核心是真正的硬件单元，负责执行指令。物理核心在执行某些类型的指令（如内存访问）时，可能会发生等待，这时核心的其他执行单元如 ALU（算术逻辑单元）可能处于闲置状态。在支持超线程（Hyper-Threading）的 CPU 上">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD 底层原理 5 - 线程池">
<meta property="og:url" content="https://www.lixkit.com/posts/34692/index.html">
<meta property="og:site_name" content="李峰峰博客">
<meta property="og:description" content="一、概述提到线程，不得不讲下 CPU，CPU 是计算机的“大脑”，负责着程序的执行和数据的处理。 现代 CPU 基本都是多核 CPU，这里的“核”是指 CPU 的物理核心，物理核心是真正的硬件单元，负责执行指令。物理核心在执行某些类型的指令（如内存访问）时，可能会发生等待，这时核心的其他执行单元如 ALU（算术逻辑单元）可能处于闲置状态。在支持超线程（Hyper-Threading）的 CPU 上">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_231.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_233.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_234.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_235.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_236.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_237.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_238.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_239.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_240.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_241.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_242.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_243.png">
<meta property="article:published_time" content="2022-12-17T01:27:00.000Z">
<meta property="article:modified_time" content="2025-03-14T00:26:48.901Z">
<meta property="article:author" content="李峰峰">
<meta property="article:tag" content="底层">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.lixkit.com/images/lix_blog_231.png">


  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      GCD 底层原理 5 - 线程池 | 李峰峰博客
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  

  
  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="李峰峰博客" type="application/atom+xml">
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>李峰峰博客</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">主页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">分类</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">主页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">分类</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>GCD 底层原理 5 - 线程池</h2>
  <p class="post-date">2022-12-17</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>提到线程，不得不讲下 CPU，CPU 是计算机的“大脑”，负责着程序的执行和数据的处理。</p>
<p>现代 CPU 基本都是多核 CPU，这里的“核”是指 CPU 的<strong>物理核心</strong>，物理核心是真正的硬件单元，负责执行指令。物理核心在执行某些类型的指令（如内存访问）时，可能会发生等待，这时核心的其他执行单元如 ALU（算术逻辑单元）可能处于闲置状态。在支持超线程（Hyper-Threading）的 CPU 上，每个物理核心通常可以提供两个<strong>逻辑核心</strong>，使得当一个逻辑核心在等待时，另一个逻辑核心可以利用闲置的执行单元来提前执行其他线程的指令。通过逻辑核心，操作系统可以调度更多的线程同时执行，这增强了系统的并发能力和响应速度。</p>
<p>所以，<strong>CPU 逻辑核心数量代表了最大并发处理数量参考上限，在逻辑核心数的范围内，操作系统可以提供较高性能的线程调度。</strong></p>
<p>但是，这并不代表系统所能并发执行的线程数量一定小于 CPU 逻辑核心数量，操作系统可以通过上下文切换在单个逻辑核心上交替执行多个线程。虽然可以调度更多线程，但同时活跃的线程数超过逻辑核心数可能导致资源竞争和性能下降，所以我们在开发时，应尽量避免创建太多的线程。</p>
<p>对于开发者来说，需要使用 OC 或者 Swift 这类高级语言去开发一个 APP，编译器会将我们使用高级语言编写的代码，会经过编译器的编译处理，先将高级语言代码转换成汇编代码，最后再将汇编代码转成 CPU 可以执行的机器码。</p>
<p>只看 CPU 的单个核（物理核心），CPU 核从程序的入口地址开始，逐条读取并执行机器指令。每个核心按照程序计数器（PC）的指引，顺序执行指令，除非遇到控制流改变的指令（如跳转、条件分支）。由于 CPU 单个核一次只能执行一个指令，所以每个 CPU 核只可以同时执行一个线程。</p>
<p>现代操作系统通过时间分片（时间片轮转）的方式实现了单个核心“同时”执行多个线程，时间片是操作系统分配给每个线程的执行时间段（通常是几十毫秒）。一个线程在其时间片内运行，时间片结束时，操作系统再切换到另一个线程继续执行。线程可以有不同的优先级，操作系统可能会优先调度高优先级的线程。在 iOS 中，优先级可以通过 GCD 的 QoS（服务质量）等级进行设置。</p>
<p>也就是说，我们开发的 iOS APP 可以执行的最大线程数量，是可以远大于 CPU 核心数量的。</p>
<p><strong>在 GCD 多线程开发中，经常会涉及一个“线程池”的概念，在提到 GCD 线程池时，经常有人说“GCD 线程池中线程最大数量是 64 个“、“GCD 最多可以创建 64 个线程”，其实这个说法是不完全正确的。</strong></p>
<h2 id="二、线程最大数量测试"><a href="#二、线程最大数量测试" class="headerlink" title="二、线程最大数量测试"></a>二、线程最大数量测试</h2><p>新建一个 macOS 的 Command Line Tool 的工程，用来测试全局队列、并发队列、串行队列最多可以创建多少个线程。</p>
<p>首先，先打印当前设备有多少个逻辑核心：<br><img src="/images/lix_blog_231.png"><br>可以看到，当前设备 CPU 的物理核心是 6 个，逻辑核心是 12 个。</p>
<p>为了看清 CPU 繁忙（<strong>活跃线程数量超过逻辑核心数量</strong>）和 CPU 空闲时，最大可创建线程的数量，需要针对两种常见分别测试。</p>
<h3 id="1、全局并发队列"><a href="#1、全局并发队列" class="headerlink" title="1、全局并发队列"></a>1、全局并发队列</h3><h4 id="（1）CPU-繁忙"><a href="#（1）CPU-繁忙" class="headerlink" title="（1）CPU 繁忙"></a>（1）CPU 繁忙</h4><p>通过下面 Demo 测试 CPU 在繁忙情况下，使用全局并发队列最多可创建多少个线程：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  李峰峰博客 https://www.lixkit.com/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Lix.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">                    <span class="comment">// 占用 CPU，模拟 CPU 繁忙情况</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/lix_blog_233.png"></p>
<p>去掉一个主线程，可以看到全局并发队列在 CPU 繁忙的情况下，最多可以创建 12 个线程，与 CPU 逻辑核心数量一致。</p>
<h4 id="（2）CPU-空闲情况"><a href="#（2）CPU-空闲情况" class="headerlink" title="（2）CPU 空闲情况"></a>（2）CPU 空闲情况</h4><p>将上面 Demo 中的 while 无限循环改成 sleep，使其不一直占用 CPU，模拟 CPU 空闲情况：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="comment">// 不占用 CPU，模拟 CPU 空闲情况</span></span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/lix_blog_234.png"><br>同样去掉一个主线程，可以看到全局并发队列在 CPU 空闲的情况下，最多可以创建 64个线程。</p>
<h4 id="（3）结论"><a href="#（3）结论" class="headerlink" title="（3）结论"></a>（3）结论</h4><p>全局队列最多可创建线程数量：</p>
<ul>
<li>CPU 繁忙时：与 CPU 逻辑核心数量一致</li>
<li>CPU 空闲时：64 个</li>
</ul>
<h3 id="2、并发队列"><a href="#2、并发队列" class="headerlink" title="2、并发队列"></a>2、并发队列</h3><p>测试并发队列时，每次循环都创建新的队列，测试在 CPU 繁忙、空闲情况下分别最多可以创建多少个线程。</p>
<h4 id="（1）CPU-繁忙情况"><a href="#（1）CPU-繁忙情况" class="headerlink" title="（1）CPU 繁忙情况"></a>（1）CPU 繁忙情况</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.lixkit.demo.%lu&quot;</span>, i];</span><br><span class="line">            <span class="comment">// 每次循环都是新的队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(label.UTF8String, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">                    <span class="comment">// 占用 CPU，模拟 CPU 繁忙情况</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/lix_blog_235.png"><br>去掉一个主线程，CPU 繁忙情况下，并发队列最多可以创建 12 个线程，和逻辑核心数量一致。</p>
<h4 id="（2）CPU-空闲情况-1"><a href="#（2）CPU-空闲情况-1" class="headerlink" title="（2）CPU 空闲情况"></a>（2）CPU 空闲情况</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.lixkit.demo.%lu&quot;</span>, i];</span><br><span class="line">            <span class="comment">// 每次循环都是新的队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(label.UTF8String, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="comment">// 不占用 CPU，模拟 CPU 空闲情况</span></span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/lix_blog_236.png"><br>去掉一个主线程，CPU 空闲情况下，并发队列最多可以创建 64 个线程。</p>
<h4 id="（3）结论-1"><a href="#（3）结论-1" class="headerlink" title="（3）结论"></a>（3）结论</h4><p>并发队列最多可创建线程数量：</p>
<ul>
<li>CPU 繁忙时：与 CPU 逻辑核心数量一致</li>
<li>CPU 空闲时：64 个</li>
</ul>
<p>与全局并发队列表现一致。</p>
<h3 id="3、串行队列"><a href="#3、串行队列" class="headerlink" title="3、串行队列"></a>3、串行队列</h3><p>测试串行队列和并发队列类似，只需要将循环里创建的队列改成串行队列即可。</p>
<h4 id="（1）CPU-繁忙情况-1"><a href="#（1）CPU-繁忙情况-1" class="headerlink" title="（1）CPU 繁忙情况"></a>（1）CPU 繁忙情况</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.lixkit.demo.%lu&quot;</span>, i];</span><br><span class="line">            <span class="comment">// 每次循环都是新的队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(label.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">                    <span class="comment">// 占用 CPU，模拟 CPU 繁忙情况</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了串行队列任务能派发完毕，这里延迟 1 秒</span></span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/lix_blog_237.png"><br>去掉一个主线程，在 CPU 繁忙情况下，串行队列最多可创建 512 个线程。</p>
<h4 id="（2）CPU-空闲情况-2"><a href="#（2）CPU-空闲情况-2" class="headerlink" title="（2）CPU 空闲情况"></a>（2）CPU 空闲情况</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.lixkit.demo.%lu&quot;</span>, i];</span><br><span class="line">            <span class="comment">// 每次循环都是新的队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(label.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="comment">// 不占用 CPU，模拟 CPU 空闲情况</span></span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了串行队列任务能派发完毕，这里延迟 1 秒</span></span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/lix_blog_238.png"><br>去掉一个主线程，在 CPU 空闲情况下，串行队列最多可创建 512 个线程。</p>
<h4 id="（3）结论-2"><a href="#（3）结论-2" class="headerlink" title="（3）结论"></a>（3）结论</h4><p><strong>无论 CPU 是否空闲，串行队列都最多可以创建 512 个线程。</strong></p>
<h3 id="4、并发队列-串行队列"><a href="#4、并发队列-串行队列" class="headerlink" title="4、并发队列 + 串行队列"></a>4、并发队列 + 串行队列</h3><p>经过上面的测试可以发现，在 CPU 空闲情况下，并发队列相较于 CPU 繁忙时，可以创建更多数量的线程，最多可以创建 64 个线程。而串行队列，无论 CPU 是否空闲，都最多可以创建多达 512 个线程。</p>
<p>那么，在 CPU 空闲情况下下，同时使用并发队列和串行队列，最多可创建的线程数量，是 512 还是 512 + 64 &#x3D; 576 个呢？</p>
<p>接下来通过 Demo 测试下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  李峰峰博客 https://www.lixkit.com/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Lix.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">            <span class="comment">// 串行队列</span></span><br><span class="line">            <span class="built_in">NSString</span> *serialLabel = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.lixkit.demo.serial.%lu&quot;</span>, i];</span><br><span class="line">            <span class="comment">// 每次循环都是新的队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(serialLabel.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="comment">// 不占用 CPU，模拟 CPU 空闲情况</span></span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 并发队列</span></span><br><span class="line">            <span class="built_in">NSString</span> *concurrentLabel = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.lixkit.demo.concurrent.%lu&quot;</span>, i];</span><br><span class="line">            <span class="comment">// 每次循环都是新的队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(concurrentLabel.UTF8String, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">            <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 i = %ld&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">                <span class="comment">// 不占用 CPU，模拟 CPU 空闲情况</span></span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了串行队列任务能派发完毕，这里延迟 1 秒</span></span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;在此处加断点看线程数量&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/lix_blog_239.png"><br>可以看到，同时使用并发队列和串行队列，最终可创建的线程数量，还是最多 512 个。</p>
<h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p>经过测试可以得出结论，关于不同队列可创建线程数量的结论如下：</p>
<ul>
<li><strong>全局队列、并发队列</strong><ul>
<li>CPU 繁忙时，最大可创建线程数量：为 CPU 逻辑核心数量。</li>
<li>CPU 空闲时，最大可创建线程数量：64 个。</li>
</ul>
</li>
<li><strong>串行队列</strong><ul>
<li>CPU 繁忙、空闲时，最大可创建线程数量均为：512 个。</li>
</ul>
</li>
<li><strong>并发队列 + 串行队列</strong><ul>
<li>两种队列一起使用，即使在 CPU 空闲时，最大可创建线程数量也为：512 个。</li>
</ul>
</li>
</ul>
<p>根据测试结果可知，“GCD 线程池中线程最大数量是 64 个“、“GCD 最多可以创建 64 个线程”这样的说法是不完全正确的。更准确的说法应该是：<strong>GCD 线程池中线程最大数量是 512 个，其中并发队列（含全局并发队列）最多可创建线程数量是 64 个，串行队列最多可创建线程数量是 512 个。其中，这个“线程池”是由内核 XNU 维护的。</strong></p>
<p>在上一篇文章<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a> 中已经分析过，<code>dispatch_async</code> 对于并发队列和串行队列申请线程的两个关键步骤如下：</p>
<ul>
<li><strong>初始化 <code>workqueue</code></strong><ul>
<li><code>pthread_workqueue_setup</code>（全局仅调用一次）初始化 <code>workqueue</code><ul>
<li>内部会调用 <code>workq_open</code> 函数（后续会分析该函数）</li>
</ul>
</li>
</ul>
</li>
<li><strong>申请线程</strong><ul>
<li><strong>并发队列</strong><ul>
<li>调用 <code>_pthread_workqueue_addthreads</code> 申请线程</li>
</ul>
</li>
<li><strong>串行队列</strong><ul>
<li>调用 <code>kevent_id</code> 申请线程</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>接下来，分别看下两种申请线程的方式分别是如何实现的。</p>
<h2 id="三、并发队列申请线程"><a href="#三、并发队列申请线程" class="headerlink" title="三、并发队列申请线程"></a>三、并发队列申请线程</h2><h3 id="1、-pthread-workqueue-addthreads"><a href="#1、-pthread-workqueue-addthreads" class="headerlink" title="1、_pthread_workqueue_addthreads"></a>1、_pthread_workqueue_addthreads</h3><p>并发队列通过 <code>_pthread_workqueue_addthreads</code> 函数申请线程去执行任务，该函数是 libpthread 提供的一个函数，函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 申请线程执行任务</span></span><br><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">///   - numthreads: 表示需要创建的线程数</span></span><br><span class="line"><span class="comment">///   - priority: 线程的优先级</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_pthread_workqueue_addthreads(<span class="type">int</span> numthreads, <span class="type">pthread_priority_t</span> priority)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__libdispatch_workerfunction == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> EPERM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">    <span class="comment">// 针对 macOS 系统的特殊处理</span></span><br><span class="line">    priority &amp;= ~_PTHREAD_PRIORITY_SCHED_PRI_FLAG;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用内核系统调用 `__workq_kernreturn`，请求添加线程。</span></span><br><span class="line">    <span class="comment">// 参数说明：</span></span><br><span class="line">    <span class="comment">// - WQOPS_QUEUE_REQTHREADS: 操作码，表示请求添加线程。</span></span><br><span class="line">    <span class="comment">// - NULL: 传递给内核的附加数据，这里为 NULL。</span></span><br><span class="line">    <span class="comment">// - numthreads: 要添加的线程数量。</span></span><br><span class="line">    <span class="comment">// - (int)priority: 线程的优先级，转换为 int 类型传递给内核。</span></span><br><span class="line">    res = __workq_kernreturn(WQOPS_QUEUE_REQTHREADS, <span class="literal">NULL</span>, numthreads, (<span class="type">int</span>)priority);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果系统调用返回 -1，表示发生错误。</span></span><br><span class="line">    <span class="comment">// 使用 `errno` 获取具体的错误码，并将其作为返回值。</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        res = errno; <span class="comment">// 获取错误码。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果，0 表示成功，非 0 表示失败。</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，该函数核心是调用 <code>__workq_kernreturn</code> 请求线程，并且调用  <code>__workq_kernreturn</code> 时，第一个参数传入的是 <code>WQOPS_QUEUE_REQTHREADS</code>。在<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a> 中已经分析过，调用 <code>_pthread_workqueue_addthreads</code> 时，传入的 <code>numthreads</code> 参数为 <code>1</code>，即每次请求一个线程。可以看到，这个 <code>numthreads</code> 参数也是透传给了 <code>__workq_kernreturn</code>。</p>
<h3 id="2、-workq-kernreturn"><a href="#2、-workq-kernreturn" class="headerlink" title="2、__workq_kernreturn"></a>2、__workq_kernreturn</h3><p><code>__workq_kernreturn</code> 是 XNU 内核提供的一个函数，<code>__workq_kernreturn</code> 本质是个系统调用，在内核态对应 <code>workq_kernreturn</code> 函数，该函数精简后的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">workq_kernreturn</span><span class="params">(<span class="keyword">struct</span> proc *p, <span class="keyword">struct</span> workq_kernreturn_args *uap, <span class="type">int32_t</span> *retval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (options) &#123;</span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WQOPS_QUEUE_REQTHREADS: &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * arg2 = number of threads to start</span></span><br><span class="line"><span class="comment">         * arg3 = priority</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        error = workq_reqthreads(p, arg2, arg3, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述逻辑中，如果 <code>options</code> 是 <code>WQOPS_QUEUE_REQTHREADS</code>，则会调用 <code>workq_reqthreads</code> 请求线程。</p>
<h3 id="3、workq-reqthreads"><a href="#3、workq-reqthreads" class="headerlink" title="3、workq_reqthreads"></a>3、workq_reqthreads</h3><p>在看 <code>workq_reqthreads</code> 函数之前，先看下几个关键的宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WORKQUEUE_MAXTHREADS            	512</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 512</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> wq_max_threads              = WORKQUEUE_MAXTHREADS; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 512 / 8 = 64		</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> wq_max_constrained_threads  = WORKQUEUE_MAXTHREADS / <span class="number">8</span>;	</span><br></pre></td></tr></table></figure>
<p>在前面几篇文章里，反复提到了 <code>workqueue</code>，这里看下 <code>workqueue</code> 的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前 workqueue 中的线程总数，包括运行中的线程、空闲线程和正在终止的线程。</span></span><br><span class="line">    <span class="type">uint16_t</span>        wq_nthreads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲的线程数</span></span><br><span class="line">    <span class="type">uint16_t</span>        wq_thidlecount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前进程结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>    *<span class="title">wq_proc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在运行任务的线程链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workq_uthread_head</span> <span class="title">wq_thrunlist</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新创建但尚未使用的线程列表，也属于空闲线程，但与 wq_thidlelist 分开存储</span></span><br><span class="line">    <span class="comment">// wq_thidlecount 数量计算包含了新建的线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workq_uthread_head</span> <span class="title">wq_thnewlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲线程链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workq_uthread_head</span> <span class="title">wq_thidlelist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>每个进程都有一个 <code>workqueue</code>，<code>workqueue</code> 中存储了一系列线程池管理相关的内容，包含线程总数、空闲的线程数等。其中，<code>workq_uthread_head</code> 定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TAILQ_HEAD(workq_uthread_head, uthread);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_HEAD(name, type)                                          \</span></span><br><span class="line"><span class="meta">__MISMATCH_TAGS_PUSH                                                    \</span></span><br><span class="line"><span class="meta">__NULLABILITY_COMPLETENESS_PUSH                                         \</span></span><br><span class="line"><span class="meta">struct name &#123;                                                           \</span></span><br><span class="line"><span class="meta">	struct type *tqh_first; <span class="comment">/* first element */</span>                     \</span></span><br><span class="line"><span class="meta">	struct type **tqh_last; <span class="comment">/* addr of last next element */</span>         \</span></span><br><span class="line"><span class="meta">	TRACEBUF                                                        \</span></span><br><span class="line"><span class="meta">&#125;   </span></span><br></pre></td></tr></table></figure>
<p>所以，GCD 的线程池是使用双向链表的结构来存储线程的。</p>
<p>再继续看下 <code>workq_reqthreads</code> 函数，<code>workq_reqthreads</code> 是 GCD 请求线程的入口函数，该函数参数及实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GCD 请求线程的入口点，负责根据请求的线程数量和优先级，创建或分配线程，并将其绑定到工作队列中。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param p 当前进程的指针</span></span><br><span class="line"><span class="comment"> * @param reqcount 请求的线程数量</span></span><br><span class="line"><span class="comment"> * @param pp 线程优先级</span></span><br><span class="line"><span class="comment"> * @param cooperative 是否为协作线程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 返回 0 表示成功，非 0 表示失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">workq_reqthreads</span><span class="params">(<span class="keyword">struct</span> proc *p, <span class="type">uint32_t</span> reqcount, <span class="type">pthread_priority_t</span> pp, <span class="type">bool</span> cooperative)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 提取线程优先级的 QoS 值</span></span><br><span class="line">    <span class="type">thread_qos_t</span> qos = _pthread_priority_thread_qos(pp);</span><br><span class="line">    <span class="comment">// 获取当前进程的 workqueue</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue</span> *<span class="title">wq</span> =</span> proc_get_wqptr(p); </span><br><span class="line">    <span class="type">uint32_t</span> unpaced, upcall_flags = WQ_FLAG_THREAD_NEWSPI; </span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数校验：工作队列是否为空，线程请求数量是否合法，QoS 是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (wq == <span class="literal">NULL</span> || reqcount &lt;= <span class="number">0</span> || reqcount &gt; UINT16_MAX ||</span><br><span class="line">        qos == THREAD_QOS_UNSPECIFIED) &#123;</span><br><span class="line">        ret = EINVAL; <span class="comment">// 参数无效</span></span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志</span></span><br><span class="line">    WQ_TRACE_WQ(TRACE_wq_wqops_reqthreads | DBG_FUNC_NONE,</span><br><span class="line">        wq, reqcount, pp, cooperative);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配线程请求结构体</span></span><br><span class="line">    <span class="type">workq_threadreq_t</span> req = zalloc(workq_zone_threadreq);</span><br><span class="line">    priority_queue_entry_init(&amp;req-&gt;tr_entry);</span><br><span class="line">    req-&gt;tr_state = WORKQ_TR_STATE_NEW; </span><br><span class="line">    req-&gt;tr_qos   = qos; </span><br><span class="line">    <span class="type">workq_tr_flags_t</span> tr_flags = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果优先级包含超额提交标志，则设置相应标志</span></span><br><span class="line">    <span class="keyword">if</span> (pp &amp; _PTHREAD_PRIORITY_OVERCOMMIT_FLAG) &#123;</span><br><span class="line">        tr_flags |= WORKQ_TR_FLAG_OVERCOMMIT;</span><br><span class="line">        upcall_flags |= WQ_FLAG_THREAD_OVERCOMMIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是协作线程，则设置协作标志</span></span><br><span class="line">    <span class="keyword">if</span> (cooperative) &#123;</span><br><span class="line">        tr_flags |= WORKQ_TR_FLAG_COOPERATIVE;</span><br><span class="line">        upcall_flags |= WQ_FLAG_THREAD_COOPERATIVE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协作线程目前不支持并行请求多个线程</span></span><br><span class="line">        <span class="keyword">if</span> (reqcount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ret = ENOTSUP; <span class="comment">// 不支持的操作</span></span><br><span class="line">            <span class="keyword">goto</span> free_and_exit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验：线程请求不能同时是超额提交和协作线程</span></span><br><span class="line">    <span class="keyword">if</span> (workq_tr_is_cooperative(tr_flags) &amp;&amp;</span><br><span class="line">        workq_tr_is_overcommit(tr_flags)) &#123;</span><br><span class="line">        ret = EINVAL; <span class="comment">// 参数无效</span></span><br><span class="line">        <span class="keyword">goto</span> free_and_exit;</span><br><span class="line">    &#125;</span><br><span class="line">    req-&gt;tr_flags = tr_flags; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志</span></span><br><span class="line">    WQ_TRACE_WQ(TRACE_wq_thread_request_initiate | DBG_FUNC_NONE,</span><br><span class="line">        wq, workq_trace_req_id(req), req-&gt;tr_qos, reqcount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁 workqueue</span></span><br><span class="line">    workq_lock_spin(wq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、线程快速请求流程</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 workqueue 正在退出，则直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (_wq_exiting(wq)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> unlock_and_exit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当用户请求并行线程时，唤醒最多 (reqcount - 1) 个线程，</span></span><br><span class="line"><span class="comment">         * 以通知调度器当前的工作负载。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 最后一个请求或未通过准入检查的请求会被加入队列，</span></span><br><span class="line"><span class="comment">         * 并通过常规的创建线程路径处理。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果线程数量不足，则添加一个线程，但需要重新评估所有条件。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        unpaced = reqcount - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reqcount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 协作线程目前不支持并行请求多个线程</span></span><br><span class="line">            assert(!workq_threadreq_is_cooperative(req));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是非超额提交线程请求，则计算允许的并行线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (workq_threadreq_is_nonovercommit(req)) &#123;</span><br><span class="line">                unpaced = workq_constrained_allowance(wq, qos, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (unpaced &gt;= reqcount - <span class="number">1</span>) &#123;</span><br><span class="line">                    unpaced = reqcount - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验：并行线程创建路径目前不支持自定义工作循环参数</span></span><br><span class="line">        assert(!(req-&gt;tr_flags &amp; WORKQ_TR_FLAG_WL_PARAMS));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这是 workq_threadreq_bind_and_unlock() 的简化版本，负责绑定线程请求并解锁。</span></span><br><span class="line">        <span class="keyword">while</span> (unpaced &gt; <span class="number">0</span> &amp;&amp; wq-&gt;wq_thidlecount) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">uth</span>;</span></span><br><span class="line">            <span class="type">bool</span> needs_wakeup;</span><br><span class="line">            <span class="type">uint8_t</span> uu_flags = UT_WORKQ_EARLY_BOUND;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是超额提交请求，则设置相应标志</span></span><br><span class="line">            <span class="keyword">if</span> (workq_tr_is_overcommit(req-&gt;tr_flags)) &#123;</span><br><span class="line">                uu_flags |= UT_WORKQ_OVERCOMMIT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从空闲线程池中弹出一个线程</span></span><br><span class="line">            uth = workq_pop_idle_thread(wq, uu_flags, &amp;needs_wakeup);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新活动线程计数和调度计数</span></span><br><span class="line">            _wq_thactive_inc(wq, qos);</span><br><span class="line">            wq-&gt;wq_thscheduled_count[_wq_bucket(qos)]++;</span><br><span class="line">            workq_thread_reset_pri(wq, uth, req, <span class="comment">/*unpark*/</span> <span class="literal">true</span>); <span class="comment">// 重置线程优先级</span></span><br><span class="line">            wq-&gt;wq_fulfilled++; <span class="comment">// 增加已完成的线程请求计数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置线程的唤醒标志和请求</span></span><br><span class="line">            uth-&gt;uu_save.uus_workq_park_data.upcall_flags = upcall_flags;</span><br><span class="line">            uth-&gt;uu_save.uus_workq_park_data.thread_request = req;</span><br><span class="line">            <span class="keyword">if</span> (needs_wakeup) &#123;</span><br><span class="line">                workq_thread_wakeup(uth); <span class="comment">// 唤醒线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            unpaced--;</span><br><span class="line">            reqcount--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (unpaced &amp;&amp; wq-&gt;wq_nthreads &lt; wq_max_threads &amp;&amp;</span><br><span class="line">        (workq_add_new_idle_thread(p, wq, workq_unpark_continue,</span><br><span class="line">        <span class="literal">false</span>, <span class="literal">NULL</span>) == KERN_SUCCESS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 workqueue 正在退出，则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (_wq_exiting(wq)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> unlock_and_exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req-&gt;tr_count = (<span class="type">uint16_t</span>)reqcount;</span><br><span class="line">    <span class="comment">// 2、线程慢速请求流程</span></span><br><span class="line">    <span class="keyword">if</span> (workq_threadreq_enqueue(wq, req)) &#123;</span><br><span class="line">        <span class="comment">// 如果线程请求入队成功，则调度创建线程</span></span><br><span class="line">        workq_schedule_creator(p, wq, WORKQ_THREADREQ_CAN_CREATE_THREADS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁 workqueue</span></span><br><span class="line">    workq_unlock(wq); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">unlock_and_exit:</span><br><span class="line">    <span class="comment">// 解锁 workqueue</span></span><br><span class="line">    workq_unlock(wq); </span><br><span class="line">free_and_exit:</span><br><span class="line">    <span class="comment">// 释放线程请求结构体</span></span><br><span class="line">    zfree(workq_zone_threadreq, req); </span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>workq_reqthreads</code> 函数中 <code>workqueue *wq</code> 的获取方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前进程的 workqueue</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue</span> *<span class="title">wq</span> =</span> proc_get_wqptr(p); </span><br></pre></td></tr></table></figure>
<p>可以知道，每个进程都有一个共用的 <code>workqueue</code>。</p>
<p>从 <code>workq_reqthreads</code> 函数实现中可以看到有针对超额提交线程、受限线程等不同线程类型的处理逻辑，那超额提交线程、受限线程分别是什么呢？</p>
<p>GCD 在管理线程时，把线程大致分成了这么几类：</p>
<ul>
<li><strong>创建者线程（Creator Thread）</strong><ul>
<li>创建者线程是一个匿名线程，用来控制线程创建节奏。</li>
<li><code>workqueue</code> 只会有一个创建者线程。</li>
<li>创建者线程会被转换成普通工作线程传到用户态执行任务，并协调创建其他线程。</li>
</ul>
</li>
<li><strong>超额提交线程 (Overcommit Threads)</strong><ul>
<li>可以突破 CPU 最大并发限制的线程，可能会引发线程爆炸(Thread Explosion)，导致上下文切换开销剧增。<ul>
<li><strong>串行队列是 <code>Overcommit</code> 的</strong>，所以串行队列创建的是超额提交线程。</li>
</ul>
</li>
</ul>
</li>
<li><strong>受限线程 (Constrained Threads)</strong><ul>
<li>根据 CPU 最大并发能力限制最大并行线程数量的线程，可以避免过度使用系统资源。<ul>
<li><strong>并发队列（含全局队列）是非 <code>Overcommit</code> 的</strong>，所以并发队列创建的是受限线程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>除此之外，还有管理线程、协作线程中，但这些不是本次分析的关注点。</p>
<p>在<a href="https://www.lixkit.com/posts/12465/">《GCD 底层原理 2 - dispatch_queue》</a> 中已经得出过结论：并发队列是非 <code>overcommit</code> 的，串行队列是 <code>overcommit</code> 的。由于走进 <code>workq_reqthreads</code> 函数的主要是并发队列，所以这里只关注非 <code>overcommit</code> 的情况即可。</p>
<p><code>workq_reqthreads</code> 中的线程请求逻辑中，根据请求的线程数量 <code>reqcount</code> 分成了两部分逻辑，根据两部分逻辑的特点，姑且称之为<strong>「快速请求流程」</strong>和<strong>「慢速请求流程」</strong>：</p>
<ul>
<li><strong>快速请求流程</strong><ul>
<li>为了能快速处理线程请求，加快线程调度速度。</li>
<li>当请求线程数量大于 1 时会先走快速请求流程。</li>
</ul>
</li>
<li><strong>慢速请求流程</strong><ul>
<li>更精细的线程调度方式，会根据所请求线程类型、优先级、CPU 负载情况，动态调整可创建线程数量。</li>
</ul>
</li>
</ul>
<p><strong><code>workq_reqthreads</code> 函数核心逻辑如下：</strong></p>
<ul>
<li><strong>获取当前进程的 <code>workqueue *wq</code></strong></li>
<li><strong>根据请求线程的数量 <code>reqcount</code> 决定走「快速请求流程」还是「慢速请求流程」</strong><ul>
<li><code>unpaced = reqcount - 1</code> 数量的请求走「快速请求流程」</li>
<li>剩余的 <code>1</code> 个请求走「慢速请求流程」</li>
</ul>
</li>
<li><strong>快速请求流程</strong><ul>
<li><font color=#ff0000>对于并发队列（队列是非 <code>overcommit</code> 的），则限制 <code>unpaced</code> 最大值为 CPU 逻辑核心数量</font><ul>
<li>这里调用 <code>workq_constrained_allowance</code> 获取 <code>unpaced</code> 最大值，该函数返回结果是 CPU 逻辑核心的数量</li>
</ul>
</li>
<li>如果线程池中的空闲线程数量 <code>wq_thidlecount</code> 足够，则通过 <code>while</code> 循环调用 <code>workq_pop_idle_thread</code> 从线程池中取 <code>unpaced</code> 个线程直接唤醒并使用。</li>
<li>如果线程池中的空闲线程已用完，且线程总数未达到上限 <code>wq_max_threads</code>（512），会调用 <code>workq_add_new_idle_thread</code> 创建新线程。否则将走慢速请求流程。</li>
<li>综上，对于并发队列，每次调用 <code>workq_reqthreads</code>，参与快速请求流程的线程请求数量最多是 CPU 逻辑核心的数量。</li>
</ul>
</li>
<li><strong>慢速请求流程</strong><ul>
<li>将线程请求入队，并调用 <code>workq_schedule_creator</code> 调度线程</li>
</ul>
</li>
</ul>
<p>但是，需要注意的是，并发队列调用 <code>workq_reqthreads</code> 时，<code>reqcount</code> 传入的参数是 <code>1</code>，且通过递归调用的方式多次调用 <code>workq_reqthreads</code> 每次申请一个线程（详情可看：<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a> ）。所以<strong>并发队列不会走进快速请求流程，而是直接走慢速请求流程。</strong></p>
<h3 id="4、workq-constrained-allowance"><a href="#4、workq-constrained-allowance" class="headerlink" title="4、workq_constrained_allowance"></a>4、workq_constrained_allowance</h3><p><code>workq_constrained_allowance</code> 函数用于根据 CPU 最大并发能力（CPU 逻辑核心数量）及受限线程数量限制，计算 CGD 是否还允许创建受限线程。</p>
<p>上面已经提到，在快速请求流程中，会调用 <code>workq_constrained_allowance</code> 获取并发队列最大参与快速请求流程的请求数量。但该函数有必要单独拿出来讲一下，<code>workq_constrained_allowance</code> 函数精简后的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算可以创建的受限制线程的数量</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">workq_constrained_allowance</span><span class="params">(<span class="keyword">struct</span> workqueue *wq, <span class="type">thread_qos_t</span> at_qos,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> uthread *uth, <span class="type">bool</span> may_start_timer, <span class="type">bool</span> record_failed_allowance)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(at_qos != WORKQ_THREAD_QOS_MANAGER);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录通过的许可数量，allowance_passed 是函数的返回值</span></span><br><span class="line">    <span class="type">uint32_t</span> allowance_passed = <span class="number">0</span>; </span><br><span class="line">    <span class="type">uint32_t</span> count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前已调度的受限线程数</span></span><br><span class="line">    <span class="type">uint32_t</span> max_count = wq-&gt;wq_constrained_threads_scheduled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果已调度线程数达到或超过最大受限线程数(64)，则不允许分配新线程</span></span><br><span class="line"><span class="comment">    * wq_max_constrained_threads = 64</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (max_count &gt;= wq_max_constrained_threads) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已调度线程数达到或超过最大线程数</span></span><br><span class="line">        allowance_passed = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 执行 out，直接返回 allowance_passed 的值 0</span></span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算剩余的可用线程数 max_count -= 64;</span></span><br><span class="line">    <span class="comment">// ⚠️ ：这里可能是一个 BUG</span></span><br><span class="line">    max_count -= wq_max_constrained_threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大并发数（CPU 逻辑核心数量）</span></span><br><span class="line">    count = wq_max_parallelism[_wq_bucket(at_qos)];</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果最大并发数大于活跃线程数和繁忙线程数之和，则允许分配新线程</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 活跃线程：正在执行任务（未被阻塞或挂起）的工作队列线程</span></span><br><span class="line"><span class="comment">    * 繁忙线程：线程被阻塞在时间窗口内（被阻塞的时间小于 200 微秒）的线程</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; thactive_count + busycount) &#123;</span><br><span class="line">        count -= thactive_count + busycount;</span><br><span class="line">        allowance_passed = MIN(count, max_count);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，不允许分配新线程</span></span><br><span class="line">        allowance_passed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回允许分配的新线程数量</span></span><br><span class="line">    <span class="keyword">return</span> allowance_passed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>wq_max_parallelism</code> 是个数组，在 <code>workq_open</code> 函数（<code>pthread_workqueue_setup</code> 中调用的该函数）中初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">workq_open</span><span class="params">(<span class="keyword">struct</span> proc *p, __unused <span class="keyword">struct</span> workq_open_args *uap,</span></span><br><span class="line"><span class="params">    __unused <span class="type">int32_t</span> *retval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wq_init_constrained_limit) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于逻辑 CPU 逻辑核心数量，决定每个优先级可同时运行的最大线程数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">thread_qos_t</span> qos = WORKQ_THREAD_QOS_MIN; qos &lt;= WORKQ_THREAD_QOS_MAX; qos++) &#123;</span><br><span class="line">            wq_max_parallelism[_wq_bucket(qos)] =</span><br><span class="line">                qos_max_parallelism(qos, QOS_PARALLELISM_COUNT_LOGICAL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">qos_max_parallelism</span><span class="params">(<span class="type">int</span> qos, <span class="type">uint64_t</span> options)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> SCHED(qos_max_parallelism)(qos, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">sched_qos_max_parallelism</span><span class="params">(__unused <span class="type">int</span> qos, <span class="type">uint64_t</span> options)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传入的选项决定返回逻辑 CPU 数量还是物理 CPU 数量</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp; QOS_PARALLELISM_COUNT_LOGICAL) &#123;</span><br><span class="line">    	<span class="comment">// 返回 CPU 逻辑核心数量</span></span><br><span class="line">    	<span class="comment">// workq_open 调用进来的时候，传的是 QOS_PARALLELISM_COUNT_LOGICAL</span></span><br><span class="line">        <span class="keyword">return</span> hinfo.logical_cpu;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则返回 CPU 物理核心数量</span></span><br><span class="line">        <span class="keyword">return</span> hinfo.physical_cpu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>workq_constrained_allowance</code> 函数中，有一段这样的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wq_max_constrained_threads = 64</span></span><br><span class="line"><span class="keyword">if</span> (max_count &gt;= wq_max_constrained_threads) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算剩余的可用线程数 max_count -= 64;</span></span><br><span class="line"><span class="comment">// ⚠️ ：这里可能是一个 BUG，因为走到这里，max_count 一定是小于 wq_max_constrained_threads 的</span></span><br><span class="line">max_count -= wq_max_constrained_threads;</span><br></pre></td></tr></table></figure>
<p>在计算 <code>max_count</code> 时，<code>max_count</code> 一定是小于 <code>wq_max_constrained_threads</code> 的，而 <code>max_count</code> 和 <code>wq_max_constrained_threads</code> 都是 <code>uint32_t</code> 类型（无符号整数），当一个较小的无符号整数减去一个较大的无符号整数时，会发生下溢，导致 <code>max_count</code> 变成一个很大的正数。</p>
<p>这个 XNU 的 BUG 则导致了后续 <code>MIN(count, max_count)</code> 结果一定是 <code>count</code>，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count -= thactive_count + busycount = CPU 逻辑核心数 -  (活跃线程数 + 繁忙线程数);</span><br></pre></td></tr></table></figure>
<p>从而导致了 <code>workq_constrained_allowance</code> 返回值一定是上面的计算结果，使 <code>MIN(count, max_count)</code> 的逻辑变得无意义。</p>
<p>更合理的计算方式应该是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面计算方式更合理，代表了剩余可创建线程的数量</span></span><br><span class="line">max_count = wq_max_constrained_threads - max_count;</span><br></pre></td></tr></table></figure>
<p>综上，<code>workq_constrained_allowance</code> 核心逻辑如下：</p>
<ul>
<li>如果已调度受限线程数超过超过最大受限线程数(64)，则不允许再新建线程，直接返回 0。</li>
<li>否则，判断是否满足 <code>CPU 逻辑核心数 &gt; (活跃线程数 + 繁忙线程数)</code>，<ul>
<li>如果满足，返回：<code>CPU 逻辑核心数 -  (活跃线程数 + 繁忙线程数)</code></li>
<li>如果不满足，返回 0，即不允许再创建线程</li>
</ul>
</li>
</ul>
<p><strong>活跃线程与繁忙线程：</strong></p>
<ul>
<li><strong>活跃线程</strong><ul>
<li>正在执行任务（未被阻塞或挂起）的工作队列线程。</li>
<li>活跃线程会占用 CPU 资源，所以需要严格控制活跃线程数量。</li>
</ul>
</li>
<li><strong>繁忙线程</strong><ul>
<li>线程被阻塞在时间窗口内（被阻塞的时间小于 200 微秒）的线程。<ul>
<li>这部分判断逻辑在 <code>workq_thread_is_busy</code> 函数中实现的。</li>
</ul>
</li>
<li>系统会记录线程阻塞的时间，如果线程在短时间窗口内被阻塞，会被视为”繁忙”线程，因为线程可能会很快被唤醒执行任务。繁忙线程本身不会消耗 CPU 资源。</li>
<li><strong>如果线程一直被阻塞，阻塞时间超过了时间窗口 200 微秒，则不统计在内了。</strong></li>
</ul>
</li>
</ul>
<h2 id="5、慢速请求流程（workq-schedule-creator）"><a href="#5、慢速请求流程（workq-schedule-creator）" class="headerlink" title="5、慢速请求流程（workq_schedule_creator）"></a>5、慢速请求流程（workq_schedule_creator）</h2><p>上面已经提到，并发队列调用 <code>workq_reqthreads</code> 时，<code>reqcount</code> 传入的参数是 <code>1</code>，且通过递归调用的方式多次调用 <code>workq_reqthreads</code> 每次申请 <code>1</code> 个线程（详情可看：<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a> ）。所以并发队列不会走进快速请求流程，而是直接走慢速请求流程。</p>
<p>慢速请求流程调用的是 <code>workq_schedule_creator</code>，该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">workq_schedule_creator</span><span class="params">(<span class="type">proc_t</span> p, <span class="keyword">struct</span> workqueue *wq,</span></span><br><span class="line"><span class="params">    <span class="type">workq_kern_threadreq_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">workq_threadreq_t</span> req;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">uth</span>;</span></span><br><span class="line">    <span class="comment">// 是否需要唤醒线程  </span></span><br><span class="line">    <span class="type">bool</span> needs_wakeup;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="comment">// 获取队列的当前的创建者线程</span></span><br><span class="line">    uth = wq-&gt;wq_creator; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wq-&gt;wq_reqcount) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 没有线程请求</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据线程优先级，为创建者线程选择一个适合的线程请求</span></span><br><span class="line"><span class="comment">    * 内部会调用 workq_constrained_allowance 做一次判断，超过最大可创建线程数量时 req 会为 NULL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    req = workq_threadreq_select_for_creator(wq);</span><br><span class="line">    <span class="keyword">if</span> (req == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有返回合适的线程请求</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uth) &#123;</span><br><span class="line">        <span class="comment">// 如果已经有一个创建者线程，根据需要调整优先级</span></span><br><span class="line">        <span class="keyword">if</span> (workq_thread_needs_priority_change(req, uth)) &#123;</span><br><span class="line">            workq_thread_reset_pri(wq, uth, req, <span class="comment">/*unpark*/</span> <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        assert(wq-&gt;wq_inheritor == get_machthread(uth));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wq-&gt;wq_thidlecount) &#123;</span><br><span class="line">        <span class="comment">// 如果没有创建者线程，优先从空闲线程中取一个线程作为创建者线程</span></span><br><span class="line">        wq-&gt;wq_creator = uth = workq_pop_idle_thread(wq, UT_WORKQ_OVERCOMMIT,</span><br><span class="line">            &amp;needs_wakeup);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needs_wakeup) &#123;</span><br><span class="line">            <span class="comment">// 唤醒线程</span></span><br><span class="line">            workq_thread_wakeup(uth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有空闲线程，需要创建一个新线程。</span></span><br><span class="line">        <span class="keyword">if</span> (__improbable(wq-&gt;wq_nthreads &gt;= wq_max_threads)) &#123;</span><br><span class="line">            <span class="comment">// 如果线程数已达上限，直接返回......</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; WORKQ_THREADREQ_SET_AST_ON_FAILURE) &#123;</span><br><span class="line">            <span class="comment">// 如果设置了失败时触发 AST，则设置 AST ......</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(flags &amp; WORKQ_THREADREQ_CAN_CREATE_THREADS)) &#123;</span><br><span class="line">            <span class="comment">// workq_reqthreads 中调用 workq_schedule_creator 时传了 WORKQ_THREADREQ_CAN_CREATE_THREADS，所以不会走此处分支</span></span><br><span class="line">            workq_schedule_immediate_thread_creation(wq);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((workq_add_new_idle_thread(p, wq,</span><br><span class="line">            workq_unpark_continue, <span class="literal">false</span>, <span class="literal">NULL</span>) == KERN_SUCCESS)) &#123;</span><br><span class="line">            <span class="comment">// 调用 workq_add_new_idle_thread 创建线程，并设置线程唤醒时执行 workq_unpark_continue 函数</span></span><br><span class="line">            <span class="keyword">goto</span> again;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果创建线程失败，调度延迟线程创建。</span></span><br><span class="line">            workq_schedule_delayed_thread_creation(wq, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>workq_schedule_creator</code> 函数中，多次提到线程（<code>uth</code>）和线程请求（<code>thread request</code>），<strong>线程和线程请求到底是什么关系呢？</strong></p>
<ul>
<li><strong>线程（<code>uth</code>）</strong><ul>
<li>线程（<code>uth</code>）是线程在内核态的形态，线程（<code>uth</code>）回传回用户空间，执行我们通过 <code>dispatch_async</code> 的 <code>block</code> 提交的具体任务。</li>
</ul>
</li>
<li><strong>线程请求（<code>thread request</code>）</strong><ul>
<li>线程请求（<code>thread request</code>）是任务在内核层面的描述，它不包含实际的 <code>dispatch_async</code> 的 <code>block</code> 任务，而是包含执行该任务所需的元数据，如 <code>QoS</code>、优先级、执行模式等。</li>
<li>线程（<code>uth</code>）需要根据线程请求（<code>thread request</code>）完成执行参数配置之后，才能提供给用户态执行任务。</li>
</ul>
</li>
</ul>
<p><strong>总结 <code>workq_schedule_creator</code> 函数逻辑如下：</strong></p>
<ul>
<li>如果进程 <code>workqueue</code> 的线程请求数量为 <code>0</code>，直接 <code>return</code>。</li>
<li>根据请求线程的优先级，调用 <code>workq_threadreq_select_for_creator</code> 按照高优先级优先的原则，为创建者线程选择一个合适的线程请求 <code>req</code>。<ul>
<li>选择线程请求时，会调用前面提到的 <code>workq_constrained_allowance</code> 判断是否还允许创建受限线程，如果不可以再创建线程，<code>workq_threadreq_select_for_creator</code> 会返回 <code>NULL</code>。</li>
<li>如果 <code>req</code> 为 <code>NULL</code>，则 <code>workq_schedule_creator</code> 函数会直接 <code>return</code>。</li>
</ul>
</li>
<li>如果创建者线程 <code>wq_creator</code> 已存在，根据线程请求 <code>req</code> 调整其优先级等参数。</li>
<li>如果创建者线程 <code>wq_creator</code> 不存在，则进入 <code>wq_creator</code> 创建流程：<ul>
<li><strong>步骤 1：</strong>是否有空闲线程，如果有，则调用 <code>workq_pop_idle_thread</code> 取一个空闲线程作为 <code>wq_creator</code>，并调用 <code>workq_thread_wakeup</code> 唤醒创建者线程 <code>wq_creator</code>。</li>
<li><strong>步骤 2：</strong>如果没有空闲线程，再判断当前线程总数是否已经达到 <code>wq_max_threads</code>（512），如果达到，不允许再创建 <code>wq_creator</code>。</li>
<li><strong>步骤 3：</strong>如果线程总数未达到 <code>wq_max_threads</code>（512），则：<ul>
<li>调用 <code>workq_add_new_idle_thread</code> 创建线程，<font color=#ff0000>并设置线程被唤醒后执行 <code>workq_unpark_continue</code> 函数。</font></li>
<li>执行 <code>goto again</code>，会前面重新走 <code>wq_creator</code> 创建流程，并在上面<strong>步骤 1</strong> 时，将这一步新建的线程作为空闲线程赋值给 <code>wq_creator</code> 并唤醒。</li>
</ul>
</li>
<li><strong>步骤 4：</strong>走到这里，说明由于前面各种条件限制，不允许再新建线程，则调用 <code>workq_schedule_delayed_thread_creation</code> 走延迟创建逻辑。<ul>
<li>在工作队列中安排一个延迟执行的线程创建任务。它会根据工作队列的当前状态和历史运行情况动态调整下次创建线程的时间间隔，实现自适应的线程创建策略。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>其中，从线程池取一个空闲线程调用的是 <code>workq_pop_idle_thread</code> 函数，该函数精简后实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> uthread *</span><br><span class="line"><span class="title function_">workq_pop_idle_thread</span><span class="params">(<span class="keyword">struct</span> workqueue *wq, <span class="type">uint16_t</span> uu_flags,</span></span><br><span class="line"><span class="params">    <span class="type">bool</span> *needs_wakeup)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">uth</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先从空闲线程链表中获取第一个线程</span></span><br><span class="line">    <span class="keyword">if</span> ((uth = TAILQ_FIRST(&amp;wq-&gt;wq_thidlelist))) &#123;</span><br><span class="line">        <span class="comment">// 如果空闲线程链表不为空，从链表中移除该线程</span></span><br><span class="line">        TAILQ_REMOVE(&amp;wq-&gt;wq_thidlelist, uth, uu_workq_entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果空闲线程链表为空，从新创建的线程链表中获取第一个线程</span></span><br><span class="line">        uth = TAILQ_FIRST(&amp;wq-&gt;wq_thnewlist);</span><br><span class="line">        TAILQ_REMOVE(&amp;wq-&gt;wq_thnewlist, uth, uu_workq_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将线程标记为运行状态</span></span><br><span class="line">    uth-&gt;uu_workq_flags |= UT_WORKQ_RUNNING | uu_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加工作队列的总调度线程计数</span></span><br><span class="line">    wq-&gt;wq_threads_scheduled++;</span><br><span class="line">    <span class="comment">// 减少空闲线程计数</span></span><br><span class="line">    wq-&gt;wq_thidlecount--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码实现可知，取空闲线程的关键逻辑如下：</p>
<ul>
<li>先从空闲线程 <code>wq_thidlelist</code> 里取一个线程。</li>
<li>空闲线程为空，则从新建线程链表 <code>wq_thnewlist</code> 中取一个线程。<ul>
<li><code>workq_add_new_idle_thread</code> 新建的线程会存到 <code>wq_thnewlist</code> 里。</li>
</ul>
</li>
<li>将取到的线程标记为运行状态，增加 <code>UT_WORKQ_RUNNING</code> 标记。<ul>
<li>所以，创建者线程 <code>wq_creator</code> 也会有 <code>UT_WORKQ_RUNNING</code> 标记。</li>
</ul>
</li>
<li>已调度线程数量 <code>wq_threads_scheduled ++</code>，空闲线程数量 <code>wq_thidlecount --</code>。</li>
<li>返回取到的空闲线程。</li>
</ul>
<h3 id="6、workq-unpark-continue"><a href="#6、workq-unpark-continue" class="headerlink" title="6、workq_unpark_continue"></a>6、workq_unpark_continue</h3><p>创建者线程 <code>wq_creator</code> 创建完成被唤醒后，会调用 <code>workq_unpark_continue</code> 函数。<code>workq_unpark_continue</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">workq_unpark_continue</span><span class="params">(<span class="type">void</span> *parameter __unused, <span class="type">wait_result_t</span> wr __unused)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">thread_t</span> th = current_thread();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">uth</span> =</span> get_bsdthread_info(th);</span><br><span class="line">    <span class="type">proc_t</span> p = current_proc();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue</span> *<span class="title">wq</span> =</span> proc_get_wqptr_fast(p); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁工作队列，确保线程安全。</span></span><br><span class="line">    workq_lock_spin(wq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前线程是创建者线程，并且满足让出条件：</span></span><br><span class="line"><span class="comment">     * - 如果当前线程的数量足以满足工作队列的需求，</span></span><br><span class="line"><span class="comment">     *   则避免将该创建者线程发送到用户空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (wq-&gt;wq_creator == uth &amp;&amp; workq_creator_should_yield(wq, uth)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果当前线程是创建者线程，并且当前活跃线程能够满足工作需求，</span></span><br><span class="line"><span class="comment">         * 则避免将该创建者线程发送到用户空间。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        uth-&gt;uu_save.uus_workq_park_data.fulfilled_snapshot = wq-&gt;wq_fulfilled; </span><br><span class="line">        uth-&gt;uu_save.uus_workq_park_data.yields++; </span><br><span class="line">        <span class="comment">// 解锁工作队列。</span></span><br><span class="line">        workq_unlock(wq); </span><br><span class="line">        <span class="comment">// 让出 CPU，并使其被唤醒后再次执行 workq_unpark_continue</span></span><br><span class="line">        thread_yield_with_continuation(workq_unpark_continue, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 标记代码不可达</span></span><br><span class="line">        __builtin_unreachable(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前线程标记为正在运行：</span></span><br><span class="line"><span class="comment">     * - 选择一个线程请求进行处理，或者将线程重新挂起。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 只有 workq_pop_idle_thread 会增加 UT_WORKQ_RUNNING 标记</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (__probable(uth-&gt;uu_workq_flags &amp; UT_WORKQ_RUNNING)) &#123;</span><br><span class="line">        workq_unpark_select_threadreq_or_park_and_unlock(p, wq, uth, WQ_SETUP_NONE);</span><br><span class="line">        <span class="comment">// 标记代码不可达。</span></span><br><span class="line">        __builtin_unreachable(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里，说明唤醒线程是为了销毁线程</span></span><br><span class="line">    <span class="keyword">if</span> (__probable(wr == THREAD_AWAKENED)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果线程被唤醒且状态为 THREAD_AWAKENED：</span></span><br><span class="line"><span class="comment">         * - 这是一个特殊情况，线程被设置为运行状态，但目的是为了销毁。</span></span><br><span class="line"><span class="comment">         * - 确保线程已经被标记为“死亡”状态（UT_WORKQ_DYING）。</span></span><br><span class="line"><span class="comment">         * - 确保线程不是新线程（UT_WORKQ_NEW 标志未设置）。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 断言目的：</span></span><br><span class="line"><span class="comment">         * 1. `uth-&gt;uu_workq_flags &amp; UT_WORKQ_DYING`：</span></span><br><span class="line"><span class="comment">         *    确保线程已经被标记为“死亡”状态，表明线程的生命周期即将结束。</span></span><br><span class="line"><span class="comment">         *    如果未设置该标志，说明逻辑存在问题，线程不应该进入此分支。</span></span><br><span class="line"><span class="comment">         * 2. `(uth-&gt;uu_workq_flags &amp; UT_WORKQ_NEW) == 0`：</span></span><br><span class="line"><span class="comment">         *    确保线程不是新创建的线程。新线程不应该直接进入“死亡”状态。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assert(uth-&gt;uu_workq_flags &amp; UT_WORKQ_DYING);</span><br><span class="line">        assert((uth-&gt;uu_workq_flags &amp; UT_WORKQ_NEW) == <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果线程被中断（THREAD_INTERRUPTED）：</span></span><br><span class="line"><span class="comment">         * - 这是一个兼容性处理，用于确保在用户空间调用 workq_thread_terminate()</span></span><br><span class="line"><span class="comment">         *   或 workq_exit() 时能够正确处理该线程。</span></span><br><span class="line"><span class="comment">         * - 增加工作队列的“死亡”线程计数（wq_thdying_count）。</span></span><br><span class="line"><span class="comment">         * - 标记线程为“死亡”状态（UT_WORKQ_DYING）。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 断言目的：</span></span><br><span class="line"><span class="comment">         * 1. `wr == THREAD_INTERRUPTED`：</span></span><br><span class="line"><span class="comment">         *    确保唤醒结果为 THREAD_INTERRUPTED，表明线程被中断唤醒。</span></span><br><span class="line"><span class="comment">         *    如果唤醒结果不是 THREAD_INTERRUPTED，说明逻辑存在问题。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assert(wr == THREAD_INTERRUPTED);</span><br><span class="line">        wq-&gt;wq_thdying_count++;</span><br><span class="line">        uth-&gt;uu_workq_flags |= UT_WORKQ_DYING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁线程逻辑</span></span><br><span class="line">    workq_unpark_for_death_and_unlock(p, wq, uth,</span><br><span class="line">        WORKQ_UNPARK_FOR_DEATH_WAS_IDLE, WQ_SETUP_NONE);</span><br><span class="line">    <span class="comment">// 标记代码不可达</span></span><br><span class="line">    __builtin_unreachable(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该函数中，多次出现了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_unreachable();</span><br></pre></td></tr></table></figure>
<p>是 GCC 和 Clang 编译器提供的一个内建函数，用于告诉编译器程序的某个代码路径是不可达的。如果代码在运行时真的到达了<code>__builtin_unreachable()</code>，会导致崩溃或其他未定义行为：<br><img src="/images/lix_blog_240.png"></p>
<p>而在 <code>workq_unpark_continue</code> 函数中，实际上是不会执行到 <code>__builtin_unreachable()</code> 的，因为 <code>__builtin_unreachable()</code> 上面所调用的函数，都是 <code>noreturn</code> 的，<strong>进去后就出不来了</strong>。</p>
<p><strong>总结 <code>workq_unpark_continue</code> 函数实现如下：</strong></p>
<ul>
<li>如果线程是创建者线程 <code>wq_creator</code>，则判断是否需要让出 CPU，如果需要，则让出 CPU 且使其被唤醒后（CPU 资源足够时）再次执行 <code>workq_unpark_continue</code>，并终止 <code>workq_unpark_continue</code> 执行。<ul>
<li>当正在工作的线程（占用 CPU）数量，超过了最大并发线程数（CPU 逻辑核心数量），则需要让出 CPU。</li>
</ul>
</li>
<li>如果线程被标记为运行状态（含 <code>UT_WORKQ_RUNNING</code> 标记），则调用 <code>workq_unpark_select_threadreq_or_park_and_unlock</code> 选择一个线程请求处理或挂起线程。<ul>
<li>所以，对于创建者线程 <code>wq_creator</code>，也会走此逻辑。</li>
</ul>
</li>
<li>否则，线程被唤醒是为了销毁线程，执行线程销毁的逻辑。</li>
</ul>
<h3 id="7、workq-unpark-select-threadreq-or-park-and-unlock"><a href="#7、workq-unpark-select-threadreq-or-park-and-unlock" class="headerlink" title="7、workq_unpark_select_threadreq_or_park_and_unlock"></a>7、workq_unpark_select_threadreq_or_park_and_unlock</h3><p>上一步提到，如果线程被标记为运行状态（含 <code>UT_WORKQ_RUNNING</code> 标记），则调用 <code>workq_unpark_select_threadreq_or_park_and_unlock</code> 选择一个线程请求处理或挂起线程，在前面已经提到，选择一个线程请求处理就是根据线程请求进行执行参数配置，完成参数配置之后，就会将配置好的线程传给用户态去执行具体任务。</p>
<p>分析源码后确认，只有 <code>workq_pop_idle_thread</code> 会增加 <code>UT_WORKQ_RUNNING</code> 标记，即从空闲线程中取出线程时增加了 <code>UT_WORKQ_RUNNING</code> 标记：</p>
<ul>
<li>快速请求流程中，从空闲线程取线程使用时。</li>
<li>慢速请求流程中，创建 <code>wq_creator</code> 时。</li>
</ul>
<p>所以，在上述两个场景中，都会走进 <code>workq_unpark_select_threadreq_or_park_and_unlock</code> 函数。</p>
<p><code>workq_unpark_select_threadreq_or_park_and_unlock</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">workq_unpark_select_threadreq_or_park_and_unlock</span><span class="params">(<span class="type">proc_t</span> p, <span class="keyword">struct</span> workqueue *wq,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> uthread *uth, <span class="type">uint32_t</span> setup_flags)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逻辑分支 1：配置线程并传给用户态执行具体任务</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 从代码上看，只有一个地方会配置 UT_WORKQ_EARLY_BOUND：</span></span><br><span class="line"><span class="comment">     * - workq_reqthreads 中取空闲线程后会设置 UT_WORKQ_EARLY_BOUND</span></span><br><span class="line"><span class="comment">     * - 说明 workq_reqthreads while 循环去线程缓存使用，线程唤醒时走这里的逻辑</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (uth-&gt;uu_workq_flags &amp; UT_WORKQ_EARLY_BOUND) &#123;</span><br><span class="line">        <span class="comment">// 如果线程是新创建的，设置首次使用标志</span></span><br><span class="line">        <span class="keyword">if</span> (uth-&gt;uu_workq_flags &amp; UT_WORKQ_NEW) &#123;</span><br><span class="line">            setup_flags |= WQ_SETUP_FIRST_USE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除线程的 NEW 和 EARLY_BOUND 标志</span></span><br><span class="line">        uth-&gt;uu_workq_flags &amp;= ~(UT_WORKQ_NEW | UT_WORKQ_EARLY_BOUND);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置并运行线程的任务</span></span><br><span class="line">        workq_setup_and_run(p, uth, setup_flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表示代码逻辑不应到达此处</span></span><br><span class="line">        __builtin_unreachable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑分支 2：选择线程请求处理或挂起线程</span></span><br><span class="line">    thread_freeze_base_pri(get_machthread(uth));</span><br><span class="line">    workq_select_threadreq_or_park_and_unlock(p, wq, uth, setup_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>该函数可以分成两个逻辑分支：</strong></p>
<ul>
<li><strong>逻辑分支 1：</strong>配置线程并传给用户态执行具体任务。<ul>
<li>当线程配置了 <code>UT_WORKQ_EARLY_BOUND</code> 标志时，会走该逻辑分支。</li>
<li>只有 <code>workq_reqthreads</code> 中取空闲线程后会设置 <code>UT_WORKQ_EARLY_BOUND</code>，所以快速请求流程获取到的线程走此逻辑分支。</li>
<li>此逻辑分支核心逻辑是调用 <code>workq_setup_and_run</code> 将线程传给用户态执行具体任务。</li>
</ul>
</li>
<li><strong>逻辑分支 2：</strong>选择线程请求处理或挂起线程。<ul>
<li>由于创建 <code>wq_creator</code> 时，未无 <code>UT_WORKQ_EARLY_BOUND</code>，所以创建者线程 <code>wq_creator</code> 会走此分支。</li>
<li>此处调用的是 <code>workq_select_threadreq_or_park_and_unlock</code> 函数</li>
</ul>
</li>
</ul>
<h3 id="8、workq-select-threadreq-or-park-and-unlock"><a href="#8、workq-select-threadreq-or-park-and-unlock" class="headerlink" title="8、workq_select_threadreq_or_park_and_unlock"></a>8、workq_select_threadreq_or_park_and_unlock</h3><p>上面已经提到，创建线程 <code>wq_creator</code> 被唤醒后，最终会执行到 <code>workq_select_threadreq_or_park_and_unlock</code> 函数，选择一个线程请求处理，或者挂起线程。该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">workq_select_threadreq_or_park_and_unlock</span><span class="params">(<span class="type">proc_t</span> p, <span class="keyword">struct</span> workqueue *wq,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> uthread *uth, <span class="type">uint32_t</span> setup_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化变量</span></span><br><span class="line">    <span class="type">workq_threadreq_t</span> req = <span class="literal">NULL</span>; <span class="comment">// 当前选中的线程请求</span></span><br><span class="line">    <span class="type">bool</span> is_creator = (wq-&gt;wq_creator == uth); <span class="comment">// 判断当前线程是否为创建者线程</span></span><br><span class="line">    <span class="type">bool</span> schedule_creator = <span class="literal">false</span>; <span class="comment">// 是否需要调度新的创建者线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (......) &#123;</span><br><span class="line">        <span class="keyword">goto</span> park; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_creator) &#123;</span><br><span class="line">        wq-&gt;wq_creator = <span class="literal">NULL</span>; <span class="comment">// 清除创建者线程标记</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (......) &#123;</span><br><span class="line">        <span class="keyword">goto</span> park_thawed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wq-&gt;wq_fulfilled++;</span><br><span class="line">    schedule_creator = workq_threadreq_dequeue(wq, req,</span><br><span class="line">        cooperative_sched_count_changed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果以下任一条件为真，调用 workq_schedule_creator，再次进入慢速请求流程：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * - 我们当前是创建者线程，所以工作队列可能需要一个新的创建者</span></span><br><span class="line"><span class="comment">     * - 我们正在绑定的请求是最高优先级的，现有创建者的优先级可能需要调整以反映下一个最高优先级的线程请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (is_creator || schedule_creator) &#123;</span><br><span class="line">        <span class="comment">// 再次进入慢速请求流程</span></span><br><span class="line">        workq_schedule_creator(p, wq, WORKQ_THREADREQ_CAN_CREATE_THREADS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁工作队列</span></span><br><span class="line">    workq_unlock(wq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果线程请求已完成，则释放其内存</span></span><br><span class="line">    <span class="keyword">if</span> (req) &#123;</span><br><span class="line">        zfree(workq_zone_threadreq, req);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程并运行</span></span><br><span class="line">    workq_setup_and_run(p, uth, setup_flags); <span class="comment">// 切换到用户空间执行</span></span><br><span class="line">    __builtin_unreachable();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程挂起逻辑</span></span><br><span class="line">park:</span><br><span class="line">    <span class="comment">// 解冻线程的基础优先级</span></span><br><span class="line">    thread_unfreeze_base_pri(get_machthread(uth));</span><br><span class="line">park_thawed:</span><br><span class="line">    <span class="comment">// 挂起线程并解锁工作队列</span></span><br><span class="line">    workq_park_and_unlock(p, wq, uth, setup_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述逻辑可知，当线程需要挂起时（例如：队列正在退出、没有线程请求或达到最大并发数量限制时），会将创建者线程 <code>wq_creator</code> 挂起（解冻优先级等待下次调度或放入空闲线程中）。否则，将：</p>
<ul>
<li>先将 <code>workqueue</code> 的 <code>wq_creator</code> 置为 <code>NULL</code>。</li>
<li>新建一个创建者线程 <code>wq_creator</code> 供下次使用。</li>
<li>将调用 <code>workq_setup_and_run</code> 将旧的创建者线程 <code>wq_creator</code> 传到用户态执行具体任务。</li>
</ul>
<p>所以，这里就看出了创建者线程 <code>wq_creator</code> 的工作流程：作为工作线程传到用户态执行具体任务，并再次通过慢速请求流程创建一个新的创建者线程 <code>wq_creator</code>，循环执行此 <code>wq_creator</code> 的工作。</p>
<h3 id="9、workq-setup-and-run"><a href="#9、workq-setup-and-run" class="headerlink" title="9、workq_setup_and_run"></a>9、workq_setup_and_run</h3><p>根据前面逻辑分析结果，有两种场景会调用 <code>workq_setup_and_run</code> 函数：</p>
<ul>
<li><strong>快速请求流程，从空闲线程中取出线程使用时。</strong></li>
<li><strong>慢速请求流程，创建者线程 <code>wq_creator</code> 处理线程请求时。</strong></li>
</ul>
<p><code>workq_setup_and_run</code> 函数主要作用是配置线程，并将线程传到用户态执行具体任务。该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">workq_setup_and_run</span><span class="params">(<span class="type">proc_t</span> p, <span class="keyword">struct</span> uthread *uth, <span class="type">int</span> setup_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程 uth 各种参数配置 ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 pthread 提供的 workq_setup_thread 函数</span></span><br><span class="line">    pthread_functions-&gt;workq_setup_thread(p, th, vmap, uth-&gt;uu_workq_stackaddr,</span><br><span class="line">        uth-&gt;uu_workq_thport, <span class="number">0</span>, setup_flags, upcall_flags);</span><br><span class="line"></span><br><span class="line">    __builtin_unreachable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>workq_setup_thread</code> 函数是由 pthread 提供的，在 libpthread 开源仓库中。<code>workq_setup_thread</code> 的主要逻辑是通过设置线程寄存器的状态，使其跳转到指定的函数，这里函数主要执行路径是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start_wqthread</span><br><span class="line">⬇️</span><br><span class="line">_pthread_wqthread</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_worker_thread2</span><br></pre></td></tr></table></figure>
<p>到这里，就和上篇文章<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a>）中并发队列申请线程并执行任务的内容对应上了。</p>
<h3 id="10、总结"><a href="#10、总结" class="headerlink" title="10、总结"></a>10、总结</h3><p>可以使用下图表示并发队列线程池管理逻辑：<br><img src="/images/lix_blog_241.png"></p>
<h2 id="四、串行队列申请线程"><a href="#四、串行队列申请线程" class="headerlink" title="四、串行队列申请线程"></a>四、串行队列申请线程</h2><p>上篇文章<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a>）中有分析过，串行队列是基于 <code>Workloop</code> 的，通过 <code>kevent_id</code> 系统调用的方式申请线程。并且对于串行队列，当有任务需要执行时，每个串行队列只会开启一个线程去执行任务。从这一点其实也可看出，<strong>队列、Workloop、线程是一一对应且绑定的。</strong></p>
<p>根据前面测试结果也可以看出，虽然每个串行队列在执行任务期间只会创建一个线程，但是有很多个不同的串行队列时，就可以创建很多个线程，最高可以创建 512 个线程，可以超过 CPU 逻辑核心数量。</p>
<p>而并发队列却需要考虑 CPU 负载情况，限制了最大并发线程数量不超过 CPU 逻辑核心数量，且线程总数不超过 64 个，XNU 这么设计，至少有下面两个好处：</p>
<ul>
<li>每个串行队列在任一时刻只有一个任务在执行，对 CPU 的消耗相对较少，系统需要确保足够的线程资源使串行队列不被阻塞，如果限制太严格，可能导致队列任务无法及时调度。</li>
<li>并发队列主要为计算密集型任务设计，目标是最大化 CPU 利用率，超过 CPU 逻辑核心数量的线程会增加上下文切换成本，会导致性能的降低。所以需要限制线程数量以确保 CPU 能高性能处理任务。</li>
</ul>
<h3 id="1、kevent-id"><a href="#1、kevent-id" class="headerlink" title="1、kevent_id"></a>1、kevent_id</h3><p>串行队列是基于 <code>Workloop</code> 并通过 <code>kevent_id</code> 系统调用的方式申请线程的，<code>kevent_id</code> 函数主要逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kevent_id</span><span class="params">(<span class="keyword">struct</span> proc *p, <span class="keyword">struct</span> kevent_id_args *uap, <span class="type">int32_t</span> *retval)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前线程的 uthread 结构体</span></span><br><span class="line">    <span class="type">uthread_t</span> uth = current_uthread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程绑定的工作队列线程请求 (workq_threadreq_t)</span></span><br><span class="line">    <span class="type">workq_threadreq_t</span> kqr = uth-&gt;uu_kqr_bound;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取当前线程绑定的 workloop</span></span><br><span class="line">    kqu.kqwl = kqr ? kqr_kqworkloop(kqr) : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程绑定了 workloop</span></span><br><span class="line">    <span class="keyword">if</span> (kqu.kqwl &amp;&amp; kqu.kqwl-&gt;kqwl_dynamicid == uap-&gt;id) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 增加 workloop 的引用计数，确保在后续操作中不会被释放</span></span><br><span class="line">        kqworkloop_retain(kqu.kqwl);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__improbable(kevent_args_requesting_events(flags, uap-&gt;nevents))) &#123;</span><br><span class="line">        <span class="comment">// 如果用户请求的事件数量不符合要求，返回 EXDEV 错误</span></span><br><span class="line">        <span class="keyword">return</span> EXDEV;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程未绑定工作循环队列，或者队列的动态 ID 不匹配</span></span><br><span class="line">        <span class="comment">// 调用 kqworkloop_get_or_create 函数，尝试获取或创建一个新的 workloop</span></span><br><span class="line">        error = kqworkloop_get_or_create(p, uap-&gt;id, <span class="literal">NULL</span>, <span class="literal">NULL</span>, flags, &amp;kqu.kqwl);</span><br><span class="line">        <span class="keyword">if</span> (__improbable(error)) &#123;</span><br><span class="line">            <span class="comment">// 如果获取或创建失败，返回错误码</span></span><br><span class="line">            <span class="keyword">return</span> error; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 kevent_modern_internal 函数，处理事件列表和更改列表</span></span><br><span class="line">    <span class="keyword">return</span> kevent_modern_internal(kqu, uap-&gt;changelist, uap-&gt;nchanges,</span><br><span class="line">                                  uap-&gt;eventlist, uap-&gt;nevents, flags, kectx, retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述主要逻辑是根据工作队列线程请求判断对应的 <code>workloop</code> 是否存在，如果不存在则新建，如果存在则直接获取。其中，是通过调用 <code>kqworkloop_get_or_create</code> 函数获取或新建 <code>workloop</code> 的。</p>
<h3 id="2、kqworkloop-get-or-create"><a href="#2、kqworkloop-get-or-create" class="headerlink" title="2、kqworkloop_get_or_create"></a>2、kqworkloop_get_or_create</h3><p><code>kqworkloop_get_or_create</code> 函数用于获取或新建 <code>workloop</code>，该函数主要实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">kqworkloop_get_or_create</span><span class="params">(<span class="keyword">struct</span> proc *p, <span class="type">kqueue_id_t</span> id,</span></span><br><span class="line"><span class="params">    <span class="type">workq_threadreq_param_t</span> *trp,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> workq_threadreq_extended_param_s *trp_extended,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="keyword">struct</span> kqworkloop **kqwlp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前进程的文件描述符表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filedesc</span> *<span class="title">fdp</span> =</span> &amp;p-&gt;p_fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 加锁哈希表</span></span><br><span class="line">        kqhash_lock(fdp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果哈希表尚未初始化，则初始化它</span></span><br><span class="line">        <span class="keyword">if</span> (__improbable(fdp-&gt;fd_kqhash == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">// 初始化哈希表</span></span><br><span class="line">            kqworkloop_hash_init(fdp); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在哈希表中查找指定 id 的 workloop </span></span><br><span class="line">        kqwl = kqworkloop_hash_lookup_locked(fdp, id);</span><br><span class="line">        <span class="keyword">if</span> (kqwl) &#123;</span><br><span class="line">            <span class="comment">// 找到了 workloop</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未找到 workloop，尝试新建一个</span></span><br><span class="line">        <span class="keyword">if</span> (__probable(alloc_kqwl == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            alloc_kqwl = zalloc_flags(kqworkloop_zone, Z_NOWAIT | Z_ZERO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__probable(alloc_kqwl)) &#123;</span><br><span class="line">            <span class="comment">// 新建 workloop 成功</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将新分配的工作循环队列插入到哈希表中</span></span><br><span class="line">            kqworkloop_hash_insert_locked(fdp, id, alloc_kqwl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解锁哈希表</span></span><br><span class="line">            kqhash_unlock(fdp); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (trp &amp;&amp; (trp-&gt;trp_flags &amp; TRP_BOUND_THREAD)) &#123;</span><br><span class="line">                <span class="comment">// 申请线程，并将线程与 workloop 绑定</span></span><br><span class="line">                error = workq_kern_threadreq_permanent_bind(p, &amp;alloc_kqwl-&gt;kqwl_request);</span><br><span class="line">                <span class="keyword">if</span> (error != KERN_SUCCESS) &#123;</span><br><span class="line">                    <span class="comment">// 如果绑定失败，释放引用计数并删除 workloop</span></span><br><span class="line">                    kqworkloop_release(alloc_kqwl);</span><br><span class="line">                    alloc_kqwl = <span class="literal">NULL</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> error;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 绑定成功 ......</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 赋值新建的 workloop</span></span><br><span class="line">            *kqwlp = alloc_kqwl; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁哈希表</span></span><br><span class="line">    kqhash_unlock(fdp); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从该函数中可以看出队列对应的 <code>workloop</code> 存储在哈希表中，<code>workloop</code> 获取和新建逻辑如下：</p>
<ul>
<li>判断哈希表是否初始化，如果没有则先初始化。</li>
<li>根据队列 <code>id</code> 从哈希表中获取 <code>workloop</code>。</li>
<li>如果哈希表中没找到，则新建一个 <code>workloop</code>，同时：<ul>
<li>将新建的 <code>workloop</code> 插入哈希表。</li>
<li>调用 <code>workq_kern_threadreq_permanent_bind</code> 函数申请线程，并将线程与 <code>workloop</code> 绑定。<ul>
<li>调用 <code>workq_kern_threadreq_permanent_bind</code> 时，传入的线程请求（<code>kqr</code>）是从 <code>workloop</code> 中获取的（<code>&amp;alloc_kqwl-&gt;kqwl_request</code>）。所以线程请求（<code>kqr</code>）已经和 <code>workloop</code> 是绑定的关系。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3、workq-kern-threadreq-permanent-bind"><a href="#3、workq-kern-threadreq-permanent-bind" class="headerlink" title="3、workq_kern_threadreq_permanent_bind"></a>3、workq_kern_threadreq_permanent_bind</h3><p>关于该函数，源码中给出了注释去解释该函数的作用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * An entry point for kevent to request a newly created workqueue thread</span><br><span class="line"> * and bind it permanently to the given workqueue thread request.</span><br><span class="line"> *</span><br><span class="line"> * It currently only supports fixed scheduler priority thread requests.</span><br><span class="line"> *</span><br><span class="line"> * The newly created thread counts towards wq_nthreads. This function returns</span><br><span class="line"> * an error if we are above that limit. There is no concept of delayed thread</span><br><span class="line"> * creation for such specially configured kqworkloops.</span><br><span class="line"> *</span><br><span class="line"> * If successful, the newly created thread will be parked in</span><br><span class="line"> * workq_bound_thread_initialize_and_unpark_continue waiting for</span><br><span class="line"> * new incoming events.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>即该函数是通过 <code>kevent</code>&#x2F;<code>kevent_id</code> 请求线程的入口点，会将线程、线程请求、<code>workloop</code> 进行绑定。新创建的线程计入 <code>wq_nthreads</code>。<strong>新创建的线程将在有任务需要处理时候，会被唤醒并调用 <code>workq_bound_thread_initialize_and_unpark_continue</code> 函数。</strong></p>
<p><code>workq_kern_threadreq_permanent_bind</code> 函数主要实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">workq_kern_threadreq_permanent_bind</span><span class="params">(<span class="keyword">struct</span> proc *p, <span class="keyword">struct</span> workq_threadreq_s *kqr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">kern_return_t</span> ret = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 用于存储新创建的线程</span></span><br><span class="line">    <span class="type">thread_t</span> new_thread = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">// 获取当前进程的 workqueue</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue</span> *<span class="title">wq</span> =</span> proc_get_wqptr_fast(p); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    workq_lock_spin(wq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前线程数是否已达到最大限制 512</span></span><br><span class="line">    <span class="keyword">if</span> (wq-&gt;wq_nthreads &gt;= wq_max_threads) &#123;</span><br><span class="line">        <span class="comment">// 如果线程数已达上限 512，返回错误码 EDOM</span></span><br><span class="line">        ret = EDOM; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// QoS 相关配置</span></span><br><span class="line">        <span class="keyword">if</span> (kqr-&gt;tr_flags &amp; WORKQ_TR_FLAG_WL_OUTSIDE_QOS) &#123;</span><br><span class="line">            <span class="comment">// 提取 workloop 参数</span></span><br><span class="line">            <span class="type">workq_threadreq_param_t</span> trp = kqueue_threadreq_workloop_param(kqr); </span><br><span class="line"></span><br><span class="line">            <span class="type">thread_qos_t</span> qos = thread_workq_qos_for_pri(trp.trp_pri); </span><br><span class="line">            <span class="keyword">if</span> (qos == THREAD_QOS_UNSPECIFIED) &#123;</span><br><span class="line">                qos = WORKQ_THREAD_QOS_ABOVEUI;</span><br><span class="line">            &#125;</span><br><span class="line">            kqr-&gt;tr_qos = qos; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置线程请求的计数为 1</span></span><br><span class="line">        kqr-&gt;tr_count = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用 workq_add_new_idle_thread 创建一个新的空闲线程。</span></span><br><span class="line"><span class="comment">         * 该函数会在创建线程时释放并重新获取工作队列锁。</span></span><br><span class="line"><span class="comment">         * 如果成功，new_thread 会指向新创建的线程。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ret = workq_add_new_idle_thread(p, wq,</span><br><span class="line">            workq_bound_thread_initialize_and_unpark_continue,</span><br><span class="line">            <span class="literal">true</span>, &amp;new_thread);</span><br><span class="line">        <span class="keyword">if</span> (ret == KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">uth</span> =</span> get_bsdthread_info(new_thread);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (kqr-&gt;tr_flags &amp; WORKQ_TR_FLAG_WL_OUTSIDE_QOS) &#123;</span><br><span class="line">                workq_thread_reset_pri(wq, uth, kqr, <span class="comment">/*unpark*/</span> <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 将线程请求（kqr）与新创建的线程（uth）进行初步关联，并设置线程的调度属性（如 QoS、优先级等）</span></span><br><span class="line"><span class="comment">             * 为后续的 kqr、uth 正式绑定提交做好准备</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            kqueue_threadreq_bind_prepost(p, kqr, uth); </span><br><span class="line">            <span class="comment">// 设置线程为永久绑定</span></span><br><span class="line">            uth-&gt;uu_workq_flags |= UT_WORKQ_PERMANENT_BIND; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    workq_unlock(wq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果线程创建成功，则提交绑定。</span></span><br><span class="line">    <span class="keyword">if</span> (ret == KERN_SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将线程请求（kqr）与新创建的线程（uth）正式绑定</span></span><br><span class="line">        kqueue_threadreq_bind_commit(p, new_thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结该函数逻辑如下：</p>
<ul>
<li>判断当前线程总数 <code>wq_nthreads</code> 是否大于等于 <code>wq_max_threads</code>（512），如果达到了上限数量 512，则不允许再新建线程。<ul>
<li>等待有线程释放后再被调度获取线程。</li>
<li>前面并发队列申请的线程，也会增加 <code>wq_nthreads</code> 计数，这就是一开始的测试中串行队列、并发队列一起使用时，线程总数仍然不能超过 512 的原因。</li>
</ul>
</li>
<li><strong>如果线程总数未达上限 512，则调用 <code>workq_add_new_idle_thread</code> 新建一个线程，并设置线程被唤醒后执行 <code>workq_bound_thread_initialize_and_unpark_continue</code> 函数。</strong></li>
<li>将线程请求（<code>kqr</code>）与新创建的线程（<code>uth</code>）进行初步关联，并设置线程的调度属性（如 <code>QoS</code>、优先级等），为后续的 <code>kqr</code>、<code>uth</code> 正式绑定提交做好准备。</li>
<li>将线程请求（<code>kqr</code>）与新创建的线程（<code>uth</code>）正式绑定。<ul>
<li>由于线程请求（<code>kqr</code>）已经和 <code>workloop</code> 是绑定的关系了，所以这一步实际上也是将线程（<code>uth</code>）与 <code>workloop</code> 进行绑定。</li>
</ul>
</li>
</ul>
<h3 id="4、workq-bound-thread-initialize-and-unpark-continue"><a href="#4、workq-bound-thread-initialize-and-unpark-continue" class="headerlink" title="4、workq_bound_thread_initialize_and_unpark_continue"></a>4、workq_bound_thread_initialize_and_unpark_continue</h3><p>前面创建的线程将在有任务需要处理时候，会被唤醒并调用 <code>workq_bound_thread_initialize_and_unpark_continue</code> 函数，该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">workq_bound_thread_initialize_and_unpark_continue</span><span class="params">(<span class="type">void</span> *parameter __unused,</span></span><br><span class="line"><span class="params">    <span class="type">wait_result_t</span> wr)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前线程的 uthread 结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">uth</span> =</span> get_bsdthread_info(current_thread()); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__probable(wr == THREAD_AWAKENED)) &#123; </span><br><span class="line">        <span class="comment">// 唤醒线程是为了执行任务</span></span><br><span class="line">        <span class="comment">// 确保 UT_WORKQ_RUNNING 和 UT_WORKQ_DYING 标志不会同时存在。</span></span><br><span class="line">        assert((uth-&gt;uu_workq_flags &amp; (UT_WORKQ_RUNNING | UT_WORKQ_DYING)) != (UT_WORKQ_RUNNING | UT_WORKQ_DYING));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保线程已永久绑定到工作循环。</span></span><br><span class="line">        assert(workq_thread_is_permanently_bound(uth));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uth-&gt;uu_workq_flags &amp; UT_WORKQ_RUNNING) &#123; </span><br><span class="line">            <span class="comment">// 如果线程处于运行状态。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清除新线程标志</span></span><br><span class="line">            assert(uth-&gt;uu_workq_flags &amp; UT_WORKQ_NEW); </span><br><span class="line">            uth-&gt;uu_workq_flags &amp;= ~UT_WORKQ_NEW; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 workloop 绑定的线程请求 kqr</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">workq_threadreq_s</span> *<span class="title">kqr</span> =</span> uth-&gt;uu_kqr_bound; </span><br><span class="line">            <span class="keyword">if</span> (kqr-&gt;tr_work_interval) &#123;</span><br><span class="line">                <span class="type">kern_return_t</span> kr;</span><br><span class="line">                kr = kern_work_interval_explicit_join(get_machthread(uth), kqr-&gt;tr_work_interval); <span class="comment">// 加入工作间隔。</span></span><br><span class="line">        </span><br><span class="line">                <span class="keyword">if</span> (kr == KERN_SUCCESS) &#123;</span><br><span class="line">                    uth-&gt;uu_workq_flags |= UT_WORKQ_WORK_INTERVAL_JOINED; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    uth-&gt;uu_workq_flags |= UT_WORKQ_WORK_INTERVAL_FAILED; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重置线程的 CPU 使用百分比限制</span></span><br><span class="line">            workq_thread_reset_cpupercent(kqr, uth); </span><br><span class="line">            <span class="comment">// 将线程传到用户态去执行具体任务</span></span><br><span class="line">            workq_bound_thread_setup_and_run(uth, WQ_SETUP_FIRST_USE); </span><br><span class="line"></span><br><span class="line">            __builtin_unreachable();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果线程未处于运行状态，说明绑定的 workloop 正在被销毁。</span></span><br><span class="line"><span class="comment">             * 线程被唤醒以清理资源并解除绑定。</span></span><br><span class="line"><span class="comment">             * 加断言确保线程被标记为“死亡”状态。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            assert(uth-&gt;uu_workq_flags &amp; UT_WORKQ_DYING);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 唤醒线程是因为线程被中断 (THREAD_INTERRUPTED)，需解除线程与 workloop 的绑定</span></span><br><span class="line"><span class="comment">         * 例如：用户强杀 APP、信号中断、系统资源限制等。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        assert(wr == THREAD_INTERRUPTED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前进程</span></span><br><span class="line">        <span class="type">proc_t</span> p = current_proc(); </span><br><span class="line">        <span class="comment">// 获取工作队列</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">workqueue</span> *<span class="title">wq</span> =</span> proc_get_wqptr_fast(p); </span><br><span class="line">        workq_lock_spin(wq); </span><br><span class="line">        assert(workq_thread_is_permanently_bound(uth)); </span><br><span class="line">        workq_unlock(wq);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程的终止逻辑依赖于线程已经完成绑定，所以终止前需要确保是已经绑定的</span></span><br><span class="line">        kqueue_threadreq_bind_commit(p, get_machthread(uth)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 终止绑定线程</span></span><br><span class="line">    workq_kern_bound_thread_terminate(uth-&gt;uu_kqr_bound); </span><br><span class="line">    __builtin_unreachable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数核心逻辑如下：</p>
<ul>
<li>如果唤醒线程是为了执行任务，则调用  <code>workq_bound_thread_setup_and_run</code> 将线程传到用户态去执行任务。</li>
<li>如果唤醒线程，是因为线程被中断（<code>INTERRUPTED</code>），则将线程与 <code>workloop</code> 解绑，并走线程退出逻辑。<ul>
<li>如下场景会导致线程被中断：<ul>
<li>用户强制杀死 APP。</li>
<li>用户态 APP 主动调用 <code>exit()</code> 或 <code>abort()</code> 终止进程。</li>
<li>用户态 APP 注册了信号处理程序，但未处理某些信号（如 <code>SIGKILL</code>），当这些信号到达时，线程会被中断。</li>
<li>在高并发场景下，APP 创建了大量线程，导致系统资源耗尽。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>其中，<code>workq_bound_thread_setup_and_run</code> 内部最终还是通过前面分析过的 <code>workq_setup_thread</code> 将任务传到 <code>pthread</code> 的。<code>workq_setup_thread</code> 的主要逻辑是通过设置线程寄存器的状态，使其跳转到指定的函数，对于串行队列，函数主要执行路径是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start_wqthread</span><br><span class="line">⬇️</span><br><span class="line">_pthread_wqthread</span><br><span class="line">⬇️</span><br><span class="line">_dispatch_workloop_worker_thread</span><br></pre></td></tr></table></figure>
<p>后续就是串行队列中具体任务的执行逻辑了，详见<a href="https://www.lixkit.com/posts/50907/">《GCD 底层原理 4 - dispatch_async》</a>。</p>
<p>到这里，应该都可以发现串行队列、并发队列在申请线程上，除了最大线程数量的差异，还有个请求路径上的差异：串行队列是直接通过 <code>kevent_id</code> 系统调用申请线程的，而并发队列是先调用 <code>pthread</code> 提供的 <code>_pthread_workqueue_addthreads</code> 函数申请线程，再由该函数进入内核态申请线程，两者差异可以用下图表示：<br><img src="/images/lix_blog_242.png"></p>
<h3 id="5、总结-1"><a href="#5、总结-1" class="headerlink" title="5、总结"></a>5、总结</h3><p>从线程申请逻辑上看，串行队列申请线程要比并发队列简单的多，可以用下图总结串行队列线程管理的流程：<br><img src="/images/lix_blog_243.png"></p>
</section>

    <!-- Copyright START -->
    
      <div>
  <ul class="post-copyright">
    <li>
      <a rel=license href=http://creativecommons.org/licenses/by/4.0/>
        <img alt="知识共享许可协议" style="border-width:0;height:30px;width:auto;" src="/css/images/copyright.png">
      </a>
    </li>
    <li>
      本文章采用 <a rel=license href=http://creativecommons.org/licenses/by/4.0/>知识共享署名 4.0 国际许可协议</a> 进行许可，完整转载、部分转载、图片转载时均请注明原文链接。
    </li>
  </ul>
<div>
    
    <!-- Copyright START -->


    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#底层" >
    <span class="tag-code">底层</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/posts/50907/">
        <span class="nav-arrow">← </span>
        
          GCD 底层原理 4 - dispatch_async
        
      </a>
    
    
      <a class="nav-right" href="/posts/15823/">
        
          文件 IO 与 mmap
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Gitalk START -->
      <div id="gitalk-container"></div>
      <!-- Gitalk END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://www.lixkit.com/posts/34692/';
    var banner = 'undefined'
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>








<link rel='stylesheet' type='text/css' href='//cdnjs.cloudflare.com/ajax/libs/gitalk/1.2.2/gitalk.min.css'>
<div id="gitalk-container"></div>
<script>
    // Promise 异步加载脚本
    function loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    // 异步加载 Gitalk
    async function initGitalk() {
        try {
            await loadScript('//cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.10.0/js/md5.min.js');
            await loadScript('//cdnjs.cloudflare.com/ajax/libs/gitalk/1.2.2/gitalk.min.js');
            const gitalk = new Gitalk({
                clientID: '124a73ebef61e7821d74',
                clientSecret: 'a1ef084cca4d78256620f08f439ba70522f84581',
                repo: 'lixkit.github.io',
                owner: 'lixkit',
                admin: ['lixkit'],
                id: md5(location.pathname),
                distractionFreeMode: false
            });
            gitalk.render('gitalk-container');
        } catch (error) {
            console.error('Error loading Gitalk:', error);
        }
    }

    // 在页面加载完成后异步加载 Gitalk
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initGitalk);
    } else {
        initGitalk();
    }
</script>


    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    
<footer class="app-footer">
  <p class="copyright">
    李峰峰 © 2016 - 2025
    
        |
        
            <a style="color: #7f8c8d;" href="http://beian.miit.gov.cn/" target="_blank" rel="noopener nofollow">京ICP备2023030486号-6</a>
        
    
  </p>
</footer>


<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script>
    var _baId = 'cef02744ce74fd7afbb6bab85e4a6c24';
    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>


<script src="/js/script.js"></script>


  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>