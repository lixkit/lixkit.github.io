<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="李峰峰博客">
  <meta name="keyword" content="李峰峰, iOS, 底层原理">
  <meta name="baidu-site-verification" content="codeva-SYZlEXwvUN" />
  <meta name="sogou_site_verification" content="YdqRkfPyHk" />


  <meta name="description" content="一、概述Grand Central Dispatch（GCD）是 iOS 中一个强大的多线程编程框架，GCD 提供了一种高效、低级别的方式来管理并发任务。 GCD 是使用队列来调度任务的执行的，GCD 队列主要有这几种：  队列（Queue） 串行队列：任务按顺序执行，一个任务完成后才开始下一个任务。 并发队列：允许多个任务同时执行，任务的开始顺序是确定的，但完成顺序不一定。   主队列（Main">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD 底层原理 2 - dispatch_queue">
<meta property="og:url" content="https://www.lixkit.com/posts/12465/index.html">
<meta property="og:site_name" content="李峰峰博客">
<meta property="og:description" content="一、概述Grand Central Dispatch（GCD）是 iOS 中一个强大的多线程编程框架，GCD 提供了一种高效、低级别的方式来管理并发任务。 GCD 是使用队列来调度任务的执行的，GCD 队列主要有这几种：  队列（Queue） 串行队列：任务按顺序执行，一个任务完成后才开始下一个任务。 并发队列：允许多个任务同时执行，任务的开始顺序是确定的，但完成顺序不一定。   主队列（Main">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_218.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_219.png">
<meta property="article:published_time" content="2022-10-25T07:24:00.000Z">
<meta property="article:modified_time" content="2025-03-14T00:26:48.900Z">
<meta property="article:author" content="李峰峰">
<meta property="article:tag" content="底层">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.lixkit.com/images/lix_blog_218.png">


  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      GCD 底层原理 2 - dispatch_queue | 李峰峰博客
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  

  
  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="李峰峰博客" type="application/atom+xml">
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>李峰峰博客</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">主页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">分类</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">主页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">分类</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>GCD 底层原理 2 - dispatch_queue</h2>
  <p class="post-date">2022-10-25</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Grand Central Dispatch（GCD）是 iOS 中一个强大的多线程编程框架，GCD 提供了一种高效、低级别的方式来管理并发任务。</p>
<p>GCD 是使用队列来调度任务的执行的，GCD 队列主要有这几种：</p>
<ul>
<li><strong>队列（Queue）</strong><ul>
<li>串行队列：任务按顺序执行，一个任务完成后才开始下一个任务。</li>
<li>并发队列：允许多个任务同时执行，任务的开始顺序是确定的，但完成顺序不一定。</li>
</ul>
</li>
<li><strong>主队列（Main Queue）</strong><ul>
<li>一个特殊的串行队列，用于在主线程上执行任务，通常用于更新 UI。</li>
<li>所有提交到主队列的任务，无论使用 dispatch_sync 还是 dispatch_async，都将在主线程执行。</li>
</ul>
</li>
<li><strong>全局并发队列（Global Concurrent Queue）</strong><ul>
<li>系统提供的并发队列，按不同优先级划分。</li>
</ul>
</li>
</ul>
<p>GCD 任务是指需要执行的代码块，有同步或异步执行两种方式：</p>
<ul>
<li><strong>同步执行（dispatch_sync）</strong>：阻塞当前线程，直到任务完成。</li>
<li><strong>异步执行（dispatch_async）</strong>：立即返回，不阻塞当前线程，任务在后台执行。</li>
</ul>
<p>其中，创建队列是通过 GCD 的 <code>dispatch_queue_create</code> 进行创建的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个串行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">&quot;com.lixkit.serialQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建一个并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">&quot;com.lixkit.concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>

<p>接下来，通过 <a href="(https://github.com/apple-oss-distributions/libdispatch)">libdispatch</a> 源码，看 <code>dispatch_queue_create</code>  实现原理。</p>
<h2 id="二、DISPATCH-QUEUE-SERIAL-DISPATCH-QUEUE-CONCURRENT"><a href="#二、DISPATCH-QUEUE-SERIAL-DISPATCH-QUEUE-CONCURRENT" class="headerlink" title="二、DISPATCH_QUEUE_SERIAL &amp; DISPATCH_QUEUE_CONCURRENT"></a>二、DISPATCH_QUEUE_SERIAL &amp; DISPATCH_QUEUE_CONCURRENT</h2><p>前面已经提到，创建队列是通过 <code>dispatch_queue_create</code> 进行创建的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个串行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">&quot;com.lixkit.serialQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建一个并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">&quot;com.lixkit.concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p>创建串行队列和并发队列，用到了这两个宏：</p>
<ul>
<li><code>DISPATCH_QUEUE_SERIAL</code></li>
<li><code>DISPATCH_QUEUE_CONCURRENT</code></li>
</ul>
<h3 id="1、DISPATCH-QUEUE-SERIAL"><a href="#1、DISPATCH-QUEUE-SERIAL" class="headerlink" title="1、DISPATCH_QUEUE_SERIAL"></a>1、DISPATCH_QUEUE_SERIAL</h3><p><code>DISPATCH_QUEUE_SERIAL</code> 用于创建串行队列，这是个宏，其本质是 <code>NULL</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_SERIAL NULL</span></span><br></pre></td></tr></table></figure>
<h3 id="2、DISPATCH-QUEUE-CONCURRENT"><a href="#2、DISPATCH-QUEUE-CONCURRENT" class="headerlink" title="2、DISPATCH_QUEUE_CONCURRENT"></a>2、DISPATCH_QUEUE_CONCURRENT</h3><p><code>DISPATCH_QUEUE_CONCURRENT</code> 也是一个宏，且其定义中使用了一系列的宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_CONCURRENT \</span></span><br><span class="line"><span class="meta">        DISPATCH_GLOBAL_OBJECT(dispatch_queue_attr_t, \</span></span><br><span class="line"><span class="meta">        _dispatch_queue_attr_concurrent)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_GLOBAL_OBJECT(type, object) ((OS_OBJECT_BRIDGE type)&amp;(object))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> _<span class="title">dispatch_queue_attr_concurrent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_OBJECT_BRIDGE __bridge</span></span><br></pre></td></tr></table></figure>
<p>将其完全展开后定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_CONCURRENT \</span></span><br><span class="line"><span class="meta">    ((__bridge dispatch_queue_attr_t)&amp;(_dispatch_queue_attr_concurrent))</span></span><br></pre></td></tr></table></figure>
<p>即 <code>DISPATCH_QUEUE_CONCURRENT</code> 是 <code>dispatch_queue_attr_t</code> 类型的指针，该指针是由全局变量 <code>_dispatch_queue_attr_concurrent</code> 的地址强制转换成的。</p>
<p><code>_dispatch_queue_attr_concurrent</code> 是什么呢？<br>上面提到，<code>DISPATCH_QUEUE_CONCURRENT</code> 是由全局变量 <code>_dispatch_queue_attr_concurrent</code> 转换成的，那么 <code>_dispatch_queue_attr_concurrent</code> 具体是什么呢？</p>
<p>可以看下 <code>init.c</code> 中下述源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DISPATCH_QUEUE_CONCURRENT resp. _dispatch_queue_attr_concurrent is aliased</span></span><br><span class="line"><span class="comment">// to array member [0] and their properties must match!</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> _<span class="title">dispatch_queue_attrs</span>[] =</span> &#123;</span><br><span class="line">    [<span class="number">0</span> ... DISPATCH_QUEUE_ATTR_COUNT - <span class="number">1</span>] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_attr),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在注释中明确提到， <code>DISPATCH_QUEUE_CONCURRENT</code> 和 <code>_dispatch_queue_attr_concurrent</code> 都是  <code>_dispatch_queue_attrs</code> 数组第 <code>0</code> 个元素的别名。即：<code>DISPATCH_QUEUE_CONCURRENT</code> 本质是  <code>_dispatch_queue_attrs</code> 数组第 <code>0</code> 个元素。</p>
<p>在上述 <code>_dispatch_queue_attrs</code> 数组的定义中，<code>DISPATCH_QUEUE_ATTR_COUNT</code> 宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QOS_USER_INTERACTIVE   ((dispatch_qos_t)6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QOS_MAX                DISPATCH_QOS_USER_INTERACTIVE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QOS_MIN_RELATIVE_PRIORITY (-15)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_QOS_COUNT (DISPATCH_QOS_MAX + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_PRIO_COUNT (1 - QOS_MIN_RELATIVE_PRIORITY)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_INACTIVE_COUNT 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ATTR_COUNT  ( \</span></span><br><span class="line"><span class="meta">        DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT * \</span></span><br><span class="line"><span class="meta">        DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT * \</span></span><br><span class="line"><span class="meta">        DISPATCH_QUEUE_ATTR_QOS_COUNT * \</span></span><br><span class="line"><span class="meta">        DISPATCH_QUEUE_ATTR_PRIO_COUNT * \</span></span><br><span class="line"><span class="meta">        DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT * \</span></span><br><span class="line"><span class="meta">        DISPATCH_QUEUE_ATTR_INACTIVE_COUNT )</span></span><br></pre></td></tr></table></figure>
<p>可以看到 <code>DISPATCH_QUEUE_ATTR_COUNT</code> 是一系列宏参与乘法计算，其最终计算结果是 <code>4032</code>。</p>
<p><code>DISPATCH_GLOBAL_OBJECT_HEADER</code> 宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_GLOBAL_OBJECT_HEADER(name) \</span></span><br><span class="line"><span class="meta">    .do_vtable = DISPATCH_VTABLE(name), \</span></span><br><span class="line"><span class="meta">    .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, \</span></span><br><span class="line"><span class="meta">    .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_VTABLE(name) DISPATCH_OBJC_CLASS(name)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_OBJC_CLASS(name)   (&amp;DISPATCH_CLASS_SYMBOL(name))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_CLASS_SYMBOL(name) _dispatch_##name##_vtable</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_OBJECT_GLOBAL_REFCNT       _OS_OBJECT_GLOBAL_REFCNT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OS_OBJECT_GLOBAL_REFCNT INT_MAX</span></span><br></pre></td></tr></table></figure>
<p>将 <code>DISPATCH_GLOBAL_OBJECT_HEADER(queue_attr)</code> 完全展开后如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.do_vtable = (&amp;_dispatch_queue_attr_vtable), <span class="comment">// 通过宏展开得出虚函数表指针</span></span><br><span class="line">.do_ref_cnt = INT_MAX, <span class="comment">// 全局对象的引用计数</span></span><br><span class="line">.do_xref_cnt = INT_MAX <span class="comment">// 全局对象的弱引用计数</span></span><br></pre></td></tr></table></figure>
<p>综上， <code>_dispatch_queue_attrs</code> 实际定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DISPATCH_QUEUE_CONCURRENT 和 _dispatch_queue_attr_concurrent 本质是 _dispatch_queue_attrs 数组第 0 个元素</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> _<span class="title">dispatch_queue_attrs</span>[] =</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 GNU C 的范围设计符号初始化数组</span></span><br><span class="line">    <span class="comment">// [0 ... 4032 - 1] 指定数组的每个元素（从索引 0 到 4031，共计 4032 个元素）都被初始化为相同的值</span></span><br><span class="line">    [<span class="number">0</span> ... <span class="number">4032</span> - <span class="number">1</span>] = &#123;</span><br><span class="line">        <span class="comment">// 初始化 do_vtable 成员为指向 _dispatch_queue_attr_vtable 的指针</span></span><br><span class="line">        <span class="comment">// 这个指针用于指向虚函数表，定义了该结构体的行为和方法</span></span><br><span class="line">        .do_vtable = (&amp;_dispatch_queue_attr_vtable), <span class="comment">// 指向虚函数表的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 do_ref_cnt 成员为 INT_MAX</span></span><br><span class="line">        <span class="comment">// 这表示全局对象的引用计数，通常设置为 INT_MAX 以防止对象被释放</span></span><br><span class="line">        .do_ref_cnt = INT_MAX, <span class="comment">// 全局对象的引用计数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 do_xref_cnt 成员为 INT_MAX</span></span><br><span class="line">        <span class="comment">// 这表示全局对象的弱引用计数，同样设置为 INT_MAX，以确保对象在程序运行期间始终有效</span></span><br><span class="line">        .do_xref_cnt = INT_MAX <span class="comment">// 全局对象的弱引用计数</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>尽管 <code>_dispatch_queue_attrs</code> 中 <code>4032</code> 个元素的初始值相同，但实际使用过程中会根据不同的条件或配置修改特定元素的属性，以支持不同的队列行为或策略。通过 <code>_dispatch_queue_attrs</code> 数组索引直接访问属性组合，而不是在运行时计算或生成新的组合，提升了访问的速度和效率。而 <code>DISPATCH_QUEUE_CONCURRENT</code> 则是 <code>_dispatch_queue_attrs</code> 数组的第 <code>0</code> 个元素。</p>
<h2 id="三、dispatch-queue-create"><a href="#三、dispatch-queue-create" class="headerlink" title="三、dispatch_queue_create"></a>三、dispatch_queue_create</h2><p><code>dispatch_queue_create</code> 函数源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_t</span></span><br><span class="line"><span class="title function_">dispatch_queue_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *label, <span class="type">dispatch_queue_attr_t</span> attr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_lane_create_with_target(label, attr,</span><br><span class="line">            DISPATCH_TARGET_QUEUE_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1、参数-label-attr"><a href="#1、参数-label-attr" class="headerlink" title="1、参数 label &amp; attr"></a>1、参数 label &amp; attr</h3><h4 id="（1）label-参数"><a href="#（1）label-参数" class="headerlink" title="（1）label 参数"></a>（1）label 参数</h4><p><code>char *</code> 类型的参数，用于为队列指定一个标识符，通常是一个描述性的字符串。label 参数对队列的功能和行为没有影响，主要用于调试和日志记录，帮助开发者识别和跟踪不同的队列。经常使用反向域名格式（如 <code>&quot;com.lixkit.serialQueue&quot;</code>），以确保标签的唯一性和可读性。</p>
<h4 id="（2）attr-参数"><a href="#（2）attr-参数" class="headerlink" title="（2）attr 参数"></a>（2）attr 参数</h4><p><code>attr</code> 参数，直接从方法定义上看是 <code>dispatch_queue_attr_t</code> 类型，实际上，其源码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_DECL(dispatch_queue_attr);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_DECL(name) typedef struct name##_s *name##_t</span></span><br></pre></td></tr></table></figure>
<p>这意味着 <code>dispatch_queue_attr_t</code> 是 <code>struct dispatch_queue_attr_s</code> 的指针类型，<code>dispatch_queue_attr_s</code> 的定义涉及到一系列宏定义和其他结构体的嵌套，将其完全展开后源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     对象系统的基础类型</span></span><br><span class="line"><span class="comment">     _as_os_obj 是一个零长度数组，用于类型转换和内存布局</span></span><br><span class="line"><span class="comment">     在对象系统中，这个字段用于支持对象模型的基础结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> _<span class="title">as_os_obj</span>[0];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     do_vtable 是一个指向虚函数表的指针</span></span><br><span class="line"><span class="comment">     这个指针用于支持方法的动态分派，类似于C++中的虚函数机制</span></span><br><span class="line"><span class="comment">     __ptrauth_objc_isa_pointer 是一个指针认证标记，增强安全性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_vtable_s</span> *__<span class="title">ptrauth_objc_isa_pointer</span> <span class="title">do_vtable</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     强引用计数</span></span><br><span class="line"><span class="comment">     用于跟踪对象的引用次数，确保对象在被引用时不会被释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> do_ref_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     弱引用计数</span></span><br><span class="line"><span class="comment">     用于管理对象的弱引用关系，允许对象在没有强引用时被释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> do_xref_cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2、返回值-dispatch-queue-t"><a href="#2、返回值-dispatch-queue-t" class="headerlink" title="2、返回值 dispatch_queue_t"></a>2、返回值 dispatch_queue_t</h3><p><code>dispatch_queue_create</code> 的返回值是 <code>dispatch_queue_t</code>，<code>dispatch_queue_t</code> 是一个指向 <code>dispatch_queue_s</code> 结构体的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">dispatch_queue_t</span>;</span></span><br></pre></td></tr></table></figure>
<p><code>dispatch_queue_s</code> 是一个复杂的结构体，包含了许多宏定义和其他结构体的嵌套。完全展开后的 <code>dispatch_queue_s</code> 源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line">    <span class="comment">// 作为基础对象的一部分，允许类型转换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> _<span class="title">as_do</span>[0];</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部对象头部定义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> _<span class="title">as_os_obj</span>[0];</span> <span class="comment">// 零长度数组，用于类型转换</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_vtable_s</span> *__<span class="title">ptrauth_objc_isa_pointer</span> <span class="title">do_vtable</span>;</span> <span class="comment">// 虚表指针，用于方法调度</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> do_ref_cnt;  <span class="comment">// 对象的引用计数</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> do_xref_cnt; <span class="comment">// 交叉引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> <span class="comment">// 下一个队列对象的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> <span class="comment">// 目标队列指针</span></span><br><span class="line">    <span class="type">void</span> *do_ctxt; <span class="comment">// 上下文指针</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">dispatch_function_t</span> DISPATCH_FUNCTION_POINTER do_finalizer; <span class="comment">// 终结器函数</span></span><br><span class="line">        <span class="type">void</span> *do_introspection_ctxt; <span class="comment">// 自省上下文</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *__dq_opaque1; <span class="comment">// 指针大小的字段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 32位整数，表示队列的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint64_t</span> <span class="keyword">volatile</span> dq_state; <span class="comment">// 队列状态</span></span><br><span class="line">        dispatch_lock dq_state_lock; <span class="comment">// 队列状态锁</span></span><br><span class="line">        <span class="type">uint32_t</span> dq_state_bits; <span class="comment">// 队列状态位</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LP64 全局队列缓存行边界</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dq_serialnum; <span class="comment">// 队列的序列号</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dq_label; <span class="comment">// 队列标签，用于标识队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，用于存储队列的标志和宽度</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> <span class="keyword">volatile</span> dq_atomic_flags; <span class="comment">// 队列的原子标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">const</span> <span class="type">uint16_t</span> dq_width; <span class="comment">// 队列的宽度，表示并发能力</span></span><br><span class="line">            <span class="type">const</span> <span class="type">uint16_t</span> __dq_opaque2; <span class="comment">// 额外的占位符字段</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">dispatch_priority_t</span> dq_priority; <span class="comment">// 队列优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，用于指向特定的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_specific_head_s</span> *<span class="title">dq_specific_head</span>;</span> <span class="comment">// 特定数据的头部</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_refs_s</span> *<span class="title">ds_refs</span>;</span> <span class="comment">// 源引用</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_timer_source_refs_s</span> *<span class="title">ds_timer_refs</span>;</span> <span class="comment">// 定时器源引用</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_recv_refs_s</span> *<span class="title">dm_recv_refs</span>;</span> <span class="comment">// Mach 消息接收引用</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_channel_callbacks_s</span> <span class="title">const</span> *<span class="title">dch_callbacks</span>;</span> <span class="comment">// 通道回调</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> dq_sref_cnt; <span class="comment">// 队列的强引用计数</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">8</span>))); <span class="comment">// 结构体按 8 字节对齐</span></span><br></pre></td></tr></table></figure>

<p>在 <code>dispatch_queue_s</code> 中，有多个匿名联合体，例如对于其中的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合体，用于存储队列的标志和宽度</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> <span class="keyword">volatile</span> dq_atomic_flags; <span class="comment">// 队列的原子标志</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">const</span> <span class="type">uint16_t</span> dq_width; <span class="comment">// 队列的宽度，表示并发能力</span></span><br><span class="line">        <span class="type">const</span> <span class="type">uint16_t</span> __dq_opaque2; <span class="comment">// 额外的占位符字段</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>匿名联合体中还有个匿名结构体，该数据结构总结如下：</p>
<ul>
<li>联合体（<code>union</code>）<ul>
<li>联合体中的所有成员共享同一段内存。</li>
<li><code>dq_atomic_flags</code> 和下面的匿名结构体共享同一段内存，对 <code>dq_atomic_flags</code> 赋值实际上就是对下面的结构体赋值。</li>
<li><code>dq_atomic_flags</code> 是 <code>32</code> 位的无符号整数类型，其占用了 <code>32</code> 位的内存区域。</li>
</ul>
</li>
<li>匿名结构体<ul>
<li>上述源码中结构体是匿名的，包含两个 <code>uint16_t</code> 类型的成员：<code>dq_width</code> 和 <code>__dq_opaque2</code>，即各自分别占用 <code>16</code> 位内存。</li>
<li>由于结构体的成员在内存中的排序是按照它们声明的顺序依次排列的，所以 <code>dq_width</code> 和 <code>__dq_opaque2</code> 分别占用 <code>dq_atomic_flags</code> 的低 <code>16</code> 位和高 <code>16</code> 位。</li>
</ul>
</li>
</ul>
<h3 id="3、-dispatch-lane-create-with-target"><a href="#3、-dispatch-lane-create-with-target" class="headerlink" title="3、_dispatch_lane_create_with_target"></a>3、_dispatch_lane_create_with_target</h3><p>再回头看下 <code>dispatch_queue_create</code> 函数的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_t</span></span><br><span class="line"><span class="title function_">dispatch_queue_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *label, <span class="type">dispatch_queue_attr_t</span> attr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_lane_create_with_target(label, attr,</span><br><span class="line">            DISPATCH_TARGET_QUEUE_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>dispatch_queue_create</code> 函数内部主要是调用了 <code>_dispatch_lane_create_with_target</code> 函数。</p>
<p>其中第三个参数 <code>DISPATCH_TARGET_QUEUE_DEFAULT</code> 本质是个 <code>NULL</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @const DISPATCH_TARGET_QUEUE_DEFAULT</span></span><br><span class="line"><span class="comment"> * @discussion Constant to pass to the dispatch_queue_create_with_target(),</span></span><br><span class="line"><span class="comment"> * dispatch_set_target_queue() and dispatch_source_create() functions to</span></span><br><span class="line"><span class="comment"> * indicate that the default target queue for the object type in question</span></span><br><span class="line"><span class="comment"> * should be used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_TARGET_QUEUE_DEFAULT NULL</span></span><br><span class="line">```c</span><br><span class="line">`_dispatch_lane_create_with_target` 实现源码如下：</span><br><span class="line">```c</span><br><span class="line"><span class="type">static</span> <span class="type">dispatch_queue_t</span></span><br><span class="line">_dispatch_lane_create_with_target(<span class="type">const</span> <span class="type">char</span> *label, <span class="type">dispatch_queue_attr_t</span> dqa,</span><br><span class="line">        <span class="type">dispatch_queue_t</span> tq, <span class="type">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、生成 dqai</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成 dqai：将传入的队列属性转换为结构体 dispatch_queue_attr_info_t 类型的 dqai</span></span><br><span class="line">    <span class="comment">// dqai 中包含了队列的服务质量（QoS）、相对优先级、超额提交属性、自动释放频率、并发性和非活动状态等信息。</span></span><br><span class="line">    <span class="type">dispatch_queue_attr_info_t</span> dqai = _dispatch_queue_attr_to_info(dqa);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取服务质量（QoS）信息。</span></span><br><span class="line">    <span class="comment">// 服务质量（QoS）是指任务的优先级，影响任务调度的优先级和资源分配。</span></span><br><span class="line">    <span class="type">dispatch_qos_t</span> qos = dqai.dqai_qos;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">    <span class="comment">// 如果不支持 pthread 的 QoS，并且 QoS 是用户交互级别，则降级为用户发起级别。</span></span><br><span class="line">    <span class="comment">// 用户交互级别：用于需要立即响应用户交互的任务，优先级最高。</span></span><br><span class="line">    <span class="comment">// 用户发起级别：用于用户主动发起的任务，优先级高于默认级别。</span></span><br><span class="line">    <span class="keyword">if</span> (qos == DISPATCH_QOS_USER_INTERACTIVE) &#123;</span><br><span class="line">        dqai.dqai_qos = qos = DISPATCH_QOS_USER_INITIATED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 QoS 是维护级别，则降级为后台级别。</span></span><br><span class="line">    <span class="comment">// 维护级别：用于系统维护任务，优先级低。</span></span><br><span class="line">    <span class="comment">// 后台级别：用于后台运行的任务，优先级低于默认级别。</span></span><br><span class="line">    <span class="keyword">if</span> (qos == DISPATCH_QOS_MAINTENANCE) &#123;</span><br><span class="line">        dqai.dqai_qos = qos = DISPATCH_QOS_BACKGROUND;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !HAVE_PTHREAD_WORKQUEUE_QOS</span></span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  2、创建 tq</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提取超额提交属性。</span></span><br><span class="line">    <span class="comment">// 超额提交：允许队列超出系统建议的并发限制，可能会导致资源争用。</span></span><br><span class="line">    <span class="type">_dispatch_queue_attr_overcommit_t</span> overcommit = dqai.dqai_overcommit;</span><br><span class="line">    <span class="comment">// 如果指定了超额提交并且有目标队列。</span></span><br><span class="line">    <span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified &amp;&amp; tq) &#123;</span><br><span class="line">        <span class="comment">// 如果目标队列不是全局队列，则崩溃。</span></span><br><span class="line">        <span class="comment">// 目标队列：队列的执行目标队列，可以是全局队列或其他队列。</span></span><br><span class="line">        <span class="keyword">if</span> (tq-&gt;do_targetq) &#123;</span><br><span class="line">            DISPATCH_CLIENT_CRASH(tq, <span class="string">&quot;Cannot specify both overcommit and &quot;</span></span><br><span class="line">                    <span class="string">&quot;a non-global target queue&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果目标队列是全局根队列。</span></span><br><span class="line">    <span class="comment">// 根队列：GCD 提供的全局并发队列，系统级别的队列。</span></span><br><span class="line">    <span class="keyword">if</span> (tq &amp;&amp; dx_type(tq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// 处理属性和目标队列之间的差异，以属性为准。</span></span><br><span class="line">        <span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) &#123;</span><br><span class="line">                overcommit = _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                overcommit = _dispatch_queue_attr_overcommit_disabled;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 QoS 未指定，则从目标队列中获取。</span></span><br><span class="line">        <span class="keyword">if</span> (qos == DISPATCH_QOS_UNSPECIFIED) &#123;</span><br><span class="line">            qos = _dispatch_priority_qos(tq-&gt;dq_priority);</span><br><span class="line">        &#125;</span><br><span class="line">        tq = <span class="literal">NULL</span>; <span class="comment">// 清除目标队列引用。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tq &amp;&amp; _dispatch_queue_is_cooperative(tq)) &#123;</span><br><span class="line">        <span class="comment">// 如果目标队列是协作型根队列，则崩溃（未实现）。</span></span><br><span class="line">        <span class="comment">// 协作型根队列：一种特殊的根队列，尚未实现。</span></span><br><span class="line">        DISPATCH_CLIENT_CRASH(tq, <span class="string">&quot;Cannot target object to cooperative root queue - not implemented&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tq &amp;&amp; !tq-&gt;do_targetq) &#123;</span><br><span class="line">        <span class="comment">// 如果目标是 pthread 或 runloop 根队列，不允许设置 QoS 或超额提交。</span></span><br><span class="line">        <span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">            DISPATCH_CLIENT_CRASH(tq, <span class="string">&quot;Cannot specify an overcommit attribute &quot;</span></span><br><span class="line">                    <span class="string">&quot;and use this kind of target queue&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果未指定超额提交，串行队列默认开启超额提交。即：串行队列是 overcommit 的，并发队列是非 overcommit 的</span></span><br><span class="line">        <span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">            overcommit = dqai.dqai_concurrent ?</span><br><span class="line">                    _dispatch_queue_attr_overcommit_disabled :</span><br><span class="line">                    _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有目标队列，根据 QoS 获取根队列。</span></span><br><span class="line">    <span class="comment">// dispatch_queue_create 函数，tq 参数是 DISPATCH_TARGET_QUEUE_DEFAULT 宏，即 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> flags = (overcommit == _dispatch_queue_attr_overcommit_enabled) ? DISPATCH_QUEUE_OVERCOMMIT : <span class="number">0</span>;</span><br><span class="line">        tq = _dispatch_get_root_queue(</span><br><span class="line">                qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">                    flags)-&gt;_as_dq;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!tq)) &#123;</span><br><span class="line">            DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、初始化队列 dq</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch_queue_create 函数，legacy 参数传的 true</span></span><br><span class="line">    <span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">        <span class="comment">// 如果指定了非传统属性，则使用非传统类。</span></span><br><span class="line">        <span class="comment">// 非传统属性：例如非活动状态或自动释放频率。</span></span><br><span class="line">        <span class="comment">// 非传统类：指不使用传统的队列类。</span></span><br><span class="line">        <span class="keyword">if</span> (dqai.dqai_inactive || dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">            legacy = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *vtable;</span><br><span class="line">    <span class="type">dispatch_queue_flags_t</span> dqf = legacy ? DQF_MUTABLE : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据并发属性选择虚函数表。</span></span><br><span class="line">    <span class="comment">// 虚函数表：包含对象方法指针的表，用于动态调度。</span></span><br><span class="line">    <span class="keyword">if</span> (dqai.dqai_concurrent) &#123;</span><br><span class="line">        <span class="comment">// 宏展开后：vtable = &amp;_dispatch_queue_concurrent_vtable</span></span><br><span class="line">        vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 宏展开后：vtable = &amp;_dispatch_queue_serial_vtable</span></span><br><span class="line">        vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置自动释放频率标志。</span></span><br><span class="line">    <span class="comment">// 自动释放频率：控制自动释放池的刷新频率。</span></span><br><span class="line">    <span class="keyword">switch</span> (dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_NEVER:</span><br><span class="line">        dqf |= DQF_AUTORELEASE_NEVER;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM:</span><br><span class="line">        dqf |= DQF_AUTORELEASE_ALWAYS;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有标签，复制标签并设置需要释放标志。</span></span><br><span class="line">    <span class="keyword">if</span> (label) &#123;</span><br><span class="line">        <span class="comment">// 调用 _dispatch_strdup_if_mutable 函数创建标签的副本</span></span><br><span class="line">        <span class="comment">// _dispatch_strdup_if_mutable 函数总是调用 strdup 创建一个新的字符串副本</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *tmp = _dispatch_strdup_if_mutable(label);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查新创建的副本（tmp）是否与原始标签（label）不同</span></span><br><span class="line">        <span class="comment">// 如果 tmp != label，说明创建了一个新的字符串副本，内存地址不同</span></span><br><span class="line">        <span class="keyword">if</span> (tmp != label) &#123;</span><br><span class="line">            <span class="comment">// 设置 DQF_LABEL_NEEDS_FREE 标志，表示需要在适当的时候释放这个标签</span></span><br><span class="line">            <span class="comment">// 这样做是为了在队列销毁时能够正确释放标签内存，避免内存泄漏</span></span><br><span class="line">            dqf |= DQF_LABEL_NEEDS_FREE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将标签变量更新为新创建的副本</span></span><br><span class="line">            <span class="comment">// 这样后续操作将使用这个新的标签副本，而不是原始标签</span></span><br><span class="line">            label = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 分配内存</span></span><br><span class="line">    <span class="comment">// 注意，dq 是 dispatch_lane_t 类型</span></span><br><span class="line">    <span class="type">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_lane_s));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.2 初始化</span></span><br><span class="line">    _dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">            DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">            (dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置队列标签和优先级。</span></span><br><span class="line">    dq-&gt;dq_label = label;</span><br><span class="line">    dq-&gt;dq_priority = _dispatch_priority_make((<span class="type">dispatch_qos_t</span>)dqai.dqai_qos,</span><br><span class="line">            dqai.dqai_relpri);</span><br><span class="line">    <span class="comment">// 如果开启超额提交，设置相应标志。</span></span><br><span class="line">    <span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">        dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列不是非活动状态，继承目标队列的优先级和工作循环。</span></span><br><span class="line">    <span class="keyword">if</span> (!dqai.dqai_inactive) &#123;</span><br><span class="line">        _dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">        _dispatch_lane_inherit_wlh_from_target(dq, tq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保留目标队列引用。</span></span><br><span class="line">    _dispatch_retain(tq);</span><br><span class="line">    <span class="comment">// 设置目标 targetq 为 tq</span></span><br><span class="line">    dq-&gt;do_targetq = tq;</span><br><span class="line">    <span class="comment">// 调试输出。</span></span><br><span class="line">    _dispatch_object_debug(dq, <span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="comment">// 返回创建的队列。</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述逻辑比较多，可以将上面逻辑拆分成下面这部分：</p>
<ul>
<li><strong>生成 <code>dqai</code>（<code>dispatch_queue_attr_info_t</code>）</strong></li>
<li><strong>创建 <code>tq</code>（<code>dispatch_queue_t</code>）</strong></li>
<li><strong>初始化队列 <code>dq</code>（<code>dispatch_lane_t</code>）</strong><ul>
<li>分配内存</li>
<li>初始化</li>
</ul>
</li>
<li><strong><code>dq</code> 其他配置</strong></li>
</ul>
<p>接下来，基于源码分别看下上述各部分逻辑。</p>
<h4 id="（1）生成-dqai"><a href="#（1）生成-dqai" class="headerlink" title="（1）生成 dqai"></a>（1）生成 dqai</h4><p><code>dqai</code> 是 <code>dispatch_queue_attr_info_t</code> 结构体类型，<code>dqai</code> 中包含了队列的服务质量（QoS）、相对优先级、超额提交属性、自动释放频率、并发性和非活动状态等信息。</p>
<p><code>dispatch_queue_attr_info_t</code> 结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_info_s</span> &#123;</span></span><br><span class="line">    <span class="comment">// 服务质量（QoS），占用 8 位。</span></span><br><span class="line">    <span class="comment">// QoS 决定了任务的优先级，影响调度和资源分配。</span></span><br><span class="line">    <span class="type">dispatch_qos_t</span> dqai_qos : <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对优先级，占用 8 位。</span></span><br><span class="line">    <span class="comment">// 这是相对于服务质量（QoS）的优先级调整值，用于进一步微调任务的调度优先级。</span></span><br><span class="line">    <span class="type">int</span> dqai_relpri : <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超额提交属性，占用 2 位。</span></span><br><span class="line">    <span class="comment">// 指示队列是否允许超出系统建议的并发限制。</span></span><br><span class="line">    <span class="comment">// 可能的值可以表示启用、禁用或未指定。</span></span><br><span class="line">    <span class="type">uint16_t</span> dqai_overcommit : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动释放频率，占用 2 位。</span></span><br><span class="line">    <span class="comment">// 控制自动释放池的刷新频率，可能的值包括从不、每个工作项或默认。</span></span><br><span class="line">    <span class="type">uint16_t</span> dqai_autorelease_frequency : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发性属性，占用 1 位。</span></span><br><span class="line">    <span class="comment">// 指示队列是并发队列（多个任务可以同时执行）还是串行队列（任务按顺序执行）。</span></span><br><span class="line">    <span class="type">uint16_t</span> dqai_concurrent : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非活动状态，占用 1 位。</span></span><br><span class="line">    <span class="comment">// 指示队列是否在初始化时处于非活动状态。</span></span><br><span class="line">    <span class="comment">// 非活动队列在激活之前不会调度任务。</span></span><br><span class="line">    <span class="type">uint16_t</span> dqai_inactive : <span class="number">1</span>;</span><br><span class="line">&#125; <span class="type">dispatch_queue_attr_info_t</span>;</span><br></pre></td></tr></table></figure>

<p>生成 <code>dqai</code> 是通过 <code>_dispatch_queue_attr_to_info</code> 函数实现的，<code>_dispatch_queue_attr_to_info</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_attr_info_t</span></span><br><span class="line">_dispatch_queue_attr_to_info(<span class="type">dispatch_queue_attr_t</span> dqa)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化一个队列属性信息结构体，用于存储解析后的队列属性。</span></span><br><span class="line">    <span class="comment">// 这个结构体包含了服务质量（QoS）、相对优先级、超额提交设置、自动释放频率、并发性和非活动状态等信息。</span></span><br><span class="line">    <span class="type">dispatch_queue_attr_info_t</span> dqai = &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入的队列属性为空，则返回默认初始化的结构体。</span></span><br><span class="line">    <span class="keyword">if</span> (!dqa) <span class="keyword">return</span> dqai;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查传入的队列属性是否在有效范围内。</span></span><br><span class="line">    <span class="comment">// 如果不在范围内，则崩溃，因为这意味着传入了无效的队列属性。</span></span><br><span class="line">    <span class="keyword">if</span> (dqa &lt; _dispatch_queue_attrs ||</span><br><span class="line">            dqa &gt;= &amp;_dispatch_queue_attrs[DISPATCH_QUEUE_ATTR_COUNT]) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(dqa-&gt;do_vtable, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算索引值，用于解析不同的属性。</span></span><br><span class="line">    <span class="comment">// 这里使用的是一个偏移量计算方法，根据不同的属性组合得出唯一的索引。</span></span><br><span class="line">    <span class="type">size_t</span> idx = (<span class="type">size_t</span>)(dqa - _dispatch_queue_attrs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析非活动状态属性。</span></span><br><span class="line">    <span class="comment">// 通过索引对非活动状态的总数取模，判断该属性是否设置。</span></span><br><span class="line">    dqai.dqai_inactive = (idx % DISPATCH_QUEUE_ATTR_INACTIVE_COUNT);</span><br><span class="line">    <span class="comment">// 更新索引，准备解析下一个属性。</span></span><br><span class="line">    idx /= DISPATCH_QUEUE_ATTR_INACTIVE_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并发性属性。</span></span><br><span class="line">    <span class="comment">// 通过索引对并发性属性的总数取模，判断队列是并发还是串行。</span></span><br><span class="line">    dqai.dqai_concurrent = !(idx % DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT);</span><br><span class="line">    <span class="comment">// 更新索引，准备解析下一个属性。</span></span><br><span class="line">    idx /= DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析相对优先级属性。</span></span><br><span class="line">    <span class="comment">// 通过索引对优先级属性的总数取模，获取相对优先级值。</span></span><br><span class="line">    dqai.dqai_relpri = -(<span class="type">int</span>)(idx % DISPATCH_QUEUE_ATTR_PRIO_COUNT);</span><br><span class="line">    <span class="comment">// 更新索引，准备解析下一个属性。</span></span><br><span class="line">    idx /= DISPATCH_QUEUE_ATTR_PRIO_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析服务质量（QoS）属性。</span></span><br><span class="line">    <span class="comment">// 通过索引对 QoS 属性的总数取模，获取 QoS 值。</span></span><br><span class="line">    dqai.dqai_qos = idx % DISPATCH_QUEUE_ATTR_QOS_COUNT;</span><br><span class="line">    <span class="comment">// 更新索引，准备解析下一个属性。</span></span><br><span class="line">    idx /= DISPATCH_QUEUE_ATTR_QOS_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析自动释放频率属性。</span></span><br><span class="line">    <span class="comment">// 通过索引对自动释放频率属性的总数取模，获取自动释放频率。</span></span><br><span class="line">    dqai.dqai_autorelease_frequency =</span><br><span class="line">            idx % DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;</span><br><span class="line">    <span class="comment">// 更新索引，准备解析下一个属性。</span></span><br><span class="line">    idx /= DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析超额提交属性。</span></span><br><span class="line">    <span class="comment">// 通过索引对超额提交属性的总数取模，获取超额提交设置。</span></span><br><span class="line">    dqai.dqai_overcommit = idx % DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;</span><br><span class="line">    <span class="comment">// 更新索引，准备解析下一个属性。</span></span><br><span class="line">    idx /= DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回解析后的队列属性信息结构体。</span></span><br><span class="line">    <span class="keyword">return</span> dqai;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面已经提到，当创建串行队列时，<code>attr</code> 参数为 <code>DISPATCH_QUEUE_SERIAL</code>，本质为 <code>NULL</code>。此时 <code>_dispatch_queue_attr_to_info</code> 函数返回值为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_attr_info_t</span> dqai = &#123;</span><br><span class="line">    .dqai_qos = <span class="number">0</span>,</span><br><span class="line">    .dqai_relpri = <span class="number">0</span>,</span><br><span class="line">    .dqai_overcommit = <span class="number">0</span>,</span><br><span class="line">    .dqai_autorelease_frequency = <span class="number">0</span>,</span><br><span class="line">    .dqai_concurrent = <span class="number">0</span>, <span class="comment">// 串行队列</span></span><br><span class="line">    .dqai_inactive = <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当创建并发队列时，<code>attr</code> 参数为 <code>DISPATCH_QUEUE_CONCURRENT</code>，此时 <code>_dispatch_queue_attr_to_info</code> 函数返回值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_attr_info_t dqai = &#123;</span><br><span class="line">    .dqai_qos = 0,</span><br><span class="line">    .dqai_relpri = 0,</span><br><span class="line">    .dqai_overcommit = 0,</span><br><span class="line">    .dqai_autorelease_frequency = 0,</span><br><span class="line">    .dqai_concurrent = 1, // 并发队列</span><br><span class="line">    .dqai_inactive = 0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以，当创建串行、并发队列时，<code>_dispatch_queue_attr_to_info</code> 函数返回的结果仅 <code>dqai_concurrent</code> 值不同，分别是 <code>0</code> 和 <code>1</code>。</p>
<h4 id="（2）创建-tq"><a href="#（2）创建-tq" class="headerlink" title="（2）创建 tq"></a>（2）创建 tq</h4><p>根据前述源码，在创建 tq 前需要先获取超额提交属性 <code>overcommit</code>，<br><code>dispatch_queue_create</code> 函数在调用时 <code>_dispatch_lane_create_with_target</code>，<code>tq</code> 参数传入的是 <code>DISPATCH_TARGET_QUEUE_DEFAULT</code>，前面已经提到，<code>DISPATCH_TARGET_QUEUE_DEFAULT</code> 本质是个 <code>NULL</code>，所以会走调用下面的 if 分支：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">    overcommit = dqai.dqai_concurrent ?</span><br><span class="line">            _dispatch_queue_attr_overcommit_disabled :</span><br><span class="line">            _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，创建串行队列时，<code>overcommi</code>t 为 <code>_dispatch_queue_attr_overcommit_enabled</code>。创建并发队列时，<code>overcommit</code> 为 <code>_dispatch_queue_attr_overcommit_enabled</code>。</p>
<p>从此处可以得到一个结论：串行队列是 <code>overcommit</code> 的，并发队列是非 <code>overcommit</code> 的。</p>
<p>接下来进入 <code>tq</code> 的创建逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有目标队列，根据 QoS 获取根队列。</span></span><br><span class="line"><span class="comment">// dispatch_queue_create 函数，tq 参数是 DISPATCH_TARGET_QUEUE_DEFAULT 宏，即 NULL</span></span><br><span class="line"><span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> flags = (overcommit == _dispatch_queue_attr_overcommit_enabled) ? DISPATCH_QUEUE_OVERCOMMIT : <span class="number">0</span>;</span><br><span class="line">    tq = _dispatch_get_root_queue(</span><br><span class="line">            qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">                flags)-&gt;_as_dq;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!tq)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>_dispatch_get_root_queue</code> 实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_queue_global_t</span></span><br><span class="line">_dispatch_get_root_queue(<span class="type">dispatch_qos_t</span> qos, <span class="type">uintptr_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查 QoS 是否在有效范围内。如果不在范围内，则触发崩溃。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(qos &lt; DISPATCH_QOS_MIN || qos &gt; DISPATCH_QOS_MAX)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Corrupted priority&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> add_on = <span class="number">0</span>; <span class="comment">// 初始化索引偏移量为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据标志设置索引偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DISPATCH_QUEUE_OVERCOMMIT) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了 OVERCOMMIT 标志，使用 OVERCOMMIT 偏移量</span></span><br><span class="line">        add_on = DISPATCH_ROOT_QUEUE_IDX_OFFSET_OVERCOMMIT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; DISPATCH_QUEUE_COOPERATIVE) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了 COOPERATIVE 标志，使用 COOPERATIVE 偏移量</span></span><br><span class="line">        add_on = DISPATCH_ROOT_QUEUE_IDX_OFFSET_COOPERATIVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并返回指向合适的全局根队列的指针</span></span><br><span class="line">    <span class="comment">// 计算公式为：3 * (qos - 1) + add_on</span></span><br><span class="line">    <span class="comment">// 其中，3 是每个 QoS 级别有三个不同类型的队列（普通、超额提交、协作）</span></span><br><span class="line">    <span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">3</span> * (qos - <span class="number">1</span>) + add_on];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先看下 <code>_dispatch_root_queues</code>，<code>_dispatch_root_queues</code> 是一个 <code>dispatch_queue_global_s</code> 类型的数组，先看下 <code>dispatch_queue_global_s</code> 的定义，<code>dispatch_queue_global_s</code> 的定义涉及击到一系列宏，将其完全展开后如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_global_s</span> &#123;</span></span><br><span class="line">    <span class="comment">// 零长度数组，用于类型转换为 dispatch_queue_s</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> _<span class="title">as_dq</span>[0];</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch 对象头部定义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> _<span class="title">as_do</span>[0];</span> <span class="comment">// 零长度数组，用于类型转换为 dispatch_object_s</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> _<span class="title">as_os_obj</span>[0];</span> <span class="comment">// 零长度数组，用于类型转换为 _os_object_s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的虚表指针，用于方法调度</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> *__<span class="title">ptrauth_objc_isa_pointer</span> <span class="title">do_vtable</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的引用计数</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> do_ref_cnt;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交叉引用计数</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> do_xref_cnt; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个队列对象的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标队列指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文指针</span></span><br><span class="line">    <span class="type">void</span> *do_ctxt; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，包含终结器函数或自省上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">dispatch_function_t</span> DISPATCH_FUNCTION_POINTER do_finalizer; </span><br><span class="line">        <span class="type">void</span> *do_introspection_ctxt; </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针大小的字段，指向队列尾部的对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_tail</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池大小</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> dgq_thread_pool_size; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针大小的字段，指向队列头部的对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_head</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起的线程数</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> dgq_pending; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，用于存储队列的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint64_t</span> <span class="keyword">volatile</span> dq_state; <span class="comment">// 队列状态</span></span><br><span class="line">        dispatch_lock dq_state_lock; <span class="comment">// 队列状态锁</span></span><br><span class="line">        <span class="type">uint32_t</span> dq_state_bits; <span class="comment">// 队列状态位</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LP64 全局队列缓存行边界</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dq_serialnum; <span class="comment">// 队列的序列号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列标签，用于标识队列</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dq_label; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，用于存储队列的标志和宽度</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> <span class="keyword">volatile</span> dq_atomic_flags; <span class="comment">// 队列的原子标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">const</span> <span class="type">uint16_t</span> dq_width; <span class="comment">// 队列的宽度，即：队列能够同时处理的任务的数量</span></span><br><span class="line">            <span class="type">const</span> <span class="type">uint16_t</span> __dq_opaque2; <span class="comment">// 额外的占位符字段</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列优先级</span></span><br><span class="line">    <span class="type">dispatch_priority_t</span> dq_priority; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，用于指向特定的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_specific_head_s</span> *<span class="title">dq_specific_head</span>;</span> <span class="comment">// 特定数据的头部</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_refs_s</span> *<span class="title">ds_refs</span>;</span> <span class="comment">// 源引用</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_timer_source_refs_s</span> *<span class="title">ds_timer_refs</span>;</span> <span class="comment">// 定时器源引用</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_recv_refs_s</span> *<span class="title">dm_recv_refs</span>;</span> <span class="comment">// Mach 消息接收引用</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_channel_callbacks_s</span> <span class="title">const</span> *<span class="title">dch_callbacks</span>;</span> <span class="comment">// 通道回调</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的强引用计数</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> dq_sref_cnt; </span><br><span class="line">&#125; __attribute__((__aligned__(<span class="number">64</span>))); <span class="comment">// 结构体按 64 字节对齐</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>dispatch_queue_global_s</code> 与前面提到的 <code>dispatch_queue_s</code> 结构几乎是一样的，最大的区别是 <code>dispatch_queue_global_s</code> 中多了个 <code>struct dispatch_queue_s _as_dq[0]; </code> 的零长数组，意味着可以通过 <code>_as_dq</code> 将 <code>dispatch_queue_global_s</code> 转成 <code>dispatch_queue_s</code>。</p>
<p>这种设计在 libdispatch 的源码中非常常见，通常用于类型转换或类型兼容性，这种设计的原理是：</p>
<ul>
<li><strong>内存布局和对齐</strong><ul>
<li>在 C 语言中，结构体的内存布局是由其成员的声明顺序决定的。编译器会按照声明的顺序为每个成员分配内存，并根据目标平台的对齐要求进行对齐。</li>
<li>零长度数组在内存中不占用空间，但它的存在可以影响后续成员的对齐和布局。</li>
</ul>
</li>
<li><strong>类型转换的目的</strong><ul>
<li>当一个结构体包含另一个结构体的零长度数组时，编译器会将该数组视作一个指向数组元素类型的指针。这意味着，在内存布局上，该结构体的起始位置与零长度数组的元素类型的起始位置一致。</li>
<li>通过这种方式，包含零长度数组的结构体可以与数组元素类型具有相同的内存起始布局，从而实现类型兼容。</li>
</ul>
</li>
<li><strong>类型兼容性的实现</strong><ul>
<li>例如，<code>dispatch_queue_global_s</code> 包含 <code>struct dispatch_queue_s _as_dq[0]</code>，这意味着在内存布局上，<code>dispatch_queue_global_s</code> 的起始位置与 <code>dispatch_queue_s</code> 的起始位置一致。</li>
<li>这允许通过 <code>_as_dq</code> 指针将 <code>dispatch_queue_global_s</code> 视作 <code>dispatch_queue_s</code>，因为它们在内存中的起始位置是相同的。</li>
</ul>
</li>
<li><strong>实现多态性</strong><ul>
<li>这种设计模式允许使用不同类型的结构体通过相同的接口进行操作，实现多态性和灵活性。</li>
<li>通过零长度数组或灵活数组成员，开发者可以在不增加内存开销的情况下，实现类型之间的灵活转换。</li>
</ul>
</li>
</ul>
<p><code>_dispatch_root_queues</code> 的定义中也涉及到一系列宏定义，将 <code>_dispatch_root_queues</code> 内部宏定义完全展开后，实际内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_global_s</span> _<span class="title">dispatch_root_queues</span>[] =</span> &#123;</span><br><span class="line">    <span class="comment">// MAINTENANCE QOS</span></span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_MAINTENANCE, <span class="number">0</span>),</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.maintenance-qos&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS_OVERCOMMIT),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_MAINTENANCE, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.maintenance-qos.overcommit&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS_COOPERATIVE] = &#123;</span><br><span class="line">        .do_vtable = DISPATCH_VTABLE(queue_concurrent),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_MAINTENANCE, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_COOPERATIVE,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.maintenance-qos.cooperative&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">6</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// BACKGROUND QOS</span></span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_BACKGROUND, <span class="number">0</span>),</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.background-qos&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">7</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS_OVERCOMMIT),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_BACKGROUND, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.background-qos.overcommit&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">8</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS_COOPERATIVE] = &#123;</span><br><span class="line">        .do_vtable = DISPATCH_VTABLE(queue_concurrent),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_BACKGROUND, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_COOPERATIVE,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.background-qos.cooperative&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">9</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// UTILITY QOS</span></span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_UTILITY, <span class="number">0</span>),</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.utility-qos&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">10</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS_OVERCOMMIT),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_UTILITY, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.utility-qos.overcommit&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">11</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS_COOPERATIVE] = &#123;</span><br><span class="line">        .do_vtable = DISPATCH_VTABLE(queue_concurrent),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_UTILITY, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_COOPERATIVE,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.utility-qos.cooperative&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">12</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// DEFAULT QOS</span></span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT),</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.default-qos&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">13</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.default-qos.overcommit&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">14</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_COOPERATIVE] = &#123;</span><br><span class="line">        .do_vtable = DISPATCH_VTABLE(queue_concurrent),</span><br><span class="line">        .dq_priority = _dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT) | DISPATCH_PRIORITY_FLAG_COOPERATIVE,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.default-qos.cooperative&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">15</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// USER_INITIATED QOS</span></span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_USER_INITIATED, <span class="number">0</span>),</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">16</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS_OVERCOMMIT),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_USER_INITIATED, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos.overcommit&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">17</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS_COOPERATIVE] = &#123;</span><br><span class="line">        .do_vtable = DISPATCH_VTABLE(queue_concurrent),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_USER_INITIATED, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_COOPERATIVE,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos.cooperative&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">18</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// USER_INTERACTIVE QOS</span></span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_USER_INTERACTIVE, <span class="number">0</span>),</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">19</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">        .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS_OVERCOMMIT),</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_USER_INTERACTIVE, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos.overcommit&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">20</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS_COOPERATIVE] = &#123;</span><br><span class="line">        .do_vtable = DISPATCH_VTABLE(queue_concurrent),</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_USER_INTERACTIVE, <span class="number">0</span>) | DISPATCH_PRIORITY_FLAG_COOPERATIVE,</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos.cooperative&quot;</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">21</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据源码可知，<code>_dispatch_root_queues</code> 本质就是一个数组，数组的 <code>index</code> 是个枚举，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS = <span class="number">0</span>,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS_COOPERATIVE,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS_COOPERATIVE,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS_COOPERATIVE,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_COOPERATIVE,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS_COOPERATIVE,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS_COOPERATIVE,</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_IDX_COUNT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据枚举定义也可以看出，数组的 <code>index</code> 是通过不同的调度策略进行拼接的，<code>_dispatch_get_root_queue</code> 中会根据不同的策略计算出对应的 <code>index</code> 从 <code>_dispatch_root_queues</code> 数组中取值。</p>
<p>再回到 <code>_dispatch_get_root_queue</code> 函数，看创建串行、并发队列时，传入的 <code>index</code>，经过计算可以知道，创建串行队列时，<code>index = 10</code>，创建并发队列时 <code>index = 9</code>。</p>
<p>所以创建串行队列时，返回的是 <code>_dispatch_root_queues</code> 数组 <code>index = 10</code> 的元素（<code>DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT</code>），即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT] = &#123;</span><br><span class="line">    DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">    .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">    .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT),</span><br><span class="line">    .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">    .dq_priority = _dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT) | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">    .dq_label = <span class="string">&quot;com.apple.root.default-qos.overcommit&quot;</span>,</span><br><span class="line">    .dq_serialnum = <span class="number">14</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>创建并发队列时，返回的是 <code>_dispatch_root_queues</code> 数组 <code>index = 9</code> 的元素（<code>DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS</code>），即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS] = &#123;</span><br><span class="line">    DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),</span><br><span class="line">    .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">    .do_ctxt = _dispatch_root_queue_ctxt(DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS),</span><br><span class="line">    .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">    .dq_priority = _dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT),</span><br><span class="line">    .dq_label = <span class="string">&quot;com.apple.root.default-qos&quot;</span>,</span><br><span class="line">    .dq_serialnum = <span class="number">13</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这里创建完成的 <code>tq</code> 会在前述的 <code>_dispatch_lane_create_with_target</code> 后续逻辑中被设置成队列的 <code>do_targetq</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">dispatch_queue_t</span></span><br><span class="line">_dispatch_lane_create_with_target(<span class="type">const</span> <span class="type">char</span> *label, <span class="type">dispatch_queue_attr_t</span> dqa,</span><br><span class="line">        <span class="type">dispatch_queue_t</span> tq, <span class="type">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> flags = (overcommit == _dispatch_queue_attr_overcommit_enabled) ? DISPATCH_QUEUE_OVERCOMMIT : <span class="number">0</span>;</span><br><span class="line">        tq = _dispatch_get_root_queue(</span><br><span class="line">                qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">                    flags)-&gt;_as_dq;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    dq-&gt;do_targetq = tq;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以对于自定义的队列，无论是串行队列还是并发队列，其 <code>do_targetq</code> 都是从根队列数组 <code>_dispatch_root_queues</code> 中取出的对应的根队列（root queue）。</p>
<h4 id="（3）初始化队列-dq（dispatch-lane-t）"><a href="#（3）初始化队列-dq（dispatch-lane-t）" class="headerlink" title="（3）初始化队列 dq（dispatch_lane_t）"></a>（3）初始化队列 dq（dispatch_lane_t）</h4><p><code>_dispatch_lane_create_with_target</code> 函数中，创建的 <code>dq</code> 是 <code>dispatch_lane_t</code> 类型，那 <code>dispatch_lane_t</code> 和前面提到的 <code>dispatch_queue_s</code> 类型是什么关系呢？</p>
<p><code>dispatch_lane_t</code> 是一个指向 <code>dispatch_lane_s</code> 结构体的指针类型。<code>dispatch_lane_s</code> 是 <code>dispatch_queue_s</code> 的子类型，继承了队列的基本功能，并扩展了用于任务调度的字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_s</span> &#123;</span></span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dq_items_head</span>;</span> <span class="comment">// 队列头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dq_items_tail</span>;</span> <span class="comment">// 队列尾</span></span><br><span class="line">    dispatch_unfair_lock_s dq_sidelock; <span class="comment">// 辅助锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch_queue_s 包含的其他字段 ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从 <code>_dispatch_lane_create_with_target</code> 函数实现上来看，如果创建的串行队列还是并发队列，返回的都是 <code>dispatch_lane_s</code> 类型。</p>
<p>初始化队列 <code>dq</code> 可以分成两部分逻辑来看：</p>
<ul>
<li><strong>分配内存</strong></li>
<li><strong>初始化</strong></li>
</ul>
<h5 id="a、分配内存"><a href="#a、分配内存" class="headerlink" title="a、分配内存"></a>a、分配内存</h5><p>分配内存主要是通过 <code>_dispatch_object_alloc</code> 函数实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_lane_s));</span><br></pre></td></tr></table></figure>
<p>其中，<code>vtable</code> 参数值通过下述逻辑获取的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dqai.dqai_concurrent) &#123;</span><br><span class="line">    <span class="comment">// 宏展开后：vtable = &amp;_dispatch_queue_concurrent_vtable</span></span><br><span class="line">    vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 宏展开后：vtable = &amp;_dispatch_queue_serial_vtable</span></span><br><span class="line">    vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>vtable</code> 实际上是一个虚表(虚函数表)，虚表主要用于支持多态性和动态方法调用，允许对象在运行时调用对应的函数实现。一个类中有虚函数（<code>virtual</code> 关键字声明的函数）时，编译器会自动为该类及其派生类自动生成虚表，虚表中的指针会指向派生类的实现。</p>
<p>可以简单理解为虚表中存储了函数具体实现的指针。对应的类或结构体，通过访问虚表中的函数指针可以调用到对应的函数实现。</p>
<p>由上述源码可以知道，当创建串行队列时，<code>vtable</code> 为 <code>&amp;_dispatch_queue_serial_vtable</code>，当创建并发队列时，<code>vtabl</code>e 为 <code>&amp;_dispatch_queue_concurrent_vtable</code>。</p>
<p>接下来以 <code>_dispatch_queue_concurrent_vtable</code> 为例，看下源码实现。从 libdispatch 的源码中，找到了如下宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_SUBCLASS_DECL(queue_concurrent, <span class="built_in">queue</span>, lane);</span><br></pre></td></tr></table></figure>
<p>根据源码，将宏完全展开后如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@protocol OS_dispatch_queue_concurrent &lt;OS_dispatch_queue&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface <span class="title function_">OS_dispatch_queue_concurrent</span> <span class="params">()</span> &lt;OS_dispatch_queue_concurrent&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dispatch_queue_concurrent_s;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> _<span class="title">OS_dispatch_queue_concurrent_vtable</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> _<span class="title">dispatch_queue_concurrent_vtable</span> __<span class="title">asm__</span>(&quot;__<span class="title">OS_dispatch_queue_concurrent_vtable</span>&quot;);</span></span><br></pre></td></tr></table></figure>
<p>从上述源码可以看出，<code>_OS_dispatch_queue_concurrent_vtable</code> 是 <code>OS_dispatch_queue_concurrent</code> 类的虚表，之后又通过 <code>__asm__</code> 指令在汇编代码中将 <code>_OS_dispatch_queue_concurrent_vtable</code> 与 <code>_dispatch_queue_concurrent_vtable</code> 进行关联。</p>
<p>所以 <code>_dispatch_queue_concurrent_vtable</code> 对应的实现类是 <code>OS_dispatch_queue_concurrent</code>，而 <code>_dispatch_queue_concurrent_vtable</code> 中则存储了 <code>OS_dispatch_queue_concurrent</code> 类相关函数的实现的指针。</p>
<p>这也是为什么将创建的并发队列打印出来之后，显示 <code>OS_dispatch_queue_concurrent</code> 的原因：<br><img src="/images/lix_blog_218.png"></p>
<p>同样的，根据源码可以知道创建串行队列，对应的实现类是 <code>OS_dispatch_queue_serial</code>。</p>
<p>从 libdispatch 的源码的下述源码，可以看到 <code>_dispatch_queue_concurrent_vtable</code> 中存储的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_concurrent, lane,</span><br><span class="line">    .do_type        = DISPATCH_QUEUE_CONCURRENT_TYPE,</span><br><span class="line">    .do_dispose     = _dispatch_lane_dispose,</span><br><span class="line">    .do_debug       = _dispatch_queue_debug,</span><br><span class="line">    .do_invoke      = _dispatch_lane_invoke,</span><br><span class="line"></span><br><span class="line">    .dq_activate    = _dispatch_lane_activate,</span><br><span class="line">    .dq_wakeup      = _dispatch_lane_wakeup,</span><br><span class="line">    .dq_push        = _dispatch_lane_concurrent_push,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_VTABLE_SUBCLASS_INSTANCE(name, ctype, ...) \</span></span><br><span class="line"><span class="meta">        OS_OBJECT_VTABLE_SUBCLASS_INSTANCE(dispatch_##name, dispatch_##ctype, \</span></span><br><span class="line"><span class="meta">                _dispatch_xref_dispose, _dispatch_dispose, \</span></span><br><span class="line"><span class="meta">                .do_kind = #name, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_OBJECT_VTABLE_SUBCLASS_INSTANCE(name, ctype, xdispose, dispose, ...) \</span></span><br><span class="line"><span class="meta">        const struct ctype##_vtable_s OS_OBJECT_CLASS_SYMBOL(name) = &#123; \</span></span><br><span class="line"><span class="meta">            ._os_obj_xref_dispose = xdispose, \</span></span><br><span class="line"><span class="meta">            ._os_obj_dispose = dispose, \</span></span><br><span class="line"><span class="meta">            ._os_obj_vtable = &#123; __VA_ARGS__ &#125;, \</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_OBJECT_CLASS_SYMBOL(name) _##name##_vtable</span></span><br></pre></td></tr></table></figure>
<p>将宏完全展开后如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> _<span class="title">dispatch_queue_concurrent_vtable</span> =</span> &#123;</span><br><span class="line">    ._os_obj_xref_dispose = _dispatch_xref_dispose,</span><br><span class="line">    ._os_obj_dispose = _dispatch_dispose,</span><br><span class="line">    ._os_obj_vtable = &#123;</span><br><span class="line">        .do_kind = <span class="string">&quot;queue_concurrent&quot;</span>,</span><br><span class="line">        .do_type = DISPATCH_QUEUE_CONCURRENT_TYPE,</span><br><span class="line">        .do_dispose = _dispatch_lane_dispose,</span><br><span class="line">        .do_debug = _dispatch_queue_debug,</span><br><span class="line">        .do_invoke = _dispatch_lane_invoke,</span><br><span class="line">        .dq_activate = _dispatch_lane_activate,</span><br><span class="line">        .dq_wakeup = _dispatch_lane_wakeup,</span><br><span class="line">        .dq_push = _dispatch_lane_concurrent_push,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，也可以看到 <code>_dispatch_queue_serial_vtable</code> 内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_lane_vtable_s</span> _<span class="title">dispatch_queue_serial_vtable</span> =</span> &#123;</span><br><span class="line">    ._os_obj_xref_dispose = _dispatch_xref_dispose,</span><br><span class="line">    ._os_obj_dispose = _dispatch_dispose,</span><br><span class="line">    ._os_obj_vtable = &#123;</span><br><span class="line">        .do_kind = <span class="string">&quot;queue_serial&quot;</span>,</span><br><span class="line">        .do_type        = DISPATCH_QUEUE_SERIAL_TYPE,</span><br><span class="line">        .do_dispose     = _dispatch_lane_dispose,</span><br><span class="line">        .do_debug       = _dispatch_queue_debug,</span><br><span class="line">        .do_invoke      = _dispatch_lane_invoke,</span><br><span class="line"></span><br><span class="line">        .dq_activate    = _dispatch_lane_activate,</span><br><span class="line">        .dq_wakeup      = _dispatch_lane_wakeup,</span><br><span class="line">        .dq_push        = _dispatch_lane_push,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中存储的各个函数实现在 libdispatch 的源码中都可以找到，这里就不一一贴出来了。</p>
<p>再回头看下分配内存逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_lane_s));</span><br></pre></td></tr></table></figure>
<p>其中 <code>_dispatch_object_alloc</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">_dispatch_object_alloc(<span class="type">const</span> <span class="type">void</span> *vtable, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _os_object_alloc_realized(vtable, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配并初始化一个 _os_object_t 类型的对象</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">_os_object_t</span></span><br><span class="line">_os_object_alloc_realized(<span class="type">const</span> <span class="type">void</span> *cls, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个 _os_object_t 类型的变量 obj，用于存储分配的对象</span></span><br><span class="line">    <span class="type">_os_object_t</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言检查，确保传入的 size 大于等于 _os_object_s 结构体的大小</span></span><br><span class="line">    <span class="comment">// 这是为了确保分配的内存足够大，能够包含 _os_object_s 结构体的所有字段</span></span><br><span class="line">    dispatch_assert(size &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> _os_object_s));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 while 循环尝试分配内存，直到分配成功为止</span></span><br><span class="line">    <span class="comment">// unlikely 宏用于提示编译器，这个条件（分配失败）不太可能发生，从而优化分支预测</span></span><br><span class="line">    <span class="keyword">while</span> (unlikely(!(obj = <span class="built_in">calloc</span>(<span class="number">1u</span>, size)))) &#123;</span><br><span class="line">        <span class="comment">// 如果内存分配失败，调用 _dispatch_temporary_resource_shortage 函数处理资源短缺</span></span><br><span class="line">        _dispatch_temporary_resource_shortage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置分配的对象的 isa 指针为传入的 cls，表示对象的类型</span></span><br><span class="line">    obj-&gt;os_obj_isa = cls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回分配并初始化好的对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述主要逻辑如下：</p>
<ul>
<li>创建 <code>_os_object_t</code> 类型的对象 <code>obj</code>，并分配内存。</li>
<li>将 <code>vtable</code> 赋值给 <code>obj-&gt;os_obj_isa</code>。<ul>
<li><code>vtable</code> 是虚表，存储了具体的函数实现的指针。</li>
<li>串行队列时，<code>vtable</code> 虚表对应实现类是 <code>OS_dispatch_queue_serial</code><ul>
<li>并发队列时，<code>vtable</code> 虚表对应实现类是 <code>OS_dispatch_queue_concurrent</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="b、初始化"><a href="#b、初始化" class="headerlink" title="b、初始化"></a>b、初始化</h5><p>初始化是通过调用 <code>_dispatch_queue_init</code> 函数实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">        DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">        (dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>调用 <code>_dispatch_queue_init</code> 传入了 4 个参数，根据源码可知，创建串行队列时，第 3 个参数（<code>width</code>）传入的十进制值是 1；</p>
<p>创建并发队列时，第 3 个参数（<code>width</code>）传入的十进制值是 <code>DISPATCH_QUEUE_WIDTH_MAX，DISPATCH_QUEUE_WIDTH_MAX</code> 是个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_WIDTH_FULL           0x1000ull</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_WIDTH_MAX  (DISPATCH_QUEUE_WIDTH_FULL - 2)</span></span><br></pre></td></tr></table></figure>
<p>经过计算，<code>DISPATCH_QUEUE_WIDTH_MAX</code> 的十进制值是 <code>4094</code>，所以创建串行队列时，第 3 个参数（<code>width</code>）传入的十进制值是 <code>4094</code>；</p>
<p>结合前面生成 <code>dqai</code> 那部分的源码，可以知道无论串行队列还是并发队列，<code>dqai.dqai_inactive</code> 值都是 0，所以，<code>_dispatch_queue_init</code> 函数第 4 个参数（<code>initial_state_bits</code>）传入的值是 <code>DISPATCH_QUEUE_ROLE_INNER</code>（<code>0x0000000000000000ull</code>）。</p>
<p><code>_dispatch_queue_init</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_queue_class_t</span></span><br><span class="line">_dispatch_queue_init(<span class="type">dispatch_queue_class_t</span> dqu, <span class="type">dispatch_queue_flags_t</span> dqf,</span><br><span class="line">        <span class="type">uint16_t</span> width, <span class="type">uint64_t</span> initial_state_bits)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化队列状态</span></span><br><span class="line">    <span class="type">uint64_t</span> dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(width);</span><br><span class="line">    <span class="comment">// 获取实际的调度队列对象</span></span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言检查，确保初始状态位只包含队列角色和非活动标志</span></span><br><span class="line">    dispatch_assert((initial_state_bits &amp; ~(DISPATCH_QUEUE_ROLE_MASK |</span><br><span class="line">            DISPATCH_QUEUE_INACTIVE)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列是非活动的，增加引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (initial_state_bits &amp; DISPATCH_QUEUE_INACTIVE) &#123;</span><br><span class="line">        dq-&gt;do_ref_cnt += <span class="number">2</span>; <span class="comment">// 参见 rdar://8181908 的 _dispatch_lane_resume</span></span><br><span class="line">        <span class="comment">// 如果是调度源类型，进一步增加引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (dx_metatype(dq) == _DISPATCH_SOURCE_TYPE) &#123;</span><br><span class="line">            dq-&gt;do_ref_cnt++; <span class="comment">// 当 DSF_DELETED 被设置时释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将初始状态位合并到队列状态中，由于传入的 initial_state_bits 参数为 DISPATCH_QUEUE_ROLE_INNER（0x0000000000000000ull），所以这一步对 dq_state 的值没有任何影响</span></span><br><span class="line">    dq_state |= initial_state_bits;</span><br><span class="line">    <span class="comment">// 将队列的下一个对象指针设置为无列表状态</span></span><br><span class="line">    dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    <span class="comment">// 将宽度标志合并到队列标志中</span></span><br><span class="line">    dqf |= DQF_WIDTH(width);</span><br><span class="line">    <span class="comment">// 原子存储队列的标志，使用 relaxed 内存顺序</span></span><br><span class="line">    os_atomic_store2o(dq, dq_atomic_flags, dqf, relaxed);</span><br><span class="line">    <span class="comment">// 设置队列的状态</span></span><br><span class="line">    dq-&gt;dq_state = dq_state;</span><br><span class="line">    <span class="comment">// 设置队列的序列号，并递增全局的队列序列号计数器</span></span><br><span class="line">    dq-&gt;dq_serialnum =</span><br><span class="line">            os_atomic_inc_orig(&amp;_dispatch_queue_serial_numbers, relaxed);</span><br><span class="line">    <span class="comment">// 返回初始化后的调度队列类对象</span></span><br><span class="line">    <span class="keyword">return</span> dqu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分逻辑，重点需要关注 <code>dq_state</code>、<code>dq_width</code> 的赋值。</p>
<p><code>dq_state</code> 的赋值比较好理解，其初始值就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(width);</span><br></pre></td></tr></table></figure>
<p>注意，这里的 <code>dq_state</code> 非最终值，后续还有 <code>dq_state</code> 赋值逻辑，在下面“dq 其他配置”部分会继续分析 <code>dq_state</code>。</p>
<p><code>dq_width</code> 字段是队列的宽度，存储了队列能够同时处理的任务的数量。关于 <code>dq_width</code> 的赋值，先回头看下 <code>dispatch_queue_t</code> 的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">dispatch_queue_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略 ......</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> <span class="comment">// 下一个队列对象的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> <span class="comment">// 目标队列指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 32位整数，表示队列的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint64_t</span> <span class="keyword">volatile</span> dq_state; <span class="comment">// 队列状态</span></span><br><span class="line">        dispatch_lock dq_state_lock; <span class="comment">// 队列状态锁</span></span><br><span class="line">        <span class="type">uint32_t</span> dq_state_bits; <span class="comment">// 队列状态位</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LP64 全局队列缓存行边界</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dq_serialnum; <span class="comment">// 队列的序列号</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dq_label; <span class="comment">// 队列标签，用于标识队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，用于存储队列的标志和宽度</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> <span class="keyword">volatile</span> dq_atomic_flags; <span class="comment">// 队列的原子标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">const</span> <span class="type">uint16_t</span> dq_width; <span class="comment">// 队列的宽度，即：队列能够同时处理的任务的数量</span></span><br><span class="line">            <span class="type">const</span> <span class="type">uint16_t</span> __dq_opaque2; <span class="comment">// 额外的占位符字段</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略 ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面已经提到，联合体中的 <code>dq_atomic_flags</code> 是 32 位的无符号整数类型，其占用了 32 位的内存区域，联合体内部 <code>dq_width</code> 和 <code>__dq_opaque2</code> 分别占用 <code>dq_atomic_flags</code> 的低 16 位和高 16 位。</p>
<p><code>_dispatch_queue_init</code> 函数中，注意下面这部分逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dqf |= DQF_WIDTH(width);</span><br><span class="line">os_atomic_store2o(dq, dq_atomic_flags, dqf, relaxed);</span><br></pre></td></tr></table></figure>
<p>其中 <code>DQF_WIDTH</code> 宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_OPTIONS(dispatch_queue_flags, <span class="type">uint32_t</span>,</span><br><span class="line">    DQF_NONE                = <span class="number">0x00000000</span>, </span><br><span class="line">    DQF_AUTORELEASE_ALWAYS  = <span class="number">0x00010000</span>, </span><br><span class="line">    DQF_AUTORELEASE_NEVER   = <span class="number">0x00020000</span>, </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DQF_AUTORELEASE_MASK 0x00030000 <span class="comment">// 自动释放相关的掩码</span></span></span><br><span class="line"></span><br><span class="line">    DQF_THREAD_BOUND        = <span class="number">0x00040000</span>, <span class="comment">// 队列与线程绑定标志</span></span><br><span class="line">    DQF_BARRIER_BIT         = <span class="number">0x00080000</span>, <span class="comment">// 队列在其目标上是一个屏障</span></span><br><span class="line">    DQF_TARGETED            = <span class="number">0x00100000</span>, <span class="comment">// 队列被其他对象作为目标</span></span><br><span class="line">    DQF_LABEL_NEEDS_FREE    = <span class="number">0x00200000</span>, </span><br><span class="line">    DQF_MUTABLE             = <span class="number">0x00400000</span>, </span><br><span class="line">    DQF_RELEASED            = <span class="number">0x00800000</span>, <span class="comment">// 引用计数为 -1，表示已释放</span></span><br><span class="line"></span><br><span class="line">    DSF_STRICT              = <span class="number">0x04000000</span>, </span><br><span class="line">    DSF_WLH_CHANGED         = <span class="number">0x08000000</span>, </span><br><span class="line">    DSF_CANCELED            = <span class="number">0x10000000</span>, </span><br><span class="line">    DSF_CANCEL_WAITER       = <span class="number">0x20000000</span>, </span><br><span class="line">    DSF_NEEDS_EVENT         = <span class="number">0x40000000</span>, </span><br><span class="line">    DSF_DELETED             = <span class="number">0x80000000</span>, </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DQF_FLAGS_MASK        ((dispatch_queue_flags_t)0xffff0000) <span class="comment">// 标志位掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DQF_WIDTH_MASK        ((dispatch_queue_flags_t)0x0000ffff) <span class="comment">// 宽度掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DQF_WIDTH(n)          ((dispatch_queue_flags_t)(uint16_t)(n)) <span class="comment">// 设置队列宽度</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>DQF_WIDTH</code> 宏将 <code>width</code> 转换为 <code>dispatch_queue_flags_t</code> 类型，并确保它位于低 16 位。具体来说，<code>DQF_WIDTH</code>(<code>width</code>) 通过将 <code>width</code> 强制转换为 <code>uint16_t</code>，然后再转换为 <code>dispatch_queue_flags_t</code>，确保宽度值仅影响低 16 位。</p>
<p>也就是说，下述逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dqf |= DQF_WIDTH(width);</span><br></pre></td></tr></table></figure>
<p>将 <code>width</code> 的值设置到 <code>dqf</code> 的低 16 位上。</p>
<p><code>os_atomic_store2o</code> 宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> os_atomic_store2o(p, f, v, m) \</span></span><br><span class="line"><span class="meta">        os_atomic_store(&amp;(p)-&gt;f, (v), m)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> os_atomic_store(p, v, m) \</span></span><br><span class="line"><span class="meta">        atomic_store_explicit(_os_atomic_c11_atomic(p), v, memory_order_##m)</span></span><br></pre></td></tr></table></figure>
<p>可以定义知道 <code>os_atomic_store2o</code> 宏的作用是将值 <code>dqf</code> 原子地存储到结构体 <code>dq</code> 的字段 <code>dq_atomic_flags</code> 中。</p>
<p>所以，最终 <code>width</code> 值将会赋值给 <code>dispatch_queue_s</code> 中的 <code>dq_width</code> 上，<code>dqf</code> 其他内容存储到 <code>__dq_opaque2</code> 中。</p>
<p>所以最终：</p>
<ul>
<li>创建串行队列时，<code>dq_width = 1</code>；</li>
<li>创建并发队列时，<code>dq_width = 4094</code>；</li>
</ul>
<h4 id="（4）dq-其他配置"><a href="#（4）dq-其他配置" class="headerlink" title="（4）dq 其他配置"></a>（4）dq 其他配置</h4><p>这部分逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置队列标签和优先级。</span></span><br><span class="line">dq-&gt;dq_label = label;</span><br><span class="line">dq-&gt;dq_priority = _dispatch_priority_make((<span class="type">dispatch_qos_t</span>)dqai.dqai_qos,</span><br><span class="line">        dqai.dqai_relpri);</span><br><span class="line"><span class="comment">// 如果开启超额提交，设置相应标志。</span></span><br><span class="line"><span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">    dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果队列不是非活动状态，继承目标队列的优先级和工作循环。</span></span><br><span class="line"><span class="keyword">if</span> (!dqai.dqai_inactive) &#123;</span><br><span class="line">    _dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">    _dispatch_lane_inherit_wlh_from_target(dq, tq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保留目标队列引用。</span></span><br><span class="line">_dispatch_retain(tq);</span><br><span class="line"><span class="comment">// 设置目标 targetq 为当前 dispatch_queue_t</span></span><br><span class="line">dq-&gt;do_targetq = tq;</span><br></pre></td></tr></table></figure>
<p>这里主要是对 <code>dq</code> 其他的一些参数的配置，这里重点看下 <code>_dispatch_lane_inherit_wlh_from_target</code> 函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_dispatch_lane_inherit_wlh_from_target(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_queue_t</span> tq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> old_state, new_state, role;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查目标队列 tq 是否具有 QUEUE_ROOT 类型标志</span></span><br><span class="line">    <span class="keyword">if</span> (!dx_hastypeflag(tq, QUEUE_ROOT)) &#123;</span><br><span class="line">        <span class="comment">// 如果 tq 不是根队列，将 role 设置为 INNER（内部队列）</span></span><br><span class="line">        role = DISPATCH_QUEUE_ROLE_INNER;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_dispatch_base_lane_is_wlh(dq, tq)) &#123;</span><br><span class="line">        <span class="comment">// 如果 dq 和 tq 共享相同的 WLH，设置 role 为 BASE_WLH</span></span><br><span class="line">        role = DISPATCH_QUEUE_ROLE_BASE_WLH;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，将 role 设置为 BASE_ANON</span></span><br><span class="line">        role = DISPATCH_QUEUE_ROLE_BASE_ANON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子操作更新 dq 的状态，确保线程安全</span></span><br><span class="line">    os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, &#123;</span><br><span class="line">        <span class="comment">// 清除旧的 role 位</span></span><br><span class="line">        new_state = old_state &amp; ~DISPATCH_QUEUE_ROLE_MASK;</span><br><span class="line">        <span class="comment">// 设置新的 role 位</span></span><br><span class="line">        new_state |= role;</span><br><span class="line">        <span class="comment">// 如果状态没有改变，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (old_state == new_state) &#123;</span><br><span class="line">            os_atomic_rmw_loop_give_up(<span class="keyword">break</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果旧状态是 base WLH 且新状态不是</span></span><br><span class="line">    <span class="keyword">if</span> (_dq_state_is_base_wlh(old_state) &amp;&amp; !_dq_state_is_base_wlh(new_state)) &#123;</span><br><span class="line">        <span class="type">dispatch_deferred_items_t</span> ddi = _dispatch_deferred_items_get();</span><br><span class="line">        <span class="keyword">if</span> (ddi &amp;&amp; ddi-&gt;ddi_wlh == (<span class="type">dispatch_wlh_t</span>)dq) &#123;</span><br><span class="line">            _dispatch_event_loop_leave_immediate(new_state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查目标队列 tq 是否具有 QUEUE_ROOT 类型标志</span></span><br><span class="line">    <span class="keyword">if</span> (!dx_hastypeflag(tq, QUEUE_ROOT)) &#123;</span><br><span class="line">        <span class="comment">// 定义需要清除和设置的标志</span></span><br><span class="line">        <span class="type">dispatch_queue_flags_t</span> clear = <span class="number">0</span>, <span class="built_in">set</span> = DQF_TARGETED;</span><br><span class="line">        <span class="comment">// 如果 tq 类型是 WORKLOOP_TYPE</span></span><br><span class="line">        <span class="keyword">if</span> (dx_metatype(tq) == _DISPATCH_WORKLOOP_TYPE) &#123;</span><br><span class="line">            clear |= DQF_MUTABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !DISPATCH_ALLOW_NON_LEAF_RETARGET</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clear |= DQF_MUTABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有需要清除的标志，则进行清除和设置操作</span></span><br><span class="line">        <span class="keyword">if</span> (clear) &#123;</span><br><span class="line">            _dispatch_queue_atomic_flags_set_and_clear(tq, <span class="built_in">set</span>, clear);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _dispatch_queue_atomic_flags_set(tq, <span class="built_in">set</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要关注角色位 <code>role</code> 配置，<code>role</code> 最终会参与 <code>dq_state</code> 的赋值 <code>new_state |= role;</code>。</p>
<p><code>role</code> 赋值判断逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dx_hastypeflag(tq, QUEUE_ROOT)) &#123;</span><br><span class="line">    role = DISPATCH_QUEUE_ROLE_INNER;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (_dispatch_base_lane_is_wlh(dq, tq)) &#123;</span><br><span class="line">    role = DISPATCH_QUEUE_ROLE_BASE_WLH;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    role = DISPATCH_QUEUE_ROLE_BASE_ANON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dx_hastypeflag</code> 是个宏，根据其源码定义以及 <code>_dispatch_queue_concurrent_vtable</code>、 <code>_dispatch_queue_serial_vtable</code> 可知，无论串行队列还是并发队列，<code>dx_hastypeflag(tq, QUEUE_ROOT)</code> 都是 <code>true</code>，所以不会走第一个 <code>if</code> 分支，故会进入 <code>_dispatch_base_lane_is_wlh</code> 函数的判断逻辑。</p>
<p><code>_dispatch_base_lane_is_wlh</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查给定的调度通道是否是工作循环（workloop）的一部分</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dispatch_base_lane_is_wlh(<span class="type">dispatch_lane_t</span> dq, <span class="type">dispatch_queue_t</span> tq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果工作队列事件机制未启用，则返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!_dispatch_kevent_workqueue_enabled)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查调度通道的类型是否为网络事件队列类型</span></span><br><span class="line">    <span class="keyword">if</span> (dx_type(dq) == DISPATCH_QUEUE_NETWORK_EVENT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// 如果是网络事件类型，则返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查调度通道的元类型是否为调度源类型</span></span><br><span class="line">    <span class="keyword">if</span> (dx_metatype(dq) == _DISPATCH_SOURCE_TYPE) &#123;</span><br><span class="line">        <span class="comment">// 源类型不支持同步等待者，因此那些不会改变 QoS 的源</span></span><br><span class="line">        <span class="comment">// 无法受益于任何具有开销的工作循环特性，</span></span><br><span class="line">        <span class="comment">// 因此只使用工作队列的 kqueue。</span></span><br><span class="line">        <span class="keyword">if</span> (likely(!upcast(dq)._ds-&gt;ds_refs-&gt;du_can_be_wlh)) &#123;</span><br><span class="line">            <span class="comment">// 如果调度源不可以是工作循环，则返回 false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确保直接引用</span></span><br><span class="line">        dispatch_assert(upcast(dq)._ds-&gt;ds_refs-&gt;du_is_direct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列宽度是否为 1 且目标队列在根队列数组中</span></span><br><span class="line">    <span class="keyword">return</span> dq-&gt;dq_width == <span class="number">1</span> &amp;&amp; _dispatch_is_in_root_queues_array(tq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_dispatch_is_in_root_queues_array(<span class="type">dispatch_queue_class_t</span> dqu)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断调度队列的指针范围是否在根队列数组的有效范围内</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * _DISPATCH_ROOT_QUEUE_IDX_COUNT = 18</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 根据前面 &quot;创建 tq&quot; 部分，创建串行队列时，index = 10，创建并发队列时 index = 9，均满足 &gt;= 0 &amp;&amp; &lt; 18</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">return</span> (dqu._dgq &gt;= _dispatch_root_queues) &amp;&amp;</span><br><span class="line">            (dqu._dgq &lt; _dispatch_root_queues + _DISPATCH_ROOT_QUEUE_IDX_COUNT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述逻辑中，无论串行队列还是并发队列，<code>_dispatch_is_in_root_queues_array</code> 函数都是返回 <code>true</code>。所以，最终 <code>_dispatch_base_lane_is_wlh</code> 函数返回值取决于 <code>dq-&gt;dq_width == 1</code> 的判断结果，即：</p>
<ul>
<li>创建串行队列时，返回值为 <code>true</code>。<ul>
<li><code>role = DISPATCH_QUEUE_ROLE_BASE_WLH;</code></li>
<li><code>dq_state = (dq_state | role) = (DISPATCH_QUEUE_STATE_INIT_VALUE(dq_width) | DISPATCH_QUEUE_ROLE_BASE_WLH);</code></li>
</ul>
</li>
<li>创建并发队列时，返回值为 <code>false</code>。<ul>
<li><code>role = DISPATCH_QUEUE_ROLE_BASE_ANON;</code></li>
<li><code>dq_state = (dq_state | role) = (DISPATCH_QUEUE_STATE_INIT_VALUE(dq_width) | DISPATCH_QUEUE_ROLE_BASE_ANON);</code></li>
</ul>
</li>
</ul>
<h4 id="（5）简单总结"><a href="#（5）简单总结" class="headerlink" title="（5）简单总结"></a>（5）简单总结</h4><p>总结一下：</p>
<ul>
<li><p><strong>串行队列</strong></p>
<ul>
<li><code>dq_width = 1；</code><ul>
<li>即串行队列最多能同时处理 <code>1</code> 个任务</li>
</ul>
</li>
<li><code>dq_state = (DISPATCH_QUEUE_STATE_INIT_VALUE(dq_width) | DISPATCH_QUEUE_ROLE_BASE_WLH);</code></li>
<li>串行队列是 <code>overcommit</code> 的</li>
</ul>
</li>
<li><p><strong>并发队列</strong></p>
<ul>
<li><code>dq_width = 4094</code><ul>
<li>即串行队列最多能同时处理 <code>4094</code> 个任务，但最终有多少个任务能够同时执行，还要看系统资源情况，例如线程池可用线程数量等。</li>
</ul>
</li>
<li><code>dq_state = (DISPATCH_QUEUE_STATE_INIT_VALUE(dq_width) | DISPATCH_QUEUE_ROLE_BASE_ANON);</code></li>
<li>并发队列是非 <code>overcommit</code> 的</li>
</ul>
</li>
</ul>
<p>对于 <code>do_targetq</code>，串行队列、并发队列的 <code>do_targetq</code>，都是从根队列数组 <code>_dispatch_root_queues</code> 中取出的对应的根队列（root queue），只不过两者取的 <code>index</code> 不一样。</p>
<p>同时，根据源码中宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_STATE_INIT_VALUE(width) \</span></span><br><span class="line"><span class="meta">        ((DISPATCH_QUEUE_WIDTH_FULL - (width)) &lt;&lt; DISPATCH_QUEUE_WIDTH_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_WIDTH_FULL           0x1000ull</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_WIDTH_SHIFT          41</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ROLE_BASE_WLH        0x0000002000000000ull</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_ROLE_BASE_ANON       0x0000001000000000ull</span></span><br></pre></td></tr></table></figure>
<p>可以计算出：<br><strong>串行队列：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq_state = (DISPATCH_QUEUE_STATE_INIT_VALUE(dq_width) | DISPATCH_QUEUE_ROLE_BASE_WLH)  = (DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="number">1</span>) | DISPATCH_QUEUE_ROLE_BASE_WLH) = <span class="number">0x001ffe2000000000</span>。</span><br></pre></td></tr></table></figure>
<p><strong>并发队列：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq_state = (DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="number">4094</span>) | DISPATCH_QUEUE_ROLE_BASE_ANON) = <span class="number">0x0000041000000000</span>。</span><br></pre></td></tr></table></figure>

<p>关于 <code>dq_width</code>、<code>dq_state</code>，我们可以使用一个 Demo 验证一下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">&quot;com.demo.serialQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">&quot;com.lixkit.concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;serialQueue = %@&quot;</span>, [serialQueue debugDescription]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;concurrentQueue = %@&quot;</span>, [concurrentQueue debugDescription]);</span><br></pre></td></tr></table></figure>
<p>运行后打印结果：<br><img src="/images/lix_blog_219.png"></p>
<p>上述打印结果中，<code>width</code> 就是 <code>dq_width</code>：</p>
<ul>
<li>串行队列 <code>width = 0x1</code>，转成十进制就是 <code>1</code>。</li>
<li>并发队列 <code>width = 0xffe</code>，转成十进制就是 <code>4094</code>。</li>
</ul>
<p>打印结果的 <code>state</code> 就是 <code>dq_state</code>，可以看到打印出的 <code>dq_width</code>、<code>dq_state</code> 和前面我们根据源码计算出的结果一致。</p>
<p>这里为什么要重点关注 <code>dq_width</code>、<code>dq_state</code>、<code>do_targetq</code>，因为后续 <code>dispatch_sync</code>、<code>dispatch_async</code> 源码中会用到。</p>
</section>

    <!-- Copyright START -->
    
      <div>
  <ul class="post-copyright">
    <li>
      <a rel=license href=http://creativecommons.org/licenses/by/4.0/>
        <img alt="知识共享许可协议" style="border-width:0;height:30px;width:auto;" src="/css/images/copyright.png">
      </a>
    </li>
    <li>
      本文章采用 <a rel=license href=http://creativecommons.org/licenses/by/4.0/>知识共享署名 4.0 国际许可协议</a> 进行许可，完整转载、部分转载、图片转载时均请注明原文链接。
    </li>
  </ul>
<div>
    
    <!-- Copyright START -->


    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#底层" >
    <span class="tag-code">底层</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/posts/33519/">
        <span class="nav-arrow">← </span>
        
          GCD 底层原理 1 - dispatch_once
        
      </a>
    
    
      <a class="nav-right" href="/posts/42034/">
        
          GCD 底层原理 3 - dispatch_sync
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Gitalk START -->
      <div id="gitalk-container"></div>
      <!-- Gitalk END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://www.lixkit.com/posts/12465/';
    var banner = 'undefined'
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>








<link rel='stylesheet' type='text/css' href='//cdnjs.cloudflare.com/ajax/libs/gitalk/1.2.2/gitalk.min.css'>
<div id="gitalk-container"></div>
<script>
    // Promise 异步加载脚本
    function loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    // 异步加载 Gitalk
    async function initGitalk() {
        try {
            await loadScript('//cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.10.0/js/md5.min.js');
            await loadScript('//cdnjs.cloudflare.com/ajax/libs/gitalk/1.2.2/gitalk.min.js');
            const gitalk = new Gitalk({
                clientID: '124a73ebef61e7821d74',
                clientSecret: 'a1ef084cca4d78256620f08f439ba70522f84581',
                repo: 'lixkit.github.io',
                owner: 'lixkit',
                admin: ['lixkit'],
                id: md5(location.pathname),
                distractionFreeMode: false
            });
            gitalk.render('gitalk-container');
        } catch (error) {
            console.error('Error loading Gitalk:', error);
        }
    }

    // 在页面加载完成后异步加载 Gitalk
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initGitalk);
    } else {
        initGitalk();
    }
</script>


    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    
<footer class="app-footer">
  <p class="copyright">
    李峰峰 © 2016 - 2025
    
        |
        
            <a style="color: #7f8c8d;" href="http://beian.miit.gov.cn/" target="_blank" rel="noopener nofollow">京ICP备2023030486号-6</a>
        
    
  </p>
</footer>


<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script>
    var _baId = 'cef02744ce74fd7afbb6bab85e4a6c24';
    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>


<script src="/js/script.js"></script>


  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>