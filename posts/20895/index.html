<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="李峰峰博客">
  <meta name="keyword" content="李峰峰, iOS, 底层原理">
  <meta name="baidu-site-verification" content="codeva-SYZlEXwvUN" />
  <meta name="sogou_site_verification" content="YdqRkfPyHk" />


  <meta name="description" content="一、概述Lex 和 Yacc 是编译器和解释器开发中广泛使用的工具，分别用于词法分析和语法分析。它们通常配合使用，帮助开发者快速构建语言处理工具，处理复杂的语言解析任务。 Lex（Lexical Analyzer Generator）是词法分析器生成器，Yacc（Yet Another Compiler Compiler）是语法分析器生成器，可以通过编写 Lex 和 Yacc 文件，实现自定义的词">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理之 Lex &amp; Yacc">
<meta property="og:url" content="https://www.lixkit.com/posts/20895/index.html">
<meta property="og:site_name" content="李峰峰博客">
<meta property="og:description" content="一、概述Lex 和 Yacc 是编译器和解释器开发中广泛使用的工具，分别用于词法分析和语法分析。它们通常配合使用，帮助开发者快速构建语言处理工具，处理复杂的语言解析任务。 Lex（Lexical Analyzer Generator）是词法分析器生成器，Yacc（Yet Another Compiler Compiler）是语法分析器生成器，可以通过编写 Lex 和 Yacc 文件，实现自定义的词">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_177.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_178.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_179.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_180.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_181.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_182.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_183.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_184.png">
<meta property="og:image" content="https://www.lixkit.com/images/lix_blog_185.png">
<meta property="article:published_time" content="2022-05-03T15:19:00.000Z">
<meta property="article:modified_time" content="2025-03-14T00:26:48.905Z">
<meta property="article:author" content="李峰峰">
<meta property="article:tag" content="热修复">
<meta property="article:tag" content="编译原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.lixkit.com/images/lix_blog_177.png">


  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      编译原理之 Lex &amp; Yacc | 李峰峰博客
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  

  
  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="李峰峰博客" type="application/atom+xml">
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>李峰峰博客</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">主页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">分类</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">主页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">分类</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>编译原理之 Lex & Yacc</h2>
  <p class="post-date">2022-05-03</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Lex 和 Yacc 是编译器和解释器开发中广泛使用的工具，分别用于词法分析和语法分析。它们通常配合使用，帮助开发者快速构建语言处理工具，处理复杂的语言解析任务。</p>
<p>Lex（Lexical Analyzer Generator）是词法分析器生成器，Yacc（Yet Another Compiler Compiler）是语法分析器生成器，可以通过编写 Lex 和 Yacc 文件，实现自定义的词法分析器和语法分析器，实现对特定语言的解析和处理。</p>
<p>Lex 最早由 Mike Lesk 和 Eric Schmidt 在 1975 年为 Unix 操作系统开发。虽然 Lex 的原始版本是闭源的，但后来出现了多个开源实现，如 <font color=#ff0000>Flex</font>（Fast Lexical Analyzer Generator），这是 Lex 的一个开源替代品。</p>
<p>Yacc 由 Stephen C. Johnson 在 1970 年代开发，旨在为 Unix 操作系统提供一个语法分析器生成工具。Yacc 的原始版本也是闭源的，但后来出现了多个开源实现，如 <font color=#ff0000>Bison</font>，这是 GNU 项目提供的 Yacc 的开源替代品。</p>
<p>macOS 已经内置了 Flex 和 Bison：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/flex</span><br><span class="line">/usr/bin/bison</span><br></pre></td></tr></table></figure>
<p><img src="/images/lix_blog_177.png"></p>
<p>&#x2F;usr&#x2F;bin 中同时还有 lex、yacc 两个工具，路径如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/lex</span><br><span class="line">/usr/bin/yacc</span><br></pre></td></tr></table></figure>
<p>其本质也是 Flex 和 Bison：<br><img src="/images/lix_blog_178.png"></p>
<p>Lex、Yacc 常用命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lex test.l      # 生成  lex.yy.c，该文件中实现了词法分析器函数  yylex()</span><br><span class="line">yacc -d test.y  # 生成 y.tab.h, y.tab.c，该文件中实现了语法分析器函数  yyparse()</span><br></pre></td></tr></table></figure>
<p><img src="/images/lix_blog_179.png"></p>
<p>在 Xcode 中，也内置了 lex 和 yacc：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lex</span><br><span class="line">/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/yacc</span><br></pre></td></tr></table></figure>
<p><img src="/images/lix_blog_180.png"></p>
<p>也就是说，Xcode 已经支持了 Lex、Yacc，可以自动将 Lex、Yacc 描述文件编译成分析器代码文件。</p>
<p>在编译流程中，Lex、Yacc 负责的工作如下：</p>
<ul>
<li><strong>Lex</strong><ul>
<li>负责<strong>“词法分析”</strong>的工作。<br></li>
</ul>
</li>
<li><strong>Yacc</strong> <ul>
<li>核心功能是<strong>“语法分析”</strong>。</li>
<li>还可以通过 Yacc 语义动作的扩展，使其承担更多工作：“语义分析”、“中间代码生成”。<ul>
<li>这种方式在实际编译器实现中比较常见，在一个解析阶段中完成多个编译步骤，以提高编译效率。即：<strong>Yacc 同时负责“语法分析”、“语义分析”、“中间代码生成”的工作。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Lex 和 Yacc 在编译器构建过程中的协同工作主要流程如下：<br><img src="/images/lix_blog_181.png"></p>
<ul>
<li><p><strong>编写 Lex &amp; Yacc 文件</strong></p>
<ul>
<li>Lex 文件<ul>
<li>定义词法分析规则的文件，包含正则表达式和相应的动作。</li>
</ul>
</li>
<li>Yacc 文件<ul>
<li>定义语法分析规则的文件，包含语法规则和相应的语义动作。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>生成分析器</strong></p>
<ul>
<li>Lex<ul>
<li>读取 Lex 文件，根据描述文件生成 C 语言实现的词法分析器代码文件 lex.yy.c，该文件中实现了词法分析器函数 <code>yylex()</code>。</li>
</ul>
</li>
<li>Yacc<ul>
<li>读取 Yacc 文件，根据描述文件生成 C 语言实现的语法分析器代码文件 y.tab.h 和 y.tab.c，该文件中实现了语法分析器函数 <code>yyparse()</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理流程</strong></p>
<ul>
<li><p>词法分析（lex.yy.c）</p>
<ul>
<li>输入源代码文件。</li>
<li>由 <code>yylex()</code> 处理源代码，识别并生成词法单元（tokens）。</li>
</ul>
</li>
<li><p>语法分析（y.tab.h、y.tab.c）</p>
<ul>
<li>接受来自 <code>yylex()</code> 的词法单元。</li>
<li>由 <code>yyparse()</code> 处理词法单元，构建语法树或执行语义动作，最终生成输出。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二、Lex"><a href="#二、Lex" class="headerlink" title="二、Lex"></a>二、Lex</h2><p>Lex 负责将输入的字符流分解成有意义的词法单元（token），Lex 文件通常使用 <code>.l</code> 扩展名，使用正则表达式来定义词法规则。</p>
<p>Lex 文件(example.l)内容示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">[a-zA-Z]+      &#123; printf(&quot;Word: %s\n&quot;, yytext); &#125;</span><br><span class="line">[0-9]+         &#123; printf(&quot;Number: %s\n&quot;, yytext); &#125;</span><br><span class="line">&quot;+&quot;            &#123; printf(&quot;Plus operator\n&quot;); &#125;</span><br><span class="line">&quot;-&quot;            &#123; printf(&quot;Minus operator\n&quot;); &#125;</span><br><span class="line">[ \t\n]+       &#123; /* 匹配空白字符，忽略 */ &#125;</span><br><span class="line">.              &#123; printf(&quot;Unknown character: %s\n&quot;, yytext); &#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int yywrap() &#123;</span><br><span class="line">    return 1;  /* 指示没有更多的输入 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Enter text:\n&quot;);</span><br><span class="line">    yylex();  /* 调用词法分析器 */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成词法分析器代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lex example.l</span><br></pre></td></tr></table></figure>
<p>编译生成可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc lex.yy.c -o lexer</span><br></pre></td></tr></table></figure>
<p>执行完上述两个命令之后，会生成文件名为 lexer 的可执行文件：<br><img src="/images/lix_blog_182.png"><br>执行可执行文件，输入测试字符串，可以看到词法分析器输出内容：<br><img src="/images/lix_blog_183.png"></p>
<p>生成的词法分析器实现代码在 lex.yy.c 中，lex.yy.c 中自动生成的主要函数如下：</p>
<ul>
<li><p><code>yylex()</code></p>
<ul>
<li>主词法分析函数，它从输入中读取字符并尝试匹配定义的模式。</li>
<li>每次调用 <code>yylex()</code> 时，它会扫描输入，找到最匹配的模式并执行相应的动作代码。</li>
<li>返回一个整数值，通常是匹配的模式的标识符（token）。</li>
</ul>
</li>
<li><p><code>yywrap()</code></p>
<ul>
<li>在输入文件结束时调用，决定是否继续读取其他输入，返回 <code>1</code> 表示输入结束，返回 <code>0</code> 表示继续。</li>
</ul>
</li>
<li><p><code>yytext</code></p>
<ul>
<li>全局字符数组或指针，存储当前匹配的文本。</li>
<li>每次 <code>yylex()</code> 匹配到模式时，<code>yytext</code> 包含匹配的字符串。</li>
<li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Matched text: %s\n&quot;, yytext);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>yyleng</code></p>
<ul>
<li>全局整数，表示 <code>yytext</code> 中匹配文本的长度。</li>
</ul>
</li>
<li><p><code>yyin</code></p>
<ul>
<li>文件指针，指向词法分析器的输入流。</li>
<li>默认情况下，<code>yyin</code> 指向 <code>stdin</code>，可以重定向到其他文件。</li>
<li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yyin = fopen(&quot;input.txt&quot;, &quot;r&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>yyout</code></p>
<ul>
<li>文件指针，指向词法分析器的输出流（通常用于调试）。</li>
<li>默认情况下，<code>yyout</code> 指向 <code>stdout</code>，可以重定向到其他文件。</li>
<li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yyout = fopen(&quot;output.txt&quot;, &quot;w&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>yyrestart(FILE *input_file)</code></p>
<ul>
<li>重置词法分析器的输入流。</li>
<li>可以在文件切换或重新开始分析时使用。</li>
<li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yyrestart(yyin);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>yyset_in(FILE * _in_str)</code></p>
<ul>
<li>设置词法分析器的输入文件。</li>
<li>调用这个函数，可以动态地更改词法分析器的输入来源，而无需重新启动词法分析器。</li>
<li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *file = fopen(&quot;input.txt&quot;, &quot;r&quot;);</span><br><span class="line">yyset_in(file);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>yylex_destroy()</code></p>
<ul>
<li>释放词法分析器使用的资源。</li>
<li>在程序结束时调用，以避免内存泄漏。</li>
</ul>
</li>
<li><p><code>yy_scan_string(const char *str)</code></p>
<ul>
<li>从字符串而不是文件中读取输入。</li>
<li>适用于需要从内存中读取输入的场景。</li>
<li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yy_scan_string(&quot;example input&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)</code></p>
<ul>
<li>切换词法分析器的输入缓冲区。</li>
<li>适用于需要在多个输入源之间切换的场景。</li>
<li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YY_BUFFER_STATE buffer = yy_scan_string(&quot;example input&quot;);</span><br><span class="line">yy_switch_to_buffer(buffer);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>这些函数和变量共同构成了 Lex 词法分析器的核心功能，使其能够高效地处理输入、匹配模式并执行相应的动作。</p>
<p>Lex 文件内容结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;定义&gt;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&lt;规则&gt;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&lt;代码&gt;</span><br></pre></td></tr></table></figure>

<p>使用 %% 对不同的部分进行分隔，其主要包含三部分内容，分别是：</p>
<ul>
<li><strong>定义（可选）</strong><ul>
<li>C 代码定义</li>
<li>命名正则表达式定义</li>
<li>指令定义</li>
</ul>
</li>
<li><strong>规则（必选）</strong><ul>
<li>模式：用于描述词法规则的正则表达式</li>
<li>动作：模式匹配时要执行的 C 代码</li>
</ul>
</li>
<li><strong>代码（可选）</strong><ul>
<li>辅助函数</li>
<li>也可以包含主程序的 main 函数</li>
<li>这部分代码会被直接拷贝进 lex.yy.c 中</li>
</ul>
</li>
</ul>
<h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>定义部分主要包含三部分内容：</p>
<ul>
<li>C 代码定义 (<code>%&#123;</code> 和 <code>%&#125;</code>)</li>
<li>命名正则表达式定义</li>
<li>指令定义（以 <code>%</code> 开头的指令）</li>
</ul>
<h4 id="（1）C-代码定义-和"><a href="#（1）C-代码定义-和" class="headerlink" title="（1）C 代码定义 (%{ 和 %})"></a>（1）C 代码定义 (%{ 和 %})</h4><p>在定义部分中，可以包含直接嵌入到生成的 C 代码中的代码片段，这些代码会被直接拷贝到生成的 C 文件的开头部分。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">/* C 代码定义 */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int my_global_variable;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>%&#123;</code> 和 <code>%&#125;</code> 之间定义的 C 代码会被 Lex 工具直接拷贝到生成的词法分析器代码中。这通常用于定义变量、包含头文件、声明函数等。</p>
<h4 id="（2）命名正则表达式定义"><a href="#（2）命名正则表达式定义" class="headerlink" title="（2）命名正则表达式定义"></a>（2）命名正则表达式定义</h4><p>用来给常用的正则表达式定义名字，这样在规则部分可以复用这些命名的表达式。</p>
<p>基本格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name expression</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">letter   [a-zA-Z]</span><br><span class="line">digit    [0-9]</span><br><span class="line">punct    [,.:;!?]</span><br><span class="line">nonblank [^ \t]</span><br><span class="line">name     &#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*</span><br></pre></td></tr></table></figure>
<p>命名正则表达式定义了表示某一类符号的正则表达式，这样可以在规则部分使用 <code>&#123;name&#125;</code> 来引用。</p>
<h4 id="（3）指令定义"><a href="#（3）指令定义" class="headerlink" title="（3）指令定义"></a>（3）指令定义</h4><p>使用以 <code>%</code> 开头的指令来修改内置变量的默认值或设置词法分析器的配置。</p>
<p>常见指令：</p>
<ul>
<li><p><code>%array</code> 和 <code>%pointer</code>：控制 <code>yytext</code> 的类型。</p>
<ul>
<li><code>%array</code>：<code>yytext</code> 是一个字符数组（默认）。</li>
<li><code>%pointer</code>：<code>yytext</code> 是一个字符指针。</li>
</ul>
</li>
<li><p><code>%s STATE</code>：定义一个状态，STATE 可以是任意字符串。</p>
<ul>
<li>词法分析器可以有多个状态，使用 <code>%s</code> 来定义新的状态。</li>
</ul>
</li>
<li><p><code>%e size</code>：定义内置的 <code>NFA</code> 表项的数量。默认值是 <code>1000</code>。</p>
</li>
<li><p><code>%n size</code>：定义内置的 <code>DFA</code> 表项的数量。默认值是 <code>500</code>。</p>
</li>
<li><p><code>%p size</code>：定义内置的 <code>move</code> 表项的数量。默认值是 <code>2500</code>。</p>
</li>
</ul>
<h3 id="2、规则"><a href="#2、规则" class="headerlink" title="2、规则"></a>2、规则</h3><h4 id="（1）规则的基本使用"><a href="#（1）规则的基本使用" class="headerlink" title="（1）规则的基本使用"></a>（1）规则的基本使用</h4><p>规则部分主要包含三部分内容：</p>
<ul>
<li><strong>模式</strong>：用于描述词法规则的正则表达式</li>
<li><strong>动作</strong>：模式匹配时要执行的 C 代码</li>
</ul>
<p>规则部分是 Lex 文件的核心部分，也是 Lex 文件 中唯一必选部分，它定义了正则表达式模式及其对应的动作。当输入匹配某个模式时，执行相应的动作代码。</p>
<p><strong>规则部分的基本结构</strong><br>规则部分由一系列的规则组成，每条规则由一个正则表达式模式和一个动作代码块构成，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern   &#123; action &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pattern</code>：一个正则表达式，用于匹配输入文本。</li>
<li><code>action</code>：C 代码块，当输入文本与模式匹配时执行的动作。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-Z]+      &#123; printf(&quot;Word: %s\n&quot;, yytext); &#125;</span><br><span class="line">[0-9]+         &#123; printf(&quot;Number: %s\n&quot;, yytext); &#125;</span><br><span class="line">&quot;+&quot;            &#123; printf(&quot;Plus operator\n&quot;); &#125;</span><br><span class="line">&quot;-&quot;            &#123; printf(&quot;Minus operator\n&quot;); &#125;</span><br><span class="line">[ \t\n]+       &#123; /* 忽略空白字符 */ &#125;</span><br><span class="line">.              &#123; printf(&quot;Unknown character: %s\n&quot;, yytext); &#125;</span><br></pre></td></tr></table></figure>
<p>上述示例中，当正则匹配到对应字符串后，打印出对应的信息。</p>
<p>正则表达式匹配规则：<br><img src="/images/lix_blog_184.png"></p>
<h4 id="（2）使用状态的规则"><a href="#（2）使用状态的规则" class="headerlink" title="（2）使用状态的规则"></a>（2）使用状态的规则</h4><p>在 Lex 中，可以使用状态来控制规则的应用范围。状态允许你在不同的上下文中应用不同的规则，使词法分析器能够处理更复杂的输入结构。</p>
<p><strong>Lex 有三种定义状态的方式：</strong></p>
<ul>
<li><code>%s</code> 定义 Exclusive 状态<ul>
<li>仅在特定状态下匹配特定规则，其他状态下不匹配。</li>
</ul>
</li>
<li><code>%x</code> 定义 Inclusive 状态<ul>
<li>在特定状态下优先匹配特定规则，但其他状态下的规则也可以匹配。</li>
</ul>
</li>
<li><code>%start</code> 定义初始状态或多个状态<ul>
<li>声明初始状态或多个状态，可以与 BEGIN 宏结合使用来切换状态。</li>
</ul>
</li>
</ul>
<p><strong>%s 定义 Exclusive 状态</strong><br><br>在这种状态下，只有特定状态下定义的规则才会被匹配。当处于其他状态时，这些规则将不会被考虑。</p>
<p>示例：处理 C 风格注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%s COMMENT</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">&quot;/*&quot;        &#123; BEGIN(COMMENT); &#125;  /* 进入 COMMENT 状态 */</span><br><span class="line">&lt;COMMENT&gt;&quot;*/&quot;   &#123; BEGIN(INITIAL); &#125;  /* 退出 COMMENT 状态，回到初始状态 */</span><br><span class="line">&lt;COMMENT&gt;.      &#123; /* 处理 COMMENT 状态下的字符 */ &#125;</span><br><span class="line">&lt;COMMENT&gt;\n     &#123; /* 处理 COMMENT 状态下的新行 */ &#125;</span><br><span class="line">.         &#123; /* 处理其他字符 */ &#125;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><code>/*</code> 会将词法分析器的状态切换到 <code>COMMENT</code>。</li>
<li>在 <code>COMMENT</code> 状态下，<code>*/</code> 会将状态切换回初始状态 <code>INITIAL</code>。</li>
<li>在 <code>COMMENT</code> 状态下的规则仅在该状态下生效，而在其他状态下无效。</li>
</ul>
<p><strong>%x 定义 Inclusive 状态</strong><br><br>在这种状态下，特定状态下的规则会优先匹配，但其他状态下的规则也可以被匹配。</p>
<p>示例：处理字符串字面量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%x STRING</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">\&quot;          &#123; BEGIN(STRING); &#125;  /* 进入 STRING 状态 */</span><br><span class="line">&lt;STRING&gt;\&quot;  &#123; BEGIN(INITIAL); &#125;  /* 退出 STRING 状态，回到初始状态 */</span><br><span class="line">&lt;STRING&gt;.   &#123; /* 处理 STRING 状态下的字符 */ &#125;</span><br><span class="line">&lt;STRING&gt;\n  &#123; /* 处理 STRING 状态下的新行 */ &#125;</span><br><span class="line">.           &#123; /* 处理其他字符 */ &#125;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><code>\&quot;</code> 会将词法分析器的状态切换到 <code>STRING</code>。</li>
<li>在 <code>STRING</code> 状态下，<code>\&quot;</code> 会将状态切换回初始状态 <code>INITIAL</code>。</li>
<li>在 <code>STRING</code> 状态下的规则优先匹配，但其他状态下的规则也可以匹配。</li>
</ul>
<p><strong>%start 定义初始状态或多个状态</strong><br><br>用于声明初始状态或多个状态，可以与 <code>BEGIN</code> 宏结合使用来切换状态。</p>
<p>示例：处理 C 和 C++ 风格注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%start C_COMMENT CC_COMMENT</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">&quot;/*&quot;        &#123; BEGIN(C_COMMENT); &#125;  /* 进入 C_COMMENT 状态 */</span><br><span class="line">&lt;CC_COMMENT&gt;&quot;*/&quot;   &#123; BEGIN(INITIAL); &#125;  /* 退出 C_COMMENT 状态，回到初始状态 */</span><br><span class="line">&lt;CC_COMMENT&gt;.      &#123; /* 处理 C_COMMENT 状态下的字符 */ &#125;</span><br><span class="line">&lt;CC_COMMENT&gt;\n     &#123; /* 处理 C_COMMENT 状态下的新行 */ &#125;</span><br><span class="line"></span><br><span class="line">&quot;//&quot;        &#123; BEGIN(CC_COMMENT); &#125;  /* 进入 CC_COMMENT 状态 */</span><br><span class="line">&lt;CC_COMMENT&gt;\n     &#123; BEGIN(INITIAL); &#125;  /* 退出 CC_COMMENT 状态，回到初始状态 */</span><br><span class="line">&lt;CC_COMMENT&gt;.      &#123; /* 处理 CC_COMMENT 状态下的字符 */ &#125;</span><br><span class="line"></span><br><span class="line">.           &#123; /* 处理其他字符 */ &#125;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><code>/*</code> 会将词法分析器的状态切换到 <code>C_COMMENT</code>。</li>
<li>在 <code>C_COMMENT</code> 状态下，<code>*/</code> 会将状态切换回初始状态 <code>INITIAL</code>。</li>
<li><code>//</code> 会将词法分析器的状态切换到 <code>CC_COMMENT</code>。</li>
<li>在 <code>CC_COMMENT</code> 状态下，<code>\n</code> 会将状态切换回初始状态 <code>INITIAL</code>。</li>
</ul>
<h3 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h3><p>代码部分是 Lex 文件的最后一部分，位于第二个 <code>%%</code> 之后。这部分通常包含主函数 <code>main()</code> 和其他用户自定义的辅助函数。用户代码部分的主要作用是启动词法分析器并处理分析结果。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line">/* 用户代码部分 */</span><br><span class="line">int main() &#123;</span><br><span class="line">    /* 启动词法分析器，单独使用 Lex 时可实现 main 函数并启动词法分析器 */</span><br><span class="line">    yylex();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int yywrap() &#123;</span><br><span class="line">    return 1; /* 返回 1 表示输入结束 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Yacc"><a href="#三、Yacc" class="headerlink" title="三、Yacc"></a>三、Yacc</h2><p>Yacc 负责根据上下文无关文法解析词法单元，生成语法树或执行相应的操作，Yacc 文件通常使用 .y 扩展名。</p>
<p>上下文无关文法在 Yacc 中起到了定义语法规则的作用，Yacc 使用上下文无关文法来描述编程语言的语法结构，并生成相应的解析器。</p>
<p>上下文无关文法（Context-Free Grammar, CFG）由诺姆·乔姆斯基（Noam Chomsky）在 1956 年提出，它是形式语言理论中的一种文法类型，用于定义编程语言的语法结构。</p>
<p>一个上下文无关文法由以下四个部分组成：</p>
<ul>
<li><p><strong>终结符集合（Terminal symbols）</strong></p>
<ul>
<li>表示语言中的基本符号，不能再被分解<ul>
<li>例如：数字（如 123）、标识符（如 x、y）、运算符（如 +、-、*、&#x2F;）、关键字（如 <code>if</code>、<code>else</code>、<code>while</code>）</li>
</ul>
</li>
<li>通常直接对应于词法分析器 Lex 生成的 token</li>
</ul>
</li>
<li><p><strong>非终结符集合（Non-terminal symbols）</strong></p>
<ul>
<li>表示语法结构，可以被分解为终结符或其他非终结符<ul>
<li>例如：表达式（如 <code>expression</code>）、语句（如 <code>statement</code>）、项（如 <code>term</code>）、因子（如 <code>factor</code>）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>生产规则集合（Production rules）</strong></p>
<ul>
<li>定义了如何将非终结符替换为终结符或其他非终结符</li>
</ul>
</li>
<li><p><strong>起始符（Start symbol）</strong></p>
<ul>
<li>一个特殊的非终结符，文法生成的语言的句子从这个符号开始</li>
</ul>
</li>
</ul>
<p>在 Yacc 文件中，对这四个部分的使用方式如下：<br><br><strong>（1）终结符集合（Terminal symbols）</strong><br><br>终结符是语言中的基本符号，不能再被分解。在 Yacc 中，终结符通过 <code>%token</code> 声明。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%token INTEGER</span><br><span class="line">%token PLUS MINUS TIMES DIVIDE LPAREN RPAREN</span><br></pre></td></tr></table></figure>
<p>这些声明表示 INTEGER、PLUS、MINUS、TIMES、DIVIDE、LPAREN 和 RPAREN 是终结符。</p>
<p><strong>（2）非终结符集合（Non-terminal symbols）</strong><br><br>非终结符表示语法结构，可以被分解为终结符或其他非终结符。在 Yacc 中，非终结符通过规则定义。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%type &lt;ival&gt; E T F</span><br></pre></td></tr></table></figure>
<p>这里的 E、T 和 F 是非终结符，表示表达式（<code>Expression</code>）、项（<code>Term</code>）和因子（<code>Factor</code>）。</p>
<p><strong>（3）生产规则集合（Production rules）</strong><br><br>生产规则定义了如何将非终结符替换为终结符或其他非终结符。在 Yacc 文件中，生产规则在 <code>%%</code> 符号之间定义。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line">E:</span><br><span class="line">    E PLUS T &#123; $$ = $1 + $3; &#125;</span><br><span class="line">    | E MINUS T &#123; $$ = $1 - $3; &#125;</span><br><span class="line">    | T</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">T:</span><br><span class="line">    T TIMES F &#123; $$ = $1 * $3; &#125;</span><br><span class="line">    | T DIVIDE F &#123; $$ = $1 / $3; &#125;</span><br><span class="line">    | F</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">F:</span><br><span class="line">    LPAREN E RPAREN &#123; $$ = $2; &#125;</span><br><span class="line">    | INTEGER &#123; $$ = $1; &#125;</span><br><span class="line">    ;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<p>这些规则描述了如何将非终结符 E、T 和 F 替换为其他非终结符和终结符的组合。</p>
<p><strong>（4）起始符（Start symbol）</strong><br><br>起始符是一个特殊的非终结符，文法生成的语言的句子从这个符号开始。在 Yacc 文件中，起始符是规则的第一个非终结符。例如，在上述规则中，E 是起始符，因为它是第一个定义的非终结符。</p>
<p>Yacc 通常与 Lex 配合使用，和 Lex 一样，Yacc 文件(example.y)内容示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token NUMBER PLUS MINUS</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">expr : expr PLUS term &#123; printf(&quot;Addition\n&quot;); &#125;</span><br><span class="line">     | expr MINUS term &#123; printf(&quot;Subtraction\n&quot;); &#125;</span><br><span class="line">     | term</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">term : NUMBER &#123; printf(&quot;Number: %d\n&quot;, $1); &#125;</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    yyparse();  /* 启动语法分析器 */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void yyerror(const char *s) &#123;</span><br><span class="line">    fprintf(stderr, &quot;Error: %s\n&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成语法分析器代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yacc -d example.y</span><br></pre></td></tr></table></figure>
<p>执行完上述命令之后，就会生成 y.tab.h、y.tab.c 语法分析器代码实现文件，其中自动生成的主要函数如下：</p>
<ul>
<li><p><code>yyparse()</code></p>
<ul>
<li>主语法分析函数，它从词法分析器获取 token 并尝试匹配定义的文法规则。</li>
<li>每次调用 <code>yyparse()</code> 时，它会启动语法分析过程，直到输入结束或遇到错误。</li>
<li>返回一个整数值，通常是 <code>0</code> 表示成功，<code>1</code> 表示有语法错误。</li>
<li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int result = yyparse();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>yyerror(const char *s)</code></p>
<ul>
<li>错误处理函数，当语法分析器遇到错误时调用。</li>
<li>通常用于打印错误信息或执行其他错误处理逻辑。</li>
<li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void yyerror(const char *s) &#123;</span><br><span class="line">	fprintf(stderr, &quot;Error: %s\n&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>yylval</code></p>
<ul>
<li>全局变量，用于存储词法分析器返回的 token 的值。</li>
<li>在词法分析器中设置 <code>yylval</code>，在语法分析器中使用。</li>
<li>默认为 <code>int</code> 类型，实际开发中通常会将 <code>yylval</code> 配置成联合体，以支持存储更复杂的数据。<ul>
<li>可以使用 <code>%union</code>、<code>%token</code>、<code>%type</code> 自定义 <code>yylval</code> 类型：<ul>
<li><p><code>%union</code> 来定义一个包含多种类型的联合体，该联合体就是 yylval 的实际类型。</p>
</li>
<li><p>使用 <code>%token</code> 声明 Lex 解析出的终结符 token 使用联合体哪个成员存储。</p>
</li>
<li><p>使用 <code>%type</code> 声明 Lex 解析出的非终结符 token 使用联合体哪个成员存储。</p>
</li>
<li><p>示例：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%union &#123;</span><br><span class="line">	int ival;</span><br><span class="line">	float fval;</span><br><span class="line">	char *sval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%token &lt;ival&gt; INTEGER</span><br><span class="line">%token &lt;fval&gt; FLOAT</span><br><span class="line">%token &lt;sval&gt; STRING</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>yychar</code></p>
<ul>
<li>全局变量，存储当前解析的 token。</li>
<li>由 <code>yyparse()</code> 使用，用于控制解析过程。</li>
<li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   if (yychar == SOME_TOKEN) &#123;</span><br><span class="line">	// Do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<br>
Yacc 文件内容结构与 Lex 完全一样，Yacc 内容结构如下：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;定义&gt;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&lt;规则&gt;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&lt;代码&gt;</span><br></pre></td></tr></table></figure>

<p>Yacc 文件也同样包含定义、规则、代码三部分内容：</p>
<ul>
<li><strong>定义（可选）</strong><ul>
<li>token 定义</li>
<li>优先级与关联性定义</li>
<li>C 代码定义</li>
</ul>
</li>
<li><strong>规则（必选）</strong><ul>
<li>定义了文法规则和对应的动作代码<ul>
<li>规则名：一个非终结符</li>
<li>产生式：由终结符和非终结符组成的序列</li>
<li>动作：C 代码，当产生式匹配时执行</li>
</ul>
</li>
</ul>
</li>
<li><strong>代码（可选）</strong><ul>
<li>辅助函数</li>
<li>也可以包含主程序的 main 函数</li>
<li>这部分代码会被直接拷贝进 y.tab.c 中</li>
</ul>
</li>
</ul>
<h3 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h3><p>定义是 Yacc 的第一部分，主要包含三部分内容：</p>
<ul>
<li>token 定义</li>
<li>优先级与关联性定义</li>
<li>C 代码定义</li>
</ul>
<h4 id="（1）-token-定义"><a href="#（1）-token-定义" class="headerlink" title="（1） token 定义"></a>（1） token 定义</h4><p>Lex 词法分析器将源代码字符串识别成一个个的 token，Yacc 语法分析器则会将 token 进行分类处理，因此两者之间必须统一 token 的类型。</p>
<p>为了使词法分析器和语法分析器之间的 token 类型一致，通常在 Yacc 文件中定义 token 类型。使用 <code>%token</code> 指令定义 token，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%token name1 name2 name3 ...</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%token NUMBER PLUS MINUS</span><br></pre></td></tr></table></figure>
<p>Yacc 会将 %token 指令转换为 C 语言的宏定义（<code>#define</code>）。</p>
<p>例如要解析一个简单的数学表达式，如 3 + 5，并计算其结果：<br>Lex 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &quot;y.tab.h&quot;  // 包含 Yacc 生成的头文件，其中定义了 token</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">[0-9]+          &#123; yylval = atoi(yytext); return INTEGER; &#125;</span><br><span class="line">&quot;+&quot;             &#123; return PLUS; &#125;</span><br><span class="line">[ \t\n]+        &#123; /* 忽略空白字符 */ &#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int yywrap() &#123;</span><br><span class="line">    return 1;  /* 指示没有更多的输入 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Yacc 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void yyerror(const char *s);</span><br><span class="line">int yylex(void);</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token INTEGER PLUS</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">expr: expr PLUS term &#123; printf(&quot;Result: %d\n&quot;, $1 + $3); &#125;</span><br><span class="line">    | term</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">term: INTEGER &#123; $$ = $1; &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Enter an expression:\n&quot;);</span><br><span class="line">    yyparse();  /* 启动语法分析器 */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void yyerror(const char *s) &#123;</span><br><span class="line">    fprintf(stderr, &quot;Error: %s\n&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中，Yacc 中定义了 INTEGER 和 PLUS 两个 Token，在 Lex 文件中使用了这两个 Token。</p>
<h4 id="（2）优先级与关联性定义"><a href="#（2）优先级与关联性定义" class="headerlink" title="（2）优先级与关联性定义"></a>（2）优先级与关联性定义</h4><p>在 Yacc 中，优先级和关联性定义用于解决语法分析中的歧义，特别是在处理运算符时。优先级决定了运算符的应用顺序，而关联性决定了相同优先级的运算符在表达式中的结合方向。</p>
<ul>
<li><p><strong>优先级</strong></p>
<ul>
<li>优先级用于确定运算符的应用顺序。例如，在表达式 3 + 4 * 5 中，乘法运算符 * 的优先级高于加法运算符 +，因此乘法会先于加法执行。</li>
</ul>
</li>
<li><p><strong>关联性</strong></p>
<ul>
<li>关联性用于确定相同优先级的运算符的结合方向。例如，在表达式 a - b - c 中，加法和减法都是左关联，即从左到右结合。而赋值运算符 &#x3D; 是右关联，即从右到左结合。</li>
</ul>
</li>
</ul>
<p>Yacc 提供了以下指令来定义运算符的优先级和关联性：</p>
<ul>
<li><code>%left</code><ul>
<li>左关联。先定义的优先级低于后定义的优先级</li>
<li>例如：算术运算符(+、-、*、&#x2F; 等)、比较运算符(&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 等)</li>
</ul>
</li>
<li><code>%right</code><ul>
<li>右关联，先定义的优先级高于后定义的优先级。</li>
<li>例如：赋值运算符(&#x3D;、+&#x3D;、-&#x3D; 等)、条件运算符(?:)</li>
</ul>
</li>
<li><code>%nonassoc</code><ul>
<li>无关联，用于定义不允许连续使用的运算符（如比较运算符）</li>
<li>例如：Python 中的逻辑运算符(and、or)</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%right &#x27;=&#x27;</span><br><span class="line">%left &#x27;+&#x27; &#x27;-&#x27;</span><br><span class="line">%left &#x27;*&#x27; &#x27;/&#x27; &#x27;%&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="（3）C-代码定义"><a href="#（3）C-代码定义" class="headerlink" title="（3）C 代码定义"></a>（3）C 代码定义</h4><p>在 <code>%&#123;</code> 和 <code>%&#125;</code> 之间可以定义 C 语言的变量和函数，这些定义会被直接拷贝到生成的 C 文件的开头部分。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int i, j, k;</span><br><span class="line">static float x = 1.0;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、规则-1"><a href="#2、规则-1" class="headerlink" title="2、规则"></a>2、规则</h3><p>规则主要包含三部分内容：</p>
<ul>
<li><strong>规则名</strong>：一个非终结符</li>
<li><strong>产生式</strong>：由终结符和非终结符组成的序列</li>
<li><strong>动作</strong>：C 代码，当产生式匹配时执行</li>
</ul>
<p>规则部分定义了一系列的语法规则。每条规则由一个非终结符和一个或多个产生式组成，每个产生式可以包含可选的语义动作。</p>
<p><strong>基本格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">identifier : definition &#123; action &#125;</span><br><span class="line">           | definition &#123; action &#125;</span><br><span class="line">           ;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>identifier</code> 是非终结符，对应文法产生式的左部。</li>
<li><code>definition</code> 是产生式，由终结符和非终结符组成，对应文法产生式的右部。</li>
<li><code>&#123; action &#125;</code> 是语义动作，当产生式匹配时执行的 C 代码。<ul>
<li>一般多个产生式对应一个 <code>action</code>，在 <code>action</code> 中，可以使用 <code>$</code> 获取产生式的值。<ul>
<li><code>$n</code> 获取第 <code>n</code> 个产生式的值。</li>
<li><code>$$</code> 表示当前产生式左侧非终结符的值，即当前产生式的结果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">expression:</span><br><span class="line">    expression &#x27;+&#x27; expression &#123;</span><br><span class="line">        $$ = $1 + $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#x27;-&#x27; expression &#123;</span><br><span class="line">        $$ = $1 - $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#x27;*&#x27; expression &#123;</span><br><span class="line">        $$ = $1 * $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#x27;/&#x27; expression &#123;</span><br><span class="line">        $$ = $1 / $3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    | NUMBER &#123;</span><br><span class="line">        $$ = $1;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>例如在上述示例中：</p>
<ul>
<li><code>expression &#39;+&#39; expression</code> 是三个产生式：<code>expression</code>、<code>&#39;+&#39;</code>、<code>expression</code></li>
<li><code>$1</code>、<code>$3</code> 表示产生式的第一个 <code>expression</code>、第二个 <code>expression</code> 的值</li>
<li><code>$$</code> 表示产生式结果</li>
</ul>
<p>默认情况下，规则部分定义的第一个非终结符为开始符号（Start Symbol）。可以使用 <code>%start</code> 指令自定义开始符号。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%start my_start_symbol</span><br></pre></td></tr></table></figure>

<h3 id="3、代码-1"><a href="#3、代码-1" class="headerlink" title="3、代码"></a>3、代码</h3><p>代码 Yacc 文件的最后一部分，可以包含辅助函数和主程序的 main 函数。这部分代码会被直接拷贝到生成的 C 文件的末尾。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 定义，略 ...</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">// 规则，略 ...</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    yyparse();  /* 启动语法分析器 */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void yyerror(const char *s) &#123;</span><br><span class="line">    fprintf(stderr, &quot;Error: %s\n&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、Lex、Yacc-完整示例及解读"><a href="#四、Lex、Yacc-完整示例及解读" class="headerlink" title="四、Lex、Yacc 完整示例及解读"></a>四、Lex、Yacc 完整示例及解读</h2><p>使用 Lex、Yacc 实现一个简单的计算器。</p>
<p>在 Xcode 中新建一个 macOS 的 Command Line Tool 工程。</p>
<p>calc.l 文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &quot;y.tab.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int yywrap(void) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[0-9]+  &#123;</span><br><span class="line">    yylval = atoi(yytext);</span><br><span class="line">    return NUMBER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[ \t]   &#123; /* ignore whitespace */ &#125;</span><br><span class="line"></span><br><span class="line">\n      &#123; return &#x27;\n&#x27;; &#125;</span><br><span class="line"></span><br><span class="line">.       &#123;</span><br><span class="line">    return yytext[0];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<p>calc.y 文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void yyerror(const char *s);</span><br><span class="line">int yylex(void);</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token NUMBER</span><br><span class="line">%left &#x27;+&#x27; &#x27;-&#x27;</span><br><span class="line">%left &#x27;*&#x27; &#x27;/&#x27;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">calculation:</span><br><span class="line">    expression &#x27;\n&#x27; &#123;</span><br><span class="line">        printf(&quot;Yacc: Completed calculation with result: %d\n&quot;, $1);</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#123;</span><br><span class="line">        printf(&quot;Yacc: Completed calculation with result: %d\n&quot;, $1);</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expression:</span><br><span class="line">    expression &#x27;+&#x27; expression &#123;</span><br><span class="line">        $$ = $1 + $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#x27;-&#x27; expression &#123;</span><br><span class="line">        $$ = $1 - $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#x27;*&#x27; expression &#123;</span><br><span class="line">        $$ = $1 * $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | expression &#x27;/&#x27; expression &#123;</span><br><span class="line">        $$ = $1 / $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | &#x27;(&#x27; expression &#x27;)&#x27; &#123;</span><br><span class="line">        $$ = $2;</span><br><span class="line">    &#125;</span><br><span class="line">    | NUMBER &#123;</span><br><span class="line">        $$ = $1;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">void yyerror(const char *s) &#123;</span><br><span class="line">    fprintf(stderr, &quot;Error: %s\n&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.m 文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.m</span><br><span class="line">//  CompilerTest</span><br><span class="line">//</span><br><span class="line">//  Created by Lix on 2022/4/13.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#include &quot;y.tab.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int yyparse(void);</span><br><span class="line">extern void yyset_in(FILE *file);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        const char *input = &quot;2 + 3 * 4\n&quot;; // 添加换行符以终止输入</span><br><span class="line"></span><br><span class="line">        FILE *inputFile = fmemopen((void *)input, strlen(input), &quot;r&quot;);</span><br><span class="line">        yyset_in(inputFile);</span><br><span class="line">        </span><br><span class="line">        if (yyparse() == 0) &#123;</span><br><span class="line">            NSLog(@&quot;Calculation successful!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSLog(@&quot;Error in calculation.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fclose(inputFile);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接运行，打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yacc: Completed calculation with result: 14</span><br><span class="line">Calculation successful!</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>因为 Xcode 内置了 Lex、Yacc 工具，所以可以直接编译运行。不同的是，Xcode 自动生成的词法分析代码文件为 Lex文件名.yy.c，例如上述示例生成的是  calc.yy.c。<br><img src="/images/lix_blog_185.png"></p>
<p>在上述示例中，调用 Lex 词法分析器的 <code>yyset_in(FILE * _in_str)</code> 函数设置词法分析器的输入文件，然后调用 Yacc 语法分析器的 <code>yyparse()</code> 函数执行语法分析及后续流程。</p>
<p><code>yyparse()</code> 是由 Yacc（或 Bison）自动生成的语法分析器的核心函数。它的主要任务是根据定义的语法规则解析输入，并执行相应的语义动作。</p>
<p><code>yyparse()</code> 伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">int yyparse() &#123;</span><br><span class="line">    int yystate = 0; // 初始状态</span><br><span class="line">    int yyn, yychar, yytoken, yym, yyerrstatus = 0;</span><br><span class="line"></span><br><span class="line">    YYSTYPE yylval;    // 存储词法单元的值</span><br><span class="line">    YYSTYPE yyval;     // 存储语法规则的语义值</span><br><span class="line">    YYSTYPE yyvs[YYMAXDEPTH]; // 符号栈</span><br><span class="line">    int yyssp;        // 状态栈指针</span><br><span class="line">    int yyss[YYMAXDEPTH]; // 状态栈</span><br><span class="line"></span><br><span class="line">    yyssp = 0;</span><br><span class="line">    yychar = YYEMPTY; // 表示当前没有读到的词法单元</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        /* 根据当前状态和词法单元yytoken查询语法表，决定下一步动作 */</span><br><span class="line">        yyn = yypact[yystate];</span><br><span class="line">        if (yyn == YYPACT_NINF) &#123;</span><br><span class="line">            // 发生错误, 调用错误处理函数</span><br><span class="line">            yyerror(&quot;syntax error&quot;);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取下一个词法单元</span><br><span class="line">        if (yychar == YYEMPTY) &#123;</span><br><span class="line">            yychar = yylex();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        yychar = yychar &lt; 0 ? 0 : yychar;</span><br><span class="line">        yytoken = YYTRANSLATE(yychar);</span><br><span class="line"></span><br><span class="line">        yyn += yytoken;</span><br><span class="line">        if (yyn &lt; 0 || yyn &gt;= YYLAST || yycheck[yyn] != yytoken) &#123;</span><br><span class="line">            yyn = yydefact[yystate];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            yyn = yytable[yyn];</span><br><span class="line">            if (yyn &lt;= 0) &#123;</span><br><span class="line">                if (yyn == 0 || yyn == YYTABLE_NINF) &#123;</span><br><span class="line">                    yychar = yylex();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                yyn = -yyn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // `移入`</span><br><span class="line">        if (yyn == YYFINAL) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (yyn == YYERROR) &#123;</span><br><span class="line">            yyerror(&quot;syntax error&quot;);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (yyn &gt; 0) &#123;</span><br><span class="line">            // 移入操作</span><br><span class="line">            yyssp++;</span><br><span class="line">            yyss[yyssp] = yystate;</span><br><span class="line">            yystate = yyn;</span><br><span class="line">            yychar = YYEMPTY;</span><br><span class="line"></span><br><span class="line">            yyvs[yyssp] = yylval;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 语法规则</span><br><span class="line">        yyn = -yyn;</span><br><span class="line">        yym = yyr2[yyn];</span><br><span class="line">        yyval = yyvs[yyssp - yym + 1];</span><br><span class="line"></span><br><span class="line">        // 执行语义动作</span><br><span class="line">        switch (yyn) &#123;</span><br><span class="line">            case 2:  // `expression: expression + expression`</span><br><span class="line">                yyval = eval_add(yyvs[yyssp - 2], yyvs[yyssp]);</span><br><span class="line">                break;</span><br><span class="line">            case 3:  // `expression: expression * expression`</span><br><span class="line">                yyval = eval_mul(yyvs[yyssp - 2], yyvs[yyssp]);</span><br><span class="line">                break;</span><br><span class="line">            // 其他规则...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        yyssp -= yym;</span><br><span class="line">        yyssp++;</span><br><span class="line">        yyss[yyssp] = yystate;</span><br><span class="line"></span><br><span class="line">        yystate = yygoto[yyn - YYNTOKENS];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>yyparse() 的主要逻辑如下：</strong></p>
<ul>
<li><strong>初始化</strong><ul>
<li>初始化状态栈和符号栈。</li>
<li>设置初始状态为起始状态。</li>
<li>读取第一个词法单元（token）。</li>
</ul>
</li>
<li><strong>主循环</strong><ul>
<li>在一个循环中，不断读取下一个词法单元，直到到达输入的结尾或检测到语法错误。</li>
</ul>
</li>
<li><strong>状态转移</strong><ul>
<li>根据当前状态和当前词法单元，从语法表中查找下一步的动作：<ul>
<li>移入（shift）：将当前词法单元移入符号栈，并转移到新状态。</li>
<li>规约（reduce）：使用一个产生式规则将栈顶的符号归约为非终结符，并转移到新状态。</li>
<li>接受（accept）：解析成功，停止解析过程。</li>
<li>错误（error）：检测到语法错误，调用错误处理函数。</li>
</ul>
</li>
</ul>
</li>
<li><strong>执行语义动作</strong><ul>
<li>在规约过程中，执行相应的语义动作，计算值或构建语法树。</li>
</ul>
</li>
</ul>
<p>所以，上述示例在解析表达式 2 + 3 * 4 时，<code>yyparse()</code> 按照以下步骤工作：</p>
<ul>
<li>初始化<ul>
<li>初始化状态和符号栈。</li>
<li>读取第一个词法单元 2。</li>
</ul>
</li>
<li>状态转移和规约：<ul>
<li>移入 2：<ul>
<li>读取下一个词法单元 +。</li>
</ul>
</li>
<li>移入 +：<ul>
<li>读取下一个词法单元 3。</li>
</ul>
</li>
<li>移入 3：<ul>
<li>读取下一个词法单元 *。</li>
</ul>
</li>
<li>移入 *：<ul>
<li>读取下一个词法单元 4。</li>
</ul>
</li>
<li>移入 4：<ul>
<li>读取下一个词法单元 \n。</li>
</ul>
</li>
<li>规约 3 * 4：<ul>
<li>匹配规则 expression ‘*’ expression。</li>
<li>执行语义动作 $$ &#x3D; $1 * $3 计算结果 12。</li>
<li>将结果 12 压入符号栈。</li>
</ul>
</li>
<li>规约 2 + 12：<ul>
<li>匹配规则 expression ‘+’ expression。</li>
<li>执行语义动作 $$ &#x3D; $1 + $3 计算结果 14。</li>
<li>将结果 14 压入符号栈。</li>
</ul>
</li>
<li>终止：读取到 \n 并匹配完成，解析成功，返回结果。</li>
</ul>
</li>
</ul>
</section>

    <!-- Copyright START -->
    
      <div>
  <ul class="post-copyright">
    <li>
      <a rel=license href=http://creativecommons.org/licenses/by/4.0/>
        <img alt="知识共享许可协议" style="border-width:0;height:30px;width:auto;" src="/css/images/copyright.png">
      </a>
    </li>
    <li>
      本文章采用 <a rel=license href=http://creativecommons.org/licenses/by/4.0/>知识共享署名 4.0 国际许可协议</a> 进行许可，完整转载、部分转载、图片转载时均请注明原文链接。
    </li>
  </ul>
<div>
    
    <!-- Copyright START -->


    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#热修复" >
    <span class="tag-code">热修复</span>
  </a>

  <a href="/tags#编译原理" >
    <span class="tag-code">编译原理</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/posts/63748/">
        <span class="nav-arrow">← </span>
        
          编译原理之 OC 编译
        
      </a>
    
    
      <a class="nav-right" href="/posts/48084/">
        
          热修复之 JSPatch 实现原理
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Gitalk START -->
      <div id="gitalk-container"></div>
      <!-- Gitalk END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://www.lixkit.com/posts/20895/';
    var banner = 'undefined'
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>








<link rel='stylesheet' type='text/css' href='//cdnjs.cloudflare.com/ajax/libs/gitalk/1.2.2/gitalk.min.css'>
<div id="gitalk-container"></div>
<script>
    // Promise 异步加载脚本
    function loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    // 异步加载 Gitalk
    async function initGitalk() {
        try {
            await loadScript('//cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.10.0/js/md5.min.js');
            await loadScript('//cdnjs.cloudflare.com/ajax/libs/gitalk/1.2.2/gitalk.min.js');
            const gitalk = new Gitalk({
                clientID: '124a73ebef61e7821d74',
                clientSecret: 'a1ef084cca4d78256620f08f439ba70522f84581',
                repo: 'lixkit.github.io',
                owner: 'lixkit',
                admin: ['lixkit'],
                id: md5(location.pathname),
                distractionFreeMode: false
            });
            gitalk.render('gitalk-container');
        } catch (error) {
            console.error('Error loading Gitalk:', error);
        }
    }

    // 在页面加载完成后异步加载 Gitalk
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initGitalk);
    } else {
        initGitalk();
    }
</script>


    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    
<footer class="app-footer">
  <p class="copyright">
    李峰峰 © 2016 - 2025
    
        |
        
            <a style="color: #7f8c8d;" href="http://beian.miit.gov.cn/" target="_blank" rel="noopener nofollow">京ICP备2023030486号-6</a>
        
    
  </p>
</footer>


<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script>
    var _baId = 'cef02744ce74fd7afbb6bab85e4a6c24';
    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>


<script src="/js/script.js"></script>


  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>